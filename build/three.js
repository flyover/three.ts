(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.THREE = {})));
}(this, (function (exports) { 'use strict';

	function __extends(d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	// Polyfills
	if (Number.EPSILON === undefined) {
	    ///Number.EPSILON = Math.pow(2, - 52);
	    Object.defineProperty(Number, 'EPSILON', { value: Math.pow(2, -52) });
	}
	//
	if (Math.sign === undefined) {
	    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	    Math.sign = function (x) {
	        return (x < 0) ? -1 : (x > 0) ? 1 : +x;
	    };
	}
	if (Function.prototype.name === undefined) {
	    // Missing in IE9-11.
	    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	    Object.defineProperty(Function.prototype, 'name', {
	        get: function () {
	            return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
	        }
	    });
	}
	if (Object.assign === undefined) {
	    // Missing in IE.
	    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	    (function () {
	        Object.assign = function (target /*: any*/) {
	            if (target === undefined || target === null) {
	                throw new TypeError('Cannot convert undefined or null to object');
	            }
	            var output = Object(target);
	            for (var index = 1; index < arguments.length; index++) {
	                var source = arguments[index];
	                if (source !== undefined && source !== null) {
	                    for (var nextKey in source) {
	                        if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
	                            output[nextKey] = source[nextKey];
	                        }
	                    }
	                }
	            }
	            return output;
	        };
	    })();
	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	var EventDispatcher = /** @class */ (function () {
	    function EventDispatcher() {
	    }
	    EventDispatcher.prototype.addEventListener = function (type, listener) {
	        if (this._listeners === undefined)
	            this._listeners = {};
	        var listeners = this._listeners;
	        if (listeners[type] === undefined) {
	            listeners[type] = [];
	        }
	        if (listeners[type].indexOf(listener) === -1) {
	            listeners[type].push(listener);
	        }
	    };
	    EventDispatcher.prototype.hasEventListener = function (type, listener) {
	        if (this._listeners === undefined)
	            return false;
	        var listeners = this._listeners;
	        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
	            return true;
	        }
	        return false;
	    };
	    EventDispatcher.prototype.removeEventListener = function (type, listener) {
	        if (this._listeners === undefined)
	            return;
	        var listeners = this._listeners;
	        var listenerArray = listeners[type];
	        if (listenerArray !== undefined) {
	            var index = listenerArray.indexOf(listener);
	            if (index !== -1) {
	                listenerArray.splice(index, 1);
	            }
	        }
	    };
	    EventDispatcher.prototype.dispatchEvent = function (event) {
	        if (this._listeners === undefined)
	            return;
	        var listeners = this._listeners;
	        var listenerArray = listeners[event.type];
	        if (listenerArray !== undefined) {
	            event.target = this;
	            var array = [];
	            var length = listenerArray.length;
	            for (var i = 0; i < length; i++) {
	                array[i] = listenerArray[i];
	            }
	            for (var i = 0; i < length; i++) {
	                array[i].call(this, event);
	            }
	        }
	    };
	    EventDispatcher.prototype.apply = function (target) {
	        console.warn("THREE.EventDispatcher: .apply is deprecated, " +
	            "just inherit or Object.assign the prototype to mix-in.");
	        Object.assign(target, this);
	    };
	    return EventDispatcher;
	}());

	var REVISION = "82";
	(function (MOUSE) {
	    MOUSE[MOUSE["LEFT"] = 0] = "LEFT";
	    MOUSE[MOUSE["MIDDLE"] = 1] = "MIDDLE";
	    MOUSE[MOUSE["RIGHT"] = 2] = "RIGHT";
	})(exports.MOUSE || (exports.MOUSE = {}));
	(function (CullFace) {
	    CullFace[CullFace["None"] = 0] = "None";
	    CullFace[CullFace["Back"] = 1] = "Back";
	    CullFace[CullFace["Front"] = 2] = "Front";
	    CullFace[CullFace["FrontBack"] = 3] = "FrontBack";
	})(exports.CullFace || (exports.CullFace = {}));
	var CullFaceNone = exports.CullFace.None;
	var CullFaceBack = exports.CullFace.Back;
	var CullFaceFront = exports.CullFace.Front;
	var CullFaceFrontBack = exports.CullFace.FrontBack;
	(function (FrontFaceDirection) {
	    FrontFaceDirection[FrontFaceDirection["CW"] = 0] = "CW";
	    FrontFaceDirection[FrontFaceDirection["CCW"] = 1] = "CCW";
	})(exports.FrontFaceDirection || (exports.FrontFaceDirection = {}));
	var FrontFaceDirectionCW = exports.FrontFaceDirection.CW;
	var FrontFaceDirectionCCW = exports.FrontFaceDirection.CCW;
	(function (ShadowMap) {
	    ShadowMap[ShadowMap["Basic"] = 0] = "Basic";
	    ShadowMap[ShadowMap["PCF"] = 1] = "PCF";
	    ShadowMap[ShadowMap["PCFSoft"] = 2] = "PCFSoft";
	})(exports.ShadowMap || (exports.ShadowMap = {}));
	var BasicShadowMap = exports.ShadowMap.Basic;
	var PCFShadowMap = exports.ShadowMap.PCF;
	var PCFSoftShadowMap = exports.ShadowMap.PCFSoft;
	(function (SideMode) {
	    SideMode[SideMode["Front"] = 0] = "Front";
	    SideMode[SideMode["Back"] = 1] = "Back";
	    SideMode[SideMode["Double"] = 2] = "Double";
	})(exports.SideMode || (exports.SideMode = {}));
	var FrontSide = exports.SideMode.Front;
	var BackSide = exports.SideMode.Back;
	var DoubleSide = exports.SideMode.Double;
	(function (ShadingMode) {
	    ShadingMode[ShadingMode["Flat"] = 1] = "Flat";
	    ShadingMode[ShadingMode["Smooth"] = 2] = "Smooth";
	})(exports.ShadingMode || (exports.ShadingMode = {}));
	var FlatShading = exports.ShadingMode.Flat;
	var SmoothShading = exports.ShadingMode.Smooth;
	(function (ColorsMode) {
	    ColorsMode[ColorsMode["None"] = 0] = "None";
	    ColorsMode[ColorsMode["Face"] = 1] = "Face";
	    ColorsMode[ColorsMode["Vertex"] = 2] = "Vertex";
	})(exports.ColorsMode || (exports.ColorsMode = {}));
	var NoColors = exports.ColorsMode.None;
	var FaceColors = exports.ColorsMode.Face;
	var VertexColors = exports.ColorsMode.Vertex;
	(function (BlendingMode) {
	    BlendingMode[BlendingMode["None"] = 0] = "None";
	    BlendingMode[BlendingMode["Normal"] = 1] = "Normal";
	    BlendingMode[BlendingMode["Additive"] = 2] = "Additive";
	    BlendingMode[BlendingMode["Subtractive"] = 3] = "Subtractive";
	    BlendingMode[BlendingMode["Multiply"] = 4] = "Multiply";
	    BlendingMode[BlendingMode["Custom"] = 5] = "Custom";
	})(exports.BlendingMode || (exports.BlendingMode = {}));
	var NoBlending = exports.BlendingMode.None;
	var NormalBlending = exports.BlendingMode.Normal;
	var AdditiveBlending = exports.BlendingMode.Additive;
	var SubtractiveBlending = exports.BlendingMode.Subtractive;
	var MultiplyBlending = exports.BlendingMode.Multiply;
	var CustomBlending = exports.BlendingMode.Custom;
	(function (BlendingEquation) {
	    BlendingEquation[BlendingEquation["Add"] = 100] = "Add";
	    BlendingEquation[BlendingEquation["Subtract"] = 101] = "Subtract";
	    BlendingEquation[BlendingEquation["ReverseSubtract"] = 102] = "ReverseSubtract";
	    BlendingEquation[BlendingEquation["Min"] = 103] = "Min";
	    BlendingEquation[BlendingEquation["Max"] = 104] = "Max";
	})(exports.BlendingEquation || (exports.BlendingEquation = {}));
	var AddEquation = exports.BlendingEquation.Add;
	var SubtractEquation = exports.BlendingEquation.Subtract;
	var ReverseSubtractEquation = exports.BlendingEquation.ReverseSubtract;
	var MinEquation = exports.BlendingEquation.Min;
	var MaxEquation = exports.BlendingEquation.Max;
	(function (BlendingFactor) {
	    BlendingFactor[BlendingFactor["Zero"] = 200] = "Zero";
	    BlendingFactor[BlendingFactor["One"] = 201] = "One";
	    BlendingFactor[BlendingFactor["SrcColor"] = 202] = "SrcColor";
	    BlendingFactor[BlendingFactor["OneMinusSrcColor"] = 203] = "OneMinusSrcColor";
	    BlendingFactor[BlendingFactor["SrcAlpha"] = 204] = "SrcAlpha";
	    BlendingFactor[BlendingFactor["OneMinusSrcAlpha"] = 205] = "OneMinusSrcAlpha";
	    BlendingFactor[BlendingFactor["DstAlpha"] = 206] = "DstAlpha";
	    BlendingFactor[BlendingFactor["OneMinusDstAlpha"] = 207] = "OneMinusDstAlpha";
	    BlendingFactor[BlendingFactor["DstColor"] = 208] = "DstColor";
	    BlendingFactor[BlendingFactor["OneMinusDstColor"] = 209] = "OneMinusDstColor";
	    BlendingFactor[BlendingFactor["SrcAlphaSaturate"] = 210] = "SrcAlphaSaturate";
	})(exports.BlendingFactor || (exports.BlendingFactor = {}));
	var ZeroFactor = exports.BlendingFactor.Zero;
	var OneFactor = exports.BlendingFactor.One;
	var SrcColorFactor = exports.BlendingFactor.SrcColor;
	var OneMinusSrcColorFactor = exports.BlendingFactor.OneMinusSrcColor;
	var SrcAlphaFactor = exports.BlendingFactor.SrcAlpha;
	var OneMinusSrcAlphaFactor = exports.BlendingFactor.OneMinusSrcAlpha;
	var DstAlphaFactor = exports.BlendingFactor.DstAlpha;
	var OneMinusDstAlphaFactor = exports.BlendingFactor.OneMinusDstAlpha;
	var DstColorFactor = exports.BlendingFactor.DstColor;
	var OneMinusDstColorFactor = exports.BlendingFactor.OneMinusDstColor;
	var SrcAlphaSaturateFactor = exports.BlendingFactor.SrcAlphaSaturate;
	(function (DepthFunction) {
	    DepthFunction[DepthFunction["Never"] = 0] = "Never";
	    DepthFunction[DepthFunction["Always"] = 1] = "Always";
	    DepthFunction[DepthFunction["Less"] = 2] = "Less";
	    DepthFunction[DepthFunction["LessEqual"] = 3] = "LessEqual";
	    DepthFunction[DepthFunction["Equal"] = 4] = "Equal";
	    DepthFunction[DepthFunction["GreaterEqual"] = 5] = "GreaterEqual";
	    DepthFunction[DepthFunction["Greater"] = 6] = "Greater";
	    DepthFunction[DepthFunction["NotEqual"] = 7] = "NotEqual";
	})(exports.DepthFunction || (exports.DepthFunction = {}));
	var NeverDepth = exports.DepthFunction.Never;
	var AlwaysDepth = exports.DepthFunction.Always;
	var LessDepth = exports.DepthFunction.Less;
	var LessEqualDepth = exports.DepthFunction.LessEqual;
	var EqualDepth = exports.DepthFunction.Equal;
	var GreaterEqualDepth = exports.DepthFunction.GreaterEqual;
	var GreaterDepth = exports.DepthFunction.Greater;
	var NotEqualDepth = exports.DepthFunction.NotEqual;
	(function (BlendingOperation) {
	    BlendingOperation[BlendingOperation["Multiply"] = 0] = "Multiply";
	    BlendingOperation[BlendingOperation["Mix"] = 1] = "Mix";
	    BlendingOperation[BlendingOperation["Add"] = 2] = "Add";
	})(exports.BlendingOperation || (exports.BlendingOperation = {}));
	var MultiplyOperation = exports.BlendingOperation.Multiply;
	var MixOperation = exports.BlendingOperation.Mix;
	var AddOperation = exports.BlendingOperation.Add;
	(function (ToneMapping) {
	    ToneMapping[ToneMapping["None"] = 0] = "None";
	    ToneMapping[ToneMapping["Linear"] = 1] = "Linear";
	    ToneMapping[ToneMapping["Reinhard"] = 2] = "Reinhard";
	    ToneMapping[ToneMapping["Uncharted2"] = 3] = "Uncharted2";
	    ToneMapping[ToneMapping["Cineon"] = 4] = "Cineon";
	})(exports.ToneMapping || (exports.ToneMapping = {}));
	var NoToneMapping = exports.ToneMapping.None;
	var LinearToneMapping = exports.ToneMapping.Linear;
	var ReinhardToneMapping = exports.ToneMapping.Reinhard;
	var Uncharted2ToneMapping = exports.ToneMapping.Uncharted2;
	var CineonToneMapping = exports.ToneMapping.Cineon;
	(function (TextureMapping) {
	    TextureMapping[TextureMapping["UV"] = 300] = "UV";
	    TextureMapping[TextureMapping["CubeReflection"] = 301] = "CubeReflection";
	    TextureMapping[TextureMapping["CubeRefraction"] = 302] = "CubeRefraction";
	    TextureMapping[TextureMapping["EquirectangularReflection"] = 303] = "EquirectangularReflection";
	    TextureMapping[TextureMapping["EquirectangularRefraction"] = 304] = "EquirectangularRefraction";
	    TextureMapping[TextureMapping["SphericalReflection"] = 305] = "SphericalReflection";
	    TextureMapping[TextureMapping["CubeUVReflection"] = 306] = "CubeUVReflection";
	    TextureMapping[TextureMapping["CubeUVRefraction"] = 307] = "CubeUVRefraction";
	})(exports.TextureMapping || (exports.TextureMapping = {}));
	var UVMapping = exports.TextureMapping.UV;
	var CubeReflectionMapping = exports.TextureMapping.CubeReflection;
	var CubeRefractionMapping = exports.TextureMapping.CubeRefraction;
	var EquirectangularReflectionMapping = exports.TextureMapping.EquirectangularReflection;
	var EquirectangularRefractionMapping = exports.TextureMapping.EquirectangularRefraction;
	var SphericalReflectionMapping = exports.TextureMapping.SphericalReflection;
	var CubeUVReflectionMapping = exports.TextureMapping.CubeUVReflection;
	var CubeUVRefractionMapping = exports.TextureMapping.CubeUVRefraction;
	(function (TextureWrapping) {
	    TextureWrapping[TextureWrapping["Repeat"] = 1000] = "Repeat";
	    TextureWrapping[TextureWrapping["ClampToEdge"] = 1001] = "ClampToEdge";
	    TextureWrapping[TextureWrapping["MirroredRepeat"] = 1002] = "MirroredRepeat";
	})(exports.TextureWrapping || (exports.TextureWrapping = {}));
	var RepeatWrapping = exports.TextureWrapping.Repeat;
	var ClampToEdgeWrapping = exports.TextureWrapping.ClampToEdge;
	var MirroredRepeatWrapping = exports.TextureWrapping.MirroredRepeat;
	(function (TextureFilter) {
	    TextureFilter[TextureFilter["Nearest"] = 1003] = "Nearest";
	    TextureFilter[TextureFilter["NearestMipMapNearest"] = 1004] = "NearestMipMapNearest";
	    TextureFilter[TextureFilter["NearestMipMapLinear"] = 1005] = "NearestMipMapLinear";
	    TextureFilter[TextureFilter["Linear"] = 1006] = "Linear";
	    TextureFilter[TextureFilter["LinearMipMapNearest"] = 1007] = "LinearMipMapNearest";
	    TextureFilter[TextureFilter["LinearMipMapLinear"] = 1008] = "LinearMipMapLinear";
	})(exports.TextureFilter || (exports.TextureFilter = {}));
	var NearestFilter = exports.TextureFilter.Nearest;
	var NearestMipMapNearestFilter = exports.TextureFilter.NearestMipMapNearest;
	var NearestMipMapLinearFilter = exports.TextureFilter.NearestMipMapLinear;
	var LinearFilter = exports.TextureFilter.Linear;
	var LinearMipMapNearestFilter = exports.TextureFilter.LinearMipMapNearest;
	var LinearMipMapLinearFilter = exports.TextureFilter.LinearMipMapLinear;
	(function (TextureType) {
	    TextureType[TextureType["UnsignedByte"] = 1009] = "UnsignedByte";
	    TextureType[TextureType["Byte"] = 1010] = "Byte";
	    TextureType[TextureType["Short"] = 1011] = "Short";
	    TextureType[TextureType["UnsignedShort"] = 1012] = "UnsignedShort";
	    TextureType[TextureType["Int"] = 1013] = "Int";
	    TextureType[TextureType["UnsignedInt"] = 1014] = "UnsignedInt";
	    TextureType[TextureType["Float"] = 1015] = "Float";
	    TextureType[TextureType["HalfFloat"] = 1016] = "HalfFloat";
	    TextureType[TextureType["UnsignedShort4444"] = 1017] = "UnsignedShort4444";
	    TextureType[TextureType["UnsignedShort5551"] = 1018] = "UnsignedShort5551";
	    TextureType[TextureType["UnsignedShort565"] = 1019] = "UnsignedShort565";
	    TextureType[TextureType["UnsignedInt248"] = 1020] = "UnsignedInt248";
	})(exports.TextureType || (exports.TextureType = {}));
	var UnsignedByteType = exports.TextureType.UnsignedByte;
	var ByteType = exports.TextureType.Byte;
	var ShortType = exports.TextureType.Short;
	var UnsignedShortType = exports.TextureType.UnsignedShort;
	var IntType = exports.TextureType.Int;
	var UnsignedIntType = exports.TextureType.UnsignedInt;
	var FloatType = exports.TextureType.Float;
	var HalfFloatType = exports.TextureType.HalfFloat;
	var UnsignedShort4444Type = exports.TextureType.UnsignedShort4444;
	var UnsignedShort5551Type = exports.TextureType.UnsignedShort5551;
	var UnsignedShort565Type = exports.TextureType.UnsignedShort565;
	var UnsignedInt248Type = exports.TextureType.UnsignedInt248;
	(function (TextureFormat) {
	    TextureFormat[TextureFormat["Alpha"] = 1021] = "Alpha";
	    TextureFormat[TextureFormat["RGB"] = 1022] = "RGB";
	    TextureFormat[TextureFormat["RGBA"] = 1023] = "RGBA";
	    TextureFormat[TextureFormat["Luminance"] = 1024] = "Luminance";
	    TextureFormat[TextureFormat["LuminanceAlpha"] = 1025] = "LuminanceAlpha";
	    TextureFormat[TextureFormat["RGBE"] = 1023] = "RGBE";
	    TextureFormat[TextureFormat["Depth"] = 1026] = "Depth";
	    TextureFormat[TextureFormat["DepthStencil"] = 1027] = "DepthStencil";
	    TextureFormat[TextureFormat["RGB_S3TC_DXT1"] = 2001] = "RGB_S3TC_DXT1";
	    TextureFormat[TextureFormat["RGBA_S3TC_DXT1"] = 2002] = "RGBA_S3TC_DXT1";
	    TextureFormat[TextureFormat["RGBA_S3TC_DXT3"] = 2003] = "RGBA_S3TC_DXT3";
	    TextureFormat[TextureFormat["RGBA_S3TC_DXT5"] = 2004] = "RGBA_S3TC_DXT5";
	    TextureFormat[TextureFormat["RGB_PVRTC_4BPPV1"] = 2100] = "RGB_PVRTC_4BPPV1";
	    TextureFormat[TextureFormat["RGB_PVRTC_2BPPV1"] = 2101] = "RGB_PVRTC_2BPPV1";
	    TextureFormat[TextureFormat["RGBA_PVRTC_4BPPV1"] = 2102] = "RGBA_PVRTC_4BPPV1";
	    TextureFormat[TextureFormat["RGBA_PVRTC_2BPPV1"] = 2103] = "RGBA_PVRTC_2BPPV1";
	    TextureFormat[TextureFormat["RGB_ETC1"] = 2151] = "RGB_ETC1";
	})(exports.TextureFormat || (exports.TextureFormat = {}));
	var AlphaFormat = exports.TextureFormat.Alpha;
	var RGBFormat = exports.TextureFormat.RGB;
	var RGBAFormat = exports.TextureFormat.RGBA;
	var LuminanceFormat = exports.TextureFormat.Luminance;
	var LuminanceAlphaFormat = exports.TextureFormat.LuminanceAlpha;
	var RGBEFormat = exports.TextureFormat.RGBE;
	var DepthFormat = exports.TextureFormat.Depth;
	var DepthStencilFormat = exports.TextureFormat.DepthStencil;
	var RGB_S3TC_DXT1_Format = exports.TextureFormat.RGB_S3TC_DXT1;
	var RGBA_S3TC_DXT1_Format = exports.TextureFormat.RGBA_S3TC_DXT1;
	var RGBA_S3TC_DXT3_Format = exports.TextureFormat.RGBA_S3TC_DXT3;
	var RGBA_S3TC_DXT5_Format = exports.TextureFormat.RGBA_S3TC_DXT5;
	var RGB_PVRTC_4BPPV1_Format = exports.TextureFormat.RGB_PVRTC_4BPPV1;
	var RGB_PVRTC_2BPPV1_Format = exports.TextureFormat.RGB_PVRTC_2BPPV1;
	var RGBA_PVRTC_4BPPV1_Format = exports.TextureFormat.RGBA_PVRTC_4BPPV1;
	var RGBA_PVRTC_2BPPV1_Format = exports.TextureFormat.RGBA_PVRTC_2BPPV1;
	var RGB_ETC1_Format = exports.TextureFormat.RGB_ETC1;
	(function (LoopMode) {
	    LoopMode[LoopMode["Once"] = 2200] = "Once";
	    LoopMode[LoopMode["Repeat"] = 2201] = "Repeat";
	    LoopMode[LoopMode["PingPong"] = 2202] = "PingPong";
	})(exports.LoopMode || (exports.LoopMode = {}));
	var LoopOnce = exports.LoopMode.Once;
	var LoopRepeat = exports.LoopMode.Repeat;
	var LoopPingPong = exports.LoopMode.PingPong;
	(function (InterpolateMode) {
	    InterpolateMode[InterpolateMode["Discrete"] = 2300] = "Discrete";
	    InterpolateMode[InterpolateMode["Linear"] = 2301] = "Linear";
	    InterpolateMode[InterpolateMode["Smooth"] = 2302] = "Smooth";
	})(exports.InterpolateMode || (exports.InterpolateMode = {}));
	var InterpolateDiscrete = exports.InterpolateMode.Discrete;
	var InterpolateLinear = exports.InterpolateMode.Linear;
	var InterpolateSmooth = exports.InterpolateMode.Smooth;
	(function (EndingMode) {
	    EndingMode[EndingMode["ZeroCurvature"] = 2400] = "ZeroCurvature";
	    EndingMode[EndingMode["ZeroSlope"] = 2401] = "ZeroSlope";
	    EndingMode[EndingMode["WrapAround"] = 2402] = "WrapAround";
	})(exports.EndingMode || (exports.EndingMode = {}));
	var ZeroCurvatureEnding = exports.EndingMode.ZeroCurvature;
	var ZeroSlopeEnding = exports.EndingMode.ZeroSlope;
	var WrapAroundEnding = exports.EndingMode.WrapAround;
	(function (DrawMode) {
	    DrawMode[DrawMode["Triangles"] = 0] = "Triangles";
	    DrawMode[DrawMode["TriangleStrip"] = 1] = "TriangleStrip";
	    DrawMode[DrawMode["TriangleFan"] = 2] = "TriangleFan";
	})(exports.DrawMode || (exports.DrawMode = {}));
	var TrianglesDrawMode = exports.DrawMode.Triangles;
	var TriangleStripDrawMode = exports.DrawMode.TriangleStrip;
	var TriangleFanDrawMode = exports.DrawMode.TriangleFan;
	(function (TextureEncoding) {
	    TextureEncoding[TextureEncoding["Linear"] = 3000] = "Linear";
	    TextureEncoding[TextureEncoding["sRGB"] = 3001] = "sRGB";
	    TextureEncoding[TextureEncoding["Gamma"] = 3007] = "Gamma";
	    TextureEncoding[TextureEncoding["RGBE"] = 3002] = "RGBE";
	    TextureEncoding[TextureEncoding["LogLuv"] = 3003] = "LogLuv";
	    TextureEncoding[TextureEncoding["RGBM7"] = 3004] = "RGBM7";
	    TextureEncoding[TextureEncoding["RGBM16"] = 3005] = "RGBM16";
	    TextureEncoding[TextureEncoding["RGBD"] = 3006] = "RGBD";
	})(exports.TextureEncoding || (exports.TextureEncoding = {}));
	var LinearEncoding = exports.TextureEncoding.Linear;
	var sRGBEncoding = exports.TextureEncoding.sRGB;
	var GammaEncoding = exports.TextureEncoding.Gamma;
	var RGBEEncoding = exports.TextureEncoding.RGBE;
	var LogLuvEncoding = exports.TextureEncoding.LogLuv;
	var RGBM7Encoding = exports.TextureEncoding.RGBM7;
	var RGBM16Encoding = exports.TextureEncoding.RGBM16;
	var RGBDEncoding = exports.TextureEncoding.RGBD;
	(function (DepthPacking) {
	    DepthPacking[DepthPacking["Basic"] = 3200] = "Basic";
	    DepthPacking[DepthPacking["RGBA"] = 3201] = "RGBA";
	})(exports.DepthPacking || (exports.DepthPacking = {}));
	var BasicDepthPacking = exports.DepthPacking.Basic;
	var RGBADepthPacking = exports.DepthPacking.RGBA;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	var _Math = /** @class */ (function () {
	    function _Math() {
	    }
	    _Math.generateUUID = function () {
	        var chars = _Math.generateUUID_chars;
	        var uuid = _Math.generateUUID_uuid;
	        for (var i = 0; i < 36; i++) {
	            if (i === 8 || i === 13 || i === 18 || i === 23) {
	                uuid[i] = '-';
	            }
	            else if (i === 14) {
	                uuid[i] = '4';
	            }
	            else {
	                var rnd = _Math.generateUUID_rnd;
	                if (rnd <= 0x02)
	                    rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
	                var r = rnd & 0xf;
	                _Math.generateUUID_rnd = rnd >> 4;
	                uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];
	            }
	        }
	        return uuid.join('');
	    };
	    _Math.clamp = function (value, min, max) {
	        return Math.max(min, Math.min(max, value));
	    };
	    // compute euclidian modulo of m % n
	    // https://en.wikipedia.org/wiki/Modulo_operation
	    _Math.euclideanModulo = function (n, m) {
	        return ((n % m) + m) % m;
	    };
	    // Linear mapping from range <a1, a2> to range <b1, b2>
	    _Math.mapLinear = function (x, a1, a2, b1, b2) {
	        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
	    };
	    // https://en.wikipedia.org/wiki/Linear_interpolation
	    _Math.lerp = function (x, y, t) {
	        return (1 - t) * x + t * y;
	    };
	    // http://en.wikipedia.org/wiki/Smoothstep
	    _Math.smoothstep = function (x, min, max) {
	        if (x <= min)
	            return 0;
	        if (x >= max)
	            return 1;
	        x = (x - min) / (max - min);
	        return x * x * (3 - 2 * x);
	    };
	    _Math.smootherstep = function (x, min, max) {
	        if (x <= min)
	            return 0;
	        if (x >= max)
	            return 1;
	        x = (x - min) / (max - min);
	        return x * x * x * (x * (x * 6 - 15) + 10);
	    };
	    _Math.random16 = function () {
	        console.warn('THREE.Math.random16() has been deprecated. Use Math.random() instead.');
	        return Math.random();
	    };
	    // Random integer from <low, high> interval
	    _Math.randInt = function (low, high) {
	        return low + Math.floor(Math.random() * (high - low + 1));
	    };
	    // Random float from <low, high> interval
	    _Math.randFloat = function (low, high) {
	        return low + Math.random() * (high - low);
	    };
	    // Random float from <-range/2, range/2> interval
	    _Math.randFloatSpread = function (range) {
	        return range * (0.5 - Math.random());
	    };
	    _Math.degToRad = function (degrees) {
	        return degrees * _Math.DEG2RAD;
	    };
	    _Math.radToDeg = function (radians) {
	        return radians * _Math.RAD2DEG;
	    };
	    _Math.isPowerOfTwo = function (value) {
	        return (value & (value - 1)) === 0 && value !== 0;
	    };
	    _Math.nearestPowerOfTwo = function (value) {
	        return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
	    };
	    _Math.nextPowerOfTwo = function (value) {
	        value--;
	        value |= value >> 1;
	        value |= value >> 2;
	        value |= value >> 4;
	        value |= value >> 8;
	        value |= value >> 16;
	        value++;
	        return value;
	    };
	    _Math.DEG2RAD = Math.PI / 180;
	    _Math.RAD2DEG = 180 / Math.PI;
	    _Math.generateUUID_chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
	    _Math.generateUUID_uuid = new Array(36);
	    _Math.generateUUID_rnd = 0;
	    return _Math;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	var Vector2 = /** @class */ (function () {
	    function Vector2(x, y) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        this.isVector2 = true;
	        this.x = x;
	        this.y = y;
	    }
	    Object.defineProperty(Vector2.prototype, "width", {
	        get: function () { return this.x; },
	        set: function (value) { this.x = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Vector2.prototype, "height", {
	        get: function () { return this.y; },
	        set: function (value) { this.y = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Vector2.prototype.set = function (x, y) {
	        this.x = x;
	        this.y = y;
	        return this;
	    };
	    Vector2.prototype.setScalar = function (scalar) {
	        this.x = scalar;
	        this.y = scalar;
	        return this;
	    };
	    Vector2.prototype.setX = function (x) {
	        this.x = x;
	        return this;
	    };
	    Vector2.prototype.setY = function (y) {
	        this.y = y;
	        return this;
	    };
	    Vector2.prototype.setComponent = function (index, value) {
	        switch (index) {
	            case 0:
	                this.x = value;
	                break;
	            case 1:
	                this.y = value;
	                break;
	            default: throw new Error('index is out of range: ' + index);
	        }
	        return this;
	    };
	    Vector2.prototype.getComponent = function (index) {
	        switch (index) {
	            case 0: return this.x;
	            case 1: return this.y;
	            default: throw new Error('index is out of range: ' + index);
	        }
	    };
	    Vector2.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Vector2.prototype.copy = function (v) {
	        this.x = v.x;
	        this.y = v.y;
	        return this;
	    };
	    Vector2.prototype.add = function (v, w) {
	        if (w !== undefined) {
	            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors(a, b) instead.');
	            return this.addVectors(v, w);
	        }
	        this.x += v.x;
	        this.y += v.y;
	        return this;
	    };
	    Vector2.prototype.addScalar = function (s) {
	        this.x += s;
	        this.y += s;
	        return this;
	    };
	    Vector2.prototype.addVectors = function (a, b) {
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        return this;
	    };
	    Vector2.prototype.addScaledVector = function (v, s) {
	        this.x += v.x * s;
	        this.y += v.y * s;
	        return this;
	    };
	    Vector2.prototype.sub = function (v, w) {
	        if (w !== undefined) {
	            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors(a, b) instead.');
	            return this.subVectors(v, w);
	        }
	        this.x -= v.x;
	        this.y -= v.y;
	        return this;
	    };
	    Vector2.prototype.subScalar = function (s) {
	        this.x -= s;
	        this.y -= s;
	        return this;
	    };
	    Vector2.prototype.subVectors = function (a, b) {
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        return this;
	    };
	    Vector2.prototype.multiply = function (v) {
	        this.x *= v.x;
	        this.y *= v.y;
	        return this;
	    };
	    Vector2.prototype.multiplyScalar = function (scalar) {
	        if (isFinite(scalar)) {
	            this.x *= scalar;
	            this.y *= scalar;
	        }
	        else {
	            this.x = 0;
	            this.y = 0;
	        }
	        return this;
	    };
	    Vector2.prototype.divide = function (v) {
	        this.x /= v.x;
	        this.y /= v.y;
	        return this;
	    };
	    Vector2.prototype.divideScalar = function (scalar) {
	        return this.multiplyScalar(1 / scalar);
	    };
	    Vector2.prototype.min = function (v) {
	        this.x = Math.min(this.x, v.x);
	        this.y = Math.min(this.y, v.y);
	        return this;
	    };
	    Vector2.prototype.max = function (v) {
	        this.x = Math.max(this.x, v.x);
	        this.y = Math.max(this.y, v.y);
	        return this;
	    };
	    Vector2.prototype.clamp = function (min, max) {
	        // This function assumes min < max, if this assumption isn't true it will not operate correctly
	        this.x = Math.max(min.x, Math.min(max.x, this.x));
	        this.y = Math.max(min.y, Math.min(max.y, this.y));
	        return this;
	    };
	    Vector2.prototype.clampScalar = function (minVal, maxVal) {
	        var min = Vector2.clampScalar_min.set(minVal, minVal);
	        var max = Vector2.clampScalar_max.set(maxVal, maxVal);
	        return this.clamp(min, max);
	    };
	    Vector2.prototype.clampLength = function (min, max) {
	        var length = this.length();
	        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
	    };
	    Vector2.prototype.floor = function () {
	        this.x = Math.floor(this.x);
	        this.y = Math.floor(this.y);
	        return this;
	    };
	    Vector2.prototype.ceil = function () {
	        this.x = Math.ceil(this.x);
	        this.y = Math.ceil(this.y);
	        return this;
	    };
	    Vector2.prototype.round = function () {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        return this;
	    };
	    Vector2.prototype.roundToZero = function () {
	        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
	        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
	        return this;
	    };
	    Vector2.prototype.negate = function () {
	        this.x = -this.x;
	        this.y = -this.y;
	        return this;
	    };
	    Vector2.prototype.dot = function (v) {
	        return this.x * v.x + this.y * v.y;
	    };
	    Vector2.prototype.lengthSq = function () {
	        return this.x * this.x + this.y * this.y;
	    };
	    Vector2.prototype.length = function () {
	        return Math.sqrt(this.x * this.x + this.y * this.y);
	    };
	    Vector2.prototype.lengthManhattan = function () {
	        return Math.abs(this.x) + Math.abs(this.y);
	    };
	    Vector2.prototype.normalize = function () {
	        return this.divideScalar(this.length());
	    };
	    Vector2.prototype.angle = function () {
	        // computes the angle in radians with respect to the positive x-axis
	        var angle = Math.atan2(this.y, this.x);
	        if (angle < 0)
	            angle += 2 * Math.PI;
	        return angle;
	    };
	    Vector2.prototype.distanceTo = function (v) {
	        return Math.sqrt(this.distanceToSquared(v));
	    };
	    Vector2.prototype.distanceToSquared = function (v) {
	        var dx = this.x - v.x, dy = this.y - v.y;
	        return dx * dx + dy * dy;
	    };
	    Vector2.prototype.distanceToManhattan = function (v) {
	        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
	    };
	    Vector2.prototype.setLength = function (length) {
	        return this.multiplyScalar(length / this.length());
	    };
	    Vector2.prototype.lerp = function (v, alpha) {
	        this.x += (v.x - this.x) * alpha;
	        this.y += (v.y - this.y) * alpha;
	        return this;
	    };
	    Vector2.prototype.lerpVectors = function (v1, v2, alpha) {
	        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
	    };
	    Vector2.prototype.equals = function (v) {
	        return ((v.x === this.x) && (v.y === this.y));
	    };
	    Vector2.prototype.fromArray = function (array, offset) {
	        if (offset === void 0) { offset = 0; }
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        return this;
	    };
	    Vector2.prototype.toArray = function (array, offset) {
	        if (array === void 0) { array = []; }
	        if (offset === void 0) { offset = 0; }
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        return array;
	    };
	    Vector2.prototype.fromAttribute = function (attribute, index, offset) {
	        if (offset === void 0) { offset = 0; }
	        index = index * attribute.itemSize + offset;
	        this.x = attribute.array[index];
	        this.y = attribute.array[index + 1];
	        return this;
	    };
	    Vector2.prototype.rotateAround = function (center, angle) {
	        var c = Math.cos(angle), s = Math.sin(angle);
	        var x = this.x - center.x;
	        var y = this.y - center.y;
	        this.x = x * c - y * s + center.x;
	        this.y = x * s + y * c + center.y;
	        return this;
	    };
	    Vector2.clampScalar_min = new Vector2();
	    Vector2.clampScalar_max = new Vector2();
	    return Vector2;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	var Texture = /** @class */ (function (_super) {
	    __extends(Texture, _super);
	    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
	        if (image === void 0) { image = Texture.DEFAULT_IMAGE; }
	        if (mapping === void 0) { mapping = Texture.DEFAULT_MAPPING; }
	        if (wrapS === void 0) { wrapS = exports.TextureWrapping.ClampToEdge; }
	        if (wrapT === void 0) { wrapT = exports.TextureWrapping.ClampToEdge; }
	        if (magFilter === void 0) { magFilter = exports.TextureFilter.Linear; }
	        if (minFilter === void 0) { minFilter = exports.TextureFilter.LinearMipMapLinear; }
	        if (format === void 0) { format = exports.TextureFormat.RGBA; }
	        if (type === void 0) { type = exports.TextureType.UnsignedByte; }
	        if (anisotropy === void 0) { anisotropy = 1; }
	        if (encoding === void 0) { encoding = exports.TextureEncoding.Linear; }
	        var _this = _super.call(this) || this;
	        _this.id = TextureIdCount();
	        _this.uuid = _Math.generateUUID();
	        _this.name = '';
	        _this.sourceFile = '';
	        _this.mipmaps = [];
	        _this.offset = new Vector2(0, 0);
	        _this.repeat = new Vector2(1, 1);
	        _this.generateMipmaps = true;
	        _this.premultiplyAlpha = false;
	        _this.flipY = true;
	        _this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	        _this.version = 0;
	        _this.onUpdate = null;
	        _this.isTexture = true;
	        _this.image = image;
	        _this.mapping = mapping;
	        _this.wrapS = wrapS;
	        _this.wrapT = wrapT;
	        _this.magFilter = magFilter;
	        _this.minFilter = minFilter;
	        _this.anisotropy = anisotropy;
	        _this.format = format;
	        _this.type = type;
	        _this.encoding = encoding;
	        return _this;
	    }
	    Object.defineProperty(Texture.prototype, "needsUpdate", {
	        set: function (value) {
	            if (value === true)
	                this.version++;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Texture.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Texture.prototype.copy = function (source) {
	        this.image = source.image;
	        this.mipmaps = source.mipmaps.slice(0);
	        this.mapping = source.mapping;
	        this.wrapS = source.wrapS;
	        this.wrapT = source.wrapT;
	        this.magFilter = source.magFilter;
	        this.minFilter = source.minFilter;
	        this.anisotropy = source.anisotropy;
	        this.format = source.format;
	        this.type = source.type;
	        this.offset.copy(source.offset);
	        this.repeat.copy(source.repeat);
	        this.generateMipmaps = source.generateMipmaps;
	        this.premultiplyAlpha = source.premultiplyAlpha;
	        this.flipY = source.flipY;
	        this.unpackAlignment = source.unpackAlignment;
	        this.encoding = source.encoding;
	        return this;
	    };
	    Texture.prototype.toJSON = function (meta) {
	        if (meta.textures[this.uuid] !== undefined) {
	            return meta.textures[this.uuid];
	        }
	        function getDataURL(image) {
	            var canvas;
	            if (image instanceof HTMLCanvasElement) {
	                canvas = image;
	            }
	            else {
	                canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
	                canvas.width = image.width;
	                canvas.height = image.height;
	                canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
	            }
	            if (canvas.width > 2048 || canvas.height > 2048) {
	                return canvas.toDataURL('image/jpeg', 0.6);
	            }
	            else {
	                return canvas.toDataURL('image/png');
	            }
	        }
	        var output = {
	            metadata: {
	                version: 4.4,
	                type: 'Texture',
	                generator: 'Texture.toJSON'
	            },
	            uuid: this.uuid,
	            name: this.name,
	            mapping: this.mapping,
	            repeat: [this.repeat.x, this.repeat.y],
	            offset: [this.offset.x, this.offset.y],
	            wrap: [this.wrapS, this.wrapT],
	            minFilter: this.minFilter,
	            magFilter: this.magFilter,
	            anisotropy: this.anisotropy,
	            flipY: this.flipY
	        };
	        if (this.image !== undefined) {
	            // TODO: Move to THREE.Image
	            var image = this.image;
	            if (image.uuid === undefined) {
	                image.uuid = _Math.generateUUID(); // UGH
	            }
	            if (meta.images[image.uuid] === undefined) {
	                meta.images[image.uuid] = {
	                    uuid: image.uuid,
	                    url: getDataURL(image)
	                };
	            }
	            output.image = image.uuid;
	        }
	        meta.textures[this.uuid] = output;
	        return output;
	    };
	    Texture.prototype.dispose = function () {
	        this.dispatchEvent({ type: 'dispose' });
	    };
	    Texture.prototype.transformUv = function (uv) {
	        if (this.mapping !== exports.TextureMapping.UV)
	            return;
	        uv.multiply(this.repeat);
	        uv.add(this.offset);
	        if (uv.x < 0 || uv.x > 1) {
	            switch (this.wrapS) {
	                case exports.TextureWrapping.Repeat:
	                    uv.x = uv.x - Math.floor(uv.x);
	                    break;
	                case exports.TextureWrapping.ClampToEdge:
	                    uv.x = uv.x < 0 ? 0 : 1;
	                    break;
	                case exports.TextureWrapping.MirroredRepeat:
	                    if (Math.abs(Math.floor(uv.x) % 2) === 1) {
	                        uv.x = Math.ceil(uv.x) - uv.x;
	                    }
	                    else {
	                        uv.x = uv.x - Math.floor(uv.x);
	                    }
	                    break;
	            }
	        }
	        if (uv.y < 0 || uv.y > 1) {
	            switch (this.wrapT) {
	                case exports.TextureWrapping.Repeat:
	                    uv.y = uv.y - Math.floor(uv.y);
	                    break;
	                case exports.TextureWrapping.ClampToEdge:
	                    uv.y = uv.y < 0 ? 0 : 1;
	                    break;
	                case exports.TextureWrapping.MirroredRepeat:
	                    if (Math.abs(Math.floor(uv.y) % 2) === 1) {
	                        uv.y = Math.ceil(uv.y) - uv.y;
	                    }
	                    else {
	                        uv.y = uv.y - Math.floor(uv.y);
	                    }
	                    break;
	            }
	        }
	        if (this.flipY) {
	            uv.y = 1 - uv.y;
	        }
	    };
	    Texture.DEFAULT_IMAGE = undefined;
	    Texture.DEFAULT_MAPPING = exports.TextureMapping.UV;
	    return Texture;
	}(EventDispatcher));
	var count = 0;
	function TextureIdCount() { return count++; }

	var Vector4 = /** @class */ (function () {
	    function Vector4(x, y, z, w) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (w === void 0) { w = 1; }
	        this.isVector4 = true;
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	    }
	    Vector4.prototype.set = function (x, y, z, w) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	        return this;
	    };
	    Vector4.prototype.setScalar = function (scalar) {
	        this.x = scalar;
	        this.y = scalar;
	        this.z = scalar;
	        this.w = scalar;
	        return this;
	    };
	    Vector4.prototype.setX = function (x) {
	        this.x = x;
	        return this;
	    };
	    Vector4.prototype.setY = function (y) {
	        this.y = y;
	        return this;
	    };
	    Vector4.prototype.setZ = function (z) {
	        this.z = z;
	        return this;
	    };
	    Vector4.prototype.setW = function (w) {
	        this.w = w;
	        return this;
	    };
	    Vector4.prototype.setComponent = function (index, value) {
	        switch (index) {
	            case 0:
	                this.x = value;
	                break;
	            case 1:
	                this.y = value;
	                break;
	            case 2:
	                this.z = value;
	                break;
	            case 3:
	                this.w = value;
	                break;
	            default: throw new Error('index is out of range: ' + index);
	        }
	        return this;
	    };
	    Vector4.prototype.getComponent = function (index) {
	        switch (index) {
	            case 0: return this.x;
	            case 1: return this.y;
	            case 2: return this.z;
	            case 3: return this.w;
	            default: throw new Error('index is out of range: ' + index);
	        }
	    };
	    Vector4.prototype.clone = function () {
	        return new this.constructor(this.x, this.y, this.z, this.w);
	    };
	    Vector4.prototype.copy = function (v) {
	        this.x = v.x;
	        this.y = v.y;
	        this.z = v.z;
	        this.w = v.w;
	        return this;
	    };
	    Vector4.prototype.add = function (v, w) {
	        if (w !== undefined) {
	            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors(a, b) instead.');
	            return this.addVectors(v, w);
	        }
	        this.x += v.x;
	        this.y += v.y;
	        this.z += v.z;
	        this.w += v.w;
	        return this;
	    };
	    Vector4.prototype.addScalar = function (s) {
	        this.x += s;
	        this.y += s;
	        this.z += s;
	        this.w += s;
	        return this;
	    };
	    Vector4.prototype.addVectors = function (a, b) {
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        this.z = a.z + b.z;
	        this.w = a.w + b.w;
	        return this;
	    };
	    Vector4.prototype.addScaledVector = function (v, s) {
	        this.x += v.x * s;
	        this.y += v.y * s;
	        this.z += v.z * s;
	        this.w += v.w * s;
	        return this;
	    };
	    Vector4.prototype.sub = function (v, w) {
	        if (w !== undefined) {
	            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors(a, b) instead.');
	            return this.subVectors(v, w);
	        }
	        this.x -= v.x;
	        this.y -= v.y;
	        this.z -= v.z;
	        this.w -= v.w;
	        return this;
	    };
	    Vector4.prototype.subScalar = function (s) {
	        this.x -= s;
	        this.y -= s;
	        this.z -= s;
	        this.w -= s;
	        return this;
	    };
	    Vector4.prototype.subVectors = function (a, b) {
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        this.z = a.z - b.z;
	        this.w = a.w - b.w;
	        return this;
	    };
	    Vector4.prototype.multiplyScalar = function (scalar) {
	        if (isFinite(scalar)) {
	            this.x *= scalar;
	            this.y *= scalar;
	            this.z *= scalar;
	            this.w *= scalar;
	        }
	        else {
	            this.x = 0;
	            this.y = 0;
	            this.z = 0;
	            this.w = 0;
	        }
	        return this;
	    };
	    Vector4.prototype.applyMatrix4 = function (m) {
	        var x = this.x, y = this.y, z = this.z, w = this.w;
	        var e = m.elements;
	        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
	        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
	        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
	        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
	        return this;
	    };
	    Vector4.prototype.divideScalar = function (scalar) {
	        return this.multiplyScalar(1 / scalar);
	    };
	    Vector4.prototype.setAxisAngleFromQuaternion = function (q) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	        // q is assumed to be normalized
	        this.w = 2 * Math.acos(q.w);
	        var s = Math.sqrt(1 - q.w * q.w);
	        if (s < 0.0001) {
	            this.x = 1;
	            this.y = 0;
	            this.z = 0;
	        }
	        else {
	            this.x = q.x / s;
	            this.y = q.y / s;
	            this.z = q.z / s;
	        }
	        return this;
	    };
	    Vector4.prototype.setAxisAngleFromRotationMatrix = function (m) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	        var angle, x, y, z; // variables for result
	        var epsilon = 0.01, // margin to allow for rounding errors
	        epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
	        te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
	        if ((Math.abs(m12 - m21) < epsilon) &&
	            (Math.abs(m13 - m31) < epsilon) &&
	            (Math.abs(m23 - m32) < epsilon)) {
	            // singularity found
	            // first check for identity matrix which must have +1 for all terms
	            // in leading diagonal and zero in other terms
	            if ((Math.abs(m12 + m21) < epsilon2) &&
	                (Math.abs(m13 + m31) < epsilon2) &&
	                (Math.abs(m23 + m32) < epsilon2) &&
	                (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
	                // this singularity is identity matrix so angle = 0
	                this.set(1, 0, 0, 0);
	                return this; // zero angle, arbitrary axis
	            }
	            // otherwise this singularity is angle = 180
	            angle = Math.PI;
	            var xx = (m11 + 1) / 2;
	            var yy = (m22 + 1) / 2;
	            var zz = (m33 + 1) / 2;
	            var xy = (m12 + m21) / 4;
	            var xz = (m13 + m31) / 4;
	            var yz = (m23 + m32) / 4;
	            if ((xx > yy) && (xx > zz)) {
	                // m11 is the largest diagonal term
	                if (xx < epsilon) {
	                    x = 0;
	                    y = 0.707106781;
	                    z = 0.707106781;
	                }
	                else {
	                    x = Math.sqrt(xx);
	                    y = xy / x;
	                    z = xz / x;
	                }
	            }
	            else if (yy > zz) {
	                // m22 is the largest diagonal term
	                if (yy < epsilon) {
	                    x = 0.707106781;
	                    y = 0;
	                    z = 0.707106781;
	                }
	                else {
	                    y = Math.sqrt(yy);
	                    x = xy / y;
	                    z = yz / y;
	                }
	            }
	            else {
	                // m33 is the largest diagonal term so base result on this
	                if (zz < epsilon) {
	                    x = 0.707106781;
	                    y = 0.707106781;
	                    z = 0;
	                }
	                else {
	                    z = Math.sqrt(zz);
	                    x = xz / z;
	                    y = yz / z;
	                }
	            }
	            this.set(x, y, z, angle);
	            return this; // return 180 deg rotation
	        }
	        // as we have reached here there are no singularities so we can handle normally
	        var s = Math.sqrt((m32 - m23) * (m32 - m23) +
	            (m13 - m31) * (m13 - m31) +
	            (m21 - m12) * (m21 - m12)); // used to normalize
	        if (Math.abs(s) < 0.001)
	            s = 1;
	        // prevent divide by zero, should not happen if matrix is orthogonal and should be
	        // caught by singularity test above, but I've left it in just in case
	        this.x = (m32 - m23) / s;
	        this.y = (m13 - m31) / s;
	        this.z = (m21 - m12) / s;
	        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
	        return this;
	    };
	    Vector4.prototype.min = function (v) {
	        this.x = Math.min(this.x, v.x);
	        this.y = Math.min(this.y, v.y);
	        this.z = Math.min(this.z, v.z);
	        this.w = Math.min(this.w, v.w);
	        return this;
	    };
	    Vector4.prototype.max = function (v) {
	        this.x = Math.max(this.x, v.x);
	        this.y = Math.max(this.y, v.y);
	        this.z = Math.max(this.z, v.z);
	        this.w = Math.max(this.w, v.w);
	        return this;
	    };
	    Vector4.prototype.clamp = function (min, max) {
	        // This function assumes min < max, if this assumption isn't true it will not operate correctly
	        this.x = Math.max(min.x, Math.min(max.x, this.x));
	        this.y = Math.max(min.y, Math.min(max.y, this.y));
	        this.z = Math.max(min.z, Math.min(max.z, this.z));
	        this.w = Math.max(min.w, Math.min(max.w, this.w));
	        return this;
	    };
	    Vector4.prototype.clampScalar = function (minVal, maxVal) {
	        var min = Vector4._clampScalar_min, max = Vector4._clampScalar_max;
	        min.set(minVal, minVal, minVal, minVal);
	        max.set(maxVal, maxVal, maxVal, maxVal);
	        return this.clamp(min, max);
	    };
	    Vector4.prototype.floor = function () {
	        this.x = Math.floor(this.x);
	        this.y = Math.floor(this.y);
	        this.z = Math.floor(this.z);
	        this.w = Math.floor(this.w);
	        return this;
	    };
	    Vector4.prototype.ceil = function () {
	        this.x = Math.ceil(this.x);
	        this.y = Math.ceil(this.y);
	        this.z = Math.ceil(this.z);
	        this.w = Math.ceil(this.w);
	        return this;
	    };
	    Vector4.prototype.round = function () {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        this.z = Math.round(this.z);
	        this.w = Math.round(this.w);
	        return this;
	    };
	    Vector4.prototype.roundToZero = function () {
	        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
	        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
	        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
	        this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
	        return this;
	    };
	    Vector4.prototype.negate = function () {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	        this.w = -this.w;
	        return this;
	    };
	    Vector4.prototype.dot = function (v) {
	        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	    };
	    Vector4.prototype.lengthSq = function () {
	        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	    };
	    Vector4.prototype.length = function () {
	        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	    };
	    Vector4.prototype.lengthManhattan = function () {
	        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
	    };
	    Vector4.prototype.normalize = function () {
	        return this.divideScalar(this.length());
	    };
	    Vector4.prototype.setLength = function (length) {
	        return this.multiplyScalar(length / this.length());
	    };
	    Vector4.prototype.lerp = function (v, alpha) {
	        this.x += (v.x - this.x) * alpha;
	        this.y += (v.y - this.y) * alpha;
	        this.z += (v.z - this.z) * alpha;
	        this.w += (v.w - this.w) * alpha;
	        return this;
	    };
	    Vector4.prototype.lerpVectors = function (v1, v2, alpha) {
	        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
	    };
	    Vector4.prototype.equals = function (v) {
	        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
	    };
	    Vector4.prototype.fromArray = function (array, offset) {
	        if (offset === void 0) { offset = 0; }
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        this.z = array[offset + 2];
	        this.w = array[offset + 3];
	        return this;
	    };
	    Vector4.prototype.toArray = function (array, offset) {
	        if (array === void 0) { array = []; }
	        if (offset === void 0) { offset = 0; }
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        array[offset + 2] = this.z;
	        array[offset + 3] = this.w;
	        return array;
	    };
	    Vector4.prototype.fromAttribute = function (attribute, index, offset) {
	        if (offset === void 0) { offset = 0; }
	        index = index * attribute.itemSize + offset;
	        this.x = attribute.array[index];
	        this.y = attribute.array[index + 1];
	        this.z = attribute.array[index + 2];
	        this.w = attribute.array[index + 3];
	        return this;
	    };
	    Vector4._clampScalar_min = new Vector4();
	    Vector4._clampScalar_max = new Vector4();
	    return Vector4;
	}());

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */
	var WebGLRenderTarget = /** @class */ (function (_super) {
	    __extends(WebGLRenderTarget, _super);
	    /*
	     In options, we can specify:
	     * Texture parameters for an auto-generated target texture
	     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	    */
	    function WebGLRenderTarget(width, height, options) {
	        var _this = _super.call(this) || this;
	        _this.isWebGLRenderTarget = true;
	        _this.uuid = _Math.generateUUID();
	        _this.width = width;
	        _this.height = height;
	        _this.scissor = new Vector4(0, 0, width, height);
	        _this.scissorTest = false;
	        _this.viewport = new Vector4(0, 0, width, height);
	        options = options || {};
	        if (options.minFilter === undefined)
	            options.minFilter = exports.TextureFilter.Linear;
	        _this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
	        _this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	        _this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	        _this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
	        return _this;
	    }
	    WebGLRenderTarget.prototype.setSize = function (width, height) {
	        if (this.width !== width || this.height !== height) {
	            this.width = width;
	            this.height = height;
	            this.dispose();
	        }
	        this.viewport.set(0, 0, width, height);
	        this.scissor.set(0, 0, width, height);
	    };
	    WebGLRenderTarget.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    WebGLRenderTarget.prototype.copy = function (source) {
	        this.width = source.width;
	        this.height = source.height;
	        this.viewport.copy(source.viewport);
	        this.texture = source.texture.clone();
	        this.depthBuffer = source.depthBuffer;
	        this.stencilBuffer = source.stencilBuffer;
	        this.depthTexture = source.depthTexture;
	        return this;
	    };
	    WebGLRenderTarget.prototype.dispose = function () {
	        this.dispatchEvent({ type: 'dispose' });
	    };
	    Object.defineProperty(WebGLRenderTarget.prototype, "wrapS", {
	        get: function () {
	            console.warn("THREE.WebGLRenderTarget .wrapS is now .texture.wrapS.");
	            return this.texture.wrapS;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderTarget .wrapS is now .texture.wrapS.");
	            this.texture.wrapS = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderTarget.prototype, "wrapT", {
	        get: function () {
	            console.warn("THREE.WebGLRenderTarget .wrapT is now .texture.wrapT.");
	            return this.texture.wrapT;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderTarget .wrapT is now .texture.wrapT.");
	            this.texture.wrapT = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderTarget.prototype, "magFilter", {
	        get: function () {
	            console.warn("THREE.WebGLRenderTarget .magFilter is now .texture.magFilter.");
	            return this.texture.magFilter;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderTarget .magFilter is now .texture.magFilter.");
	            this.texture.magFilter = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderTarget.prototype, "minFilter", {
	        get: function () {
	            console.warn("THREE.WebGLRenderTarget .minFilter is now .texture.minFilter.");
	            return this.texture.minFilter;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderTarget .minFilter is now .texture.minFilter.");
	            this.texture.minFilter = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderTarget.prototype, "anisotropy", {
	        get: function () {
	            console.warn("THREE.WebGLRenderTarget .anisotropy is now .texture.anisotropy.");
	            return this.texture.anisotropy;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderTarget .anisotropy is now .texture.anisotropy.");
	            this.texture.anisotropy = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderTarget.prototype, "offset", {
	        get: function () {
	            console.warn("THREE.WebGLRenderTarget .offset is now .texture.offset.");
	            return this.texture.offset;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderTarget .offset is now .texture.offset.");
	            this.texture.offset = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderTarget.prototype, "repeat", {
	        get: function () {
	            console.warn("THREE.WebGLRenderTarget .repeat is now .texture.repeat.");
	            return this.texture.repeat;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderTarget .repeat is now .texture.repeat.");
	            this.texture.repeat = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderTarget.prototype, "format", {
	        get: function () {
	            console.warn("THREE.WebGLRenderTarget .format is now .texture.format.");
	            return this.texture.format;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderTarget .format is now .texture.format.");
	            this.texture.format = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderTarget.prototype, "type", {
	        get: function () {
	            console.warn("THREE.WebGLRenderTarget .type is now .texture.type.");
	            return this.texture.type;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderTarget .type is now .texture.type.");
	            this.texture.type = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderTarget.prototype, "generateMipmaps", {
	        get: function () {
	            console.warn("THREE.WebGLRenderTarget .generateMipmaps is now .texture.generateMipmaps.");
	            return this.texture.generateMipmaps;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderTarget .generateMipmaps is now .texture.generateMipmaps.");
	            this.texture.generateMipmaps = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return WebGLRenderTarget;
	}(EventDispatcher));

	/**
	 * @author alteredq / http://alteredqualia.com
	 */
	var WebGLRenderTargetCube = /** @class */ (function (_super) {
	    __extends(WebGLRenderTargetCube, _super);
	    function WebGLRenderTargetCube(width, height, options) {
	        var _this = _super.call(this, width, height, options) || this;
	        _this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	        _this.activeMipMapLevel = 0;
	        _this.isWebGLRenderTargetCube = true;
	        return _this;
	    }
	    return WebGLRenderTargetCube;
	}(WebGLRenderTarget));

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	var Quaternion = /** @class */ (function () {
	    function Quaternion(x, y, z, w) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (w === void 0) { w = 1; }
	        this.onChangeCallback = function () { };
	        this._x = x;
	        this._y = y;
	        this._z = z;
	        this._w = w;
	    }
	    Object.defineProperty(Quaternion.prototype, "x", {
	        get: function () { return this._x; },
	        set: function (value) { this._x = value; this.onChangeCallback(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Quaternion.prototype, "y", {
	        get: function () { return this._y; },
	        set: function (value) { this._y = value; this.onChangeCallback(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Quaternion.prototype, "z", {
	        get: function () { return this._z; },
	        set: function (value) { this._z = value; this.onChangeCallback(); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Quaternion.prototype, "w", {
	        get: function () { return this._w; },
	        set: function (value) { this._w = value; this.onChangeCallback(); },
	        enumerable: true,
	        configurable: true
	    });
	    Quaternion.prototype.set = function (x, y, z, w) {
	        this._x = x;
	        this._y = y;
	        this._z = z;
	        this._w = w;
	        this.onChangeCallback();
	        return this;
	    };
	    Quaternion.prototype.clone = function () {
	        return new this.constructor(this._x, this._y, this._z, this._w);
	    };
	    Quaternion.prototype.copy = function (quaternion) {
	        this._x = quaternion.x;
	        this._y = quaternion.y;
	        this._z = quaternion.z;
	        this._w = quaternion.w;
	        this.onChangeCallback();
	        return this;
	    };
	    Quaternion.prototype.setFromEuler = function (euler, update) {
	        if (update === void 0) { update = true; }
	        // http://www.mathworks.com/matlabcentral/fileexchange/
	        //   20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
	        //  content/SpinCalc.m
	        var c1 = Math.cos(euler._x / 2);
	        var c2 = Math.cos(euler._y / 2);
	        var c3 = Math.cos(euler._z / 2);
	        var s1 = Math.sin(euler._x / 2);
	        var s2 = Math.sin(euler._y / 2);
	        var s3 = Math.sin(euler._z / 2);
	        var order = euler.order;
	        if (order === 'XYZ') {
	            this._x = s1 * c2 * c3 + c1 * s2 * s3;
	            this._y = c1 * s2 * c3 - s1 * c2 * s3;
	            this._z = c1 * c2 * s3 + s1 * s2 * c3;
	            this._w = c1 * c2 * c3 - s1 * s2 * s3;
	        }
	        else if (order === 'YXZ') {
	            this._x = s1 * c2 * c3 + c1 * s2 * s3;
	            this._y = c1 * s2 * c3 - s1 * c2 * s3;
	            this._z = c1 * c2 * s3 - s1 * s2 * c3;
	            this._w = c1 * c2 * c3 + s1 * s2 * s3;
	        }
	        else if (order === 'ZXY') {
	            this._x = s1 * c2 * c3 - c1 * s2 * s3;
	            this._y = c1 * s2 * c3 + s1 * c2 * s3;
	            this._z = c1 * c2 * s3 + s1 * s2 * c3;
	            this._w = c1 * c2 * c3 - s1 * s2 * s3;
	        }
	        else if (order === 'ZYX') {
	            this._x = s1 * c2 * c3 - c1 * s2 * s3;
	            this._y = c1 * s2 * c3 + s1 * c2 * s3;
	            this._z = c1 * c2 * s3 - s1 * s2 * c3;
	            this._w = c1 * c2 * c3 + s1 * s2 * s3;
	        }
	        else if (order === 'YZX') {
	            this._x = s1 * c2 * c3 + c1 * s2 * s3;
	            this._y = c1 * s2 * c3 + s1 * c2 * s3;
	            this._z = c1 * c2 * s3 - s1 * s2 * c3;
	            this._w = c1 * c2 * c3 - s1 * s2 * s3;
	        }
	        else if (order === 'XZY') {
	            this._x = s1 * c2 * c3 - c1 * s2 * s3;
	            this._y = c1 * s2 * c3 - s1 * c2 * s3;
	            this._z = c1 * c2 * s3 + s1 * s2 * c3;
	            this._w = c1 * c2 * c3 + s1 * s2 * s3;
	        }
	        if (update !== false)
	            this.onChangeCallback();
	        return this;
	    };
	    Quaternion.prototype.setFromAxisAngle = function (axis, angle) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	        // assumes axis is normalized
	        var halfAngle = angle / 2, s = Math.sin(halfAngle);
	        this._x = axis.x * s;
	        this._y = axis.y * s;
	        this._z = axis.z * s;
	        this._w = Math.cos(halfAngle);
	        this.onChangeCallback();
	        return this;
	    };
	    Quaternion.prototype.setFromRotationMatrix = function (m) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	        var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
	        var s;
	        if (trace > 0) {
	            s = 0.5 / Math.sqrt(trace + 1.0);
	            this._w = 0.25 / s;
	            this._x = (m32 - m23) * s;
	            this._y = (m13 - m31) * s;
	            this._z = (m21 - m12) * s;
	        }
	        else if (m11 > m22 && m11 > m33) {
	            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
	            this._w = (m32 - m23) / s;
	            this._x = 0.25 * s;
	            this._y = (m12 + m21) / s;
	            this._z = (m13 + m31) / s;
	        }
	        else if (m22 > m33) {
	            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
	            this._w = (m13 - m31) / s;
	            this._x = (m12 + m21) / s;
	            this._y = 0.25 * s;
	            this._z = (m23 + m32) / s;
	        }
	        else {
	            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
	            this._w = (m21 - m12) / s;
	            this._x = (m13 + m31) / s;
	            this._y = (m23 + m32) / s;
	            this._z = 0.25 * s;
	        }
	        this.onChangeCallback();
	        return this;
	    };
	    Quaternion.prototype.setFromUnitVectors = function (vFrom, vTo) {
	        // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	        // assumes direction vectors vFrom and vTo are normalized
	        var v1 = Quaternion._setFromUnitVectors_v1 = (Quaternion._setFromUnitVectors_v1 || new Vector3());
	        var EPS = 0.000001;
	        var r = vFrom.dot(vTo) + 1;
	        if (r < EPS) {
	            r = 0;
	            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
	                v1.set(-vFrom.y, vFrom.x, 0);
	            }
	            else {
	                v1.set(0, -vFrom.z, vFrom.y);
	            }
	        }
	        else {
	            v1.crossVectors(vFrom, vTo);
	        }
	        this._x = v1.x;
	        this._y = v1.y;
	        this._z = v1.z;
	        this._w = r;
	        return this.normalize();
	    };
	    Quaternion.prototype.inverse = function () {
	        return this.conjugate().normalize();
	    };
	    Quaternion.prototype.conjugate = function () {
	        this._x *= -1;
	        this._y *= -1;
	        this._z *= -1;
	        this.onChangeCallback();
	        return this;
	    };
	    Quaternion.prototype.dot = function (v) {
	        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	    };
	    Quaternion.prototype.lengthSq = function () {
	        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	    };
	    Quaternion.prototype.length = function () {
	        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
	    };
	    Quaternion.prototype.normalize = function () {
	        var l = this.length();
	        if (l === 0) {
	            this._x = 0;
	            this._y = 0;
	            this._z = 0;
	            this._w = 1;
	        }
	        else {
	            l = 1 / l;
	            this._x = this._x * l;
	            this._y = this._y * l;
	            this._z = this._z * l;
	            this._w = this._w * l;
	        }
	        this.onChangeCallback();
	        return this;
	    };
	    Quaternion.prototype.multiply = function (q, p) {
	        if (p !== undefined) {
	            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions(a, b) instead.');
	            return this.multiplyQuaternions(q, p);
	        }
	        return this.multiplyQuaternions(this, q);
	    };
	    Quaternion.prototype.premultiply = function (q) {
	        return this.multiplyQuaternions(q, this);
	    };
	    Quaternion.prototype.multiplyQuaternions = function (a, b) {
	        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
	        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
	        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
	        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
	        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	        this.onChangeCallback();
	        return this;
	    };
	    Quaternion.prototype.slerp = function (qb, t) {
	        if (t === 0)
	            return this;
	        if (t === 1)
	            return this.copy(qb);
	        var x = this._x, y = this._y, z = this._z, w = this._w;
	        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	        if (cosHalfTheta < 0) {
	            this._w = -qb._w;
	            this._x = -qb._x;
	            this._y = -qb._y;
	            this._z = -qb._z;
	            cosHalfTheta = -cosHalfTheta;
	        }
	        else {
	            this.copy(qb);
	        }
	        if (cosHalfTheta >= 1.0) {
	            this._w = w;
	            this._x = x;
	            this._y = y;
	            this._z = z;
	            return this;
	        }
	        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
	        if (Math.abs(sinHalfTheta) < 0.001) {
	            this._w = 0.5 * (w + this._w);
	            this._x = 0.5 * (x + this._x);
	            this._y = 0.5 * (y + this._y);
	            this._z = 0.5 * (z + this._z);
	            return this;
	        }
	        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
	        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
	        this._w = (w * ratioA + this._w * ratioB);
	        this._x = (x * ratioA + this._x * ratioB);
	        this._y = (y * ratioA + this._y * ratioB);
	        this._z = (z * ratioA + this._z * ratioB);
	        this.onChangeCallback();
	        return this;
	    };
	    Quaternion.prototype.equals = function (quaternion) {
	        return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
	    };
	    Quaternion.prototype.fromArray = function (array, offset) {
	        if (offset === void 0) { offset = 0; }
	        this._x = array[offset];
	        this._y = array[offset + 1];
	        this._z = array[offset + 2];
	        this._w = array[offset + 3];
	        this.onChangeCallback();
	        return this;
	    };
	    Quaternion.prototype.toArray = function (array, offset) {
	        if (array === void 0) { array = []; }
	        if (offset === void 0) { offset = 0; }
	        array[offset] = this._x;
	        array[offset + 1] = this._y;
	        array[offset + 2] = this._z;
	        array[offset + 3] = this._w;
	        return array;
	    };
	    Quaternion.prototype.onChange = function (callback) {
	        this.onChangeCallback = callback;
	        return this;
	    };
	    Quaternion.slerp = function (qa, qb, qm, t) {
	        return qm.copy(qa).slerp(qb, t);
	    };
	    Quaternion.slerpFlat = function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
	        // fuzz-free, array-based Quaternion SLERP operation
	        var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
	        var x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
	        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
	            var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = (cos >= 0 ? 1 : -1), sqrSin = 1 - cos * cos;
	            // Skip the Slerp for tiny steps to avoid numeric problems:
	            if (sqrSin > Number.EPSILON) {
	                var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
	                s = Math.sin(s * len) / sin;
	                t = Math.sin(t * len) / sin;
	            }
	            var tDir = t * dir;
	            x0 = x0 * s + x1 * tDir;
	            y0 = y0 * s + y1 * tDir;
	            z0 = z0 * s + z1 * tDir;
	            w0 = w0 * s + w1 * tDir;
	            // Normalize in case we just did a lerp:
	            if (s === 1 - t) {
	                var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
	                x0 *= f;
	                y0 *= f;
	                z0 *= f;
	                w0 *= f;
	            }
	        }
	        dst[dstOffset] = x0;
	        dst[dstOffset + 1] = y0;
	        dst[dstOffset + 2] = z0;
	        dst[dstOffset + 3] = w0;
	    };
	    Quaternion.prototype.multiplyVector3 = function (vector) {
	        console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion(quaternion) instead.");
	        return vector.applyQuaternion(this);
	    };
	    return Quaternion;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	var Vector3 = /** @class */ (function () {
	    function Vector3(x, y, z) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        this.isVector3 = true;
	        this.x = x;
	        this.y = y;
	        this.z = z;
	    }
	    Vector3.prototype.set = function (x, y, z) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        return this;
	    };
	    Vector3.prototype.setScalar = function (scalar) {
	        this.x = scalar;
	        this.y = scalar;
	        this.z = scalar;
	        return this;
	    };
	    Vector3.prototype.setX = function (x) {
	        this.x = x;
	        return this;
	    };
	    Vector3.prototype.setY = function (y) {
	        this.y = y;
	        return this;
	    };
	    Vector3.prototype.setZ = function (z) {
	        this.z = z;
	        return this;
	    };
	    Vector3.prototype.setComponent = function (index, value) {
	        switch (index) {
	            case 0:
	                this.x = value;
	                break;
	            case 1:
	                this.y = value;
	                break;
	            case 2:
	                this.z = value;
	                break;
	            default: throw new Error('index is out of range: ' + index);
	        }
	        return this;
	    };
	    Vector3.prototype.getComponent = function (index) {
	        switch (index) {
	            case 0: return this.x;
	            case 1: return this.y;
	            case 2: return this.z;
	            default: throw new Error('index is out of range: ' + index);
	        }
	    };
	    Vector3.prototype.clone = function () {
	        return new this.constructor(this.x, this.y, this.z);
	    };
	    Vector3.prototype.copy = function (v) {
	        this.x = v.x;
	        this.y = v.y;
	        this.z = v.z;
	        return this;
	    };
	    Vector3.prototype.add = function (v, w) {
	        if (w !== undefined) {
	            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors(a, b) instead.');
	            return this.addVectors(v, w);
	        }
	        this.x += v.x;
	        this.y += v.y;
	        this.z += v.z;
	        return this;
	    };
	    Vector3.prototype.addScalar = function (s) {
	        this.x += s;
	        this.y += s;
	        this.z += s;
	        return this;
	    };
	    Vector3.prototype.addVectors = function (a, b) {
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        this.z = a.z + b.z;
	        return this;
	    };
	    Vector3.prototype.addScaledVector = function (v, s) {
	        this.x += v.x * s;
	        this.y += v.y * s;
	        this.z += v.z * s;
	        return this;
	    };
	    Vector3.prototype.sub = function (v, w) {
	        if (w !== undefined) {
	            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors(a, b) instead.');
	            return this.subVectors(v, w);
	        }
	        this.x -= v.x;
	        this.y -= v.y;
	        this.z -= v.z;
	        return this;
	    };
	    Vector3.prototype.subScalar = function (s) {
	        this.x -= s;
	        this.y -= s;
	        this.z -= s;
	        return this;
	    };
	    Vector3.prototype.subVectors = function (a, b) {
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        this.z = a.z - b.z;
	        return this;
	    };
	    Vector3.prototype.multiply = function (v, w) {
	        if (w !== undefined) {
	            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors(a, b) instead.');
	            return this.multiplyVectors(v, w);
	        }
	        this.x *= v.x;
	        this.y *= v.y;
	        this.z *= v.z;
	        return this;
	    };
	    Vector3.prototype.multiplyScalar = function (scalar) {
	        if (isFinite(scalar)) {
	            this.x *= scalar;
	            this.y *= scalar;
	            this.z *= scalar;
	        }
	        else {
	            this.x = 0;
	            this.y = 0;
	            this.z = 0;
	        }
	        return this;
	    };
	    Vector3.prototype.multiplyVectors = function (a, b) {
	        this.x = a.x * b.x;
	        this.y = a.y * b.y;
	        this.z = a.z * b.z;
	        return this;
	    };
	    Vector3.prototype.applyEuler = function (euler) {
	        var quaternion = Vector3._applyEuler_quaternion;
	        return this.applyQuaternion(quaternion.setFromEuler(euler));
	    };
	    Vector3.prototype.applyAxisAngle = function (axis, angle) {
	        var quaternion = Vector3._applyAxisAngle_quaternion;
	        return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
	    };
	    Vector3.prototype.applyMatrix3 = function (m) {
	        var x = this.x, y = this.y, z = this.z;
	        var e = m.elements;
	        this.x = e[0] * x + e[3] * y + e[6] * z;
	        this.y = e[1] * x + e[4] * y + e[7] * z;
	        this.z = e[2] * x + e[5] * y + e[8] * z;
	        return this;
	    };
	    Vector3.prototype.applyMatrix4 = function (m) {
	        // input: THREE.Matrix4 affine matrix
	        var x = this.x, y = this.y, z = this.z;
	        var e = m.elements;
	        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
	        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
	        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
	        return this;
	    };
	    Vector3.prototype.applyProjection = function (m) {
	        // input: THREE.Matrix4 projection matrix
	        var x = this.x, y = this.y, z = this.z;
	        var e = m.elements;
	        var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]); // perspective divide
	        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
	        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
	        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
	        return this;
	    };
	    Vector3.prototype.applyQuaternion = function (q) {
	        var x = this.x, y = this.y, z = this.z;
	        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
	        // calculate quat * vector
	        var ix = qw * x + qy * z - qz * y;
	        var iy = qw * y + qz * x - qx * z;
	        var iz = qw * z + qx * y - qy * x;
	        var iw = -qx * x - qy * y - qz * z;
	        // calculate result * inverse quat
	        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	        return this;
	    };
	    Vector3.prototype.project = function (camera) {
	        var matrix = Vector3._project_matrix = (Vector3._project_matrix || new Matrix4());
	        matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
	        return this.applyProjection(matrix);
	    };
	    Vector3.prototype.unproject = function (camera) {
	        var matrix = Vector3._unproject_matrix = (Vector3._unproject_matrix || new Matrix4());
	        matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
	        return this.applyProjection(matrix);
	    };
	    Vector3.prototype.transformDirection = function (m) {
	        // input: THREE.Matrix4 affine matrix
	        // vector interpreted as a direction
	        var x = this.x, y = this.y, z = this.z;
	        var e = m.elements;
	        this.x = e[0] * x + e[4] * y + e[8] * z;
	        this.y = e[1] * x + e[5] * y + e[9] * z;
	        this.z = e[2] * x + e[6] * y + e[10] * z;
	        return this.normalize();
	    };
	    Vector3.prototype.divide = function (v) {
	        this.x /= v.x;
	        this.y /= v.y;
	        this.z /= v.z;
	        return this;
	    };
	    Vector3.prototype.divideScalar = function (scalar) {
	        return this.multiplyScalar(1 / scalar);
	    };
	    Vector3.prototype.min = function (v) {
	        this.x = Math.min(this.x, v.x);
	        this.y = Math.min(this.y, v.y);
	        this.z = Math.min(this.z, v.z);
	        return this;
	    };
	    Vector3.prototype.max = function (v) {
	        this.x = Math.max(this.x, v.x);
	        this.y = Math.max(this.y, v.y);
	        this.z = Math.max(this.z, v.z);
	        return this;
	    };
	    Vector3.prototype.clamp = function (min, max) {
	        // This function assumes min < max, if this assumption isn't true it will not operate correctly
	        this.x = Math.max(min.x, Math.min(max.x, this.x));
	        this.y = Math.max(min.y, Math.min(max.y, this.y));
	        this.z = Math.max(min.z, Math.min(max.z, this.z));
	        return this;
	    };
	    Vector3.prototype.clampScalar = function (minVal, maxVal) {
	        var min = Vector3._clampScalar_min, max = Vector3._clampScalar_max;
	        min.set(minVal, minVal, minVal);
	        max.set(maxVal, maxVal, maxVal);
	        return this.clamp(min, max);
	    };
	    Vector3.prototype.clampLength = function (min, max) {
	        var length = this.length();
	        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
	    };
	    Vector3.prototype.floor = function () {
	        this.x = Math.floor(this.x);
	        this.y = Math.floor(this.y);
	        this.z = Math.floor(this.z);
	        return this;
	    };
	    Vector3.prototype.ceil = function () {
	        this.x = Math.ceil(this.x);
	        this.y = Math.ceil(this.y);
	        this.z = Math.ceil(this.z);
	        return this;
	    };
	    Vector3.prototype.round = function () {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        this.z = Math.round(this.z);
	        return this;
	    };
	    Vector3.prototype.roundToZero = function () {
	        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
	        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
	        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
	        return this;
	    };
	    Vector3.prototype.negate = function () {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	        return this;
	    };
	    Vector3.prototype.dot = function (v) {
	        return this.x * v.x + this.y * v.y + this.z * v.z;
	    };
	    Vector3.prototype.lengthSq = function () {
	        return this.x * this.x + this.y * this.y + this.z * this.z;
	    };
	    Vector3.prototype.length = function () {
	        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	    };
	    Vector3.prototype.lengthManhattan = function () {
	        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	    };
	    Vector3.prototype.normalize = function () {
	        return this.divideScalar(this.length());
	    };
	    Vector3.prototype.setLength = function (length) {
	        return this.multiplyScalar(length / this.length());
	    };
	    Vector3.prototype.lerp = function (v, alpha) {
	        this.x += (v.x - this.x) * alpha;
	        this.y += (v.y - this.y) * alpha;
	        this.z += (v.z - this.z) * alpha;
	        return this;
	    };
	    Vector3.prototype.lerpVectors = function (v1, v2, alpha) {
	        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
	    };
	    Vector3.prototype.cross = function (v, w) {
	        if (w !== undefined) {
	            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors(a, b) instead.');
	            return this.crossVectors(v, w);
	        }
	        var x = this.x, y = this.y, z = this.z;
	        this.x = y * v.z - z * v.y;
	        this.y = z * v.x - x * v.z;
	        this.z = x * v.y - y * v.x;
	        return this;
	    };
	    Vector3.prototype.crossVectors = function (a, b) {
	        var ax = a.x, ay = a.y, az = a.z;
	        var bx = b.x, by = b.y, bz = b.z;
	        this.x = ay * bz - az * by;
	        this.y = az * bx - ax * bz;
	        this.z = ax * by - ay * bx;
	        return this;
	    };
	    Vector3.prototype.projectOnVector = function (vector) {
	        var scalar = vector.dot(this) / vector.lengthSq();
	        return this.copy(vector).multiplyScalar(scalar);
	    };
	    Vector3.prototype.projectOnPlane = function (planeNormal) {
	        var v1 = Vector3._projectOnPlane_v1;
	        v1.copy(this).projectOnVector(planeNormal);
	        return this.sub(v1);
	    };
	    Vector3.prototype.reflect = function (normal) {
	        // reflect incident vector off plane orthogonal to normal
	        // normal is assumed to have unit length
	        var v1 = Vector3._reflect_v1;
	        return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
	    };
	    Vector3.prototype.angleTo = function (v) {
	        var theta = this.dot(v) / (Math.sqrt(this.lengthSq() * v.lengthSq()));
	        // clamp, to handle numerical problems
	        return Math.acos(_Math.clamp(theta, -1, 1));
	    };
	    Vector3.prototype.distanceTo = function (v) {
	        return Math.sqrt(this.distanceToSquared(v));
	    };
	    Vector3.prototype.distanceToSquared = function (v) {
	        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
	        return dx * dx + dy * dy + dz * dz;
	    };
	    Vector3.prototype.distanceToManhattan = function (v) {
	        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
	    };
	    Vector3.prototype.setFromSpherical = function (s) {
	        var sinPhiRadius = Math.sin(s.phi) * s.radius;
	        this.x = sinPhiRadius * Math.sin(s.theta);
	        this.y = Math.cos(s.phi) * s.radius;
	        this.z = sinPhiRadius * Math.cos(s.theta);
	        return this;
	    };
	    Vector3.prototype.setFromMatrixPosition = function (m) {
	        return this.setFromMatrixColumn(m, 3);
	    };
	    Vector3.prototype.setFromMatrixScale = function (m) {
	        var sx = this.setFromMatrixColumn(m, 0).length();
	        var sy = this.setFromMatrixColumn(m, 1).length();
	        var sz = this.setFromMatrixColumn(m, 2).length();
	        this.x = sx;
	        this.y = sy;
	        this.z = sz;
	        return this;
	    };
	    Vector3.prototype.setFromMatrixColumn = function (m, index) {
	        //if (typeof m === 'number') {
	        //  console.warn('THREE.Vector3: setFromMatrixColumn now expects (matrix, index).');
	        //  const temp = m;
	        //  m = index;
	        //  index = temp;
	        //}
	        return this.fromArray(m.elements, index * 4);
	    };
	    Vector3.prototype.equals = function (v) {
	        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
	    };
	    Vector3.prototype.fromArray = function (array, offset) {
	        if (offset === void 0) { offset = 0; }
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        this.z = array[offset + 2];
	        return this;
	    };
	    Vector3.prototype.toArray = function (array, offset) {
	        if (array === void 0) { array = []; }
	        if (offset === void 0) { offset = 0; }
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        array[offset + 2] = this.z;
	        return array;
	    };
	    Vector3.prototype.fromAttribute = function (attribute, index, offset) {
	        if (offset === void 0) { offset = 0; }
	        index = index * attribute.itemSize + offset;
	        this.x = attribute.array[index];
	        this.y = attribute.array[index + 1];
	        this.z = attribute.array[index + 2];
	        return this;
	    };
	    Vector3.prototype.setEulerFromRotationMatrix = function () {
	        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
	    };
	    Vector3.prototype.setEulerFromQuaternion = function () {
	        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
	    };
	    Vector3.prototype.getPositionFromMatrix = function (m) {
	        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
	        return this.setFromMatrixPosition(m);
	    };
	    Vector3.prototype.getScaleFromMatrix = function (m) {
	        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
	        return this.setFromMatrixScale(m);
	    };
	    Vector3.prototype.getColumnFromMatrix = function (index, matrix) {
	        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
	        return this.setFromMatrixColumn(matrix, index);
	    };
	    Vector3._applyEuler_quaternion = new Quaternion();
	    Vector3._applyAxisAngle_quaternion = new Quaternion();
	    Vector3._clampScalar_min = new Vector3();
	    Vector3._clampScalar_max = new Vector3();
	    Vector3._projectOnPlane_v1 = new Vector3();
	    Vector3._reflect_v1 = new Vector3();
	    return Vector3;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	var Euler = /** @class */ (function () {
	    function Euler(x, y, z, order) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (order === void 0) { order = Euler.DefaultOrder; }
	        this._order = Euler.DefaultOrder;
	        this.onChangeCallback = function () { };
	        this.isEuler = true;
	        this._x = x;
	        this._y = y;
	        this._z = z;
	        this._order = order;
	    }
	    Object.defineProperty(Euler.prototype, "x", {
	        get: function () {
	            return this._x;
	        },
	        set: function (value) {
	            this._x = value;
	            this.onChangeCallback();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Euler.prototype, "y", {
	        get: function () {
	            return this._y;
	        },
	        set: function (value) {
	            this._y = value;
	            this.onChangeCallback();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Euler.prototype, "z", {
	        get: function () {
	            return this._z;
	        },
	        set: function (value) {
	            this._z = value;
	            this.onChangeCallback();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Euler.prototype, "order", {
	        get: function () {
	            return this._order;
	        },
	        set: function (value) {
	            this._order = value;
	            this.onChangeCallback();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Euler.prototype.set = function (x, y, z, order) {
	        if (order === void 0) { order = this._order; }
	        this._x = x;
	        this._y = y;
	        this._z = z;
	        this._order = order;
	        this.onChangeCallback();
	        return this;
	    };
	    Euler.prototype.clone = function () {
	        return new this.constructor(this._x, this._y, this._z, this._order);
	    };
	    Euler.prototype.copy = function (euler) {
	        this._x = euler._x;
	        this._y = euler._y;
	        this._z = euler._z;
	        this._order = euler._order;
	        this.onChangeCallback();
	        return this;
	    };
	    Euler.prototype.setFromRotationMatrix = function (m, order, update) {
	        if (order === void 0) { order = this._order; }
	        if (update === void 0) { update = true; }
	        var clamp = _Math.clamp;
	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	        var te = m.elements;
	        var m11 = te[0], m12 = te[4], m13 = te[8];
	        var m21 = te[1], m22 = te[5], m23 = te[9];
	        var m31 = te[2], m32 = te[6], m33 = te[10];
	        if (order === 'XYZ') {
	            this._y = Math.asin(clamp(m13, -1, 1));
	            if (Math.abs(m13) < 0.99999) {
	                this._x = Math.atan2(-m23, m33);
	                this._z = Math.atan2(-m12, m11);
	            }
	            else {
	                this._x = Math.atan2(m32, m22);
	                this._z = 0;
	            }
	        }
	        else if (order === 'YXZ') {
	            this._x = Math.asin(-clamp(m23, -1, 1));
	            if (Math.abs(m23) < 0.99999) {
	                this._y = Math.atan2(m13, m33);
	                this._z = Math.atan2(m21, m22);
	            }
	            else {
	                this._y = Math.atan2(-m31, m11);
	                this._z = 0;
	            }
	        }
	        else if (order === 'ZXY') {
	            this._x = Math.asin(clamp(m32, -1, 1));
	            if (Math.abs(m32) < 0.99999) {
	                this._y = Math.atan2(-m31, m33);
	                this._z = Math.atan2(-m12, m22);
	            }
	            else {
	                this._y = 0;
	                this._z = Math.atan2(m21, m11);
	            }
	        }
	        else if (order === 'ZYX') {
	            this._y = Math.asin(-clamp(m31, -1, 1));
	            if (Math.abs(m31) < 0.99999) {
	                this._x = Math.atan2(m32, m33);
	                this._z = Math.atan2(m21, m11);
	            }
	            else {
	                this._x = 0;
	                this._z = Math.atan2(-m12, m22);
	            }
	        }
	        else if (order === 'YZX') {
	            this._z = Math.asin(clamp(m21, -1, 1));
	            if (Math.abs(m21) < 0.99999) {
	                this._x = Math.atan2(-m23, m22);
	                this._y = Math.atan2(-m31, m11);
	            }
	            else {
	                this._x = 0;
	                this._y = Math.atan2(m13, m33);
	            }
	        }
	        else if (order === 'XZY') {
	            this._z = Math.asin(-clamp(m12, -1, 1));
	            if (Math.abs(m12) < 0.99999) {
	                this._x = Math.atan2(m32, m22);
	                this._y = Math.atan2(m13, m11);
	            }
	            else {
	                this._x = Math.atan2(-m23, m33);
	                this._y = 0;
	            }
	        }
	        else {
	            console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
	        }
	        this._order = order;
	        if (update !== false)
	            this.onChangeCallback();
	        return this;
	    };
	    Euler.prototype.setFromQuaternion = function (q, order, update) {
	        if (update === void 0) { update = false; }
	        var matrix = Euler._setFromQuaternion_matrix || (Euler._setFromQuaternion_matrix = new Matrix4());
	        matrix.makeRotationFromQuaternion(q);
	        return this.setFromRotationMatrix(matrix, order, update);
	    };
	    Euler.prototype.setFromVector3 = function (v, order) {
	        if (order === void 0) { order = this._order; }
	        return this.set(v.x, v.y, v.z, order);
	    };
	    Euler.prototype.reorder = function (newOrder) {
	        // WARNING: this discards revolution information -bhouston
	        var q = Euler._reorder_q || (Euler._reorder_q = new Quaternion());
	        q.setFromEuler(this);
	        return this.setFromQuaternion(q, newOrder);
	    };
	    Euler.prototype.equals = function (euler) {
	        return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
	    };
	    Euler.prototype.fromArray = function (array) {
	        this._x = array[0];
	        this._y = array[1];
	        this._z = array[2];
	        if (array[3] !== undefined)
	            this._order = array[3];
	        this.onChangeCallback();
	        return this;
	    };
	    Euler.prototype.toArray = function (array, offset) {
	        if (array === void 0) { array = []; }
	        if (offset === void 0) { offset = 0; }
	        array[offset] = this._x;
	        array[offset + 1] = this._y;
	        array[offset + 2] = this._z;
	        array[offset + 3] = this._order;
	        return array;
	    };
	    Euler.prototype.toVector3 = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        return result.set(this._x, this._y, this._z);
	    };
	    Euler.prototype.onChange = function (callback) {
	        this.onChangeCallback = callback;
	        return this;
	    };
	    Euler.DefaultOrder = 'XYZ';
	    Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
	    return Euler;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	var Matrix4 = /** @class */ (function () {
	    function Matrix4() {
	        this.isMatrix4 = true;
	        this.elements = new Float32Array([
	            1, 0, 0, 0,
	            0, 1, 0, 0,
	            0, 0, 1, 0,
	            0, 0, 0, 1
	        ]);
	        if (arguments.length > 0) {
	            console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
	        }
	    }
	    Matrix4.prototype.set = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
	        var te = this.elements;
	        te[0] = n11;
	        te[4] = n12;
	        te[8] = n13;
	        te[12] = n14;
	        te[1] = n21;
	        te[5] = n22;
	        te[9] = n23;
	        te[13] = n24;
	        te[2] = n31;
	        te[6] = n32;
	        te[10] = n33;
	        te[14] = n34;
	        te[3] = n41;
	        te[7] = n42;
	        te[11] = n43;
	        te[15] = n44;
	        return this;
	    };
	    Matrix4.prototype.identity = function () {
	        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	        return this;
	    };
	    Matrix4.prototype.clone = function () {
	        return new this.constructor().fromArray(this.elements);
	    };
	    Matrix4.prototype.copy = function (m) {
	        this.elements.set(m.elements);
	        return this;
	    };
	    Matrix4.prototype.copyPosition = function (m) {
	        var te = this.elements;
	        var me = m.elements;
	        te[12] = me[12];
	        te[13] = me[13];
	        te[14] = me[14];
	        return this;
	    };
	    Matrix4.prototype.extractBasis = function (xAxis, yAxis, zAxis) {
	        xAxis.setFromMatrixColumn(this, 0);
	        yAxis.setFromMatrixColumn(this, 1);
	        zAxis.setFromMatrixColumn(this, 2);
	        return this;
	    };
	    Matrix4.prototype.makeBasis = function (xAxis, yAxis, zAxis) {
	        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
	        return this;
	    };
	    Matrix4.prototype.extractRotation = function (m) {
	        var v1 = Matrix4._extractRotation_v1;
	        var te = this.elements;
	        var me = m.elements;
	        var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
	        var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
	        var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
	        te[0] = me[0] * scaleX;
	        te[1] = me[1] * scaleX;
	        te[2] = me[2] * scaleX;
	        te[4] = me[4] * scaleY;
	        te[5] = me[5] * scaleY;
	        te[6] = me[6] * scaleY;
	        te[8] = me[8] * scaleZ;
	        te[9] = me[9] * scaleZ;
	        te[10] = me[10] * scaleZ;
	        return this;
	    };
	    Matrix4.prototype.makeRotationFromEuler = function (euler) {
	        if ((euler && euler instanceof Euler) === false) {
	            console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
	        }
	        var te = this.elements;
	        var x = euler.x, y = euler.y, z = euler.z;
	        var a = Math.cos(x), b = Math.sin(x);
	        var c = Math.cos(y), d = Math.sin(y);
	        var e = Math.cos(z), f = Math.sin(z);
	        if (euler.order === 'XYZ') {
	            var ae = a * e, af = a * f, be = b * e, bf = b * f;
	            te[0] = c * e;
	            te[4] = -c * f;
	            te[8] = d;
	            te[1] = af + be * d;
	            te[5] = ae - bf * d;
	            te[9] = -b * c;
	            te[2] = bf - ae * d;
	            te[6] = be + af * d;
	            te[10] = a * c;
	        }
	        else if (euler.order === 'YXZ') {
	            var ce = c * e, cf = c * f, de = d * e, df = d * f;
	            te[0] = ce + df * b;
	            te[4] = de * b - cf;
	            te[8] = a * d;
	            te[1] = a * f;
	            te[5] = a * e;
	            te[9] = -b;
	            te[2] = cf * b - de;
	            te[6] = df + ce * b;
	            te[10] = a * c;
	        }
	        else if (euler.order === 'ZXY') {
	            var ce = c * e, cf = c * f, de = d * e, df = d * f;
	            te[0] = ce - df * b;
	            te[4] = -a * f;
	            te[8] = de + cf * b;
	            te[1] = cf + de * b;
	            te[5] = a * e;
	            te[9] = df - ce * b;
	            te[2] = -a * d;
	            te[6] = b;
	            te[10] = a * c;
	        }
	        else if (euler.order === 'ZYX') {
	            var ae = a * e, af = a * f, be = b * e, bf = b * f;
	            te[0] = c * e;
	            te[4] = be * d - af;
	            te[8] = ae * d + bf;
	            te[1] = c * f;
	            te[5] = bf * d + ae;
	            te[9] = af * d - be;
	            te[2] = -d;
	            te[6] = b * c;
	            te[10] = a * c;
	        }
	        else if (euler.order === 'YZX') {
	            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	            te[0] = c * e;
	            te[4] = bd - ac * f;
	            te[8] = bc * f + ad;
	            te[1] = f;
	            te[5] = a * e;
	            te[9] = -b * e;
	            te[2] = -d * e;
	            te[6] = ad * f + bc;
	            te[10] = ac - bd * f;
	        }
	        else if (euler.order === 'XZY') {
	            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	            te[0] = c * e;
	            te[4] = -f;
	            te[8] = d * e;
	            te[1] = ac * f + bd;
	            te[5] = a * e;
	            te[9] = ad * f - bc;
	            te[2] = bc * f - ad;
	            te[6] = b * e;
	            te[10] = bd * f + ac;
	        }
	        // last column
	        te[3] = 0;
	        te[7] = 0;
	        te[11] = 0;
	        // bottom row
	        te[12] = 0;
	        te[13] = 0;
	        te[14] = 0;
	        te[15] = 1;
	        return this;
	    };
	    Matrix4.prototype.makeRotationFromQuaternion = function (q) {
	        var te = this.elements;
	        var x = q.x, y = q.y, z = q.z, w = q.w;
	        var x2 = x + x, y2 = y + y, z2 = z + z;
	        var xx = x * x2, xy = x * y2, xz = x * z2;
	        var yy = y * y2, yz = y * z2, zz = z * z2;
	        var wx = w * x2, wy = w * y2, wz = w * z2;
	        te[0] = 1 - (yy + zz);
	        te[4] = xy - wz;
	        te[8] = xz + wy;
	        te[1] = xy + wz;
	        te[5] = 1 - (xx + zz);
	        te[9] = yz - wx;
	        te[2] = xz - wy;
	        te[6] = yz + wx;
	        te[10] = 1 - (xx + yy);
	        // last column
	        te[3] = 0;
	        te[7] = 0;
	        te[11] = 0;
	        // bottom row
	        te[12] = 0;
	        te[13] = 0;
	        te[14] = 0;
	        te[15] = 1;
	        return this;
	    };
	    Matrix4.prototype.lookAt = function (eye, target, up) {
	        var x = Matrix4._lookAt_x;
	        var y = Matrix4._lookAt_y;
	        var z = Matrix4._lookAt_z;
	        var te = this.elements;
	        z.subVectors(eye, target).normalize();
	        if (z.lengthSq() === 0) {
	            z.z = 1;
	        }
	        x.crossVectors(up, z).normalize();
	        if (x.lengthSq() === 0) {
	            z.z += 0.0001;
	            x.crossVectors(up, z).normalize();
	        }
	        y.crossVectors(z, x);
	        te[0] = x.x;
	        te[4] = y.x;
	        te[8] = z.x;
	        te[1] = x.y;
	        te[5] = y.y;
	        te[9] = z.y;
	        te[2] = x.z;
	        te[6] = y.z;
	        te[10] = z.z;
	        return this;
	    };
	    Matrix4.prototype.multiply = function (m, n) {
	        if (n !== undefined) {
	            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices(a, b) instead.');
	            return this.multiplyMatrices(m, n);
	        }
	        return this.multiplyMatrices(this, m);
	    };
	    Matrix4.prototype.premultiply = function (m) {
	        return this.multiplyMatrices(m, this);
	    };
	    Matrix4.prototype.multiplyMatrices = function (a, b) {
	        var ae = a.elements;
	        var be = b.elements;
	        var te = this.elements;
	        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
	        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
	        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
	        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
	        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
	        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
	        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
	        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
	        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
	        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
	        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
	        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
	        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
	        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
	        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
	        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
	        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
	        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
	        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
	        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
	        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	        return this;
	    };
	    Matrix4.prototype.multiplyToArray = function (a, b, r) {
	        var te = this.elements;
	        this.multiplyMatrices(a, b);
	        r[0] = te[0];
	        r[1] = te[1];
	        r[2] = te[2];
	        r[3] = te[3];
	        r[4] = te[4];
	        r[5] = te[5];
	        r[6] = te[6];
	        r[7] = te[7];
	        r[8] = te[8];
	        r[9] = te[9];
	        r[10] = te[10];
	        r[11] = te[11];
	        r[12] = te[12];
	        r[13] = te[13];
	        r[14] = te[14];
	        r[15] = te[15];
	        return this;
	    };
	    Matrix4.prototype.multiplyScalar = function (s) {
	        var te = this.elements;
	        te[0] *= s;
	        te[4] *= s;
	        te[8] *= s;
	        te[12] *= s;
	        te[1] *= s;
	        te[5] *= s;
	        te[9] *= s;
	        te[13] *= s;
	        te[2] *= s;
	        te[6] *= s;
	        te[10] *= s;
	        te[14] *= s;
	        te[3] *= s;
	        te[7] *= s;
	        te[11] *= s;
	        te[15] *= s;
	        return this;
	    };
	    Matrix4.prototype.applyToVector3Array = function (array, offset, length) {
	        if (offset === void 0) { offset = 0; }
	        if (length === void 0) { length = array.length; }
	        var v1 = Matrix4._applyToVector3Array_v1;
	        for (var i = 0, j = offset; i < length; i += 3, j += 3) {
	            v1.fromArray(array, j);
	            v1.applyMatrix4(this);
	            v1.toArray(array, j);
	        }
	        return array;
	    };
	    Matrix4.prototype.applyToBuffer = function (buffer, offset, length) {
	        if (offset === void 0) { offset = 0; }
	        if (length === void 0) { length = buffer.length / buffer.itemSize; }
	        var v1 = Matrix4._applyToBuffer_v1;
	        for (var i = 0, j = offset; i < length; i++, j++) {
	            v1.x = buffer.getX(j);
	            v1.y = buffer.getY(j);
	            v1.z = buffer.getZ(j);
	            v1.applyMatrix4(this);
	            buffer.setXYZ(j, v1.x, v1.y, v1.z);
	        }
	        return buffer;
	    };
	    Matrix4.prototype.determinant = function () {
	        var te = this.elements;
	        var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
	        var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
	        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
	        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
	        //TODO: make this more efficient
	        //(based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm)
	        return (n41 * (+n14 * n23 * n32
	            - n13 * n24 * n32
	            - n14 * n22 * n33
	            + n12 * n24 * n33
	            + n13 * n22 * n34
	            - n12 * n23 * n34) +
	            n42 * (+n11 * n23 * n34
	                - n11 * n24 * n33
	                + n14 * n21 * n33
	                - n13 * n21 * n34
	                + n13 * n24 * n31
	                - n14 * n23 * n31) +
	            n43 * (+n11 * n24 * n32
	                - n11 * n22 * n34
	                - n14 * n21 * n32
	                + n12 * n21 * n34
	                + n14 * n22 * n31
	                - n12 * n24 * n31) +
	            n44 * (-n13 * n22 * n31
	                - n11 * n23 * n32
	                + n11 * n22 * n33
	                + n13 * n21 * n32
	                - n12 * n21 * n33
	                + n12 * n23 * n31));
	    };
	    Matrix4.prototype.transpose = function () {
	        var te = this.elements;
	        var tmp;
	        tmp = te[1];
	        te[1] = te[4];
	        te[4] = tmp;
	        tmp = te[2];
	        te[2] = te[8];
	        te[8] = tmp;
	        tmp = te[6];
	        te[6] = te[9];
	        te[9] = tmp;
	        tmp = te[3];
	        te[3] = te[12];
	        te[12] = tmp;
	        tmp = te[7];
	        te[7] = te[13];
	        te[13] = tmp;
	        tmp = te[11];
	        te[11] = te[14];
	        te[14] = tmp;
	        return this;
	    };
	    Matrix4.prototype.flattenToArrayOffset = function (array, offset) {
	        if (array === void 0) { array = []; }
	        if (offset === void 0) { offset = 0; }
	        console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated " +
	            "- just use .toArray instead.");
	        return this.toArray(array, offset);
	    };
	    Matrix4.prototype.getPosition = function () {
	        var v1 = Matrix4._getPosition_v1;
	        console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition(matrix) instead.');
	        return v1.setFromMatrixColumn(this, 3);
	    };
	    Matrix4.prototype.setPosition = function (v) {
	        var te = this.elements;
	        te[12] = v.x;
	        te[13] = v.y;
	        te[14] = v.z;
	        return this;
	    };
	    Matrix4.prototype.getInverse = function (m, throwOnDegenerate) {
	        if (throwOnDegenerate === void 0) { throwOnDegenerate = false; }
	        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	        var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	        if (det === 0) {
	            var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
	            if (throwOnDegenerate === true) {
	                throw new Error(msg);
	            }
	            else {
	                console.warn(msg);
	            }
	            return this.identity();
	        }
	        var detInv = 1 / det;
	        te[0] = t11 * detInv;
	        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
	        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
	        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
	        te[4] = t12 * detInv;
	        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
	        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
	        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
	        te[8] = t13 * detInv;
	        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
	        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
	        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
	        te[12] = t14 * detInv;
	        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
	        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
	        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
	        return this;
	    };
	    Matrix4.prototype.scale = function (v) {
	        var te = this.elements;
	        var x = v.x, y = v.y, z = v.z;
	        te[0] *= x;
	        te[4] *= y;
	        te[8] *= z;
	        te[1] *= x;
	        te[5] *= y;
	        te[9] *= z;
	        te[2] *= x;
	        te[6] *= y;
	        te[10] *= z;
	        te[3] *= x;
	        te[7] *= y;
	        te[11] *= z;
	        return this;
	    };
	    Matrix4.prototype.getMaxScaleOnAxis = function () {
	        var te = this.elements;
	        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
	        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
	        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
	        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
	    };
	    Matrix4.prototype.makeTranslation = function (x, y, z) {
	        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
	        return this;
	    };
	    Matrix4.prototype.makeRotationX = function (theta) {
	        var c = Math.cos(theta), s = Math.sin(theta);
	        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
	        return this;
	    };
	    Matrix4.prototype.makeRotationY = function (theta) {
	        var c = Math.cos(theta), s = Math.sin(theta);
	        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
	        return this;
	    };
	    Matrix4.prototype.makeRotationZ = function (theta) {
	        var c = Math.cos(theta), s = Math.sin(theta);
	        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	        return this;
	    };
	    Matrix4.prototype.makeRotationAxis = function (axis, angle) {
	        // Based on http://www.gamedev.net/reference/articles/article1199.asp
	        var c = Math.cos(angle);
	        var s = Math.sin(angle);
	        var t = 1 - c;
	        var x = axis.x, y = axis.y, z = axis.z;
	        var tx = t * x, ty = t * y;
	        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
	        return this;
	    };
	    Matrix4.prototype.makeScale = function (x, y, z) {
	        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
	        return this;
	    };
	    Matrix4.prototype.compose = function (position, quaternion, scale) {
	        this.makeRotationFromQuaternion(quaternion);
	        this.scale(scale);
	        this.setPosition(position);
	        return this;
	    };
	    Matrix4.prototype.decompose = function (position, quaternion, scale) {
	        var vector = Matrix4._decompose_vector, matrix = Matrix4._decompose_matrix;
	        var te = this.elements;
	        var sx = vector.set(te[0], te[1], te[2]).length();
	        var sy = vector.set(te[4], te[5], te[6]).length();
	        var sz = vector.set(te[8], te[9], te[10]).length();
	        // if determine is negative, we need to invert one scale
	        var det = this.determinant();
	        if (det < 0) {
	            sx = -sx;
	        }
	        position.x = te[12];
	        position.y = te[13];
	        position.z = te[14];
	        // scale the rotation part
	        matrix.elements.set(this.elements); // at this point matrix is incomplete so we can't use .copy()
	        var invSX = 1 / sx;
	        var invSY = 1 / sy;
	        var invSZ = 1 / sz;
	        matrix.elements[0] *= invSX;
	        matrix.elements[1] *= invSX;
	        matrix.elements[2] *= invSX;
	        matrix.elements[4] *= invSY;
	        matrix.elements[5] *= invSY;
	        matrix.elements[6] *= invSY;
	        matrix.elements[8] *= invSZ;
	        matrix.elements[9] *= invSZ;
	        matrix.elements[10] *= invSZ;
	        quaternion.setFromRotationMatrix(matrix);
	        scale.x = sx;
	        scale.y = sy;
	        scale.z = sz;
	        return this;
	    };
	    Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
	        var te = this.elements;
	        var x = 2 * near / (right - left);
	        var y = 2 * near / (top - bottom);
	        var a = (right + left) / (right - left);
	        var b = (top + bottom) / (top - bottom);
	        var c = -(far + near) / (far - near);
	        var d = -2 * far * near / (far - near);
	        te[0] = x;
	        te[4] = 0;
	        te[8] = a;
	        te[12] = 0;
	        te[1] = 0;
	        te[5] = y;
	        te[9] = b;
	        te[13] = 0;
	        te[2] = 0;
	        te[6] = 0;
	        te[10] = c;
	        te[14] = d;
	        te[3] = 0;
	        te[7] = 0;
	        te[11] = -1;
	        te[15] = 0;
	        return this;
	    };
	    Matrix4.prototype.makePerspective = function (fov, aspect, near, far) {
	        var ymax = near * Math.tan(_Math.DEG2RAD * fov * 0.5);
	        var ymin = -ymax;
	        var xmin = ymin * aspect;
	        var xmax = ymax * aspect;
	        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
	    };
	    Matrix4.prototype.makeOrthographic = function (left, right, top, bottom, near, far) {
	        var te = this.elements;
	        var w = 1.0 / (right - left);
	        var h = 1.0 / (top - bottom);
	        var p = 1.0 / (far - near);
	        var x = (right + left) * w;
	        var y = (top + bottom) * h;
	        var z = (far + near) * p;
	        te[0] = 2 * w;
	        te[4] = 0;
	        te[8] = 0;
	        te[12] = -x;
	        te[1] = 0;
	        te[5] = 2 * h;
	        te[9] = 0;
	        te[13] = -y;
	        te[2] = 0;
	        te[6] = 0;
	        te[10] = -2 * p;
	        te[14] = -z;
	        te[3] = 0;
	        te[7] = 0;
	        te[11] = 0;
	        te[15] = 1;
	        return this;
	    };
	    Matrix4.prototype.equals = function (matrix) {
	        var te = this.elements;
	        var me = matrix.elements;
	        for (var i = 0; i < 16; i++) {
	            if (te[i] !== me[i])
	                return false;
	        }
	        return true;
	    };
	    Matrix4.prototype.fromArray = function (array, offset) {
	        if (offset === void 0) { offset = 0; }
	        for (var i = 0; i < 16; i++) {
	            this.elements[i] = array[i + offset];
	        }
	        return this;
	    };
	    Matrix4.prototype.toArray = function (array, offset) {
	        if (array === void 0) { array = []; }
	        if (offset === void 0) { offset = 0; }
	        var te = this.elements;
	        array[offset] = te[0];
	        array[offset + 1] = te[1];
	        array[offset + 2] = te[2];
	        array[offset + 3] = te[3];
	        array[offset + 4] = te[4];
	        array[offset + 5] = te[5];
	        array[offset + 6] = te[6];
	        array[offset + 7] = te[7];
	        array[offset + 8] = te[8];
	        array[offset + 9] = te[9];
	        array[offset + 10] = te[10];
	        array[offset + 11] = te[11];
	        array[offset + 12] = te[12];
	        array[offset + 13] = te[13];
	        array[offset + 14] = te[14];
	        array[offset + 15] = te[15];
	        return array;
	    };
	    Matrix4.prototype.extractPosition = function (m) {
	        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
	        return this.copyPosition(m);
	    };
	    Matrix4.prototype.setRotationFromQuaternion = function (q) {
	        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
	        return this.makeRotationFromQuaternion(q);
	    };
	    Matrix4.prototype.multiplyVector3 = function (vector) {
	        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4(matrix) or vector.applyProjection(matrix) instead.");
	        return vector.applyProjection(this);
	    };
	    Matrix4.prototype.multiplyVector4 = function (vector) {
	        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4(matrix) instead.");
	        return vector.applyMatrix4(this);
	    };
	    Matrix4.prototype.multiplyVector3Array = function (a) {
	        console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array(array) instead.");
	        return this.applyToVector3Array(a);
	    };
	    Matrix4.prototype.rotateAxis = function (v) {
	        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection(matrix) instead.");
	        v.transformDirection(this);
	    };
	    Matrix4.prototype.crossVector = function (vector) {
	        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4(matrix) instead.");
	        return vector.applyMatrix4(this);
	    };
	    Matrix4.prototype.translate = function (v) {
	        console.error("THREE.Matrix4: .translate() has been removed.");
	    };
	    Matrix4.prototype.rotateX = function (angle) {
	        console.error("THREE.Matrix4: .rotateX() has been removed.");
	    };
	    Matrix4.prototype.rotateY = function (angle) {
	        console.error("THREE.Matrix4: .rotateY() has been removed.");
	    };
	    Matrix4.prototype.rotateZ = function (angle) {
	        console.error("THREE.Matrix4: .rotateZ() has been removed.");
	    };
	    Matrix4.prototype.rotateByAxis = function (axis, angle) {
	        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
	    };
	    Matrix4._extractRotation_v1 = new Vector3();
	    Matrix4._lookAt_x = new Vector3();
	    Matrix4._lookAt_y = new Vector3();
	    Matrix4._lookAt_z = new Vector3();
	    Matrix4._applyToVector3Array_v1 = new Vector3();
	    Matrix4._applyToBuffer_v1 = new Vector3();
	    Matrix4._getPosition_v1 = new Vector3();
	    Matrix4._decompose_vector = new Vector3();
	    Matrix4._decompose_matrix = new Matrix4();
	    return Matrix4;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var CubeTexture = /** @class */ (function (_super) {
	    __extends(CubeTexture, _super);
	    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
	        if (images === void 0) { images = []; }
	        if (mapping === void 0) { mapping = exports.TextureMapping.CubeReflection; }
	        var _this = _super.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
	        _this.isCubeTexture = true;
	        _this.flipY = false;
	        return _this;
	    }
	    Object.defineProperty(CubeTexture.prototype, "images", {
	        get: function () { return this.image; },
	        set: function (value) { this.image = value; },
	        enumerable: true,
	        configurable: true
	    });
	    return CubeTexture;
	}(Texture));

	/**
	 * @author tschw
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms(gl, program, renderer)'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue(gl, value, [renderer])
	 *
	 *     uploads a uniform value(s)
	 *    the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload(gl, seq, values, renderer)
	 *
	 *     sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue(seq, values) : filteredSeq
	 *
	 *     filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue(gl, name, value)
	 *
	 *     sets uniform with  name 'name' to 'value'
	 *
	 * .set(gl, obj, prop)
	 *
	 *     sets uniform from object and property with same name than uniform
	 *
	 * .setOptional(gl, obj, prop)
	 *
	 *     like .set for an optional property of the object
	 *
	 */
	var emptyTexture = new Texture();
	var emptyCubeTexture = new CubeTexture();
	// --- Base for inner nodes (including the root) ---
	var UniformContainer = /** @class */ (function () {
	    function UniformContainer() {
	        this.seq = [];
	        this.map = [];
	    }
	    return UniformContainer;
	}());
	// --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)
	var arrayCacheF32 = [];
	var arrayCacheI32 = [];
	// Flattening for arrays of vectors and matrices
	function flatten(array, nBlocks, blockSize) {
	    var firstElem = array[0];
	    if (firstElem <= 0 || firstElem > 0)
	        return array;
	    // unoptimized: ! isNaN(firstElem)
	    // see http://jacksondunstan.com/articles/983
	    var n = nBlocks * blockSize;
	    var r = arrayCacheF32[n];
	    if (r === undefined) {
	        r = new Float32Array(n);
	        arrayCacheF32[n] = r;
	    }
	    if (nBlocks !== 0) {
	        firstElem.toArray(r, 0);
	        for (var i = 1, offset = 0; i !== nBlocks; ++i) {
	            offset += blockSize;
	            array[i].toArray(r, offset);
	        }
	    }
	    return r;
	}
	// Texture unit allocation
	function allocTexUnits(renderer, n) {
	    var r = arrayCacheI32[n];
	    if (r === undefined) {
	        r = new Int32Array(n);
	        arrayCacheI32[n] = r;
	    }
	    for (var i = 0; i !== n; ++i)
	        r[i] = renderer.allocTextureUnit();
	    return r;
	}
	// --- Uniform Classes ---
	var SingleUniform = /** @class */ (function () {
	    function SingleUniform(id, activeInfo, addr) {
	        this.id = id;
	        this.addr = addr;
	        this.setValue = this.getSingularSetter(activeInfo.type);
	        // this.path = activeInfo.name; // DEBUG
	    }
	    // Note: Defining these methods externally, because they come in a bunch
	    // and this way their names minify.
	    // Single scalar
	    SingleUniform.prototype.setValue1f = function (gl, v) { gl.uniform1f(this.addr, v); };
	    SingleUniform.prototype.setValue1i = function (gl, v) { gl.uniform1i(this.addr, v); };
	    // Single float vector (from flat array or THREE.VectorN)
	    SingleUniform.prototype.setValue2fv = function (gl, v) {
	        if (v.x === undefined)
	            gl.uniform2fv(this.addr, v);
	        else
	            gl.uniform2f(this.addr, v.x, v.y);
	    };
	    SingleUniform.prototype.setValue3fv = function (gl, v) {
	        if (v.x !== undefined)
	            gl.uniform3f(this.addr, v.x, v.y, v.z);
	        else if (v.r !== undefined)
	            gl.uniform3f(this.addr, v.r, v.g, v.b);
	        else
	            gl.uniform3fv(this.addr, v);
	    };
	    SingleUniform.prototype.setValue4fv = function (gl, v) {
	        if (v.x === undefined)
	            gl.uniform4fv(this.addr, v);
	        else
	            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
	    };
	    // Single matrix (from flat array or MatrixN)
	    SingleUniform.prototype.setValue2fm = function (gl, v) {
	        gl.uniformMatrix2fv(this.addr, false, v.elements || v);
	    };
	    SingleUniform.prototype.setValue3fm = function (gl, v) {
	        gl.uniformMatrix3fv(this.addr, false, v.elements || v);
	    };
	    SingleUniform.prototype.setValue4fm = function (gl, v) {
	        gl.uniformMatrix4fv(this.addr, false, v.elements || v);
	    };
	    // Single texture (2D / Cube)
	    SingleUniform.prototype.setValueT1 = function (gl, v, renderer) {
	        var unit = renderer.allocTextureUnit();
	        gl.uniform1i(this.addr, unit);
	        renderer.setTexture2D(v || emptyTexture, unit);
	    };
	    SingleUniform.prototype.setValueT6 = function (gl, v, renderer) {
	        var unit = renderer.allocTextureUnit();
	        gl.uniform1i(this.addr, unit);
	        renderer.setTextureCube(v || emptyCubeTexture, unit);
	    };
	    // Integer / Boolean vectors or arrays thereof (always flat arrays)
	    SingleUniform.prototype.setValue2iv = function (gl, v) { gl.uniform2iv(this.addr, v); };
	    SingleUniform.prototype.setValue3iv = function (gl, v) { gl.uniform3iv(this.addr, v); };
	    SingleUniform.prototype.setValue4iv = function (gl, v) { gl.uniform4iv(this.addr, v); };
	    // Helper to pick the right setter for the singular case
	    SingleUniform.prototype.getSingularSetter = function (type) {
	        switch (type) {
	            case 0x1406: return this.setValue1f; // FLOAT
	            case 0x8b50: return this.setValue2fv; // _VEC2
	            case 0x8b51: return this.setValue3fv; // _VEC3
	            case 0x8b52: return this.setValue4fv; // _VEC4
	            case 0x8b5a: return this.setValue2fm; // _MAT2
	            case 0x8b5b: return this.setValue3fm; // _MAT3
	            case 0x8b5c: return this.setValue4fm; // _MAT4
	            case 0x8b5e: return this.setValueT1; // SAMPLER_2D
	            case 0x8b60: return this.setValueT6; // SAMPLER_CUBE
	            case 0x1404:
	            case 0x8b56: return this.setValue1i; // INT, BOOL
	            case 0x8b53:
	            case 0x8b57: return this.setValue2iv; // _VEC2
	            case 0x8b54:
	            case 0x8b58: return this.setValue3iv; // _VEC3
	            case 0x8b55:
	            case 0x8b59: return this.setValue4iv; // _VEC4
	        }
	    };
	    return SingleUniform;
	}());
	var PureArrayUniform = /** @class */ (function () {
	    function PureArrayUniform(id, activeInfo, addr) {
	        this.id = id;
	        this.addr = addr;
	        this.size = activeInfo.size;
	        this.setValue = this.getPureArraySetter(activeInfo.type);
	        // this.path = activeInfo.name; // DEBUG
	    }
	    // Array of scalars
	    PureArrayUniform.prototype.setValue1fv = function (gl, v) { gl.uniform1fv(this.addr, v); };
	    PureArrayUniform.prototype.setValue1iv = function (gl, v) { gl.uniform1iv(this.addr, v); };
	    // Array of vectors (flat or from THREE classes)
	    PureArrayUniform.prototype.setValueV2a = function (gl, v) {
	        gl.uniform2fv(this.addr, flatten(v, this.size, 2));
	    };
	    PureArrayUniform.prototype.setValueV3a = function (gl, v) {
	        gl.uniform3fv(this.addr, flatten(v, this.size, 3));
	    };
	    PureArrayUniform.prototype.setValueV4a = function (gl, v) {
	        gl.uniform4fv(this.addr, flatten(v, this.size, 4));
	    };
	    // Array of matrices (flat or from THREE clases)
	    PureArrayUniform.prototype.setValueM2a = function (gl, v) {
	        gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));
	    };
	    PureArrayUniform.prototype.setValueM3a = function (gl, v) {
	        gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));
	    };
	    PureArrayUniform.prototype.setValueM4a = function (gl, v) {
	        gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));
	    };
	    // Array of textures (2D / Cube)
	    PureArrayUniform.prototype.setValueT1a = function (gl, v, renderer) {
	        var n = v.length, units = allocTexUnits(renderer, n);
	        gl.uniform1iv(this.addr, units);
	        for (var i = 0; i !== n; ++i) {
	            renderer.setTexture2D(v[i] || emptyTexture, units[i]);
	        }
	    };
	    PureArrayUniform.prototype.setValueT6a = function (gl, v, renderer) {
	        var n = v.length, units = allocTexUnits(renderer, n);
	        gl.uniform1iv(this.addr, units);
	        for (var i = 0; i !== n; ++i) {
	            renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
	        }
	    };
	    // Integer / Boolean vectors or arrays thereof (always flat arrays)
	    PureArrayUniform.prototype.setValue2iv = function (gl, v) { gl.uniform2iv(this.addr, v); };
	    PureArrayUniform.prototype.setValue3iv = function (gl, v) { gl.uniform3iv(this.addr, v); };
	    PureArrayUniform.prototype.setValue4iv = function (gl, v) { gl.uniform4iv(this.addr, v); };
	    // Helper to pick the right setter for a pure (bottom-level) array
	    PureArrayUniform.prototype.getPureArraySetter = function (type) {
	        switch (type) {
	            case 0x1406: return this.setValue1fv; // FLOAT
	            case 0x8b50: return this.setValueV2a; // _VEC2
	            case 0x8b51: return this.setValueV3a; // _VEC3
	            case 0x8b52: return this.setValueV4a; // _VEC4
	            case 0x8b5a: return this.setValueM2a; // _MAT2
	            case 0x8b5b: return this.setValueM3a; // _MAT3
	            case 0x8b5c: return this.setValueM4a; // _MAT4
	            case 0x8b5e: return this.setValueT1a; // SAMPLER_2D
	            case 0x8b60: return this.setValueT6a; // SAMPLER_CUBE
	            case 0x1404:
	            case 0x8b56: return this.setValue1iv; // INT, BOOL
	            case 0x8b53:
	            case 0x8b57: return this.setValue2iv; // _VEC2
	            case 0x8b54:
	            case 0x8b58: return this.setValue3iv; // _VEC3
	            case 0x8b55:
	            case 0x8b59: return this.setValue4iv; // _VEC4
	        }
	    };
	    return PureArrayUniform;
	}());
	var StructuredUniform = /** @class */ (function (_super) {
	    __extends(StructuredUniform, _super);
	    function StructuredUniform(id) {
	        var _this = _super.call(this) || this;
	        _this.id = id;
	        return _this;
	    }
	    StructuredUniform.prototype.setValue = function (gl, value) {
	        // Note: Don't need an extra 'renderer' parameter, since samplers
	        // are not allowed in structured uniforms.
	        var seq = this.seq;
	        for (var i = 0, n = seq.length; i !== n; ++i) {
	            var u = seq[i];
	            u.setValue(gl, value[u.id]);
	        }
	    };
	    return StructuredUniform;
	}(UniformContainer));
	// --- Top-level ---
	// Parser - builds up the property tree from the path strings
	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
	// extracts
	//   - the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.
	function addUniform(container, uniformObject) {
	    container.seq.push(uniformObject);
	    container.map[uniformObject.id] = uniformObject;
	}
	function parseUniform(activeInfo, addr, container) {
	    var path = activeInfo.name;
	    var pathLength = path.length;
	    // reset RegExp object, because of the early exit of a previous run
	    RePathPart.lastIndex = 0;
	    for (;;) {
	        var match = RePathPart.exec(path);
	        var matchEnd = RePathPart.lastIndex;
	        var id = match[1];
	        var idIsIndex = match[2] === ']';
	        var subscript = match[3];
	        //if (idIsIndex) id = id | 0; // convert to integer
	        if (idIsIndex)
	            id = parseInt(id, 10).toString(); // convert to integer
	        if (subscript === undefined ||
	            subscript === '[' && matchEnd + 2 === pathLength) {
	            // bare name or "pure" bottom-level array "[0]" suffix
	            addUniform(container, subscript === undefined ?
	                new SingleUniform(id, activeInfo, addr) :
	                new PureArrayUniform(id, activeInfo, addr));
	            break;
	        }
	        else {
	            // step into inner node / create it in case it doesn't exist
	            var map = container.map;
	            var next = map[id];
	            if (next === undefined) {
	                next = new StructuredUniform(id);
	                addUniform(container, next);
	            }
	            container = next;
	        }
	    }
	}
	// Root Container
	var WebGLUniforms = /** @class */ (function (_super) {
	    __extends(WebGLUniforms, _super);
	    function WebGLUniforms(gl, program, renderer) {
	        var _this = _super.call(this) || this;
	        _this.renderer = renderer;
	        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
	        for (var i = 0; i !== n; ++i) {
	            var info = gl.getActiveUniform(program, i), path = info.name, addr = gl.getUniformLocation(program, path);
	            parseUniform(info, addr, _this);
	        }
	        return _this;
	    }
	    WebGLUniforms.prototype.setValue = function (gl, name, value) {
	        var u = this.map[name];
	        if (u !== undefined)
	            u.setValue(gl, value, this.renderer);
	    };
	    WebGLUniforms.prototype.set = function (gl, object, name) {
	        var u = this.map[name];
	        if (u !== undefined)
	            u.setValue(gl, object[name], this.renderer);
	    };
	    WebGLUniforms.prototype.setOptional = function (gl, object, name) {
	        var v = object[name];
	        if (v !== undefined)
	            this.setValue(gl, name, v);
	    };
	    // Static interface
	    WebGLUniforms.upload = function (gl, seq, values, renderer) {
	        for (var i = 0, n = seq.length; i !== n; ++i) {
	            var u = seq[i], v = values[u.id];
	            if (v.needsUpdate !== false) {
	                // note: always updating when .needsUpdate is undefined
	                u.setValue(gl, v.value, renderer);
	            }
	        }
	    };
	    WebGLUniforms.seqWithValue = function (seq, values) {
	        var r = [];
	        for (var i = 0, n = seq.length; i !== n; ++i) {
	            var u = seq[i];
	            if (u.id in values)
	                r.push(u);
	        }
	        return r;
	    };
	    return WebGLUniforms;
	}(UniformContainer));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Color = /** @class */ (function () {
	    function Color(r, g, b) {
	        this.r = 1;
	        this.g = 1;
	        this.b = 1;
	        this.isColor = true;
	        //if (g === undefined && b === undefined) {
	        //  // r is THREE.Color, hex or string
	        //  this.set(r);
	        //}
	        //this.setRGB(r, g, b);
	        if (r instanceof Color) {
	            this.copy(r);
	        }
	        else if (typeof (r) === 'string') {
	            this.setStyle(r);
	        }
	        else if (typeof (r) === 'number') {
	            if (typeof (g) === 'number' && typeof (b) === 'number') {
	                this.setRGB(r, g, b);
	            }
	            else {
	                this.setHex(r);
	            }
	        }
	    }
	    Color.prototype.set = function (value) {
	        if (value && value instanceof Color) {
	            this.copy(value);
	        }
	        else if (typeof (value) === 'number') {
	            this.setHex(value);
	        }
	        else if (typeof (value) === 'string') {
	            this.setStyle(value);
	        }
	        return this;
	    };
	    Color.prototype.setScalar = function (scalar) {
	        this.r = scalar;
	        this.g = scalar;
	        this.b = scalar;
	        return this;
	    };
	    Color.prototype.setHex = function (hex) {
	        hex = Math.floor(hex);
	        this.r = (hex >> 16 & 255) / 255;
	        this.g = (hex >> 8 & 255) / 255;
	        this.b = (hex & 255) / 255;
	        return this;
	    };
	    Color.prototype.setRGB = function (r, g, b) {
	        this.r = r;
	        this.g = g;
	        this.b = b;
	        return this;
	    };
	    Color.prototype.setHSL = function (h, s, l) {
	        function hue2rgb(p, q, t) {
	            if (t < 0)
	                t += 1;
	            if (t > 1)
	                t -= 1;
	            if (t < 1 / 6)
	                return p + (q - p) * 6 * t;
	            if (t < 1 / 2)
	                return q;
	            if (t < 2 / 3)
	                return p + (q - p) * 6 * (2 / 3 - t);
	            return p;
	        }
	        // h,s,l ranges are in 0.0 - 1.0
	        h = _Math.euclideanModulo(h, 1);
	        s = _Math.clamp(s, 0, 1);
	        l = _Math.clamp(l, 0, 1);
	        if (s === 0) {
	            this.r = this.g = this.b = l;
	        }
	        else {
	            var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
	            var q = (2 * l) - p;
	            this.r = hue2rgb(q, p, h + 1 / 3);
	            this.g = hue2rgb(q, p, h);
	            this.b = hue2rgb(q, p, h - 1 / 3);
	        }
	        return this;
	    };
	    Color.prototype.setStyle = function (style) {
	        function handleAlpha(alpha) {
	            if (alpha === undefined)
	                return;
	            if (parseFloat(alpha) < 1) {
	                console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
	            }
	        }
	        var m;
	        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
	            // rgb / hsl
	            var color = void 0;
	            var name = m[1];
	            var components = m[2];
	            switch (name) {
	                case 'rgb':
	                case 'rgba':
	                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
	                        // rgb(255,0,0) rgba(255,0,0,0.5)
	                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
	                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
	                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
	                        handleAlpha(color[5]);
	                        return this;
	                    }
	                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
	                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
	                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
	                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
	                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
	                        handleAlpha(color[5]);
	                        return this;
	                    }
	                    break;
	                case 'hsl':
	                case 'hsla':
	                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
	                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
	                        var h = parseFloat(color[1]) / 360;
	                        var s = parseInt(color[2], 10) / 100;
	                        var l = parseInt(color[3], 10) / 100;
	                        handleAlpha(color[5]);
	                        return this.setHSL(h, s, l);
	                    }
	                    break;
	            }
	        }
	        else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
	            // hex color
	            var hex = m[1];
	            var size = hex.length;
	            if (size === 3) {
	                // #ff0
	                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
	                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
	                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
	                return this;
	            }
	            else if (size === 6) {
	                // #ff0000
	                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
	                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
	                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
	                return this;
	            }
	        }
	        if (style && style.length > 0) {
	            // color keywords
	            var hex = ColorKeywords[style];
	            if (hex !== undefined) {
	                // red
	                this.setHex(hex);
	            }
	            else {
	                // unknown color
	                console.warn('THREE.Color: Unknown color ' + style);
	            }
	        }
	        return this;
	    };
	    Color.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Color.prototype.copy = function (color) {
	        this.r = color.r;
	        this.g = color.g;
	        this.b = color.b;
	        return this;
	    };
	    Color.prototype.copyGammaToLinear = function (color, gammaFactor) {
	        if (gammaFactor === void 0) { gammaFactor = 2.0; }
	        this.r = Math.pow(color.r, gammaFactor);
	        this.g = Math.pow(color.g, gammaFactor);
	        this.b = Math.pow(color.b, gammaFactor);
	        return this;
	    };
	    Color.prototype.copyLinearToGamma = function (color, gammaFactor) {
	        if (gammaFactor === void 0) { gammaFactor = 2.0; }
	        var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
	        this.r = Math.pow(color.r, safeInverse);
	        this.g = Math.pow(color.g, safeInverse);
	        this.b = Math.pow(color.b, safeInverse);
	        return this;
	    };
	    Color.prototype.convertGammaToLinear = function () {
	        var r = this.r, g = this.g, b = this.b;
	        this.r = r * r;
	        this.g = g * g;
	        this.b = b * b;
	        return this;
	    };
	    Color.prototype.convertLinearToGamma = function () {
	        this.r = Math.sqrt(this.r);
	        this.g = Math.sqrt(this.g);
	        this.b = Math.sqrt(this.b);
	        return this;
	    };
	    Color.prototype.getHex = function () {
	        return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
	    };
	    Color.prototype.getHexString = function () {
	        return ('000000' + this.getHex().toString(16)).slice(-6);
	    };
	    Color.prototype.getHSL = function (hsl) {
	        if (hsl === void 0) { hsl = { h: 0, s: 0, l: 0 }; }
	        // h,s,l ranges are in 0.0 - 1.0
	        var r = this.r, g = this.g, b = this.b;
	        var max = Math.max(r, g, b);
	        var min = Math.min(r, g, b);
	        var hue, saturation;
	        var lightness = (min + max) / 2.0;
	        if (min === max) {
	            hue = 0;
	            saturation = 0;
	        }
	        else {
	            var delta = max - min;
	            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
	            switch (max) {
	                case r:
	                    hue = (g - b) / delta + (g < b ? 6 : 0);
	                    break;
	                case g:
	                    hue = (b - r) / delta + 2;
	                    break;
	                case b:
	                    hue = (r - g) / delta + 4;
	                    break;
	            }
	            hue /= 6;
	        }
	        hsl.h = hue;
	        hsl.s = saturation;
	        hsl.l = lightness;
	        return hsl;
	    };
	    Color.prototype.getStyle = function () {
	        return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
	    };
	    Color.prototype.offsetHSL = function (h, s, l) {
	        var hsl = this.getHSL();
	        hsl.h += h;
	        hsl.s += s;
	        hsl.l += l;
	        this.setHSL(hsl.h, hsl.s, hsl.l);
	        return this;
	    };
	    Color.prototype.add = function (color) {
	        this.r += color.r;
	        this.g += color.g;
	        this.b += color.b;
	        return this;
	    };
	    Color.prototype.addColors = function (color1, color2) {
	        this.r = color1.r + color2.r;
	        this.g = color1.g + color2.g;
	        this.b = color1.b + color2.b;
	        return this;
	    };
	    Color.prototype.addScalar = function (s) {
	        this.r += s;
	        this.g += s;
	        this.b += s;
	        return this;
	    };
	    Color.prototype.sub = function (color) {
	        this.r = Math.max(0, this.r - color.r);
	        this.g = Math.max(0, this.g - color.g);
	        this.b = Math.max(0, this.b - color.b);
	        return this;
	    };
	    Color.prototype.multiply = function (color) {
	        this.r *= color.r;
	        this.g *= color.g;
	        this.b *= color.b;
	        return this;
	    };
	    Color.prototype.multiplyScalar = function (s) {
	        this.r *= s;
	        this.g *= s;
	        this.b *= s;
	        return this;
	    };
	    Color.prototype.lerp = function (color, alpha) {
	        this.r += (color.r - this.r) * alpha;
	        this.g += (color.g - this.g) * alpha;
	        this.b += (color.b - this.b) * alpha;
	        return this;
	    };
	    Color.prototype.equals = function (c) {
	        return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
	    };
	    Color.prototype.fromArray = function (array, offset) {
	        if (offset === void 0) { offset = 0; }
	        this.r = array[offset];
	        this.g = array[offset + 1];
	        this.b = array[offset + 2];
	        return this;
	    };
	    Color.prototype.toArray = function (array, offset) {
	        if (array === void 0) { array = []; }
	        if (offset === void 0) { offset = 0; }
	        array[offset] = this.r;
	        array[offset + 1] = this.g;
	        array[offset + 2] = this.b;
	        return array;
	    };
	    Color.prototype.toJSON = function (meta) {
	        return this.getHex();
	    };
	    return Color;
	}());
	var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */
	var Matrix3 = /** @class */ (function () {
	    function Matrix3() {
	        this.elements = new Float32Array([
	            1, 0, 0,
	            0, 1, 0,
	            0, 0, 1
	        ]);
	        this.isMatrix3 = true;
	        if (arguments.length > 0) {
	            console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
	        }
	    }
	    Matrix3.prototype.set = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
	        var te = this.elements;
	        te[0] = n11;
	        te[1] = n21;
	        te[2] = n31;
	        te[3] = n12;
	        te[4] = n22;
	        te[5] = n32;
	        te[6] = n13;
	        te[7] = n23;
	        te[8] = n33;
	        return this;
	    };
	    Matrix3.prototype.identity = function () {
	        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
	        return this;
	    };
	    Matrix3.prototype.clone = function () {
	        return new this.constructor().fromArray(this.elements);
	    };
	    Matrix3.prototype.copy = function (m) {
	        var me = m.elements;
	        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
	        return this;
	    };
	    Matrix3.prototype.setFromMatrix4 = function (m) {
	        var me = m.elements;
	        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
	        return this;
	    };
	    Matrix3.prototype.applyToVector3Array = function (array, offset, length) {
	        if (offset === void 0) { offset = 0; }
	        if (length === void 0) { length = array.length; }
	        var v1 = Matrix3.applyToVector3Array_v1;
	        for (var i = 0, j = offset; i < length; i += 3, j += 3) {
	            v1.fromArray(array, j);
	            v1.applyMatrix3(this);
	            v1.toArray(array, j);
	        }
	        return array;
	    };
	    Matrix3.prototype.applyToBuffer = function (buffer, offset, length) {
	        if (offset === void 0) { offset = 0; }
	        if (length === void 0) { length = buffer.length / buffer.itemSize; }
	        var v1 = Matrix3.applyToBuffer_v1;
	        for (var i = 0, j = offset; i < length; i++, j++) {
	            v1.x = buffer.getX(j);
	            v1.y = buffer.getY(j);
	            v1.z = buffer.getZ(j);
	            v1.applyMatrix3(this);
	            buffer.setXYZ(j, v1.x, v1.y, v1.z);
	        }
	        return buffer;
	    };
	    Matrix3.prototype.multiplyScalar = function (s) {
	        var te = this.elements;
	        te[0] *= s;
	        te[3] *= s;
	        te[6] *= s;
	        te[1] *= s;
	        te[4] *= s;
	        te[7] *= s;
	        te[2] *= s;
	        te[5] *= s;
	        te[8] *= s;
	        return this;
	    };
	    Matrix3.prototype.determinant = function () {
	        var te = this.elements;
	        var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
	        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	    };
	    Matrix3.prototype.getInverse = function (matrix, throwOnDegenerate) {
	        if (matrix === void 0) { matrix = new Matrix3(); }
	        if (throwOnDegenerate === void 0) { throwOnDegenerate = false; }
	        var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
	        if (det === 0) {
	            var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
	            if (throwOnDegenerate === true) {
	                throw new Error(msg);
	            }
	            else {
	                console.warn(msg);
	            }
	            return this.identity();
	        }
	        var detInv = 1 / det;
	        te[0] = t11 * detInv;
	        te[1] = (n31 * n23 - n33 * n21) * detInv;
	        te[2] = (n32 * n21 - n31 * n22) * detInv;
	        te[3] = t12 * detInv;
	        te[4] = (n33 * n11 - n31 * n13) * detInv;
	        te[5] = (n31 * n12 - n32 * n11) * detInv;
	        te[6] = t13 * detInv;
	        te[7] = (n21 * n13 - n23 * n11) * detInv;
	        te[8] = (n22 * n11 - n21 * n12) * detInv;
	        return this;
	    };
	    Matrix3.prototype.transpose = function () {
	        var tmp;
	        var m = this.elements;
	        tmp = m[1];
	        m[1] = m[3];
	        m[3] = tmp;
	        tmp = m[2];
	        m[2] = m[6];
	        m[6] = tmp;
	        tmp = m[5];
	        m[5] = m[7];
	        m[7] = tmp;
	        return this;
	    };
	    Matrix3.prototype.flattenToArrayOffset = function (array, offset) {
	        if (array === void 0) { array = []; }
	        console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated " +
	            "- just use .toArray instead.");
	        return this.toArray(array, offset);
	    };
	    Matrix3.prototype.getNormalMatrix = function (matrix4) {
	        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
	    };
	    Matrix3.prototype.transposeIntoArray = function (r) {
	        var m = this.elements;
	        r[0] = m[0];
	        r[1] = m[3];
	        r[2] = m[6];
	        r[3] = m[1];
	        r[4] = m[4];
	        r[5] = m[7];
	        r[6] = m[2];
	        r[7] = m[5];
	        r[8] = m[8];
	        return this;
	    };
	    Matrix3.prototype.fromArray = function (array, offset) {
	        if (offset === void 0) { offset = 0; }
	        for (var i = 0; i < 9; i++) {
	            this.elements[i] = array[i + offset];
	        }
	        return this;
	    };
	    Matrix3.prototype.toArray = function (array, offset) {
	        if (array === void 0) { array = []; }
	        if (offset === void 0) { offset = 0; }
	        var te = this.elements;
	        array[offset] = te[0];
	        array[offset + 1] = te[1];
	        array[offset + 2] = te[2];
	        array[offset + 3] = te[3];
	        array[offset + 4] = te[4];
	        array[offset + 5] = te[5];
	        array[offset + 6] = te[6];
	        array[offset + 7] = te[7];
	        array[offset + 8] = te[8];
	        return array;
	    };
	    Matrix3.prototype.multiplyVector3 = function (vector) {
	        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3(matrix) instead.");
	        return vector.applyMatrix3(this);
	    };
	    Matrix3.prototype.multiplyVector3Array = function (a) {
	        console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array(array) instead.");
	        return this.applyToVector3Array(a);
	    };
	    Matrix3.applyToVector3Array_v1 = new Vector3();
	    Matrix3.applyToBuffer_v1 = new Vector3();
	    return Matrix3;
	}());

	/**
	 * Uniform Utilities
	 */
	var UniformsUtils = /** @class */ (function () {
	    function UniformsUtils() {
	    }
	    UniformsUtils.merge = function (uniforms) {
	        var merged = {};
	        for (var u = 0; u < uniforms.length; u++) {
	            var tmp = UniformsUtils.clone(uniforms[u]);
	            for (var p in tmp) {
	                merged[p] = tmp[p];
	            }
	        }
	        return merged;
	    };
	    UniformsUtils.clone = function (uniforms_src) {
	        var uniforms_dst = {};
	        for (var u in uniforms_src) {
	            uniforms_dst[u] = {};
	            for (var p in uniforms_src[u]) {
	                var parameter_src = uniforms_src[u][p];
	                if (parameter_src && (parameter_src instanceof Color ||
	                    parameter_src instanceof Matrix3 || parameter_src instanceof Matrix4 ||
	                    parameter_src instanceof Vector2 || parameter_src instanceof Vector3 || parameter_src instanceof Vector4 ||
	                    parameter_src instanceof Texture)) {
	                    uniforms_dst[u][p] = parameter_src.clone();
	                }
	                else if (Array.isArray(parameter_src)) {
	                    uniforms_dst[u][p] = parameter_src.slice();
	                }
	                else {
	                    uniforms_dst[u][p] = parameter_src;
	                }
	            }
	        }
	        return uniforms_dst;
	    };
	    return UniformsUtils;
	}());

	var alphamap_fragment = [
	    "#ifdef USE_ALPHAMAP",
	    "",
	    "	diffuseColor.a *= texture2D( alphaMap, vUv ).g;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var alphamap_pars_fragment = [
	    "#ifdef USE_ALPHAMAP",
	    "",
	    "	uniform sampler2D alphaMap;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var alphatest_fragment = [
	    "#ifdef ALPHATEST",
	    "",
	    "	if ( diffuseColor.a < ALPHATEST ) discard;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var aomap_fragment = [
	    "#ifdef USE_AOMAP",
	    "",
	    "	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;",
	    "",
	    "	reflectedLight.indirectDiffuse *= ambientOcclusion;",
	    "",
	    "	#if defined( USE_ENVMAP ) && defined( PHYSICAL )",
	    "",
	    "		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
	    "",
	    "		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var aomap_pars_fragment = [
	    "#ifdef USE_AOMAP",
	    "",
	    "	uniform sampler2D aoMap;",
	    "	uniform float aoMapIntensity;",
	    "",
	    "#endif",
	].join('\n');

	var begin_vertex = [
	    "",
	    "vec3 transformed = vec3( position );",
	    "",
	].join('\n');

	var beginnormal_vertex = [
	    "",
	    "vec3 objectNormal = vec3( normal );",
	    "",
	].join('\n');

	var bsdfs = [
	    "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {",
	    "",
	    "	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );",
	    "",
	    "}",
	    "",
	    "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {",
	    "",
	    "		if( decayExponent > 0.0 ) {",
	    "",
	    "#if defined ( PHYSICALLY_CORRECT_LIGHTS )",
	    "",
	    "			// based upon Frostbite 3 Moving to Physically-based Rendering",
	    "			// page 32, equation 26: E[window1]",
	    "			// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf",
	    "			// this is intended to be used on spot and point lights who are represented as luminous intensity",
	    "			// but who must be converted to luminous irradiance for surface lighting calculation",
	    "			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );",
	    "			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );",
	    "			return distanceFalloff * maxDistanceCutoffFactor;",
	    "",
	    "#else",
	    "",
	    "			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );",
	    "",
	    "#endif",
	    "",
	    "		}",
	    "",
	    "		return 1.0;",
	    "}",
	    "",
	    "vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {",
	    "",
	    "	return RECIPROCAL_PI * diffuseColor;",
	    "",
	    "} // validated",
	    "",
	    "",
	    "vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {",
	    "",
	    "	// Original approximation by Christophe Schlick '94",
	    "	//;float fresnel = pow( 1.0 - dotLH, 5.0 );",
	    "",
	    "	// Optimized variant (presented by Epic at SIGGRAPH '13)",
	    "	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );",
	    "",
	    "	return ( 1.0 - specularColor ) * fresnel + specularColor;",
	    "",
	    "} // validated",
	    "",
	    "",
	    "// Microfacet Models for Refraction through Rough Surfaces - equation (34)",
	    "// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html",
	    "// alpha is \"roughness squared\" in Disney’s reparameterization",
	    "float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {",
	    "",
	    "	// geometry term = G(l)⋅G(v) / 4(n⋅l)(n⋅v)",
	    "",
	    "	float a2 = pow2( alpha );",
	    "",
	    "	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );",
	    "	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );",
	    "",
	    "	return 1.0 / ( gl * gv );",
	    "",
	    "} // validated",
	    "",
	    "// from page 12, listing 2 of http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf",
	    "float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {",
	    "",
	    "	float a2 = pow2( alpha );",
	    "",
	    "	// dotNL and dotNV are explicitly swapped. This is not a mistake.",
	    "	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );",
	    "	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );",
	    "",
	    "	return 0.5 / max( gv + gl, EPSILON );",
	    "}",
	    "",
	    "",
	    "",
	    "// Microfacet Models for Refraction through Rough Surfaces - equation (33)",
	    "// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html",
	    "// alpha is \"roughness squared\" in Disney’s reparameterization",
	    "float D_GGX( const in float alpha, const in float dotNH ) {",
	    "",
	    "	float a2 = pow2( alpha );",
	    "",
	    "	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1",
	    "",
	    "	return RECIPROCAL_PI * a2 / pow2( denom );",
	    "",
	    "}",
	    "",
	    "",
	    "// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility",
	    "vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {",
	    "",
	    "	float alpha = pow2( roughness ); // UE4's roughness",
	    "",
	    "	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );",
	    "",
	    "	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );",
	    "	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
	    "	float dotNH = saturate( dot( geometry.normal, halfDir ) );",
	    "	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );",
	    "",
	    "	vec3 F = F_Schlick( specularColor, dotLH );",
	    "",
	    "	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );",
	    "",
	    "	float D = D_GGX( alpha, dotNH );",
	    "",
	    "	return F * ( G * D );",
	    "",
	    "} // validated",
	    "",
	    "",
	    "// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile",
	    "vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {",
	    "",
	    "	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
	    "",
	    "	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );",
	    "",
	    "	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );",
	    "",
	    "	vec4 r = roughness * c0 + c1;",
	    "",
	    "	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;",
	    "",
	    "	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;",
	    "",
	    "	return specularColor * AB.x + AB.y;",
	    "",
	    "} // validated",
	    "",
	    "",
	    "float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {",
	    "",
	    "	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)",
	    "	return 0.25;",
	    "",
	    "}",
	    "",
	    "float D_BlinnPhong( const in float shininess, const in float dotNH ) {",
	    "",
	    "	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );",
	    "",
	    "}",
	    "",
	    "vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {",
	    "",
	    "	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );",
	    "",
	    "	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );",
	    "	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
	    "	float dotNH = saturate( dot( geometry.normal, halfDir ) );",
	    "	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );",
	    "",
	    "	vec3 F = F_Schlick( specularColor, dotLH );",
	    "",
	    "	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );",
	    "",
	    "	float D = D_BlinnPhong( shininess, dotNH );",
	    "",
	    "	return F * ( G * D );",
	    "",
	    "} // validated",
	    "",
	    "// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html",
	    "float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {",
	    "	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );",
	    "}",
	    "",
	    "float BlinnExponentToGGXRoughness( const in float blinnExponent ) {",
	    "	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );",
	    "}",
	    "",
	].join('\n');

	var bumpmap_pars_fragment = [
	    "#ifdef USE_BUMPMAP",
	    "",
	    "	uniform sampler2D bumpMap;",
	    "	uniform float bumpScale;",
	    "",
	    "	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen",
	    "	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html",
	    "",
	    "	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)",
	    "",
	    "	vec2 dHdxy_fwd() {",
	    "",
	    "		vec2 dSTdx = dFdx( vUv );",
	    "		vec2 dSTdy = dFdy( vUv );",
	    "",
	    "		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
	    "		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
	    "		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",
	    "",
	    "		return vec2( dBx, dBy );",
	    "",
	    "	}",
	    "",
	    "	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",
	    "",
	    "		vec3 vSigmaX = dFdx( surf_pos );",
	    "		vec3 vSigmaY = dFdy( surf_pos );",
	    "		vec3 vN = surf_norm;		// normalized",
	    "",
	    "		vec3 R1 = cross( vSigmaY, vN );",
	    "		vec3 R2 = cross( vN, vSigmaX );",
	    "",
	    "		float fDet = dot( vSigmaX, R1 );",
	    "",
	    "		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
	    "		return normalize( abs( fDet ) * surf_norm - vGrad );",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var clipping_planes_fragment = [
	    "#if NUM_CLIPPING_PLANES > 0",
	    "",
	    "	for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {",
	    "",
	    "		vec4 plane = clippingPlanes[ i ];",
	    "		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var clipping_planes_pars_fragment = [
	    "#if NUM_CLIPPING_PLANES > 0",
	    "",
	    "	#if ! defined( PHYSICAL ) && ! defined( PHONG )",
	    "		varying vec3 vViewPosition;",
	    "	#endif",
	    "",
	    "	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var clipping_planes_pars_vertex = [
	    "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )",
	    "	varying vec3 vViewPosition;",
	    "#endif",
	    "",
	].join('\n');

	var clipping_planes_vertex = [
	    "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )",
	    "	vViewPosition = - mvPosition.xyz;",
	    "#endif",
	    "",
	    "",
	].join('\n');

	var color_fragment = [
	    "#ifdef USE_COLOR",
	    "",
	    "	diffuseColor.rgb *= vColor;",
	    "",
	    "#endif",
	].join('\n');

	var color_pars_fragment = [
	    "#ifdef USE_COLOR",
	    "",
	    "	varying vec3 vColor;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var color_pars_vertex = [
	    "#ifdef USE_COLOR",
	    "",
	    "	varying vec3 vColor;",
	    "",
	    "#endif",
	].join('\n');

	var color_vertex = [
	    "#ifdef USE_COLOR",
	    "",
	    "	vColor.xyz = color.xyz;",
	    "",
	    "#endif",
	].join('\n');

	var common = [
	    "#define PI 3.14159265359",
	    "#define PI2 6.28318530718",
	    "#define RECIPROCAL_PI 0.31830988618",
	    "#define RECIPROCAL_PI2 0.15915494",
	    "#define LOG2 1.442695",
	    "#define EPSILON 1e-6",
	    "",
	    "#define saturate(a) clamp( a, 0.0, 1.0 )",
	    "#define whiteCompliment(a) ( 1.0 - saturate( a ) )",
	    "",
	    "float pow2( const in float x ) { return x*x; }",
	    "float pow3( const in float x ) { return x*x*x; }",
	    "float pow4( const in float x ) { float x2 = x*x; return x2*x2; }",
	    "float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }",
	    "// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.",
	    "// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/",
	    "highp float rand( const in vec2 uv ) {",
	    "	const highp float a = 12.9898, b = 78.233, c = 43758.5453;",
	    "	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );",
	    "	return fract(sin(sn) * c);",
	    "}",
	    "",
	    "struct IncidentLight {",
	    "	vec3 color;",
	    "	vec3 direction;",
	    "	bool visible;",
	    "};",
	    "",
	    "struct ReflectedLight {",
	    "	vec3 directDiffuse;",
	    "	vec3 directSpecular;",
	    "	vec3 indirectDiffuse;",
	    "	vec3 indirectSpecular;",
	    "};",
	    "",
	    "struct GeometricContext {",
	    "	vec3 position;",
	    "	vec3 normal;",
	    "	vec3 viewDir;",
	    "};",
	    "",
	    "",
	    "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
	    "",
	    "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
	    "",
	    "}",
	    "",
	    "// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations",
	    "vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {",
	    "",
	    "	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );",
	    "",
	    "}",
	    "",
	    "vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {",
	    "",
	    "	float distance = dot( planeNormal, point - pointOnPlane );",
	    "",
	    "	return - distance * planeNormal + point;",
	    "",
	    "}",
	    "",
	    "float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {",
	    "",
	    "	return sign( dot( point - pointOnPlane, planeNormal ) );",
	    "",
	    "}",
	    "",
	    "vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {",
	    "",
	    "	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;",
	    "",
	    "}",
	    "",
	].join('\n');

	var cube_uv_reflection_fragment = [
	    "#ifdef ENVMAP_TYPE_CUBE_UV",
	    "",
	    "#define cubeUV_textureSize (1024.0)",
	    "",
	    "int getFaceFromDirection(vec3 direction) {",
	    "	vec3 absDirection = abs(direction);",
	    "	int face = -1;",
	    "	if( absDirection.x > absDirection.z ) {",
	    "		if(absDirection.x > absDirection.y )",
	    "			face = direction.x > 0.0 ? 0 : 3;",
	    "		else",
	    "			face = direction.y > 0.0 ? 1 : 4;",
	    "	}",
	    "	else {",
	    "		if(absDirection.z > absDirection.y )",
	    "			face = direction.z > 0.0 ? 2 : 5;",
	    "		else",
	    "			face = direction.y > 0.0 ? 1 : 4;",
	    "	}",
	    "	return face;",
	    "}",
	    "#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)",
	    "#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))",
	    "",
	    "vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {",
	    "	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);",
	    "	float dxRoughness = dFdx(roughness);",
	    "	float dyRoughness = dFdy(roughness);",
	    "	vec3 dx = dFdx( vec * scale * dxRoughness );",
	    "	vec3 dy = dFdy( vec * scale * dyRoughness );",
	    "	float d = max( dot( dx, dx ), dot( dy, dy ) );",
	    "	// Clamp the value to the max mip level counts. hard coded to 6 mips",
	    "	d = clamp(d, 1.0, cubeUV_rangeClamp);",
	    "	float mipLevel = 0.5 * log2(d);",
	    "	return vec2(floor(mipLevel), fract(mipLevel));",
	    "}",
	    "",
	    "#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)",
	    "#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)",
	    "",
	    "vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {",
	    "	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;",
	    "	float a = 16.0 * cubeUV_rcpTextureSize;",
	    "",
	    "	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );",
	    "	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;",
	    "	// float powScale = exp2(roughnessLevel + mipLevel);",
	    "	float powScale = exp2_packed.x * exp2_packed.y;",
	    "	// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);",
	    "	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;",
	    "	// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);",
	    "	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;",
	    "",
	    "	bool bRes = mipLevel == 0.0;",
	    "	scale =  bRes && (scale < a) ? a : scale;",
	    "",
	    "	vec3 r;",
	    "	vec2 offset;",
	    "	int face = getFaceFromDirection(direction);",
	    "",
	    "	float rcpPowScale = 1.0 / powScale;",
	    "",
	    "	if( face == 0) {",
	    "		r = vec3(direction.x, -direction.z, direction.y);",
	    "		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);",
	    "		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;",
	    "	}",
	    "	else if( face == 1) {",
	    "		r = vec3(direction.y, direction.x, direction.z);",
	    "		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);",
	    "		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;",
	    "	}",
	    "	else if( face == 2) {",
	    "		r = vec3(direction.z, direction.x, direction.y);",
	    "		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);",
	    "		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;",
	    "	}",
	    "	else if( face == 3) {",
	    "		r = vec3(direction.x, direction.z, direction.y);",
	    "		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);",
	    "		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;",
	    "	}",
	    "	else if( face == 4) {",
	    "		r = vec3(direction.y, direction.x, -direction.z);",
	    "		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);",
	    "		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;",
	    "	}",
	    "	else {",
	    "		r = vec3(direction.z, -direction.x, direction.y);",
	    "		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);",
	    "		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;",
	    "	}",
	    "	r = normalize(r);",
	    "	float texelOffset = 0.5 * cubeUV_rcpTextureSize;",
	    "	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;",
	    "	vec2 base = offset + vec2( texelOffset );",
	    "	return base + s * ( scale - 2.0 * texelOffset );",
	    "}",
	    "",
	    "#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)",
	    "",
	    "vec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {",
	    "	float roughnessVal = roughness* cubeUV_maxLods3;",
	    "	float r1 = floor(roughnessVal);",
	    "	float r2 = r1 + 1.0;",
	    "	float t = fract(roughnessVal);",
	    "	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);",
	    "	float s = mipInfo.y;",
	    "	float level0 = mipInfo.x;",
	    "	float level1 = level0 + 1.0;",
	    "	level1 = level1 > 5.0 ? 5.0 : level1;",
	    "",
	    "	// round to nearest mipmap if we are not interpolating.",
	    "	level0 += min( floor( s + 0.5 ), 5.0 );",
	    "",
	    "	// Tri linear interpolation.",
	    "	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);",
	    "	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));",
	    "",
	    "	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);",
	    "	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));",
	    "",
	    "	vec4 result = mix(color10, color20, t);",
	    "",
	    "	return vec4(result.rgb, 1.0);",
	    "}",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var defaultnormal_vertex = [
	    "#ifdef FLIP_SIDED",
	    "",
	    "	objectNormal = -objectNormal;",
	    "",
	    "#endif",
	    "",
	    "vec3 transformedNormal = normalMatrix * objectNormal;",
	    "",
	].join('\n');

	var displacementmap_pars_vertex = [
	    "#ifdef USE_DISPLACEMENTMAP",
	    "",
	    "	uniform sampler2D displacementMap;",
	    "	uniform float displacementScale;",
	    "	uniform float displacementBias;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var displacementmap_vertex = [
	    "#ifdef USE_DISPLACEMENTMAP",
	    "",
	    "	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var emissivemap_fragment = [
	    "#ifdef USE_EMISSIVEMAP",
	    "",
	    "	vec4 emissiveColor = texture2D( emissiveMap, vUv );",
	    "",
	    "	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;",
	    "",
	    "	totalEmissiveRadiance *= emissiveColor.rgb;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var emissivemap_pars_fragment = [
	    "#ifdef USE_EMISSIVEMAP",
	    "",
	    "	uniform sampler2D emissiveMap;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var encodings_fragment = [
	    "  gl_FragColor = linearToOutputTexel( gl_FragColor );",
	    "",
	].join('\n');

	var encodings_pars_fragment = [
	    "// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/",
	    "",
	    "vec4 LinearToLinear( in vec4 value ) {",
	    "  return value;",
	    "}",
	    "",
	    "vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {",
	    "  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );",
	    "}",
	    "vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {",
	    "  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );",
	    "}",
	    "",
	    "vec4 sRGBToLinear( in vec4 value ) {",
	    "  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );",
	    "}",
	    "vec4 LinearTosRGB( in vec4 value ) {",
	    "  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );",
	    "}",
	    "",
	    "vec4 RGBEToLinear( in vec4 value ) {",
	    "  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );",
	    "}",
	    "vec4 LinearToRGBE( in vec4 value ) {",
	    "  float maxComponent = max( max( value.r, value.g ), value.b );",
	    "  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );",
	    "  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );",
	    "//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );",
	    "}",
	    "",
	    "// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html",
	    "vec4 RGBMToLinear( in vec4 value, in float maxRange ) {",
	    "  return vec4( value.xyz * value.w * maxRange, 1.0 );",
	    "}",
	    "vec4 LinearToRGBM( in vec4 value, in float maxRange ) {",
	    "  float maxRGB = max( value.x, max( value.g, value.b ) );",
	    "  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );",
	    "  M            = ceil( M * 255.0 ) / 255.0;",
	    "  return vec4( value.rgb / ( M * maxRange ), M );",
	    "}",
	    "",
	    "// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html",
	    "vec4 RGBDToLinear( in vec4 value, in float maxRange ) {",
	    "    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );",
	    "}",
	    "vec4 LinearToRGBD( in vec4 value, in float maxRange ) {",
	    "    float maxRGB = max( value.x, max( value.g, value.b ) );",
	    "    float D      = max( maxRange / maxRGB, 1.0 );",
	    "    D            = min( floor( D ) / 255.0, 1.0 );",
	    "    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );",
	    "}",
	    "",
	    "// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html",
	    "",
	    "// M matrix, for encoding",
	    "const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );",
	    "vec4 LinearToLogLuv( in vec4 value )  {",
	    "  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;",
	    "  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));",
	    "  vec4 vResult;",
	    "  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;",
	    "  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;",
	    "  vResult.w = fract(Le);",
	    "  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;",
	    "  return vResult;",
	    "}",
	    "",
	    "// Inverse M matrix, for decoding",
	    "const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );",
	    "vec4 LogLuvToLinear( in vec4 value ) {",
	    "  float Le = value.z * 255.0 + value.w;",
	    "  vec3 Xp_Y_XYZp;",
	    "  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);",
	    "  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;",
	    "  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;",
	    "  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;",
	    "  return vec4( max(vRGB, 0.0), 1.0 );",
	    "}",
	    "",
	].join('\n');

	var envmap_fragment = [
	    "#ifdef USE_ENVMAP",
	    "",
	    "	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )",
	    "",
	    "		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
	    "",
	    "		// Transforming Normal Vectors with the Inverse Transformation",
	    "		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );",
	    "",
	    "		#ifdef ENVMAP_MODE_REFLECTION",
	    "",
	    "			vec3 reflectVec = reflect( cameraToVertex, worldNormal );",
	    "",
	    "		#else",
	    "",
	    "			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );",
	    "",
	    "		#endif",
	    "",
	    "	#else",
	    "",
	    "		vec3 reflectVec = vReflect;",
	    "",
	    "	#endif",
	    "",
	    "	#ifdef ENVMAP_TYPE_CUBE",
	    "",
	    "		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",
	    "",
	    "	#elif defined( ENVMAP_TYPE_EQUIREC )",
	    "",
	    "		vec2 sampleUV;",
	    "		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );",
	    "		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;",
	    "		vec4 envColor = texture2D( envMap, sampleUV );",
	    "",
	    "	#elif defined( ENVMAP_TYPE_SPHERE )",
	    "",
	    "		vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );",
	    "		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );",
	    "",
	    "	#else",
	    "",
	    "		vec4 envColor = vec4( 0.0 );",
	    "",
	    "	#endif",
	    "",
	    "	envColor = envMapTexelToLinear( envColor );",
	    "",
	    "	#ifdef ENVMAP_BLENDING_MULTIPLY",
	    "",
	    "		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );",
	    "",
	    "	#elif defined( ENVMAP_BLENDING_MIX )",
	    "",
	    "		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );",
	    "",
	    "	#elif defined( ENVMAP_BLENDING_ADD )",
	    "",
	    "		outgoingLight += envColor.xyz * specularStrength * reflectivity;",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var envmap_pars_fragment = [
	    "#if defined( USE_ENVMAP ) || defined( PHYSICAL )",
	    "	uniform float reflectivity;",
	    "	uniform float envMapIntenstiy;",
	    "#endif",
	    "",
	    "#ifdef USE_ENVMAP",
	    "",
	    "	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )",
	    "		varying vec3 vWorldPosition;",
	    "	#endif",
	    "",
	    "	#ifdef ENVMAP_TYPE_CUBE",
	    "		uniform samplerCube envMap;",
	    "	#else",
	    "		uniform sampler2D envMap;",
	    "	#endif",
	    "	uniform float flipEnvMap;",
	    "",
	    "	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )",
	    "		uniform float refractionRatio;",
	    "	#else",
	    "		varying vec3 vReflect;",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var envmap_pars_vertex = [
	    "#ifdef USE_ENVMAP",
	    "",
	    "	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )",
	    "		varying vec3 vWorldPosition;",
	    "",
	    "	#else",
	    "",
	    "		varying vec3 vReflect;",
	    "		uniform float refractionRatio;",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var envmap_vertex = [
	    "#ifdef USE_ENVMAP",
	    "",
	    "	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )",
	    "",
	    "		vWorldPosition = worldPosition.xyz;",
	    "",
	    "	#else",
	    "",
	    "		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",
	    "",
	    "		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );",
	    "",
	    "		#ifdef ENVMAP_MODE_REFLECTION",
	    "",
	    "			vReflect = reflect( cameraToVertex, worldNormal );",
	    "",
	    "		#else",
	    "",
	    "			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",
	    "",
	    "		#endif",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var fog_fragment = [
	    "#ifdef USE_FOG",
	    "",
	    "	#ifdef USE_LOGDEPTHBUF_EXT",
	    "",
	    "		float depth = gl_FragDepthEXT / gl_FragCoord.w;",
	    "",
	    "	#else",
	    "",
	    "		float depth = gl_FragCoord.z / gl_FragCoord.w;",
	    "",
	    "	#endif",
	    "",
	    "	#ifdef FOG_EXP2",
	    "",
	    "		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );",
	    "",
	    "	#else",
	    "",
	    "		float fogFactor = smoothstep( fogNear, fogFar, depth );",
	    "",
	    "	#endif",
	    "",
	    "	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var fog_pars_fragment = [
	    "#ifdef USE_FOG",
	    "",
	    "	uniform vec3 fogColor;",
	    "",
	    "	#ifdef FOG_EXP2",
	    "",
	    "		uniform float fogDensity;",
	    "",
	    "	#else",
	    "",
	    "		uniform float fogNear;",
	    "		uniform float fogFar;",
	    "	#endif",
	    "",
	    "#endif",
	].join('\n');

	var lightmap_fragment = [
	    "#ifdef USE_LIGHTMAP",
	    "",
	    "	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var lightmap_pars_fragment = [
	    "#ifdef USE_LIGHTMAP",
	    "",
	    "	uniform sampler2D lightMap;",
	    "	uniform float lightMapIntensity;",
	    "",
	    "#endif",
	].join('\n');

	var lights_lambert_vertex = [
	    "vec3 diffuse = vec3( 1.0 );",
	    "",
	    "GeometricContext geometry;",
	    "geometry.position = mvPosition.xyz;",
	    "geometry.normal = normalize( transformedNormal );",
	    "geometry.viewDir = normalize( -mvPosition.xyz );",
	    "",
	    "GeometricContext backGeometry;",
	    "backGeometry.position = geometry.position;",
	    "backGeometry.normal = -geometry.normal;",
	    "backGeometry.viewDir = geometry.viewDir;",
	    "",
	    "vLightFront = vec3( 0.0 );",
	    "",
	    "#ifdef DOUBLE_SIDED",
	    "	vLightBack = vec3( 0.0 );",
	    "#endif",
	    "",
	    "IncidentLight directLight;",
	    "float dotNL;",
	    "vec3 directLightColor_Diffuse;",
	    "",
	    "#if NUM_POINT_LIGHTS > 0",
	    "",
	    "	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",
	    "",
	    "		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );",
	    "",
	    "		dotNL = dot( geometry.normal, directLight.direction );",
	    "		directLightColor_Diffuse = PI * directLight.color;",
	    "",
	    "		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;",
	    "",
	    "		#ifdef DOUBLE_SIDED",
	    "",
	    "			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;",
	    "",
	    "		#endif",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	    "#if NUM_SPOT_LIGHTS > 0",
	    "",
	    "	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {",
	    "",
	    "		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );",
	    "",
	    "		dotNL = dot( geometry.normal, directLight.direction );",
	    "		directLightColor_Diffuse = PI * directLight.color;",
	    "",
	    "		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;",
	    "",
	    "		#ifdef DOUBLE_SIDED",
	    "",
	    "			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;",
	    "",
	    "		#endif",
	    "	}",
	    "",
	    "#endif",
	    "",
	    "#if NUM_DIR_LIGHTS > 0",
	    "",
	    "	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
	    "",
	    "		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );",
	    "",
	    "		dotNL = dot( geometry.normal, directLight.direction );",
	    "		directLightColor_Diffuse = PI * directLight.color;",
	    "",
	    "		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;",
	    "",
	    "		#ifdef DOUBLE_SIDED",
	    "",
	    "			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;",
	    "",
	    "		#endif",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	    "#if NUM_HEMI_LIGHTS > 0",
	    "",
	    "	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {",
	    "",
	    "		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );",
	    "",
	    "		#ifdef DOUBLE_SIDED",
	    "",
	    "			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );",
	    "",
	    "		#endif",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var lights_pars = [
	    "uniform vec3 ambientLightColor;",
	    "",
	    "vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {",
	    "",
	    "	vec3 irradiance = ambientLightColor;",
	    "",
	    "	#ifndef PHYSICALLY_CORRECT_LIGHTS",
	    "",
	    "		irradiance *= PI;",
	    "",
	    "	#endif",
	    "",
	    "	return irradiance;",
	    "",
	    "}",
	    "",
	    "#if NUM_DIR_LIGHTS > 0",
	    "",
	    "	struct DirectionalLight {",
	    "		vec3 direction;",
	    "		vec3 color;",
	    "",
	    "		int shadow;",
	    "		float shadowBias;",
	    "		float shadowRadius;",
	    "		vec2 shadowMapSize;",
	    "	};",
	    "",
	    "	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];",
	    "",
	    "	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {",
	    "",
	    "		directLight.color = directionalLight.color;",
	    "		directLight.direction = directionalLight.direction;",
	    "		directLight.visible = true;",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	    "",
	    "#if NUM_POINT_LIGHTS > 0",
	    "",
	    "	struct PointLight {",
	    "		vec3 position;",
	    "		vec3 color;",
	    "		float distance;",
	    "		float decay;",
	    "",
	    "		int shadow;",
	    "		float shadowBias;",
	    "		float shadowRadius;",
	    "		vec2 shadowMapSize;",
	    "	};",
	    "",
	    "	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];",
	    "",
	    "	// directLight is an out parameter as having it as a return value caused compiler errors on some devices",
	    "	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {",
	    "",
	    "		vec3 lVector = pointLight.position - geometry.position;",
	    "		directLight.direction = normalize( lVector );",
	    "",
	    "		float lightDistance = length( lVector );",
	    "",
	    "		if ( testLightInRange( lightDistance, pointLight.distance ) ) {",
	    "",
	    "			directLight.color = pointLight.color;",
	    "			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );",
	    "",
	    "			directLight.visible = true;",
	    "",
	    "		} else {",
	    "",
	    "			directLight.color = vec3( 0.0 );",
	    "			directLight.visible = false;",
	    "",
	    "		}",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	    "",
	    "#if NUM_SPOT_LIGHTS > 0",
	    "",
	    "	struct SpotLight {",
	    "		vec3 position;",
	    "		vec3 direction;",
	    "		vec3 color;",
	    "		float distance;",
	    "		float decay;",
	    "		float coneCos;",
	    "		float penumbraCos;",
	    "",
	    "		int shadow;",
	    "		float shadowBias;",
	    "		float shadowRadius;",
	    "		vec2 shadowMapSize;",
	    "	};",
	    "",
	    "	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];",
	    "",
	    "	// directLight is an out parameter as having it as a return value caused compiler errors on some devices",
	    "	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {",
	    "",
	    "		vec3 lVector = spotLight.position - geometry.position;",
	    "		directLight.direction = normalize( lVector );",
	    "",
	    "		float lightDistance = length( lVector );",
	    "		float angleCos = dot( directLight.direction, spotLight.direction );",
	    "",
	    "		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {",
	    "",
	    "			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );",
	    "",
	    "			directLight.color = spotLight.color;",
	    "			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );",
	    "",
	    "			directLight.visible = true;",
	    "",
	    "		} else {",
	    "",
	    "			directLight.color = vec3( 0.0 );",
	    "			directLight.visible = false;",
	    "",
	    "		}",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	    "",
	    "#if NUM_HEMI_LIGHTS > 0",
	    "",
	    "	struct HemisphereLight {",
	    "		vec3 direction;",
	    "		vec3 skyColor;",
	    "		vec3 groundColor;",
	    "	};",
	    "",
	    "	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];",
	    "",
	    "	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {",
	    "",
	    "		float dotNL = dot( geometry.normal, hemiLight.direction );",
	    "		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;",
	    "",
	    "		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );",
	    "",
	    "		#ifndef PHYSICALLY_CORRECT_LIGHTS",
	    "",
	    "			irradiance *= PI;",
	    "",
	    "		#endif",
	    "",
	    "		return irradiance;",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	    "",
	    "#if defined( USE_ENVMAP ) && defined( PHYSICAL )",
	    "",
	    "	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {",
	    "",
	    "		#include <normal_flip>",
	    "",
	    "		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );",
	    "",
	    "		#ifdef ENVMAP_TYPE_CUBE",
	    "",
	    "			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );",
	    "",
	    "			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level",
	    "			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.",
	    "",
	    "			#ifdef TEXTURE_LOD_EXT",
	    "",
	    "				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );",
	    "",
	    "			#else",
	    "",
	    "				// force the bias high to get the last LOD level as it is the most blurred.",
	    "				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );",
	    "",
	    "			#endif",
	    "",
	    "			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;",
	    "",
	    "		#elif defined( ENVMAP_TYPE_CUBE_UV )",
	    "",
	    "			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );",
	    "			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );",
	    "",
	    "		#else",
	    "",
	    "			vec4 envMapColor = vec4( 0.0 );",
	    "",
	    "		#endif",
	    "",
	    "		return PI * envMapColor.rgb * envMapIntensity;",
	    "",
	    "	}",
	    "",
	    "	// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html",
	    "	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {",
	    "",
	    "		//float envMapWidth = pow( 2.0, maxMIPLevelScalar );",
	    "		//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );",
	    "",
	    "		float maxMIPLevelScalar = float( maxMIPLevel );",
	    "		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );",
	    "",
	    "		// clamp to allowable LOD ranges.",
	    "		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );",
	    "",
	    "	}",
	    "",
	    "	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {",
	    "",
	    "		#ifdef ENVMAP_MODE_REFLECTION",
	    "",
	    "			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );",
	    "",
	    "		#else",
	    "",
	    "			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );",
	    "",
	    "		#endif",
	    "",
	    "		#include <normal_flip>",
	    "",
	    "		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );",
	    "",
	    "		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );",
	    "",
	    "		#ifdef ENVMAP_TYPE_CUBE",
	    "",
	    "			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );",
	    "",
	    "			#ifdef TEXTURE_LOD_EXT",
	    "",
	    "				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );",
	    "",
	    "			#else",
	    "",
	    "				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );",
	    "",
	    "			#endif",
	    "",
	    "			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;",
	    "",
	    "		#elif defined( ENVMAP_TYPE_CUBE_UV )",
	    "",
	    "			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );",
	    "			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));",
	    "",
	    "		#elif defined( ENVMAP_TYPE_EQUIREC )",
	    "",
	    "			vec2 sampleUV;",
	    "			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );",
	    "			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;",
	    "",
	    "			#ifdef TEXTURE_LOD_EXT",
	    "",
	    "				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );",
	    "",
	    "			#else",
	    "",
	    "				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );",
	    "",
	    "			#endif",
	    "",
	    "			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;",
	    "",
	    "		#elif defined( ENVMAP_TYPE_SPHERE )",
	    "",
	    "			vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );",
	    "",
	    "			#ifdef TEXTURE_LOD_EXT",
	    "",
	    "				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );",
	    "",
	    "			#else",
	    "",
	    "				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );",
	    "",
	    "			#endif",
	    "",
	    "			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;",
	    "",
	    "		#endif",
	    "",
	    "		return envMapColor.rgb * envMapIntensity;",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var lights_phong_fragment = [
	    "BlinnPhongMaterial material;",
	    "material.diffuseColor = diffuseColor.rgb;",
	    "material.specularColor = specular;",
	    "material.specularShininess = shininess;",
	    "material.specularStrength = specularStrength;",
	    "",
	].join('\n');

	var lights_phong_pars_fragment = [
	    "varying vec3 vViewPosition;",
	    "",
	    "#ifndef FLAT_SHADED",
	    "",
	    "	varying vec3 vNormal;",
	    "",
	    "#endif",
	    "",
	    "",
	    "struct BlinnPhongMaterial {",
	    "",
	    "	vec3	diffuseColor;",
	    "	vec3	specularColor;",
	    "	float	specularShininess;",
	    "	float	specularStrength;",
	    "",
	    "};",
	    "",
	    "void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {",
	    "",
	    "	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );",
	    "",
	    "	vec3 irradiance = dotNL * directLight.color;",
	    "",
	    "	#ifndef PHYSICALLY_CORRECT_LIGHTS",
	    "",
	    "		irradiance *= PI; // punctual light",
	    "",
	    "	#endif",
	    "",
	    "	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );",
	    "	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;",
	    "",
	    "}",
	    "",
	    "void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {",
	    "",
	    "	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );",
	    "",
	    "}",
	    "",
	    "#define RE_Direct				RE_Direct_BlinnPhong",
	    "#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong",
	    "",
	    "#define Material_LightProbeLOD( material )	(0)",
	    "",
	].join('\n');

	var lights_physical_fragment = [
	    "PhysicalMaterial material;",
	    "material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );",
	    "material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );",
	    "#ifdef STANDARD",
	    "	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );",
	    "#else",
	    "	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );",
	    "	material.clearCoat = saturate( clearCoat ); // Burley clearcoat model",
	    "	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );",
	    "#endif",
	    "",
	].join('\n');

	var lights_physical_pars_fragment = [
	    "struct PhysicalMaterial {",
	    "",
	    "	vec3	diffuseColor;",
	    "	float	specularRoughness;",
	    "	vec3	specularColor;",
	    "",
	    "	#ifndef STANDARD",
	    "		float clearCoat;",
	    "		float clearCoatRoughness;",
	    "	#endif",
	    "",
	    "};",
	    "",
	    "#define MAXIMUM_SPECULAR_COEFFICIENT 0.16",
	    "#define DEFAULT_SPECULAR_COEFFICIENT 0.04",
	    "",
	    "// Clear coat directional hemishperical reflectance (this approximation should be improved)",
	    "float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {",
	    "",
	    "	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );",
	    "",
	    "}",
	    "",
	    "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {",
	    "",
	    "	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );",
	    "",
	    "	vec3 irradiance = dotNL * directLight.color;",
	    "",
	    "	#ifndef PHYSICALLY_CORRECT_LIGHTS",
	    "",
	    "		irradiance *= PI; // punctual light",
	    "",
	    "	#endif",
	    "",
	    "	#ifndef STANDARD",
	    "		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );",
	    "	#else",
	    "		float clearCoatDHR = 0.0;",
	    "	#endif",
	    "",
	    "	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );",
	    "	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );",
	    "",
	    "	#ifndef STANDARD",
	    "",
	    "		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );",
	    "",
	    "	#endif",
	    "",
	    "}",
	    "",
	    "void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {",
	    "",
	    "	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );",
	    "",
	    "}",
	    "",
	    "void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {",
	    "",
	    "	#ifndef STANDARD",
	    "		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
	    "		float dotNL = dotNV;",
	    "		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );",
	    "	#else",
	    "		float clearCoatDHR = 0.0;",
	    "	#endif",
	    "",
	    "	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );",
	    "",
	    "	#ifndef STANDARD",
	    "",
	    "		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );",
	    "",
	    "	#endif",
	    "",
	    "}",
	    "",
	    "#define RE_Direct				RE_Direct_Physical",
	    "#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical",
	    "#define RE_IndirectSpecular		RE_IndirectSpecular_Physical",
	    "",
	    "#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )",
	    "#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )",
	    "",
	    "// ref: http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf",
	    "float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {",
	    "",
	    "	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );",
	    "",
	    "}",
	    "",
	].join('\n');

	var lights_template = [
	    "//",
	    "// This is a template that can be used to light a material, it uses pluggable RenderEquations (RE)",
	    "//   for specific lighting scenarios.",
	    "//",
	    "// Instructions for use:",
	    "//  - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined",
	    "//  - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???",
	    "//  - Create a material parameter that is to be passed as the third parameter to your lighting functions.",
	    "//",
	    "// TODO:",
	    "//  - Add area light support.",
	    "//  - Add sphere light support.",
	    "//  - Add diffuse light probe (irradiance cubemap) support.",
	    "//",
	    "",
	    "GeometricContext geometry;",
	    "",
	    "geometry.position = - vViewPosition;",
	    "geometry.normal = normal;",
	    "geometry.viewDir = normalize( vViewPosition );",
	    "",
	    "IncidentLight directLight;",
	    "",
	    "#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )",
	    "",
	    "	PointLight pointLight;",
	    "",
	    "	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",
	    "",
	    "		pointLight = pointLights[ i ];",
	    "",
	    "		getPointDirectLightIrradiance( pointLight, geometry, directLight );",
	    "",
	    "		#ifdef USE_SHADOWMAP",
	    "		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;",
	    "		#endif",
	    "",
	    "		RE_Direct( directLight, geometry, material, reflectedLight );",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	    "#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )",
	    "",
	    "	SpotLight spotLight;",
	    "",
	    "	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {",
	    "",
	    "		spotLight = spotLights[ i ];",
	    "",
	    "		getSpotDirectLightIrradiance( spotLight, geometry, directLight );",
	    "",
	    "		#ifdef USE_SHADOWMAP",
	    "		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;",
	    "		#endif",
	    "",
	    "		RE_Direct( directLight, geometry, material, reflectedLight );",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	    "#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )",
	    "",
	    "	DirectionalLight directionalLight;",
	    "",
	    "	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
	    "",
	    "		directionalLight = directionalLights[ i ];",
	    "",
	    "		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );",
	    "",
	    "		#ifdef USE_SHADOWMAP",
	    "		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;",
	    "		#endif",
	    "",
	    "		RE_Direct( directLight, geometry, material, reflectedLight );",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	    "#if defined( RE_IndirectDiffuse )",
	    "",
	    "	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );",
	    "",
	    "	#ifdef USE_LIGHTMAP",
	    "",
	    "		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;",
	    "",
	    "		#ifndef PHYSICALLY_CORRECT_LIGHTS",
	    "",
	    "			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage",
	    "",
	    "		#endif",
	    "",
	    "		irradiance += lightMapIrradiance;",
	    "",
	    "	#endif",
	    "",
	    "	#if ( NUM_HEMI_LIGHTS > 0 )",
	    "",
	    "		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {",
	    "",
	    "			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );",
	    "",
	    "		}",
	    "",
	    "	#endif",
	    "",
	    "	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )",
	    "",
	    "		// TODO, replace 8 with the real maxMIPLevel",
	    "	 	irradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, 8 );",
	    "",
	    "	#endif",
	    "",
	    "	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );",
	    "",
	    "#endif",
	    "",
	    "#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )",
	    "",
	    "	// TODO, replace 8 with the real maxMIPLevel",
	    "	vec3 radiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), 8 );",
	    "",
	    "	#ifndef STANDARD",
	    "		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );",
	    "	#else",
	    "		vec3 clearCoatRadiance = vec3( 0.0 );",
	    "	#endif",
	    "		",
	    "	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var logdepthbuf_fragment = [
	    "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)",
	    "",
	    "	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;",
	    "",
	    "#endif",
	].join('\n');

	var logdepthbuf_pars_fragment = [
	    "#ifdef USE_LOGDEPTHBUF",
	    "",
	    "	uniform float logDepthBufFC;",
	    "",
	    "	#ifdef USE_LOGDEPTHBUF_EXT",
	    "",
	    "		varying float vFragDepth;",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var logdepthbuf_pars_vertex = [
	    "#ifdef USE_LOGDEPTHBUF",
	    "",
	    "	#ifdef USE_LOGDEPTHBUF_EXT",
	    "",
	    "		varying float vFragDepth;",
	    "",
	    "	#endif",
	    "",
	    "	uniform float logDepthBufFC;",
	    "",
	    "#endif",
	].join('\n');

	var logdepthbuf_vertex = [
	    "#ifdef USE_LOGDEPTHBUF",
	    "",
	    "	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;",
	    "",
	    "	#ifdef USE_LOGDEPTHBUF_EXT",
	    "",
	    "		vFragDepth = 1.0 + gl_Position.w;",
	    "",
	    "	#else",
	    "",
	    "		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var map_fragment = [
	    "#ifdef USE_MAP",
	    "",
	    "	vec4 texelColor = texture2D( map, vUv );",
	    "",
	    "	texelColor = mapTexelToLinear( texelColor );",
	    "	diffuseColor *= texelColor;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var map_pars_fragment = [
	    "#ifdef USE_MAP",
	    "",
	    "	uniform sampler2D map;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var map_particle_fragment = [
	    "#ifdef USE_MAP",
	    "",
	    "	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );",
	    "	diffuseColor *= mapTexelToLinear( mapTexel );",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var map_particle_pars_fragment = [
	    "#ifdef USE_MAP",
	    "",
	    "	uniform vec4 offsetRepeat;",
	    "	uniform sampler2D map;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var metalnessmap_fragment = [
	    "float metalnessFactor = metalness;",
	    "",
	    "#ifdef USE_METALNESSMAP",
	    "",
	    "	vec4 texelMetalness = texture2D( metalnessMap, vUv );",
	    "	metalnessFactor *= texelMetalness.r;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var metalnessmap_pars_fragment = [
	    "#ifdef USE_METALNESSMAP",
	    "",
	    "	uniform sampler2D metalnessMap;",
	    "",
	    "#endif",
	].join('\n');

	var morphnormal_vertex = [
	    "#ifdef USE_MORPHNORMALS",
	    "",
	    "	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
	    "	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
	    "	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
	    "	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var morphtarget_pars_vertex = [
	    "#ifdef USE_MORPHTARGETS",
	    "",
	    "	#ifndef USE_MORPHNORMALS",
	    "",
	    "	uniform float morphTargetInfluences[ 8 ];",
	    "",
	    "	#else",
	    "",
	    "	uniform float morphTargetInfluences[ 4 ];",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	].join('\n');

	var morphtarget_vertex = [
	    "#ifdef USE_MORPHTARGETS",
	    "",
	    "	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
	    "	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
	    "	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
	    "	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",
	    "",
	    "	#ifndef USE_MORPHNORMALS",
	    "",
	    "	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
	    "	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
	    "	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
	    "	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var normal_flip = [
	    "#ifdef DOUBLE_SIDED",
	    "	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );",
	    "#else",
	    "	float flipNormal = 1.0;",
	    "#endif",
	    "",
	].join('\n');

	var normal_fragment = [
	    "#ifdef FLAT_SHADED",
	    "",
	    "	// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...",
	    "",
	    "	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );",
	    "	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );",
	    "	vec3 normal = normalize( cross( fdx, fdy ) );",
	    "",
	    "#else",
	    "",
	    "	vec3 normal = normalize( vNormal ) * flipNormal;",
	    "",
	    "#endif",
	    "",
	    "#ifdef USE_NORMALMAP",
	    "",
	    "	normal = perturbNormal2Arb( -vViewPosition, normal );",
	    "",
	    "#elif defined( USE_BUMPMAP )",
	    "",
	    "	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var normalmap_pars_fragment = [
	    "#ifdef USE_NORMALMAP",
	    "",
	    "	uniform sampler2D normalMap;",
	    "	uniform vec2 normalScale;",
	    "",
	    "	// Per-Pixel Tangent Space Normal Mapping",
	    "	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html",
	    "",
	    "	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",
	    "",
	    "		vec3 q0 = dFdx( eye_pos.xyz );",
	    "		vec3 q1 = dFdy( eye_pos.xyz );",
	    "		vec2 st0 = dFdx( vUv.st );",
	    "		vec2 st1 = dFdy( vUv.st );",
	    "",
	    "		vec3 S = normalize( q0 * st1.t - q1 * st0.t );",
	    "		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
	    "		vec3 N = normalize( surf_norm );",
	    "",
	    "		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;",
	    "		mapN.xy = normalScale * mapN.xy;",
	    "		mat3 tsn = mat3( S, T, N );",
	    "		return normalize( tsn * mapN );",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var packing = [
	    "vec3 packNormalToRGB( const in vec3 normal ) {",
	    "  return normalize( normal ) * 0.5 + 0.5;",
	    "}",
	    "",
	    "vec3 unpackRGBToNormal( const in vec3 rgb ) {",
	    "  return 1.0 - 2.0 * rgb.xyz;",
	    "}",
	    "",
	    "const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)",
	    "const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)",
	    "",
	    "const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );",
	    "const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );",
	    "",
	    "const float ShiftRight8 = 1. / 256.;",
	    "",
	    "vec4 packDepthToRGBA( const in float v ) {",
	    "",
	    "	vec4 r = vec4( fract( v * PackFactors ), v );",
	    "	r.yzw -= r.xyz * ShiftRight8; // tidy overflow",
	    "	return r * PackUpscale;",
	    "",
	    "}",
	    "",
	    "float unpackRGBAToDepth( const in vec4 v ) {",
	    "",
	    "	return dot( v, UnpackFactors );",
	    "",
	    "}",
	    "",
	    "// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions",
	    "",
	    "float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {",
	    "  return ( viewZ + near ) / ( near - far );",
	    "}",
	    "float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {",
	    "  return linearClipZ * ( near - far ) - near;",
	    "}",
	    "",
	    "float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {",
	    "  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );",
	    "}",
	    "float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {",
	    "  return ( near * far ) / ( ( far - near ) * invClipZ - far );",
	    "}",
	    "",
	].join('\n');

	var premultiplied_alpha_fragment = [
	    "#ifdef PREMULTIPLIED_ALPHA",
	    "",
	    "	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.",
	    "	gl_FragColor.rgb *= gl_FragColor.a;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var project_vertex = [
	    "#ifdef USE_SKINNING",
	    "",
	    "	vec4 mvPosition = modelViewMatrix * skinned;",
	    "",
	    "#else",
	    "",
	    "	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );",
	    "",
	    "#endif",
	    "",
	    "gl_Position = projectionMatrix * mvPosition;",
	    "",
	].join('\n');

	var roughnessmap_fragment = [
	    "float roughnessFactor = roughness;",
	    "",
	    "#ifdef USE_ROUGHNESSMAP",
	    "",
	    "	vec4 texelRoughness = texture2D( roughnessMap, vUv );",
	    "	roughnessFactor *= texelRoughness.r;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var roughnessmap_pars_fragment = [
	    "#ifdef USE_ROUGHNESSMAP",
	    "",
	    "	uniform sampler2D roughnessMap;",
	    "",
	    "#endif",
	].join('\n');

	var shadowmap_pars_fragment = [
	    "#ifdef USE_SHADOWMAP",
	    "",
	    "	#if NUM_DIR_LIGHTS > 0",
	    "",
	    "		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];",
	    "		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];",
	    "",
	    "	#endif",
	    "",
	    "	#if NUM_SPOT_LIGHTS > 0",
	    "",
	    "		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];",
	    "		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];",
	    "",
	    "	#endif",
	    "",
	    "	#if NUM_POINT_LIGHTS > 0",
	    "",
	    "		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];",
	    "		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];",
	    "",
	    "	#endif",
	    "",
	    "	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {",
	    "",
	    "		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );",
	    "",
	    "	}",
	    "",
	    "	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {",
	    "",
	    "		const vec2 offset = vec2( 0.0, 1.0 );",
	    "",
	    "		vec2 texelSize = vec2( 1.0 ) / size;",
	    "		vec2 centroidUV = floor( uv * size + 0.5 ) / size;",
	    "",
	    "		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );",
	    "		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );",
	    "		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );",
	    "		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );",
	    "",
	    "		vec2 f = fract( uv * size + 0.5 );",
	    "",
	    "		float a = mix( lb, lt, f.y );",
	    "		float b = mix( rb, rt, f.y );",
	    "		float c = mix( a, b, f.x );",
	    "",
	    "		return c;",
	    "",
	    "	}",
	    "",
	    "	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {",
	    "",
	    "		shadowCoord.xyz /= shadowCoord.w;",
	    "		shadowCoord.z += shadowBias;",
	    "",
	    "		// if ( something && something ) breaks ATI OpenGL shader compiler",
	    "		// if ( all( something, something ) ) using this instead",
	    "",
	    "		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
	    "		bool inFrustum = all( inFrustumVec );",
	    "",
	    "		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",
	    "",
	    "		bool frustumTest = all( frustumTestVec );",
	    "",
	    "		if ( frustumTest ) {",
	    "",
	    "		#if defined( SHADOWMAP_TYPE_PCF )",
	    "",
	    "			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;",
	    "",
	    "			float dx0 = - texelSize.x * shadowRadius;",
	    "			float dy0 = - texelSize.y * shadowRadius;",
	    "			float dx1 = + texelSize.x * shadowRadius;",
	    "			float dy1 = + texelSize.y * shadowRadius;",
	    "",
	    "			return (",
	    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +",
	    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +",
	    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +",
	    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +",
	    "				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +",
	    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +",
	    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +",
	    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +",
	    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )",
	    "			) * ( 1.0 / 9.0 );",
	    "",
	    "		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",
	    "",
	    "			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;",
	    "",
	    "			float dx0 = - texelSize.x * shadowRadius;",
	    "			float dy0 = - texelSize.y * shadowRadius;",
	    "			float dx1 = + texelSize.x * shadowRadius;",
	    "			float dy1 = + texelSize.y * shadowRadius;",
	    "",
	    "			return (",
	    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +",
	    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +",
	    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +",
	    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +",
	    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +",
	    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +",
	    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +",
	    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +",
	    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )",
	    "			) * ( 1.0 / 9.0 );",
	    "",
	    "		#else // no percentage-closer filtering:",
	    "",
	    "			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );",
	    "",
	    "		#endif",
	    "",
	    "		}",
	    "",
	    "		return 1.0;",
	    "",
	    "	}",
	    "",
	    "	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D",
	    "	// vector suitable for 2D texture mapping. This code uses the following layout for the",
	    "	// 2D texture:",
	    "	//",
	    "	// xzXZ",
	    "	//  y Y",
	    "	//",
	    "	// Y - Positive y direction",
	    "	// y - Negative y direction",
	    "	// X - Positive x direction",
	    "	// x - Negative x direction",
	    "	// Z - Positive z direction",
	    "	// z - Negative z direction",
	    "	//",
	    "	// Source and test bed:",
	    "	// https://gist.github.com/tschw/da10c43c467ce8afd0c4",
	    "",
	    "	vec2 cubeToUV( vec3 v, float texelSizeY ) {",
	    "",
	    "		// Number of texels to avoid at the edge of each square",
	    "",
	    "		vec3 absV = abs( v );",
	    "",
	    "		// Intersect unit cube",
	    "",
	    "		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );",
	    "		absV *= scaleToCube;",
	    "",
	    "		// Apply scale to avoid seams",
	    "",
	    "		// two texels less per square (one texel will do for NEAREST)",
	    "		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );",
	    "",
	    "		// Unwrap",
	    "",
	    "		// space: -1 ... 1 range for each square",
	    "		//",
	    "		// #X##		dim    := ( 4 , 2 )",
	    "		//  # #		center := ( 1 , 1 )",
	    "",
	    "		vec2 planar = v.xy;",
	    "",
	    "		float almostATexel = 1.5 * texelSizeY;",
	    "		float almostOne = 1.0 - almostATexel;",
	    "",
	    "		if ( absV.z >= almostOne ) {",
	    "",
	    "			if ( v.z > 0.0 )",
	    "				planar.x = 4.0 - v.x;",
	    "",
	    "		} else if ( absV.x >= almostOne ) {",
	    "",
	    "			float signX = sign( v.x );",
	    "			planar.x = v.z * signX + 2.0 * signX;",
	    "",
	    "		} else if ( absV.y >= almostOne ) {",
	    "",
	    "			float signY = sign( v.y );",
	    "			planar.x = v.x + 2.0 * signY + 2.0;",
	    "			planar.y = v.z * signY - 2.0;",
	    "",
	    "		}",
	    "",
	    "		// Transform to UV space",
	    "",
	    "		// scale := 0.5 / dim",
	    "		// translate := ( center + 0.5 ) / dim",
	    "		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );",
	    "",
	    "	}",
	    "",
	    "	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {",
	    "",
	    "		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );",
	    "",
	    "		// for point lights, the uniform @vShadowCoord is re-purposed to hold",
	    "		// the distance from the light to the world-space position of the fragment.",
	    "		vec3 lightToPosition = shadowCoord.xyz;",
	    "",
	    "		// bd3D = base direction 3D",
	    "		vec3 bd3D = normalize( lightToPosition );",
	    "		// dp = distance from light to fragment position",
	    "		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;",
	    "",
	    "		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )",
	    "",
	    "			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;",
	    "",
	    "			return (",
	    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +",
	    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +",
	    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +",
	    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +",
	    "				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +",
	    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +",
	    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +",
	    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +",
	    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )",
	    "			) * ( 1.0 / 9.0 );",
	    "",
	    "		#else // no percentage-closer filtering",
	    "",
	    "			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );",
	    "",
	    "		#endif",
	    "",
	    "	}",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var shadowmap_pars_vertex = [
	    "#ifdef USE_SHADOWMAP",
	    "",
	    "	#if NUM_DIR_LIGHTS > 0",
	    "",
	    "		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];",
	    "		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];",
	    "",
	    "	#endif",
	    "",
	    "	#if NUM_SPOT_LIGHTS > 0",
	    "",
	    "		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];",
	    "		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];",
	    "",
	    "	#endif",
	    "",
	    "	#if NUM_POINT_LIGHTS > 0",
	    "",
	    "		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];",
	    "		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var shadowmap_vertex = [
	    "#ifdef USE_SHADOWMAP",
	    "",
	    "	#if NUM_DIR_LIGHTS > 0",
	    "",
	    "	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
	    "",
	    "		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;",
	    "",
	    "	}",
	    "",
	    "	#endif",
	    "",
	    "	#if NUM_SPOT_LIGHTS > 0",
	    "",
	    "	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {",
	    "",
	    "		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;",
	    "",
	    "	}",
	    "",
	    "	#endif",
	    "",
	    "	#if NUM_POINT_LIGHTS > 0",
	    "",
	    "	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",
	    "",
	    "		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;",
	    "",
	    "	}",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var shadowmask_pars_fragment = [
	    "float getShadowMask() {",
	    "",
	    "	float shadow = 1.0;",
	    "",
	    "	#ifdef USE_SHADOWMAP",
	    "",
	    "	#if NUM_DIR_LIGHTS > 0",
	    "",
	    "	DirectionalLight directionalLight;",
	    "",
	    "	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
	    "",
	    "		directionalLight = directionalLights[ i ];",
	    "		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;",
	    "",
	    "	}",
	    "",
	    "	#endif",
	    "",
	    "	#if NUM_SPOT_LIGHTS > 0",
	    "",
	    "	SpotLight spotLight;",
	    "",
	    "	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {",
	    "",
	    "		spotLight = spotLights[ i ];",
	    "		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;",
	    "",
	    "	}",
	    "",
	    "	#endif",
	    "",
	    "	#if NUM_POINT_LIGHTS > 0",
	    "",
	    "	PointLight pointLight;",
	    "",
	    "	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",
	    "",
	    "		pointLight = pointLights[ i ];",
	    "		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;",
	    "",
	    "	}",
	    "",
	    "	#endif",
	    "",
	    "	#endif",
	    "",
	    "	return shadow;",
	    "",
	    "}",
	    "",
	].join('\n');

	var skinbase_vertex = [
	    "#ifdef USE_SKINNING",
	    "",
	    "	mat4 boneMatX = getBoneMatrix( skinIndex.x );",
	    "	mat4 boneMatY = getBoneMatrix( skinIndex.y );",
	    "	mat4 boneMatZ = getBoneMatrix( skinIndex.z );",
	    "	mat4 boneMatW = getBoneMatrix( skinIndex.w );",
	    "",
	    "#endif",
	].join('\n');

	var skinning_pars_vertex = [
	    "#ifdef USE_SKINNING",
	    "",
	    "	uniform mat4 bindMatrix;",
	    "	uniform mat4 bindMatrixInverse;",
	    "",
	    "	#ifdef BONE_TEXTURE",
	    "",
	    "		uniform sampler2D boneTexture;",
	    "		uniform int boneTextureWidth;",
	    "		uniform int boneTextureHeight;",
	    "",
	    "		mat4 getBoneMatrix( const in float i ) {",
	    "",
	    "			float j = i * 4.0;",
	    "			float x = mod( j, float( boneTextureWidth ) );",
	    "			float y = floor( j / float( boneTextureWidth ) );",
	    "",
	    "			float dx = 1.0 / float( boneTextureWidth );",
	    "			float dy = 1.0 / float( boneTextureHeight );",
	    "",
	    "			y = dy * ( y + 0.5 );",
	    "",
	    "			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
	    "			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
	    "			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
	    "			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",
	    "",
	    "			mat4 bone = mat4( v1, v2, v3, v4 );",
	    "",
	    "			return bone;",
	    "",
	    "		}",
	    "",
	    "	#else",
	    "",
	    "		uniform mat4 boneMatrices[ MAX_BONES ];",
	    "",
	    "		mat4 getBoneMatrix( const in float i ) {",
	    "",
	    "			mat4 bone = boneMatrices[ int(i) ];",
	    "			return bone;",
	    "",
	    "		}",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var skinning_vertex = [
	    "#ifdef USE_SKINNING",
	    "",
	    "	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );",
	    "",
	    "	vec4 skinned = vec4( 0.0 );",
	    "	skinned += boneMatX * skinVertex * skinWeight.x;",
	    "	skinned += boneMatY * skinVertex * skinWeight.y;",
	    "	skinned += boneMatZ * skinVertex * skinWeight.z;",
	    "	skinned += boneMatW * skinVertex * skinWeight.w;",
	    "	skinned  = bindMatrixInverse * skinned;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var skinnormal_vertex = [
	    "#ifdef USE_SKINNING",
	    "",
	    "	mat4 skinMatrix = mat4( 0.0 );",
	    "	skinMatrix += skinWeight.x * boneMatX;",
	    "	skinMatrix += skinWeight.y * boneMatY;",
	    "	skinMatrix += skinWeight.z * boneMatZ;",
	    "	skinMatrix += skinWeight.w * boneMatW;",
	    "	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;",
	    "",
	    "	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var specularmap_fragment = [
	    "float specularStrength;",
	    "",
	    "#ifdef USE_SPECULARMAP",
	    "",
	    "	vec4 texelSpecular = texture2D( specularMap, vUv );",
	    "	specularStrength = texelSpecular.r;",
	    "",
	    "#else",
	    "",
	    "	specularStrength = 1.0;",
	    "",
	    "#endif",
	].join('\n');

	var specularmap_pars_fragment = [
	    "#ifdef USE_SPECULARMAP",
	    "",
	    "	uniform sampler2D specularMap;",
	    "",
	    "#endif",
	].join('\n');

	var tonemapping_fragment = [
	    "#if defined( TONE_MAPPING )",
	    "",
	    "  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var tonemapping_pars_fragment = [
	    "#define saturate(a) clamp( a, 0.0, 1.0 )",
	    "",
	    "uniform float toneMappingExposure;",
	    "uniform float toneMappingWhitePoint;",
	    "",
	    "// exposure only",
	    "vec3 LinearToneMapping( vec3 color ) {",
	    "",
	    "  return toneMappingExposure * color;",
	    "",
	    "}",
	    "",
	    "// source: https://www.cs.utah.edu/~reinhard/cdrom/",
	    "vec3 ReinhardToneMapping( vec3 color ) {",
	    "",
	    "  color *= toneMappingExposure;",
	    "  return saturate( color / ( vec3( 1.0 ) + color ) );",
	    "",
	    "}",
	    "",
	    "// source: http://filmicgames.com/archives/75",
	    "#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )",
	    "vec3 Uncharted2ToneMapping( vec3 color ) {",
	    "",
	    "  // John Hable's filmic operator from Uncharted 2 video game",
	    "  color *= toneMappingExposure;",
	    "  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );",
	    "",
	    "}",
	    "",
	    "// source: http://filmicgames.com/archives/75",
	    "vec3 OptimizedCineonToneMapping( vec3 color ) {",
	    "",
	    "  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson",
	    "  color *= toneMappingExposure;",
	    "  color = max( vec3( 0.0 ), color - 0.004 );",
	    "  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );",
	    "",
	    "}",
	    "",
	].join('\n');

	var uv_pars_fragment = [
	    "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )",
	    "",
	    "	varying vec2 vUv;",
	    "",
	    "#endif",
	].join('\n');

	var uv_pars_vertex = [
	    "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )",
	    "",
	    "	varying vec2 vUv;",
	    "	uniform vec4 offsetRepeat;",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var uv_vertex = [
	    "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )",
	    "",
	    "	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",
	    "",
	    "#endif",
	].join('\n');

	var uv2_pars_fragment = [
	    "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )",
	    "",
	    "	varying vec2 vUv2;",
	    "",
	    "#endif",
	].join('\n');

	var uv2_pars_vertex = [
	    "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )",
	    "",
	    "	attribute vec2 uv2;",
	    "	varying vec2 vUv2;",
	    "",
	    "#endif",
	].join('\n');

	var uv2_vertex = [
	    "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )",
	    "",
	    "	vUv2 = uv2;",
	    "",
	    "#endif",
	].join('\n');

	var worldpos_vertex = [
	    "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",
	    "",
	    "	#ifdef USE_SKINNING",
	    "",
	    "		vec4 worldPosition = modelMatrix * skinned;",
	    "",
	    "	#else",
	    "",
	    "		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );",
	    "",
	    "	#endif",
	    "",
	    "#endif",
	    "",
	].join('\n');

	var cube_frag = [
	    "uniform samplerCube tCube;",
	    "uniform float tFlip;",
	    "uniform float opacity;",
	    "",
	    "varying vec3 vWorldPosition;",
	    "",
	    "#include <common>",
	    "",
	    "void main() {",
	    "",
	    "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
	    "	gl_FragColor.a *= opacity;",
	    "",
	    "}",
	    "",
	].join('\n');

	var cube_vert = [
	    "varying vec3 vWorldPosition;",
	    "",
	    "#include <common>",
	    "",
	    "void main() {",
	    "",
	    "	vWorldPosition = transformDirection( position, modelMatrix );",
	    "",
	    "	#include <begin_vertex>",
	    "	#include <project_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var depth_frag = [
	    "#if DEPTH_PACKING == 3200",
	    "",
	    "	uniform float opacity;",
	    "",
	    "#endif",
	    "",
	    "#include <common>",
	    "#include <packing>",
	    "#include <uv_pars_fragment>",
	    "#include <map_pars_fragment>",
	    "#include <alphamap_pars_fragment>",
	    "#include <logdepthbuf_pars_fragment>",
	    "#include <clipping_planes_pars_fragment>",
	    "",
	    "void main() {",
	    "",
	    "	#include <clipping_planes_fragment>",
	    "",
	    "	vec4 diffuseColor = vec4( 1.0 );",
	    "",
	    "	#if DEPTH_PACKING == 3200",
	    "",
	    "		diffuseColor.a = opacity;",
	    "",
	    "	#endif",
	    "",
	    "	#include <map_fragment>",
	    "	#include <alphamap_fragment>",
	    "	#include <alphatest_fragment>",
	    "",
	    "	#include <logdepthbuf_fragment>",
	    "",
	    "	#if DEPTH_PACKING == 3200",
	    "",
	    "		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );",
	    "",
	    "	#elif DEPTH_PACKING == 3201",
	    "",
	    "		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );",
	    "",
	    "	#endif",
	    "",
	    "}",
	    "",
	].join('\n');

	var depth_vert = [
	    "#include <common>",
	    "#include <uv_pars_vertex>",
	    "#include <displacementmap_pars_vertex>",
	    "#include <morphtarget_pars_vertex>",
	    "#include <skinning_pars_vertex>",
	    "#include <logdepthbuf_pars_vertex>",
	    "#include <clipping_planes_pars_vertex>",
	    "",
	    "void main() {",
	    "",
	    "	#include <uv_vertex>",
	    "",
	    "	#include <skinbase_vertex>",
	    "",
	    "	#include <begin_vertex>",
	    "	#include <displacementmap_vertex>",
	    "	#include <morphtarget_vertex>",
	    "	#include <skinning_vertex>",
	    "	#include <project_vertex>",
	    "	#include <logdepthbuf_vertex>",
	    "	#include <clipping_planes_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var distanceRGBA_frag = [
	    "uniform vec3 lightPos;",
	    "varying vec4 vWorldPosition;",
	    "",
	    "#include <common>",
	    "#include <packing>",
	    "#include <clipping_planes_pars_fragment>",
	    "",
	    "void main () {",
	    "",
	    "	#include <clipping_planes_fragment>",
	    "",
	    "	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );",
	    "",
	    "}",
	    "",
	].join('\n');

	var distanceRGBA_vert = [
	    "varying vec4 vWorldPosition;",
	    "",
	    "#include <common>",
	    "#include <morphtarget_pars_vertex>",
	    "#include <skinning_pars_vertex>",
	    "#include <clipping_planes_pars_vertex>",
	    "",
	    "void main() {",
	    "",
	    "	#include <skinbase_vertex>",
	    "	#include <begin_vertex>",
	    "	#include <morphtarget_vertex>",
	    "	#include <skinning_vertex>",
	    "	#include <project_vertex>",
	    "	#include <worldpos_vertex>",
	    "	#include <clipping_planes_vertex>",
	    "",
	    "	vWorldPosition = worldPosition;",
	    "",
	    "}",
	    "",
	].join('\n');

	var equirect_frag = [
	    "uniform sampler2D tEquirect;",
	    "uniform float tFlip;",
	    "",
	    "varying vec3 vWorldPosition;",
	    "",
	    "#include <common>",
	    "",
	    "void main() {",
	    "",
	    "	// 	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
	    "	vec3 direction = normalize( vWorldPosition );",
	    "	vec2 sampleUV;",
	    "	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
	    "	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
	    "	gl_FragColor = texture2D( tEquirect, sampleUV );",
	    "",
	    "}",
	    "",
	].join('\n');

	var equirect_vert = [
	    "varying vec3 vWorldPosition;",
	    "",
	    "#include <common>",
	    "",
	    "void main() {",
	    "",
	    "	vWorldPosition = transformDirection( position, modelMatrix );",
	    "",
	    "	#include <begin_vertex>",
	    "	#include <project_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var linedashed_frag = [
	    "uniform vec3 diffuse;",
	    "uniform float opacity;",
	    "",
	    "uniform float dashSize;",
	    "uniform float totalSize;",
	    "",
	    "varying float vLineDistance;",
	    "",
	    "#include <common>",
	    "#include <color_pars_fragment>",
	    "#include <fog_pars_fragment>",
	    "#include <logdepthbuf_pars_fragment>",
	    "#include <clipping_planes_pars_fragment>",
	    "",
	    "void main() {",
	    "",
	    "	#include <clipping_planes_fragment>",
	    "",
	    "	if ( mod( vLineDistance, totalSize ) > dashSize ) {",
	    "",
	    "		discard;",
	    "",
	    "	}",
	    "",
	    "	vec3 outgoingLight = vec3( 0.0 );",
	    "	vec4 diffuseColor = vec4( diffuse, opacity );",
	    "",
	    "	#include <logdepthbuf_fragment>",
	    "	#include <color_fragment>",
	    "",
	    "	outgoingLight = diffuseColor.rgb; // simple shader",
	    "",
	    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	    "",
	    "	#include <premultiplied_alpha_fragment>",
	    "	#include <tonemapping_fragment>",
	    "	#include <encodings_fragment>",
	    "	#include <fog_fragment>",
	    "",
	    "}",
	    "",
	].join('\n');

	var linedashed_vert = [
	    "uniform float scale;",
	    "attribute float lineDistance;",
	    "",
	    "varying float vLineDistance;",
	    "",
	    "#include <common>",
	    "#include <color_pars_vertex>",
	    "#include <logdepthbuf_pars_vertex>",
	    "#include <clipping_planes_pars_vertex>",
	    "",
	    "void main() {",
	    "",
	    "	#include <color_vertex>",
	    "",
	    "	vLineDistance = scale * lineDistance;",
	    "",
	    "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	    "	gl_Position = projectionMatrix * mvPosition;",
	    "",
	    "	#include <logdepthbuf_vertex>",
	    "	#include <clipping_planes_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var meshbasic_frag = [
	    "uniform vec3 diffuse;",
	    "uniform float opacity;",
	    "",
	    "#ifndef FLAT_SHADED",
	    "",
	    "	varying vec3 vNormal;",
	    "",
	    "#endif",
	    "",
	    "#include <common>",
	    "#include <color_pars_fragment>",
	    "#include <uv_pars_fragment>",
	    "#include <uv2_pars_fragment>",
	    "#include <map_pars_fragment>",
	    "#include <alphamap_pars_fragment>",
	    "#include <aomap_pars_fragment>",
	    "#include <envmap_pars_fragment>",
	    "#include <fog_pars_fragment>",
	    "#include <specularmap_pars_fragment>",
	    "#include <logdepthbuf_pars_fragment>",
	    "#include <clipping_planes_pars_fragment>",
	    "",
	    "void main() {",
	    "",
	    "	#include <clipping_planes_fragment>",
	    "",
	    "	vec4 diffuseColor = vec4( diffuse, opacity );",
	    "",
	    "	#include <logdepthbuf_fragment>",
	    "	#include <map_fragment>",
	    "	#include <color_fragment>",
	    "	#include <alphamap_fragment>",
	    "	#include <alphatest_fragment>",
	    "	#include <specularmap_fragment>",
	    "",
	    "	ReflectedLight reflectedLight;",
	    "	reflectedLight.directDiffuse = vec3( 0.0 );",
	    "	reflectedLight.directSpecular = vec3( 0.0 );",
	    "	reflectedLight.indirectDiffuse = diffuseColor.rgb;",
	    "	reflectedLight.indirectSpecular = vec3( 0.0 );",
	    "",
	    "	#include <aomap_fragment>",
	    "",
	    "	vec3 outgoingLight = reflectedLight.indirectDiffuse;",
	    "",
	    "	#include <normal_flip>",
	    "	#include <envmap_fragment>",
	    "",
	    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	    "",
	    "	#include <premultiplied_alpha_fragment>",
	    "	#include <tonemapping_fragment>",
	    "	#include <encodings_fragment>",
	    "	#include <fog_fragment>",
	    "",
	    "}",
	    "",
	].join('\n');

	var meshbasic_vert = [
	    "#include <common>",
	    "#include <uv_pars_vertex>",
	    "#include <uv2_pars_vertex>",
	    "#include <envmap_pars_vertex>",
	    "#include <color_pars_vertex>",
	    "#include <morphtarget_pars_vertex>",
	    "#include <skinning_pars_vertex>",
	    "#include <logdepthbuf_pars_vertex>",
	    "#include <clipping_planes_pars_vertex>",
	    "",
	    "void main() {",
	    "",
	    "	#include <uv_vertex>",
	    "	#include <uv2_vertex>",
	    "	#include <color_vertex>",
	    "	#include <skinbase_vertex>",
	    "",
	    "	#ifdef USE_ENVMAP",
	    "",
	    "	#include <beginnormal_vertex>",
	    "	#include <morphnormal_vertex>",
	    "	#include <skinnormal_vertex>",
	    "	#include <defaultnormal_vertex>",
	    "",
	    "	#endif",
	    "",
	    "	#include <begin_vertex>",
	    "	#include <morphtarget_vertex>",
	    "	#include <skinning_vertex>",
	    "	#include <project_vertex>",
	    "	#include <logdepthbuf_vertex>",
	    "",
	    "	#include <worldpos_vertex>",
	    "	#include <clipping_planes_vertex>",
	    "	#include <envmap_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var meshlambert_frag = [
	    "uniform vec3 diffuse;",
	    "uniform vec3 emissive;",
	    "uniform float opacity;",
	    "",
	    "varying vec3 vLightFront;",
	    "",
	    "#ifdef DOUBLE_SIDED",
	    "",
	    "	varying vec3 vLightBack;",
	    "",
	    "#endif",
	    "",
	    "#include <common>",
	    "#include <packing>",
	    "#include <color_pars_fragment>",
	    "#include <uv_pars_fragment>",
	    "#include <uv2_pars_fragment>",
	    "#include <map_pars_fragment>",
	    "#include <alphamap_pars_fragment>",
	    "#include <aomap_pars_fragment>",
	    "#include <lightmap_pars_fragment>",
	    "#include <emissivemap_pars_fragment>",
	    "#include <envmap_pars_fragment>",
	    "#include <bsdfs>",
	    "#include <lights_pars>",
	    "#include <fog_pars_fragment>",
	    "#include <shadowmap_pars_fragment>",
	    "#include <shadowmask_pars_fragment>",
	    "#include <specularmap_pars_fragment>",
	    "#include <logdepthbuf_pars_fragment>",
	    "#include <clipping_planes_pars_fragment>",
	    "",
	    "void main() {",
	    "",
	    "	#include <clipping_planes_fragment>",
	    "",
	    "	vec4 diffuseColor = vec4( diffuse, opacity );",
	    "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
	    "	vec3 totalEmissiveRadiance = emissive;",
	    "",
	    "	#include <logdepthbuf_fragment>",
	    "	#include <map_fragment>",
	    "	#include <color_fragment>",
	    "	#include <alphamap_fragment>",
	    "	#include <alphatest_fragment>",
	    "	#include <specularmap_fragment>",
	    "	#include <emissivemap_fragment>",
	    "",
	    "	// accumulation",
	    "	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );",
	    "",
	    "	#include <lightmap_fragment>",
	    "",
	    "	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );",
	    "",
	    "	#ifdef DOUBLE_SIDED",
	    "",
	    "		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;",
	    "",
	    "	#else",
	    "",
	    "		reflectedLight.directDiffuse = vLightFront;",
	    "",
	    "	#endif",
	    "",
	    "	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();",
	    "",
	    "	// modulation",
	    "	#include <aomap_fragment>",
	    "",
	    "	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;",
	    "",
	    "	#include <normal_flip>",
	    "	#include <envmap_fragment>",
	    "",
	    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	    "",
	    "	#include <premultiplied_alpha_fragment>",
	    "	#include <tonemapping_fragment>",
	    "	#include <encodings_fragment>",
	    "	#include <fog_fragment>",
	    "",
	    "}",
	    "",
	].join('\n');

	var meshlambert_vert = [
	    "#define LAMBERT",
	    "",
	    "varying vec3 vLightFront;",
	    "",
	    "#ifdef DOUBLE_SIDED",
	    "",
	    "	varying vec3 vLightBack;",
	    "",
	    "#endif",
	    "",
	    "#include <common>",
	    "#include <uv_pars_vertex>",
	    "#include <uv2_pars_vertex>",
	    "#include <envmap_pars_vertex>",
	    "#include <bsdfs>",
	    "#include <lights_pars>",
	    "#include <color_pars_vertex>",
	    "#include <morphtarget_pars_vertex>",
	    "#include <skinning_pars_vertex>",
	    "#include <shadowmap_pars_vertex>",
	    "#include <logdepthbuf_pars_vertex>",
	    "#include <clipping_planes_pars_vertex>",
	    "",
	    "void main() {",
	    "",
	    "	#include <uv_vertex>",
	    "	#include <uv2_vertex>",
	    "	#include <color_vertex>",
	    "",
	    "	#include <beginnormal_vertex>",
	    "	#include <morphnormal_vertex>",
	    "	#include <skinbase_vertex>",
	    "	#include <skinnormal_vertex>",
	    "	#include <defaultnormal_vertex>",
	    "",
	    "	#include <begin_vertex>",
	    "	#include <morphtarget_vertex>",
	    "	#include <skinning_vertex>",
	    "	#include <project_vertex>",
	    "	#include <logdepthbuf_vertex>",
	    "	#include <clipping_planes_vertex>",
	    "",
	    "	#include <worldpos_vertex>",
	    "	#include <envmap_vertex>",
	    "	#include <lights_lambert_vertex>",
	    "	#include <shadowmap_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var meshphong_frag = [
	    "#define PHONG",
	    "",
	    "uniform vec3 diffuse;",
	    "uniform vec3 emissive;",
	    "uniform vec3 specular;",
	    "uniform float shininess;",
	    "uniform float opacity;",
	    "",
	    "#include <common>",
	    "#include <packing>",
	    "#include <color_pars_fragment>",
	    "#include <uv_pars_fragment>",
	    "#include <uv2_pars_fragment>",
	    "#include <map_pars_fragment>",
	    "#include <alphamap_pars_fragment>",
	    "#include <aomap_pars_fragment>",
	    "#include <lightmap_pars_fragment>",
	    "#include <emissivemap_pars_fragment>",
	    "#include <envmap_pars_fragment>",
	    "#include <fog_pars_fragment>",
	    "#include <bsdfs>",
	    "#include <lights_pars>",
	    "#include <lights_phong_pars_fragment>",
	    "#include <shadowmap_pars_fragment>",
	    "#include <bumpmap_pars_fragment>",
	    "#include <normalmap_pars_fragment>",
	    "#include <specularmap_pars_fragment>",
	    "#include <logdepthbuf_pars_fragment>",
	    "#include <clipping_planes_pars_fragment>",
	    "",
	    "void main() {",
	    "",
	    "	#include <clipping_planes_fragment>",
	    "",
	    "	vec4 diffuseColor = vec4( diffuse, opacity );",
	    "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
	    "	vec3 totalEmissiveRadiance = emissive;",
	    "",
	    "	#include <logdepthbuf_fragment>",
	    "	#include <map_fragment>",
	    "	#include <color_fragment>",
	    "	#include <alphamap_fragment>",
	    "	#include <alphatest_fragment>",
	    "	#include <specularmap_fragment>",
	    "	#include <normal_flip>",
	    "	#include <normal_fragment>",
	    "	#include <emissivemap_fragment>",
	    "",
	    "	// accumulation",
	    "	#include <lights_phong_fragment>",
	    "	#include <lights_template>",
	    "",
	    "	// modulation",
	    "	#include <aomap_fragment>",
	    "",
	    "	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
	    "",
	    "	#include <envmap_fragment>",
	    "",
	    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	    "",
	    "	#include <premultiplied_alpha_fragment>",
	    "	#include <tonemapping_fragment>",
	    "	#include <encodings_fragment>",
	    "	#include <fog_fragment>",
	    "",
	    "}",
	    "",
	].join('\n');

	var meshphong_vert = [
	    "#define PHONG",
	    "",
	    "varying vec3 vViewPosition;",
	    "",
	    "#ifndef FLAT_SHADED",
	    "",
	    "	varying vec3 vNormal;",
	    "",
	    "#endif",
	    "",
	    "#include <common>",
	    "#include <uv_pars_vertex>",
	    "#include <uv2_pars_vertex>",
	    "#include <displacementmap_pars_vertex>",
	    "#include <envmap_pars_vertex>",
	    "#include <color_pars_vertex>",
	    "#include <morphtarget_pars_vertex>",
	    "#include <skinning_pars_vertex>",
	    "#include <shadowmap_pars_vertex>",
	    "#include <logdepthbuf_pars_vertex>",
	    "#include <clipping_planes_pars_vertex>",
	    "",
	    "void main() {",
	    "",
	    "	#include <uv_vertex>",
	    "	#include <uv2_vertex>",
	    "	#include <color_vertex>",
	    "",
	    "	#include <beginnormal_vertex>",
	    "	#include <morphnormal_vertex>",
	    "	#include <skinbase_vertex>",
	    "	#include <skinnormal_vertex>",
	    "	#include <defaultnormal_vertex>",
	    "",
	    "#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED",
	    "",
	    "	vNormal = normalize( transformedNormal );",
	    "",
	    "#endif",
	    "",
	    "	#include <begin_vertex>",
	    "	#include <displacementmap_vertex>",
	    "	#include <morphtarget_vertex>",
	    "	#include <skinning_vertex>",
	    "	#include <project_vertex>",
	    "	#include <logdepthbuf_vertex>",
	    "	#include <clipping_planes_vertex>",
	    "",
	    "	vViewPosition = - mvPosition.xyz;",
	    "",
	    "	#include <worldpos_vertex>",
	    "	#include <envmap_vertex>",
	    "	#include <shadowmap_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var meshphysical_frag = [
	    "#define PHYSICAL",
	    "",
	    "uniform vec3 diffuse;",
	    "uniform vec3 emissive;",
	    "uniform float roughness;",
	    "uniform float metalness;",
	    "uniform float opacity;",
	    "",
	    "#ifndef STANDARD",
	    "	uniform float clearCoat;",
	    "	uniform float clearCoatRoughness;",
	    "#endif",
	    "",
	    "uniform float envMapIntensity; // temporary",
	    "",
	    "varying vec3 vViewPosition;",
	    "",
	    "#ifndef FLAT_SHADED",
	    "",
	    "	varying vec3 vNormal;",
	    "",
	    "#endif",
	    "",
	    "#include <common>",
	    "#include <packing>",
	    "#include <color_pars_fragment>",
	    "#include <uv_pars_fragment>",
	    "#include <uv2_pars_fragment>",
	    "#include <map_pars_fragment>",
	    "#include <alphamap_pars_fragment>",
	    "#include <aomap_pars_fragment>",
	    "#include <lightmap_pars_fragment>",
	    "#include <emissivemap_pars_fragment>",
	    "#include <envmap_pars_fragment>",
	    "#include <fog_pars_fragment>",
	    "#include <bsdfs>",
	    "#include <cube_uv_reflection_fragment>",
	    "#include <lights_pars>",
	    "#include <lights_physical_pars_fragment>",
	    "#include <shadowmap_pars_fragment>",
	    "#include <bumpmap_pars_fragment>",
	    "#include <normalmap_pars_fragment>",
	    "#include <roughnessmap_pars_fragment>",
	    "#include <metalnessmap_pars_fragment>",
	    "#include <logdepthbuf_pars_fragment>",
	    "#include <clipping_planes_pars_fragment>",
	    "",
	    "void main() {",
	    "",
	    "	#include <clipping_planes_fragment>",
	    "",
	    "	vec4 diffuseColor = vec4( diffuse, opacity );",
	    "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
	    "	vec3 totalEmissiveRadiance = emissive;",
	    "",
	    "	#include <logdepthbuf_fragment>",
	    "	#include <map_fragment>",
	    "	#include <color_fragment>",
	    "	#include <alphamap_fragment>",
	    "	#include <alphatest_fragment>",
	    "	#include <specularmap_fragment>",
	    "	#include <roughnessmap_fragment>",
	    "	#include <metalnessmap_fragment>",
	    "	#include <normal_flip>",
	    "	#include <normal_fragment>",
	    "	#include <emissivemap_fragment>",
	    "",
	    "	// accumulation",
	    "	#include <lights_physical_fragment>",
	    "	#include <lights_template>",
	    "",
	    "	// modulation",
	    "	#include <aomap_fragment>",
	    "",
	    "	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
	    "",
	    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	    "",
	    "	#include <premultiplied_alpha_fragment>",
	    "	#include <tonemapping_fragment>",
	    "	#include <encodings_fragment>",
	    "	#include <fog_fragment>",
	    "",
	    "}",
	    "",
	].join('\n');

	var meshphysical_vert = [
	    "#define PHYSICAL",
	    "",
	    "varying vec3 vViewPosition;",
	    "",
	    "#ifndef FLAT_SHADED",
	    "",
	    "	varying vec3 vNormal;",
	    "",
	    "#endif",
	    "",
	    "#include <common>",
	    "#include <uv_pars_vertex>",
	    "#include <uv2_pars_vertex>",
	    "#include <displacementmap_pars_vertex>",
	    "#include <color_pars_vertex>",
	    "#include <morphtarget_pars_vertex>",
	    "#include <skinning_pars_vertex>",
	    "#include <shadowmap_pars_vertex>",
	    "#include <specularmap_pars_fragment>",
	    "#include <logdepthbuf_pars_vertex>",
	    "#include <clipping_planes_pars_vertex>",
	    "",
	    "void main() {",
	    "",
	    "	#include <uv_vertex>",
	    "	#include <uv2_vertex>",
	    "	#include <color_vertex>",
	    "",
	    "	#include <beginnormal_vertex>",
	    "	#include <morphnormal_vertex>",
	    "	#include <skinbase_vertex>",
	    "	#include <skinnormal_vertex>",
	    "	#include <defaultnormal_vertex>",
	    "",
	    "#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED",
	    "",
	    "	vNormal = normalize( transformedNormal );",
	    "",
	    "#endif",
	    "",
	    "	#include <begin_vertex>",
	    "	#include <displacementmap_vertex>",
	    "	#include <morphtarget_vertex>",
	    "	#include <skinning_vertex>",
	    "	#include <project_vertex>",
	    "	#include <logdepthbuf_vertex>",
	    "	#include <clipping_planes_vertex>",
	    "",
	    "	vViewPosition = - mvPosition.xyz;",
	    "",
	    "	#include <worldpos_vertex>",
	    "	#include <shadowmap_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var normal_frag = [
	    "uniform float opacity;",
	    "varying vec3 vNormal;",
	    "",
	    "#include <common>",
	    "#include <packing>",
	    "#include <logdepthbuf_pars_fragment>",
	    "#include <clipping_planes_pars_fragment>",
	    "",
	    "void main() {",
	    "",
	    "	#include <clipping_planes_fragment>",
	    "	gl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );",
	    "",
	    "	#include <logdepthbuf_fragment>",
	    "",
	    "}",
	    "",
	].join('\n');

	var normal_vert = [
	    "varying vec3 vNormal;",
	    "",
	    "#include <common>",
	    "#include <morphtarget_pars_vertex>",
	    "#include <logdepthbuf_pars_vertex>",
	    "#include <clipping_planes_pars_vertex>",
	    "",
	    "void main() {",
	    "",
	    "	vNormal = normalize( normalMatrix * normal );",
	    "",
	    "	#include <begin_vertex>",
	    "	#include <morphtarget_vertex>",
	    "	#include <project_vertex>",
	    "	#include <logdepthbuf_vertex>",
	    "	#include <clipping_planes_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var points_frag = [
	    "uniform vec3 diffuse;",
	    "uniform float opacity;",
	    "",
	    "#include <common>",
	    "#include <packing>",
	    "#include <color_pars_fragment>",
	    "#include <map_particle_pars_fragment>",
	    "#include <fog_pars_fragment>",
	    "#include <shadowmap_pars_fragment>",
	    "#include <logdepthbuf_pars_fragment>",
	    "#include <clipping_planes_pars_fragment>",
	    "",
	    "void main() {",
	    "",
	    "	#include <clipping_planes_fragment>",
	    "",
	    "	vec3 outgoingLight = vec3( 0.0 );",
	    "	vec4 diffuseColor = vec4( diffuse, opacity );",
	    "",
	    "	#include <logdepthbuf_fragment>",
	    "	#include <map_particle_fragment>",
	    "	#include <color_fragment>",
	    "	#include <alphatest_fragment>",
	    "",
	    "	outgoingLight = diffuseColor.rgb;",
	    "",
	    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
	    "",
	    "	#include <premultiplied_alpha_fragment>",
	    "	#include <tonemapping_fragment>",
	    "	#include <encodings_fragment>",
	    "	#include <fog_fragment>",
	    "",
	    "}",
	    "",
	].join('\n');

	var points_vert = [
	    "uniform float size;",
	    "uniform float scale;",
	    "",
	    "#include <common>",
	    "#include <color_pars_vertex>",
	    "#include <shadowmap_pars_vertex>",
	    "#include <logdepthbuf_pars_vertex>",
	    "#include <clipping_planes_pars_vertex>",
	    "",
	    "void main() {",
	    "",
	    "	#include <color_vertex>",
	    "	#include <begin_vertex>",
	    "	#include <project_vertex>",
	    "",
	    "	#ifdef USE_SIZEATTENUATION",
	    "		gl_PointSize = size * ( scale / - mvPosition.z );",
	    "	#else",
	    "		gl_PointSize = size;",
	    "	#endif",
	    "",
	    "	#include <logdepthbuf_vertex>",
	    "	#include <clipping_planes_vertex>",
	    "	#include <worldpos_vertex>",
	    "	#include <shadowmap_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var shadow_frag = [
	    "uniform float opacity;",
	    "",
	    "#include <common>",
	    "#include <packing>",
	    "#include <bsdfs>",
	    "#include <lights_pars>",
	    "#include <shadowmap_pars_fragment>",
	    "#include <shadowmask_pars_fragment>",
	    "",
	    "void main() {",
	    "",
	    "	gl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );",
	    "",
	    "}",
	    "",
	].join('\n');

	var shadow_vert = [
	    "#include <shadowmap_pars_vertex>",
	    "",
	    "void main() {",
	    "",
	    "	#include <begin_vertex>",
	    "	#include <project_vertex>",
	    "	#include <worldpos_vertex>",
	    "	#include <shadowmap_vertex>",
	    "",
	    "}",
	    "",
	].join('\n');

	var ShaderChunk = {
	    alphamap_fragment: alphamap_fragment,
	    alphamap_pars_fragment: alphamap_pars_fragment,
	    alphatest_fragment: alphatest_fragment,
	    aomap_fragment: aomap_fragment,
	    aomap_pars_fragment: aomap_pars_fragment,
	    begin_vertex: begin_vertex,
	    beginnormal_vertex: beginnormal_vertex,
	    bsdfs: bsdfs,
	    bumpmap_pars_fragment: bumpmap_pars_fragment,
	    clipping_planes_fragment: clipping_planes_fragment,
	    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	    clipping_planes_vertex: clipping_planes_vertex,
	    color_fragment: color_fragment,
	    color_pars_fragment: color_pars_fragment,
	    color_pars_vertex: color_pars_vertex,
	    color_vertex: color_vertex,
	    common: common,
	    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	    defaultnormal_vertex: defaultnormal_vertex,
	    displacementmap_pars_vertex: displacementmap_pars_vertex,
	    displacementmap_vertex: displacementmap_vertex,
	    emissivemap_fragment: emissivemap_fragment,
	    emissivemap_pars_fragment: emissivemap_pars_fragment,
	    encodings_fragment: encodings_fragment,
	    encodings_pars_fragment: encodings_pars_fragment,
	    envmap_fragment: envmap_fragment,
	    envmap_pars_fragment: envmap_pars_fragment,
	    envmap_pars_vertex: envmap_pars_vertex,
	    envmap_vertex: envmap_vertex,
	    fog_fragment: fog_fragment,
	    fog_pars_fragment: fog_pars_fragment,
	    lightmap_fragment: lightmap_fragment,
	    lightmap_pars_fragment: lightmap_pars_fragment,
	    lights_lambert_vertex: lights_lambert_vertex,
	    lights_pars: lights_pars,
	    lights_phong_fragment: lights_phong_fragment,
	    lights_phong_pars_fragment: lights_phong_pars_fragment,
	    lights_physical_fragment: lights_physical_fragment,
	    lights_physical_pars_fragment: lights_physical_pars_fragment,
	    lights_template: lights_template,
	    logdepthbuf_fragment: logdepthbuf_fragment,
	    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	    logdepthbuf_vertex: logdepthbuf_vertex,
	    map_fragment: map_fragment,
	    map_pars_fragment: map_pars_fragment,
	    map_particle_fragment: map_particle_fragment,
	    map_particle_pars_fragment: map_particle_pars_fragment,
	    metalnessmap_fragment: metalnessmap_fragment,
	    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	    morphnormal_vertex: morphnormal_vertex,
	    morphtarget_pars_vertex: morphtarget_pars_vertex,
	    morphtarget_vertex: morphtarget_vertex,
	    normal_flip: normal_flip,
	    normal_fragment: normal_fragment,
	    normalmap_pars_fragment: normalmap_pars_fragment,
	    packing: packing,
	    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	    project_vertex: project_vertex,
	    roughnessmap_fragment: roughnessmap_fragment,
	    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	    shadowmap_pars_fragment: shadowmap_pars_fragment,
	    shadowmap_pars_vertex: shadowmap_pars_vertex,
	    shadowmap_vertex: shadowmap_vertex,
	    shadowmask_pars_fragment: shadowmask_pars_fragment,
	    skinbase_vertex: skinbase_vertex,
	    skinning_pars_vertex: skinning_pars_vertex,
	    skinning_vertex: skinning_vertex,
	    skinnormal_vertex: skinnormal_vertex,
	    specularmap_fragment: specularmap_fragment,
	    specularmap_pars_fragment: specularmap_pars_fragment,
	    tonemapping_fragment: tonemapping_fragment,
	    tonemapping_pars_fragment: tonemapping_pars_fragment,
	    uv_pars_fragment: uv_pars_fragment,
	    uv_pars_vertex: uv_pars_vertex,
	    uv_vertex: uv_vertex,
	    uv2_pars_fragment: uv2_pars_fragment,
	    uv2_pars_vertex: uv2_pars_vertex,
	    uv2_vertex: uv2_vertex,
	    worldpos_vertex: worldpos_vertex,
	    cube_frag: cube_frag,
	    cube_vert: cube_vert,
	    depth_frag: depth_frag,
	    depth_vert: depth_vert,
	    distanceRGBA_frag: distanceRGBA_frag,
	    distanceRGBA_vert: distanceRGBA_vert,
	    equirect_frag: equirect_frag,
	    equirect_vert: equirect_vert,
	    linedashed_frag: linedashed_frag,
	    linedashed_vert: linedashed_vert,
	    meshbasic_frag: meshbasic_frag,
	    meshbasic_vert: meshbasic_vert,
	    meshlambert_frag: meshlambert_frag,
	    meshlambert_vert: meshlambert_vert,
	    meshphong_frag: meshphong_frag,
	    meshphong_vert: meshphong_vert,
	    meshphysical_frag: meshphysical_frag,
	    meshphysical_vert: meshphysical_vert,
	    normal_frag: normal_frag,
	    normal_vert: normal_vert,
	    points_frag: points_frag,
	    points_vert: points_vert,
	    shadow_frag: shadow_frag,
	    shadow_vert: shadow_vert
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */
	var UniformsLib = {
	    common: {
	        diffuse: { value: new Color(0xeeeeee) },
	        opacity: { value: 1.0 },
	        map: { value: null },
	        offsetRepeat: { value: new Vector4(0, 0, 1, 1) },
	        specularMap: { value: null },
	        alphaMap: { value: null },
	        envMap: { value: null },
	        flipEnvMap: { value: -1 },
	        reflectivity: { value: 1.0 },
	        refractionRatio: { value: 0.98 }
	    },
	    aomap: {
	        aoMap: { value: null },
	        aoMapIntensity: { value: 1 }
	    },
	    lightmap: {
	        lightMap: { value: null },
	        lightMapIntensity: { value: 1 }
	    },
	    emissivemap: {
	        emissiveMap: { value: null }
	    },
	    bumpmap: {
	        bumpMap: { value: null },
	        bumpScale: { value: 1 }
	    },
	    normalmap: {
	        normalMap: { value: null },
	        normalScale: { value: new Vector2(1, 1) }
	    },
	    displacementmap: {
	        displacementMap: { value: null },
	        displacementScale: { value: 1 },
	        displacementBias: { value: 0 }
	    },
	    roughnessmap: {
	        roughnessMap: { value: null }
	    },
	    metalnessmap: {
	        metalnessMap: { value: null }
	    },
	    fog: {
	        fogDensity: { value: 0.00025 },
	        fogNear: { value: 1 },
	        fogFar: { value: 2000 },
	        fogColor: { value: new Color(0xffffff) }
	    },
	    lights: {
	        ambientLightColor: { value: [] },
	        directionalLights: { value: [], properties: {
	                direction: {},
	                color: {},
	                shadow: {},
	                shadowBias: {},
	                shadowRadius: {},
	                shadowMapSize: {}
	            } },
	        directionalShadowMap: { value: [] },
	        directionalShadowMatrix: { value: [] },
	        spotLights: { value: [], properties: {
	                color: {},
	                position: {},
	                direction: {},
	                distance: {},
	                coneCos: {},
	                penumbraCos: {},
	                decay: {},
	                shadow: {},
	                shadowBias: {},
	                shadowRadius: {},
	                shadowMapSize: {}
	            } },
	        spotShadowMap: { value: [] },
	        spotShadowMatrix: { value: [] },
	        pointLights: { value: [], properties: {
	                color: {},
	                position: {},
	                decay: {},
	                distance: {},
	                shadow: {},
	                shadowBias: {},
	                shadowRadius: {},
	                shadowMapSize: {}
	            } },
	        pointShadowMap: { value: [] },
	        pointShadowMatrix: { value: [] },
	        hemisphereLights: { value: [], properties: {
	                direction: {},
	                skyColor: {},
	                groundColor: {}
	            } }
	    },
	    points: {
	        diffuse: { value: new Color(0xeeeeee) },
	        opacity: { value: 1.0 },
	        size: { value: 1.0 },
	        scale: { value: 1.0 },
	        map: { value: null },
	        offsetRepeat: { value: new Vector4(0, 0, 1, 1) }
	    }
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	var ShaderLib = {
	    basic: {
	        uniforms: UniformsUtils.merge([
	            UniformsLib.common,
	            UniformsLib.aomap,
	            UniformsLib.fog
	        ]),
	        vertexShader: ShaderChunk.meshbasic_vert,
	        fragmentShader: ShaderChunk.meshbasic_frag
	    },
	    lambert: {
	        uniforms: UniformsUtils.merge([
	            UniformsLib.common,
	            UniformsLib.aomap,
	            UniformsLib.lightmap,
	            UniformsLib.emissivemap,
	            UniformsLib.fog,
	            UniformsLib.lights,
	            {
	                emissive: { value: new Color(0x000000) }
	            }
	        ]),
	        vertexShader: ShaderChunk.meshlambert_vert,
	        fragmentShader: ShaderChunk.meshlambert_frag
	    },
	    phong: {
	        uniforms: UniformsUtils.merge([
	            UniformsLib.common,
	            UniformsLib.aomap,
	            UniformsLib.lightmap,
	            UniformsLib.emissivemap,
	            UniformsLib.bumpmap,
	            UniformsLib.normalmap,
	            UniformsLib.displacementmap,
	            UniformsLib.fog,
	            UniformsLib.lights,
	            {
	                emissive: { value: new Color(0x000000) },
	                specular: { value: new Color(0x111111) },
	                shininess: { value: 30 }
	            }
	        ]),
	        vertexShader: ShaderChunk.meshphong_vert,
	        fragmentShader: ShaderChunk.meshphong_frag
	    },
	    standard: {
	        uniforms: UniformsUtils.merge([
	            UniformsLib.common,
	            UniformsLib.aomap,
	            UniformsLib.lightmap,
	            UniformsLib.emissivemap,
	            UniformsLib.bumpmap,
	            UniformsLib.normalmap,
	            UniformsLib.displacementmap,
	            UniformsLib.roughnessmap,
	            UniformsLib.metalnessmap,
	            UniformsLib.fog,
	            UniformsLib.lights,
	            {
	                emissive: { value: new Color(0x000000) },
	                roughness: { value: 0.5 },
	                metalness: { value: 0 },
	                envMapIntensity: { value: 1 },
	            }
	        ]),
	        vertexShader: ShaderChunk.meshphysical_vert,
	        fragmentShader: ShaderChunk.meshphysical_frag
	    },
	    points: {
	        uniforms: UniformsUtils.merge([
	            UniformsLib.points,
	            UniformsLib.fog
	        ]),
	        vertexShader: ShaderChunk.points_vert,
	        fragmentShader: ShaderChunk.points_frag
	    },
	    dashed: {
	        uniforms: UniformsUtils.merge([
	            UniformsLib.common,
	            UniformsLib.fog,
	            {
	                scale: { value: 1 },
	                dashSize: { value: 1 },
	                totalSize: { value: 2 }
	            }
	        ]),
	        vertexShader: ShaderChunk.linedashed_vert,
	        fragmentShader: ShaderChunk.linedashed_frag
	    },
	    depth: {
	        uniforms: UniformsUtils.merge([
	            UniformsLib.common,
	            UniformsLib.displacementmap
	        ]),
	        vertexShader: ShaderChunk.depth_vert,
	        fragmentShader: ShaderChunk.depth_frag
	    },
	    normal: {
	        uniforms: {
	            opacity: { value: 1.0 }
	        },
	        vertexShader: ShaderChunk.normal_vert,
	        fragmentShader: ShaderChunk.normal_frag
	    },
	    /* -------------------------------------------------------------------------
	    //  Cube map shader
	     ------------------------------------------------------------------------- */
	    cube: {
	        uniforms: {
	            tCube: { value: null },
	            tFlip: { value: -1 },
	            opacity: { value: 1.0 }
	        },
	        vertexShader: ShaderChunk.cube_vert,
	        fragmentShader: ShaderChunk.cube_frag
	    },
	    /* -------------------------------------------------------------------------
	    //  Cube map shader
	     ------------------------------------------------------------------------- */
	    equirect: {
	        uniforms: {
	            tEquirect: { value: null },
	            tFlip: { value: -1 }
	        },
	        vertexShader: ShaderChunk.equirect_vert,
	        fragmentShader: ShaderChunk.equirect_frag
	    },
	    distanceRGBA: {
	        uniforms: {
	            lightPos: { value: new Vector3() }
	        },
	        vertexShader: ShaderChunk.distanceRGBA_vert,
	        fragmentShader: ShaderChunk.distanceRGBA_frag
	    }
	};
	ShaderLib.physical = {
	    uniforms: UniformsUtils.merge([
	        ShaderLib.standard.uniforms,
	        {
	            clearCoat: { value: 0 },
	            clearCoatRoughness: { value: 0 }
	        }
	    ]),
	    vertexShader: ShaderChunk.meshphysical_vert,
	    fragmentShader: ShaderChunk.meshphysical_frag
	};

	/**
	 * @author bhouston / http://clara.io
	 */
	var Box2 = /** @class */ (function () {
	    function Box2(min, max) {
	        if (min === void 0) { min = new Vector2(+Infinity, +Infinity); }
	        if (max === void 0) { max = new Vector2(-Infinity, -Infinity); }
	        this.min = min;
	        this.max = max;
	    }
	    Box2.prototype.set = function (min, max) {
	        this.min.copy(min);
	        this.max.copy(max);
	        return this;
	    };
	    Box2.prototype.setFromPoints = function (points) {
	        this.makeEmpty();
	        for (var i = 0, il = points.length; i < il; i++) {
	            this.expandByPoint(points[i]);
	        }
	        return this;
	    };
	    Box2.prototype.setFromCenterAndSize = function (center, size) {
	        var v1 = Box2._setFromCenterAndSize_v1;
	        var halfSize = v1.copy(size).multiplyScalar(0.5);
	        this.min.copy(center).sub(halfSize);
	        this.max.copy(center).add(halfSize);
	        return this;
	    };
	    Box2.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Box2.prototype.copy = function (box) {
	        this.min.copy(box.min);
	        this.max.copy(box.max);
	        return this;
	    };
	    Box2.prototype.makeEmpty = function () {
	        this.min.x = this.min.y = +Infinity;
	        this.max.x = this.max.y = -Infinity;
	        return this;
	    };
	    Box2.prototype.isEmpty = function () {
	        // this is a more robust check for empty than (volume <= 0) because volume can get positive with two negative axes
	        return (this.max.x < this.min.x) || (this.max.y < this.min.y);
	    };
	    Box2.prototype.getCenter = function (result) {
	        if (result === void 0) { result = new Vector2(); }
	        return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
	    };
	    Box2.prototype.getSize = function (result) {
	        if (result === void 0) { result = new Vector2(); }
	        return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);
	    };
	    Box2.prototype.expandByPoint = function (point) {
	        this.min.min(point);
	        this.max.max(point);
	        return this;
	    };
	    Box2.prototype.expandByVector = function (vector) {
	        this.min.sub(vector);
	        this.max.add(vector);
	        return this;
	    };
	    Box2.prototype.expandByScalar = function (scalar) {
	        this.min.addScalar(-scalar);
	        this.max.addScalar(scalar);
	        return this;
	    };
	    Box2.prototype.containsPoint = function (point) {
	        if (point.x < this.min.x || point.x > this.max.x ||
	            point.y < this.min.y || point.y > this.max.y) {
	            return false;
	        }
	        return true;
	    };
	    Box2.prototype.containsBox = function (box) {
	        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) &&
	            (this.min.y <= box.min.y) && (box.max.y <= this.max.y)) {
	            return true;
	        }
	        return false;
	    };
	    Box2.prototype.getParameter = function (point, result) {
	        if (result === void 0) { result = new Vector2(); }
	        // This can potentially have a divide by zero if the box
	        // has a size dimension of 0.
	        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
	    };
	    Box2.prototype.intersectsBox = function (box) {
	        // using 6 splitting planes to rule out intersections.
	        if (box.max.x < this.min.x || box.min.x > this.max.x ||
	            box.max.y < this.min.y || box.min.y > this.max.y) {
	            return false;
	        }
	        return true;
	    };
	    Box2.prototype.clampPoint = function (point, result) {
	        if (result === void 0) { result = new Vector2(); }
	        return result.copy(point).clamp(this.min, this.max);
	    };
	    Box2.prototype.distanceToPoint = function (point) {
	        var v1 = Box2._distanceToPoint_v1;
	        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
	        return clampedPoint.sub(point).length();
	    };
	    Box2.prototype.intersect = function (box) {
	        this.min.max(box.min);
	        this.max.min(box.max);
	        return this;
	    };
	    Box2.prototype.union = function (box) {
	        this.min.min(box.min);
	        this.max.max(box.max);
	        return this;
	    };
	    Box2.prototype.translate = function (offset) {
	        this.min.add(offset);
	        this.max.add(offset);
	        return this;
	    };
	    Box2.prototype.equals = function (box) {
	        return box.min.equals(this.min) && box.max.equals(this.max);
	    };
	    Box2.prototype.empty = function () {
	        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
	        return this.isEmpty();
	    };
	    Box2.prototype.center = function (optionalTarget) {
	        if (optionalTarget === void 0) { optionalTarget = new Vector2(); }
	        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
	        return this.getCenter(optionalTarget);
	    };
	    Box2.prototype.size = function (optionalTarget) {
	        if (optionalTarget === void 0) { optionalTarget = new Vector2(); }
	        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
	        return this.getSize(optionalTarget);
	    };
	    Box2.prototype.isIntersectionBox = function (box) {
	        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
	        return this.intersectsBox(box);
	    };
	    Box2._setFromCenterAndSize_v1 = new Vector2();
	    Box2._distanceToPoint_v1 = new Vector2();
	    return Box2;
	}());

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var LensFlarePlugin = /** @class */ (function () {
	    function LensFlarePlugin(renderer, flares) {
	        this.renderer = renderer;
	        this.flares = flares;
	    }
	    LensFlarePlugin.prototype.init = function () {
	        var gl = this.renderer.context;
	        var state = this.renderer.state;
	        var vertices = new Float32Array([
	            -1, -1, 0, 0,
	            1, -1, 1, 0,
	            1, 1, 1, 1,
	            -1, 1, 0, 1
	        ]);
	        var faces = new Uint16Array([
	            0, 1, 2,
	            0, 2, 3
	        ]);
	        // buffers
	        var vertexBuffer = this.vertexBuffer = gl.createBuffer();
	        var elementBuffer = this.elementBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
	        // textures
	        var tempTexture = this.tempTexture = gl.createTexture();
	        var occlusionTexture = this.occlusionTexture = gl.createTexture();
	        state.bindTexture(gl.TEXTURE_2D, tempTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	        state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	        var shader = this.shader = {
	            vertexShader: [
	                "uniform lowp int renderType;",
	                "uniform vec3 screenPosition;",
	                "uniform vec2 scale;",
	                "uniform float rotation;",
	                "uniform sampler2D occlusionMap;",
	                "attribute vec2 position;",
	                "attribute vec2 uv;",
	                "varying vec2 vUV;",
	                "varying float vVisibility;",
	                "void main() {",
	                "vUV = uv;",
	                "vec2 pos = position;",
	                "if (renderType == 2) {",
	                "vec4 visibility = texture2D(occlusionMap, vec2(0.1, 0.1));",
	                "visibility += texture2D(occlusionMap, vec2(0.5, 0.1));",
	                "visibility += texture2D(occlusionMap, vec2(0.9, 0.1));",
	                "visibility += texture2D(occlusionMap, vec2(0.9, 0.5));",
	                "visibility += texture2D(occlusionMap, vec2(0.9, 0.9));",
	                "visibility += texture2D(occlusionMap, vec2(0.5, 0.9));",
	                "visibility += texture2D(occlusionMap, vec2(0.1, 0.9));",
	                "visibility += texture2D(occlusionMap, vec2(0.1, 0.5));",
	                "visibility += texture2D(occlusionMap, vec2(0.5, 0.5));",
	                "vVisibility =        visibility.r / 9.0;",
	                "vVisibility *= 1.0 - visibility.g / 9.0;",
	                "vVisibility *=       visibility.b / 9.0;",
	                "vVisibility *= 1.0 - visibility.a / 9.0;",
	                "pos.x = cos(rotation) * position.x - sin(rotation) * position.y;",
	                "pos.y = sin(rotation) * position.x + cos(rotation) * position.y;",
	                "}",
	                "gl_Position = vec4((pos * scale + screenPosition.xy).xy, screenPosition.z, 1.0);",
	                "}"
	            ].join("\n"),
	            fragmentShader: [
	                "uniform lowp int renderType;",
	                "uniform sampler2D map;",
	                "uniform float opacity;",
	                "uniform vec3 color;",
	                "varying vec2 vUV;",
	                "varying float vVisibility;",
	                "void main() {",
	                // pink square
	                "if (renderType == 0) {",
	                "gl_FragColor = vec4(1.0, 0.0, 1.0, 0.0);",
	                // restore
	                "} else if (renderType == 1) {",
	                "gl_FragColor = texture2D(map, vUV);",
	                // flare
	                "} else {",
	                "vec4 texture = texture2D(map, vUV);",
	                "texture.a *= opacity * vVisibility;",
	                "gl_FragColor = texture;",
	                "gl_FragColor.rgb *= color;",
	                "}",
	                "}"
	            ].join("\n")
	        };
	        var program = this.program = this.createProgram(shader);
	        this.attributes = {
	            vertex: gl.getAttribLocation(program, "position"),
	            uv: gl.getAttribLocation(program, "uv")
	        };
	        this.uniforms = {
	            renderType: gl.getUniformLocation(program, "renderType"),
	            map: gl.getUniformLocation(program, "map"),
	            occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
	            opacity: gl.getUniformLocation(program, "opacity"),
	            color: gl.getUniformLocation(program, "color"),
	            scale: gl.getUniformLocation(program, "scale"),
	            rotation: gl.getUniformLocation(program, "rotation"),
	            screenPosition: gl.getUniformLocation(program, "screenPosition")
	        };
	    };
	    /*
	     * Render lens flares
	     * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	     *         reads these back and calculates occlusion.
	     */
	    LensFlarePlugin.prototype.render = function (scene, camera, viewport) {
	        var gl = this.renderer.context;
	        var state = this.renderer.state;
	        var flares = this.flares;
	        if (flares.length === 0)
	            return;
	        var tempPosition = new Vector3();
	        var invAspect = viewport.w / viewport.z;
	        var halfViewportWidth = viewport.z * 0.5;
	        var halfViewportHeight = viewport.w * 0.5;
	        var size = 16 / viewport.w;
	        var scale = new Vector2(size * invAspect, size);
	        var screenPosition = new Vector3(1, 1, 0);
	        var screenPositionPixels = new Vector2(1, 1);
	        var validArea = new Box2();
	        validArea.min.set(viewport.x, viewport.y);
	        validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
	        if (this.program === undefined) {
	            this.init();
	        }
	        var uniforms = this.uniforms;
	        var attributes = this.attributes;
	        gl.useProgram(this.program);
	        state.initAttributes();
	        state.enableAttribute(attributes.vertex);
	        state.enableAttribute(attributes.uv);
	        state.disableUnusedAttributes();
	        // loop through all lens flares to update their occlusion and positions
	        // setup gl and common used attribs/uniforms
	        gl.uniform1i(uniforms.occlusionMap, 0);
	        gl.uniform1i(uniforms.map, 1);
	        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	        gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
	        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
	        state.disable(gl.CULL_FACE);
	        state.setDepthWrite(false);
	        for (var i = 0, l = flares.length; i < l; i++) {
	            size = 16 / viewport.w;
	            scale.set(size * invAspect, size);
	            // calc object screen position
	            var flare = flares[i];
	            tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
	            tempPosition.applyMatrix4(camera.matrixWorldInverse);
	            tempPosition.applyProjection(camera.projectionMatrix);
	            // setup arrays for gl programs
	            screenPosition.copy(tempPosition);
	            // horizontal and vertical coordinate of the lower left corner of the pixels to copy
	            screenPositionPixels.x = viewport.x + (screenPosition.x * halfViewportWidth) + halfViewportWidth - 8;
	            screenPositionPixels.y = viewport.y + (screenPosition.y * halfViewportHeight) + halfViewportHeight - 8;
	            // screen cull
	            if (validArea.containsPoint(screenPositionPixels) === true) {
	                // save current RGB to temp texture
	                state.activeTexture(gl.TEXTURE0);
	                state.bindTexture(gl.TEXTURE_2D, null);
	                state.activeTexture(gl.TEXTURE1);
	                state.bindTexture(gl.TEXTURE_2D, this.tempTexture);
	                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
	                // render pink quad
	                gl.uniform1i(uniforms.renderType, 0);
	                gl.uniform2f(uniforms.scale, scale.x, scale.y);
	                gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
	                state.disable(gl.BLEND);
	                state.enable(gl.DEPTH_TEST);
	                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
	                // copy result to occlusionMap
	                state.activeTexture(gl.TEXTURE0);
	                state.bindTexture(gl.TEXTURE_2D, this.occlusionTexture);
	                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
	                // restore graphics
	                gl.uniform1i(uniforms.renderType, 1);
	                state.disable(gl.DEPTH_TEST);
	                state.activeTexture(gl.TEXTURE1);
	                state.bindTexture(gl.TEXTURE_2D, this.tempTexture);
	                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
	                // update object positions
	                flare.positionScreen.copy(screenPosition);
	                if (flare.customUpdateCallback) {
	                    flare.customUpdateCallback(flare);
	                }
	                else {
	                    flare.updateLensFlares();
	                }
	                // render flares
	                gl.uniform1i(uniforms.renderType, 2);
	                state.enable(gl.BLEND);
	                for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
	                    var sprite = flare.lensFlares[j];
	                    if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
	                        screenPosition.x = sprite.x;
	                        screenPosition.y = sprite.y;
	                        screenPosition.z = sprite.z;
	                        size = sprite.size * sprite.scale / viewport.w;
	                        scale.x = size * invAspect;
	                        scale.y = size;
	                        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
	                        gl.uniform2f(uniforms.scale, scale.x, scale.y);
	                        gl.uniform1f(uniforms.rotation, sprite.rotation);
	                        gl.uniform1f(uniforms.opacity, sprite.opacity);
	                        gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
	                        state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
	                        this.renderer.setTexture2D(sprite.texture, 1);
	                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
	                    }
	                }
	            }
	        }
	        // restore gl
	        state.enable(gl.CULL_FACE);
	        state.enable(gl.DEPTH_TEST);
	        state.setDepthWrite(true);
	        this.renderer.resetGLState();
	    };
	    LensFlarePlugin.prototype.createProgram = function (shader) {
	        var gl = this.renderer.context;
	        var program = gl.createProgram();
	        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	        var prefix = "precision " + this.renderer.getPrecision() + " float;\n";
	        gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
	        gl.shaderSource(vertexShader, prefix + shader.vertexShader);
	        gl.compileShader(fragmentShader);
	        gl.compileShader(vertexShader);
	        gl.attachShader(program, fragmentShader);
	        gl.attachShader(program, vertexShader);
	        gl.linkProgram(program);
	        return program;
	    };
	    return LensFlarePlugin;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var Fog = /** @class */ (function () {
	    function Fog(color, near, far) {
	        if (near === void 0) { near = 1; }
	        if (far === void 0) { far = 1000; }
	        this.name = '';
	        this.isFog = true;
	        this.color = new Color(color);
	        this.near = near;
	        this.far = far;
	    }
	    Fog.prototype.clone = function () {
	        return new this.constructor(this.color.getHex(), this.near, this.far);
	    };
	    Fog.prototype.toJSON = function (meta) {
	        return {
	            type: 'Fog',
	            color: this.color.getHex(),
	            near: this.near,
	            far: this.far
	        };
	    };
	    return Fog;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var FogExp2 = /** @class */ (function () {
	    function FogExp2(color, density) {
	        if (density === void 0) { density = 0.00025; }
	        this.name = '';
	        this.isFogExp2 = true;
	        this.color = new Color(color);
	        this.density = density;
	    }
	    FogExp2.prototype.clone = function () {
	        return new this.constructor(this.color.getHex(), this.density);
	    };
	    FogExp2.prototype.toJSON = function (meta) {
	        return {
	            type: 'FogExp2',
	            color: this.color.getHex(),
	            density: this.density
	        };
	    };
	    return FogExp2;
	}());

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var SpritePlugin = /** @class */ (function () {
	    function SpritePlugin(renderer, sprites) {
	        this.renderer = renderer;
	        this.sprites = sprites;
	    }
	    SpritePlugin.prototype.init = function () {
	        var renderer = this.renderer;
	        var gl = renderer.context;
	        var vertices = new Float32Array([
	            -0.5, -0.5, 0, 0,
	            0.5, -0.5, 1, 0,
	            0.5, 0.5, 1, 1,
	            -0.5, 0.5, 0, 1
	        ]);
	        var faces = new Uint16Array([
	            0, 1, 2,
	            0, 2, 3
	        ]);
	        var vertexBuffer = this.vertexBuffer = gl.createBuffer();
	        var elementBuffer = this.elementBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
	        var program = this.program = this.createProgram();
	        this.attributes = {
	            position: gl.getAttribLocation(program, 'position'),
	            uv: gl.getAttribLocation(program, 'uv')
	        };
	        this.uniforms = {
	            uvOffset: gl.getUniformLocation(program, 'uvOffset'),
	            uvScale: gl.getUniformLocation(program, 'uvScale'),
	            rotation: gl.getUniformLocation(program, 'rotation'),
	            scale: gl.getUniformLocation(program, 'scale'),
	            color: gl.getUniformLocation(program, 'color'),
	            map: gl.getUniformLocation(program, 'map'),
	            opacity: gl.getUniformLocation(program, 'opacity'),
	            modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
	            projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
	            fogType: gl.getUniformLocation(program, 'fogType'),
	            fogDensity: gl.getUniformLocation(program, 'fogDensity'),
	            fogNear: gl.getUniformLocation(program, 'fogNear'),
	            fogFar: gl.getUniformLocation(program, 'fogFar'),
	            fogColor: gl.getUniformLocation(program, 'fogColor'),
	            alphaTest: gl.getUniformLocation(program, 'alphaTest')
	        };
	        var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
	        canvas.width = 8;
	        canvas.height = 8;
	        var context = canvas.getContext('2d');
	        context.fillStyle = 'white';
	        context.fillRect(0, 0, 8, 8);
	        var texture = this.texture = new Texture(canvas);
	        texture.needsUpdate = true;
	    };
	    SpritePlugin.prototype.render = function (scene, camera) {
	        // decompose matrixWorld
	        var spritePosition = new Vector3();
	        var spriteRotation = new Quaternion();
	        var spriteScale = new Vector3();
	        var renderer = this.renderer;
	        var sprites = this.sprites;
	        var gl = renderer.context;
	        var state = renderer.state;
	        if (sprites.length === 0)
	            return;
	        // setup gl
	        if (this.program === undefined) {
	            this.init();
	        }
	        var program = this.program;
	        var attributes = this.attributes;
	        var uniforms = this.uniforms;
	        gl.useProgram(program);
	        state.initAttributes();
	        state.enableAttribute(attributes.position);
	        state.enableAttribute(attributes.uv);
	        state.disableUnusedAttributes();
	        state.disable(gl.CULL_FACE);
	        state.enable(gl.BLEND);
	        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	        gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
	        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
	        gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
	        state.activeTexture(gl.TEXTURE0);
	        gl.uniform1i(uniforms.map, 0);
	        var oldFogType = 0;
	        var sceneFogType = 0;
	        var fog = scene.fog;
	        if (fog) {
	            gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
	            if ((fog && fog instanceof Fog)) {
	                gl.uniform1f(uniforms.fogNear, fog.near);
	                gl.uniform1f(uniforms.fogFar, fog.far);
	                gl.uniform1i(uniforms.fogType, 1);
	                oldFogType = 1;
	                sceneFogType = 1;
	            }
	            else if ((fog && fog instanceof FogExp2)) {
	                gl.uniform1f(uniforms.fogDensity, fog.density);
	                gl.uniform1i(uniforms.fogType, 2);
	                oldFogType = 2;
	                sceneFogType = 2;
	            }
	        }
	        else {
	            gl.uniform1i(uniforms.fogType, 0);
	            oldFogType = 0;
	            sceneFogType = 0;
	        }
	        // update positions and sort
	        for (var i = 0, l = sprites.length; i < l; i++) {
	            var sprite = sprites[i];
	            sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
	            sprite.z = -sprite.modelViewMatrix.elements[14];
	        }
	        sprites.sort(SpritePlugin.painterSortStable);
	        // render all sprites
	        var scale = [];
	        for (var i = 0, l = sprites.length; i < l; i++) {
	            var sprite = sprites[i];
	            var material = sprite.material;
	            if (material.visible === false)
	                continue;
	            gl.uniform1f(uniforms.alphaTest, material.alphaTest);
	            gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
	            sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
	            scale[0] = spriteScale.x;
	            scale[1] = spriteScale.y;
	            var fogType = 0;
	            if (scene.fog && material.fog) {
	                fogType = sceneFogType;
	            }
	            if (oldFogType !== fogType) {
	                gl.uniform1i(uniforms.fogType, fogType);
	                oldFogType = fogType;
	            }
	            if (material.map !== null) {
	                gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
	                gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
	            }
	            else {
	                gl.uniform2f(uniforms.uvOffset, 0, 0);
	                gl.uniform2f(uniforms.uvScale, 1, 1);
	            }
	            gl.uniform1f(uniforms.opacity, material.opacity);
	            gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
	            gl.uniform1f(uniforms.rotation, material.rotation);
	            gl.uniform2fv(uniforms.scale, scale);
	            state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
	            state.setDepthTest(material.depthTest);
	            state.setDepthWrite(material.depthWrite);
	            if (material.map) {
	                renderer.setTexture2D(material.map, 0);
	            }
	            else {
	                renderer.setTexture2D(this.texture, 0);
	            }
	            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
	        }
	        // restore gl
	        state.enable(gl.CULL_FACE);
	        renderer.resetGLState();
	    };
	    SpritePlugin.prototype.createProgram = function () {
	        var renderer = this.renderer;
	        var gl = renderer.context;
	        var program = gl.createProgram();
	        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	        gl.shaderSource(vertexShader, [
	            'precision ' + renderer.getPrecision() + ' float;',
	            'uniform mat4 modelViewMatrix;',
	            'uniform mat4 projectionMatrix;',
	            'uniform float rotation;',
	            'uniform vec2 scale;',
	            'uniform vec2 uvOffset;',
	            'uniform vec2 uvScale;',
	            'attribute vec2 position;',
	            'attribute vec2 uv;',
	            'varying vec2 vUV;',
	            'void main() {',
	            'vUV = uvOffset + uv * uvScale;',
	            'vec2 alignedPosition = position * scale;',
	            'vec2 rotatedPosition;',
	            'rotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;',
	            'rotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;',
	            'vec4 finalPosition;',
	            'finalPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);',
	            'finalPosition.xy += rotatedPosition;',
	            'finalPosition = projectionMatrix * finalPosition;',
	            'gl_Position = finalPosition;',
	            '}'
	        ].join('\n'));
	        gl.shaderSource(fragmentShader, [
	            'precision ' + renderer.getPrecision() + ' float;',
	            'uniform vec3 color;',
	            'uniform sampler2D map;',
	            'uniform float opacity;',
	            'uniform int fogType;',
	            'uniform vec3 fogColor;',
	            'uniform float fogDensity;',
	            'uniform float fogNear;',
	            'uniform float fogFar;',
	            'uniform float alphaTest;',
	            'varying vec2 vUV;',
	            'void main() {',
	            'vec4 texture = texture2D(map, vUV);',
	            'if (texture.a < alphaTest) discard;',
	            'gl_FragColor = vec4(color * texture.xyz, texture.a * opacity);',
	            'if (fogType > 0) {',
	            'float depth = gl_FragCoord.z / gl_FragCoord.w;',
	            'float fogFactor = 0.0;',
	            'if (fogType == 1) {',
	            'fogFactor = smoothstep(fogNear, fogFar, depth);',
	            '} else {',
	            'const float LOG2 = 1.442695;',
	            'fogFactor = exp2(- fogDensity * fogDensity * depth * depth * LOG2);',
	            'fogFactor = 1.0 - clamp(fogFactor, 0.0, 1.0);',
	            '}',
	            'gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);',
	            '}',
	            '}'
	        ].join('\n'));
	        gl.compileShader(vertexShader);
	        gl.compileShader(fragmentShader);
	        gl.attachShader(program, vertexShader);
	        gl.attachShader(program, fragmentShader);
	        gl.linkProgram(program);
	        return program;
	    };
	    SpritePlugin.painterSortStable = function (a, b) {
	        if (a.renderOrder !== b.renderOrder) {
	            return a.renderOrder - b.renderOrder;
	        }
	        else if (a.z !== b.z) {
	            return b.z - a.z;
	        }
	        else {
	            return b.id - a.id;
	        }
	    };
	    return SpritePlugin;
	}());

	var Material = /** @class */ (function (_super) {
	    __extends(Material, _super);
	    function Material() {
	        var _this = _super.call(this) || this;
	        _this.id = MaterialIdCount();
	        _this.uuid = _Math.generateUUID();
	        _this.name = '';
	        _this.type = 'Material';
	        _this.fog = true;
	        _this.lights = true;
	        _this.blending = exports.BlendingMode.Normal;
	        _this.side = exports.SideMode.Front;
	        _this.shading = exports.ShadingMode.Smooth; // THREE.ShadingMode.Flat, THREE.ShadingMode.Smooth
	        _this.vertexColors = exports.ColorsMode.None; // THREE.ColorsMode.No, THREE.ColorsMode.Vertex, THREE.ColorsMode.Face
	        _this._opacity = 1;
	        _this.transparent = false;
	        _this.blendSrc = exports.BlendingFactor.SrcAlpha;
	        _this.blendDst = exports.BlendingFactor.OneMinusSrcAlpha;
	        _this.blendEquation = exports.BlendingEquation.Add;
	        _this.blendSrcAlpha = null;
	        _this.blendDstAlpha = null;
	        _this.blendEquationAlpha = null;
	        _this.depthFunc = exports.DepthFunction.LessEqual;
	        _this.depthTest = true;
	        _this.depthWrite = true;
	        _this.clipping = false;
	        _this.clippingPlanes = null;
	        _this.clipIntersection = false;
	        _this.clipShadows = false;
	        _this.colorWrite = true;
	        _this.precision = null; // override the renderer's default precision for this material
	        _this.polygonOffset = false;
	        _this.polygonOffsetFactor = 0;
	        _this.polygonOffsetUnits = 0;
	        _this.alphaTest = 0;
	        _this.premultipliedAlpha = false;
	        _this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	        _this.visible = true;
	        _this._needsUpdate = true;
	        // }
	        _this.isMaterial = true;
	        _this.isMultiMaterial = false;
	        return _this;
	    }
	    Object.defineProperty(Material.prototype, "opacity", {
	        get: function () {
	            return this._opacity;
	        },
	        set: function (value) {
	            this._opacity = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Material.prototype, "needsUpdate", {
	        get: function () {
	            return this._needsUpdate;
	        },
	        set: function (value) {
	            if (value === true)
	                this.update();
	            this._needsUpdate = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Material.prototype.setValues = function (values) {
	        if (values === undefined)
	            return;
	        for (var key in values) {
	            var newValue = values[key];
	            if (newValue === undefined) {
	                console.warn("THREE.Material: '" + key + "' parameter is undefined.");
	                continue;
	            }
	            var currentValue = this[key];
	            if (currentValue === undefined) {
	                console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
	                continue;
	            }
	            if ((currentValue && currentValue instanceof Color)) {
	                currentValue.set(newValue);
	            }
	            else if ((currentValue && currentValue instanceof Vector3) && (newValue && newValue instanceof Vector3)) {
	                currentValue.copy(newValue);
	            }
	            else if (key === 'overdraw') {
	                // ensure overdraw is backwards-compatible with legacy boolean type
	                this[key] = Number(newValue);
	            }
	            else {
	                this[key] = newValue;
	            }
	        }
	    };
	    Material.prototype.toJSON = function (meta) {
	        var isRoot = meta === undefined;
	        if (isRoot) {
	            meta = {
	                textures: {},
	                images: {}
	            };
	        }
	        var data = {
	            metadata: {
	                version: 4.4,
	                type: 'Material',
	                generator: 'Material.toJSON'
	            }
	        };
	        // standard Material serialization
	        data.uuid = this.uuid;
	        data.type = this.type;
	        if (this.name !== '')
	            data.name = this.name;
	        if ((this.color && this.color instanceof Color))
	            data.color = this.color.getHex();
	        if (this.roughness !== undefined)
	            data.roughness = this.roughness;
	        if (this.metalness !== undefined)
	            data.metalness = this.metalness;
	        if ((this.emissive && this.emissive instanceof Color))
	            data.emissive = this.emissive.getHex();
	        if ((this.specular && this.specular instanceof Color))
	            data.specular = this.specular.getHex();
	        if (this.shininess !== undefined)
	            data.shininess = this.shininess;
	        if ((this.map && this.map instanceof Texture))
	            data.map = this.map.toJSON(meta).uuid;
	        if ((this.alphaMap && this.alphaMap instanceof Texture))
	            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
	        if ((this.lightMap && this.lightMap instanceof Texture))
	            data.lightMap = this.lightMap.toJSON(meta).uuid;
	        if ((this.bumpMap && this.bumpMap instanceof Texture)) {
	            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
	            data.bumpScale = this.bumpScale;
	        }
	        if ((this.normalMap && this.normalMap instanceof Texture)) {
	            data.normalMap = this.normalMap.toJSON(meta).uuid;
	            data.normalScale = this.normalScale.toArray();
	        }
	        if ((this.displacementMap && this.displacementMap instanceof Texture)) {
	            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
	            data.displacementScale = this.displacementScale;
	            data.displacementBias = this.displacementBias;
	        }
	        if ((this.roughnessMap && this.roughnessMap instanceof Texture))
	            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
	        if ((this.metalnessMap && this.metalnessMap instanceof Texture))
	            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
	        if ((this.emissiveMap && this.emissiveMap instanceof Texture))
	            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
	        if ((this.specularMap && this.specularMap instanceof Texture))
	            data.specularMap = this.specularMap.toJSON(meta).uuid;
	        if ((this.envMap && this.envMap instanceof Texture)) {
	            data.envMap = this.envMap.toJSON(meta).uuid;
	            data.reflectivity = this.reflectivity; // Scale behind envMap
	        }
	        if (this.size !== undefined)
	            data.size = this.size;
	        if (this.sizeAttenuation !== undefined)
	            data.sizeAttenuation = this.sizeAttenuation;
	        if (this.blending !== exports.BlendingMode.Normal)
	            data.blending = this.blending;
	        if (this.shading !== exports.ShadingMode.Smooth)
	            data.shading = this.shading;
	        if (this.side !== exports.SideMode.Front)
	            data.side = this.side;
	        if (this.vertexColors !== exports.ColorsMode.None)
	            data.vertexColors = this.vertexColors;
	        if (this.opacity < 1)
	            data.opacity = this.opacity;
	        if (this.transparent === true)
	            data.transparent = this.transparent;
	        data.depthFunc = this.depthFunc;
	        data.depthTest = this.depthTest;
	        data.depthWrite = this.depthWrite;
	        if (this.alphaTest > 0)
	            data.alphaTest = this.alphaTest;
	        if (this.premultipliedAlpha === true)
	            data.premultipliedAlpha = this.premultipliedAlpha;
	        if (this.wireframe === true)
	            data.wireframe = this.wireframe;
	        if (this.wireframeLinewidth > 1)
	            data.wireframeLinewidth = this.wireframeLinewidth;
	        if (this.wireframeLinecap !== 'round')
	            data.wireframeLinecap = this.wireframeLinecap;
	        if (this.wireframeLinejoin !== 'round')
	            data.wireframeLinejoin = this.wireframeLinejoin;
	        data.skinning = this.skinning;
	        data.morphTargets = this.morphTargets;
	        // TODO: Copied from Object3D.toJSON
	        function extractFromCache(cache) {
	            var values = [];
	            for (var key in cache) {
	                var data_1 = cache[key];
	                delete data_1.metadata;
	                values.push(data_1);
	            }
	            return values;
	        }
	        if (isRoot) {
	            var textures = extractFromCache(meta.textures);
	            var images = extractFromCache(meta.images);
	            if (textures.length > 0)
	                data.textures = textures;
	            if (images.length > 0)
	                data.images = images;
	        }
	        return data;
	    };
	    Material.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Material.prototype.copy = function (source) {
	        this.name = source.name;
	        this.fog = source.fog;
	        this.lights = source.lights;
	        this.blending = source.blending;
	        this.side = source.side;
	        this.shading = source.shading;
	        this.vertexColors = source.vertexColors;
	        this.opacity = source.opacity;
	        this.transparent = source.transparent;
	        this.blendSrc = source.blendSrc;
	        this.blendDst = source.blendDst;
	        this.blendEquation = source.blendEquation;
	        this.blendSrcAlpha = source.blendSrcAlpha;
	        this.blendDstAlpha = source.blendDstAlpha;
	        this.blendEquationAlpha = source.blendEquationAlpha;
	        this.depthFunc = source.depthFunc;
	        this.depthTest = source.depthTest;
	        this.depthWrite = source.depthWrite;
	        this.colorWrite = source.colorWrite;
	        this.precision = source.precision;
	        this.polygonOffset = source.polygonOffset;
	        this.polygonOffsetFactor = source.polygonOffsetFactor;
	        this.polygonOffsetUnits = source.polygonOffsetUnits;
	        this.alphaTest = source.alphaTest;
	        this.premultipliedAlpha = source.premultipliedAlpha;
	        this.overdraw = source.overdraw;
	        this.visible = source.visible;
	        this.clipShadows = source.clipShadows;
	        this.clipIntersection = source.clipIntersection;
	        var srcPlanes = source.clippingPlanes, dstPlanes = null;
	        if (srcPlanes !== null) {
	            var n = srcPlanes.length;
	            dstPlanes = new Array(n);
	            for (var i = 0; i !== n; ++i)
	                dstPlanes[i] = srcPlanes[i].clone();
	        }
	        this.clippingPlanes = dstPlanes;
	        return this;
	    };
	    Material.prototype.update = function () {
	        this.dispatchEvent({ type: 'update' });
	    };
	    Material.prototype.dispose = function () {
	        this.dispatchEvent({ type: 'dispose' });
	    };
	    Object.defineProperty(Material.prototype, "wrapAround", {
	        get: function () {
	            console.warn("THREE." + this.type + ": .wrapAround has been removed.");
	            return false;
	        },
	        set: function (value) {
	            console.warn("THREE." + this.type + ": .wrapAround has been removed.");
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Material.prototype, "wrapRGB", {
	        get: function () {
	            console.warn("THREE." + this.type + ": .wrapRGB has been removed.");
	            return new Color();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Material;
	}(EventDispatcher));
	var count$1 = 0;
	function MaterialIdCount() { return count$1++; }

	var ShaderMaterial = /** @class */ (function (_super) {
	    __extends(ShaderMaterial, _super);
	    function ShaderMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        // }
	        _this.isShaderMaterial = true;
	        _this.type = 'ShaderMaterial';
	        _this.defines = {};
	        _this.uniforms = {};
	        _this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}';
	        _this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}';
	        _this.linewidth = 1;
	        _this.wireframe = false;
	        _this.wireframeLinewidth = 1;
	        _this.fog = false; // set to use scene fog
	        _this.lights = false; // set to use scene lights
	        _this.clipping = false; // set to use user-defined clipping planes
	        _this.skinning = false; // set to use skinning attribute streams
	        _this.morphTargets = false; // set to use morph targets
	        _this.morphNormals = false; // set to use morph normals
	        _this.extensions = {
	            derivatives: false,
	            fragDepth: false,
	            drawBuffers: false,
	            shaderTextureLOD: false // set to use shader texture LOD
	        };
	        // When rendered geometry doesn't include these attributes but the material does,
	        // use these default values in WebGL. This avoids errors when buffer data is missing.
	        _this.defaultAttributeValues = {
	            'color': [1, 1, 1],
	            'uv': [0, 0],
	            'uv2': [0, 0]
	        };
	        _this.index0AttributeName = undefined;
	        if (parameters !== undefined) {
	            _this.setValues(parameters);
	        }
	        return _this;
	    }
	    ShaderMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.fragmentShader = source.fragmentShader;
	        this.vertexShader = source.vertexShader;
	        this.uniforms = UniformsUtils.clone(source.uniforms);
	        this.defines = source.defines;
	        this.wireframe = source.wireframe;
	        this.wireframeLinewidth = source.wireframeLinewidth;
	        this.lights = source.lights;
	        this.clipping = source.clipping;
	        this.skinning = source.skinning;
	        this.morphTargets = source.morphTargets;
	        this.morphNormals = source.morphNormals;
	        this.extensions = source.extensions;
	        return this;
	    };
	    ShaderMaterial.prototype.toJSON = function (meta) {
	        var data = _super.prototype.toJSON.call(this, meta);
	        data.uniforms = this.uniforms;
	        data.vertexShader = this.vertexShader;
	        data.fragmentShader = this.fragmentShader;
	        return data;
	    };
	    Object.defineProperty(ShaderMaterial.prototype, "derivatives", {
	        get: function () {
	            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
	            return this.extensions.derivatives;
	        },
	        set: function (value) {
	            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
	            this.extensions.derivatives = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ShaderMaterial;
	}(Material));

	var MeshDepthMaterial = /** @class */ (function (_super) {
	    __extends(MeshDepthMaterial, _super);
	    function MeshDepthMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        _this.isMeshDepthMaterial = true;
	        _this.type = 'MeshDepthMaterial';
	        _this.depthPacking = exports.DepthPacking.Basic;
	        _this.skinning = false;
	        _this.morphTargets = false;
	        _this.map = null;
	        _this.alphaMap = null;
	        _this.displacementMap = null;
	        _this.displacementScale = 1;
	        _this.displacementBias = 0;
	        _this.wireframe = false;
	        _this.wireframeLinewidth = 1;
	        _this.fog = false;
	        _this.lights = false;
	        _this.setValues(parameters);
	        return _this;
	    }
	    MeshDepthMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.depthPacking = source.depthPacking;
	        this.skinning = source.skinning;
	        this.morphTargets = source.morphTargets;
	        this.map = source.map;
	        this.alphaMap = source.alphaMap;
	        this.displacementMap = source.displacementMap;
	        this.displacementScale = source.displacementScale;
	        this.displacementBias = source.displacementBias;
	        this.wireframe = source.wireframe;
	        this.wireframeLinewidth = source.wireframeLinewidth;
	        return this;
	    };
	    return MeshDepthMaterial;
	}(Material));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var Face3 = /** @class */ (function () {
	    function Face3(a, b, c, normal, color, materialIndex) {
	        this.a = a;
	        this.b = b;
	        this.c = c;
	        this.normal = (normal && normal instanceof Vector3) ? normal : new Vector3();
	        this.vertexNormals = Array.isArray(normal) ? normal : [];
	        this.color = (color && color instanceof Color) ? color : new Color();
	        this.vertexColors = Array.isArray(color) ? color : [];
	        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	    }
	    Face3.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Face3.prototype.copy = function (source) {
	        this.a = source.a;
	        this.b = source.b;
	        this.c = source.c;
	        this.normal.copy(source.normal);
	        this.color.copy(source.color);
	        this.materialIndex = source.materialIndex;
	        for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
	            this.vertexNormals[i] = source.vertexNormals[i].clone();
	        }
	        for (var i = 0, il = source.vertexColors.length; i < il; i++) {
	            this.vertexColors[i] = source.vertexColors[i].clone();
	        }
	        return this;
	    };
	    return Face3;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Layers = /** @class */ (function () {
	    function Layers() {
	        this.mask = 1;
	    }
	    Layers.prototype.set = function (channel) {
	        this.mask = 1 << channel;
	    };
	    Layers.prototype.enable = function (channel) {
	        this.mask |= 1 << channel;
	    };
	    Layers.prototype.toggle = function (channel) {
	        this.mask ^= 1 << channel;
	    };
	    Layers.prototype.disable = function (channel) {
	        this.mask &= ~(1 << channel);
	    };
	    Layers.prototype.test = function (layers) {
	        return (this.mask & layers.mask) !== 0;
	    };
	    return Layers;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */
	var Object3D = /** @class */ (function (_super) {
	    __extends(Object3D, _super);
	    function Object3D() {
	        var _this = _super.call(this) || this;
	        _this.id = Object3DIdCount();
	        _this.uuid = _Math.generateUUID();
	        _this.name = '';
	        _this.type = 'Object3D';
	        _this.parent = null;
	        _this.children = [];
	        _this.up = Object3D.DefaultUp.clone();
	        _this.position = new Vector3();
	        _this.rotation = new Euler();
	        _this.quaternion = new Quaternion();
	        _this.scale = new Vector3(1, 1, 1);
	        _this.modelViewMatrix = new Matrix4();
	        _this.normalMatrix = new Matrix3();
	        _this.matrix = new Matrix4();
	        _this.matrixWorld = new Matrix4();
	        _this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	        _this.matrixWorldNeedsUpdate = false;
	        _this.layers = new Layers();
	        _this.visible = true;
	        _this.castShadow = false;
	        _this.receiveShadow = false;
	        _this.frustumCulled = true;
	        _this.renderOrder = 0;
	        _this.userData = {};
	        _this.onBeforeRender = function () { };
	        _this.onAfterRender = function () { };
	        _this.geometry = undefined;
	        _this.material = undefined;
	        // }
	        _this.isObject3D = true;
	        var rotation = _this.rotation;
	        var quaternion = _this.quaternion;
	        function onRotationChange() {
	            quaternion.setFromEuler(rotation, false);
	        }
	        function onQuaternionChange() {
	            rotation.setFromQuaternion(quaternion, undefined, false);
	        }
	        rotation.onChange(onRotationChange);
	        quaternion.onChange(onQuaternionChange);
	        return _this;
	    }
	    Object3D.prototype.applyMatrix = function (matrix) {
	        this.matrix.multiplyMatrices(matrix, this.matrix);
	        this.matrix.decompose(this.position, this.quaternion, this.scale);
	    };
	    Object3D.prototype.setRotationFromAxisAngle = function (axis, angle) {
	        // assumes axis is normalized
	        this.quaternion.setFromAxisAngle(axis, angle);
	    };
	    Object3D.prototype.setRotationFromEuler = function (euler) {
	        this.quaternion.setFromEuler(euler, true);
	    };
	    Object3D.prototype.setRotationFromMatrix = function (m) {
	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	        this.quaternion.setFromRotationMatrix(m);
	    };
	    Object3D.prototype.setRotationFromQuaternion = function (q) {
	        // assumes q is normalized
	        this.quaternion.copy(q);
	    };
	    Object3D.prototype.rotateOnAxis = function (axis, angle) {
	        // rotate object on axis in object space
	        // axis is assumed to be normalized
	        var q1 = Object3D._rotateOnAxis_q1;
	        q1.setFromAxisAngle(axis, angle);
	        this.quaternion.multiply(q1);
	        return this;
	    };
	    Object3D.prototype.rotateX = function (angle) {
	        var v1 = Object3D._rotateX_v1;
	        return this.rotateOnAxis(v1, angle);
	    };
	    Object3D.prototype.rotateY = function (angle) {
	        var v1 = Object3D._rotateY_v1;
	        return this.rotateOnAxis(v1, angle);
	    };
	    Object3D.prototype.rotateZ = function (angle) {
	        var v1 = Object3D._rotateZ_v1;
	        return this.rotateOnAxis(v1, angle);
	    };
	    Object3D.prototype.translateOnAxis = function (axis, distance) {
	        // translate object by distance along axis in object space
	        // axis is assumed to be normalized
	        var v1 = Object3D._translateOnAxis_v1;
	        v1.copy(axis).applyQuaternion(this.quaternion);
	        this.position.add(v1.multiplyScalar(distance));
	        return this;
	    };
	    Object3D.prototype.translateX = function (distance) {
	        var v1 = Object3D._translateX_v1;
	        return this.translateOnAxis(v1, distance);
	    };
	    Object3D.prototype.translateY = function (distance) {
	        var v1 = Object3D._translateY_v1;
	        return this.translateOnAxis(v1, distance);
	    };
	    Object3D.prototype.translateZ = function (distance) {
	        var v1 = Object3D._translateZ_v1;
	        return this.translateOnAxis(v1, distance);
	    };
	    Object3D.prototype.localToWorld = function (vector) {
	        return vector.applyMatrix4(this.matrixWorld);
	    };
	    Object3D.prototype.worldToLocal = function (vector) {
	        var m1 = Object3D._worldToLocal_m1;
	        return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
	    };
	    Object3D.prototype.lookAt = function (vector) {
	        // This routine does not support objects with rotated and/or translated parent(s)
	        var m1 = Object3D._lookAt_m1;
	        m1.lookAt(vector, this.position, this.up);
	        this.quaternion.setFromRotationMatrix(m1);
	    };
	    Object3D.prototype.add = function (object) {
	        if (arguments.length > 1) {
	            for (var i = 0; i < arguments.length; i++) {
	                this.add(arguments[i]);
	            }
	            return this;
	        }
	        if (object === this) {
	            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
	            return this;
	        }
	        if ((object && object instanceof Object3D)) {
	            if (object.parent !== null) {
	                object.parent.remove(object);
	            }
	            object.parent = this;
	            object.dispatchEvent({ type: 'added' });
	            this.children.push(object);
	        }
	        else {
	            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
	        }
	        return this;
	    };
	    Object3D.prototype.remove = function (object) {
	        if (arguments.length > 1) {
	            for (var i = 0; i < arguments.length; i++) {
	                this.remove(arguments[i]);
	            }
	        }
	        var index = this.children.indexOf(object);
	        if (index !== -1) {
	            object.parent = null;
	            object.dispatchEvent({ type: 'removed' });
	            this.children.splice(index, 1);
	        }
	    };
	    Object3D.prototype.getObjectById = function (id) {
	        return this.getObjectByProperty('id', id);
	    };
	    Object3D.prototype.getObjectByName = function (name) {
	        return this.getObjectByProperty('name', name);
	    };
	    Object3D.prototype.getObjectByProperty = function (name, value) {
	        if (this[name] === value)
	            return this;
	        for (var i = 0, l = this.children.length; i < l; i++) {
	            var child = this.children[i];
	            var object = child.getObjectByProperty(name, value);
	            if (object !== undefined) {
	                return object;
	            }
	        }
	        return undefined;
	    };
	    Object3D.prototype.getWorldPosition = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        this.updateMatrixWorld(true);
	        return result.setFromMatrixPosition(this.matrixWorld);
	    };
	    Object3D.prototype.getWorldQuaternion = function (result) {
	        if (result === void 0) { result = new Quaternion(); }
	        var position = Object3D._getWorldQuaternion_position;
	        var scale = Object3D._getWorldQuaternion_scale;
	        this.updateMatrixWorld(true);
	        this.matrixWorld.decompose(position, result, scale);
	        return result;
	    };
	    Object3D.prototype.getWorldRotation = function (result) {
	        if (result === void 0) { result = new Euler(); }
	        var quaternion = Object3D._getWorldRotation_quaternion;
	        this.getWorldQuaternion(quaternion);
	        return result.setFromQuaternion(quaternion, this.rotation.order, false);
	    };
	    Object3D.prototype.getWorldScale = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        var position = Object3D._getWorldScale_position;
	        var quaternion = Object3D._getWorldScale_quaternion;
	        this.updateMatrixWorld(true);
	        this.matrixWorld.decompose(position, quaternion, result);
	        return result;
	    };
	    Object3D.prototype.getWorldDirection = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        var quaternion = Object3D._getWorldDirection_quaternion;
	        this.getWorldQuaternion(quaternion);
	        return result.set(0, 0, 1).applyQuaternion(quaternion);
	    };
	    Object3D.prototype.raycast = function (raycaster, intersects) {
	        return intersects;
	    };
	    Object3D.prototype.traverse = function (callback) {
	        callback(this);
	        var children = this.children;
	        for (var i = 0, l = children.length; i < l; i++) {
	            children[i].traverse(callback);
	        }
	    };
	    Object3D.prototype.traverseVisible = function (callback) {
	        if (this.visible === false)
	            return;
	        callback(this);
	        var children = this.children;
	        for (var i = 0, l = children.length; i < l; i++) {
	            children[i].traverseVisible(callback);
	        }
	    };
	    Object3D.prototype.traverseAncestors = function (callback) {
	        var parent = this.parent;
	        if (parent !== null) {
	            callback(parent);
	            parent.traverseAncestors(callback);
	        }
	    };
	    Object3D.prototype.updateMatrix = function () {
	        this.matrix.compose(this.position, this.quaternion, this.scale);
	        this.matrixWorldNeedsUpdate = true;
	    };
	    Object3D.prototype.updateMatrixWorld = function (force) {
	        if (force === void 0) { force = false; }
	        if (this.matrixAutoUpdate === true)
	            this.updateMatrix();
	        if (this.matrixWorldNeedsUpdate === true || force === true) {
	            if (this.parent === null) {
	                this.matrixWorld.copy(this.matrix);
	            }
	            else {
	                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
	            }
	            this.matrixWorldNeedsUpdate = false;
	            force = true;
	        }
	        // update children
	        var children = this.children;
	        for (var i = 0, l = children.length; i < l; i++) {
	            children[i].updateMatrixWorld(force);
	        }
	    };
	    Object3D.prototype.toJSON = function (meta) {
	        // meta is '' when called from JSON.stringify
	        var isRootObject = (meta === undefined || meta === '');
	        var output = {};
	        // meta is a hash used to collect geometries, materials.
	        // not providing it implies that this is the root object
	        // being serialized.
	        if (isRootObject) {
	            // initialize meta obj
	            meta = {
	                geometries: {},
	                materials: {},
	                textures: {},
	                images: {}
	            };
	            output.metadata = {
	                version: 4.4,
	                type: 'Object',
	                generator: 'Object3D.toJSON'
	            };
	        }
	        // standard Object3D serialization
	        var object = {};
	        object.uuid = this.uuid;
	        object.type = this.type;
	        if (this.name !== '')
	            object.name = this.name;
	        if (JSON.stringify(this.userData) !== '{}')
	            object.userData = this.userData;
	        if (this.castShadow === true)
	            object.castShadow = true;
	        if (this.receiveShadow === true)
	            object.receiveShadow = true;
	        if (this.visible === false)
	            object.visible = false;
	        object.matrix = this.matrix.toArray();
	        //
	        if (this.geometry !== undefined) {
	            if (meta.geometries[this.geometry.uuid] === undefined) {
	                meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
	            }
	            object.geometry = this.geometry.uuid;
	        }
	        if (this.material !== undefined) {
	            if (meta.materials[this.material.uuid] === undefined) {
	                meta.materials[this.material.uuid] = this.material.toJSON(meta);
	            }
	            object.material = this.material.uuid;
	        }
	        //
	        if (this.children.length > 0) {
	            object.children = [];
	            for (var i = 0; i < this.children.length; i++) {
	                object.children.push(this.children[i].toJSON(meta).object);
	            }
	        }
	        if (isRootObject) {
	            var geometries = extractFromCache(meta.geometries);
	            var materials = extractFromCache(meta.materials);
	            var textures = extractFromCache(meta.textures);
	            var images = extractFromCache(meta.images);
	            if (geometries.length > 0)
	                output.geometries = geometries;
	            if (materials.length > 0)
	                output.materials = materials;
	            if (textures.length > 0)
	                output.textures = textures;
	            if (images.length > 0)
	                output.images = images;
	        }
	        output.object = object;
	        return output;
	        // extract data from the cache hash
	        // remove metadata on each item
	        // and return as array
	        function extractFromCache(cache) {
	            var values = [];
	            for (var key in cache) {
	                var data = cache[key];
	                delete data.metadata;
	                values.push(data);
	            }
	            return values;
	        }
	    };
	    Object3D.prototype.clone = function (recursive) {
	        if (recursive === void 0) { recursive = true; }
	        return new this.constructor().copy(this, recursive);
	    };
	    Object3D.prototype.copy = function (source, recursive) {
	        if (recursive === void 0) { recursive = true; }
	        this.name = source.name;
	        this.up.copy(source.up);
	        this.position.copy(source.position);
	        this.quaternion.copy(source.quaternion);
	        this.scale.copy(source.scale);
	        this.matrix.copy(source.matrix);
	        this.matrixWorld.copy(source.matrixWorld);
	        this.matrixAutoUpdate = source.matrixAutoUpdate;
	        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	        this.visible = source.visible;
	        this.castShadow = source.castShadow;
	        this.receiveShadow = source.receiveShadow;
	        this.frustumCulled = source.frustumCulled;
	        this.renderOrder = source.renderOrder;
	        this.userData = JSON.parse(JSON.stringify(source.userData));
	        if (recursive === true) {
	            for (var i = 0; i < source.children.length; i++) {
	                var child = source.children[i];
	                this.add(child.clone());
	            }
	        }
	        return this;
	    };
	    Object3D.prototype.getChildByName = function (name) {
	        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
	        return this.getObjectByName(name);
	    };
	    Object3D.prototype.renderDepth = function (value) {
	        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
	    };
	    Object3D.prototype.translate = function (distance, axis) {
	        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis(axis, distance) instead.");
	        return this.translateOnAxis(axis, distance);
	    };
	    Object.defineProperty(Object3D.prototype, "eulerOrder", {
	        get: function () {
	            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
	            return this.rotation.order;
	        },
	        set: function (value) {
	            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
	            this.rotation.order = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Object3D.prototype, "useQuaternion", {
	        get: function () {
	            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
	            return true;
	        },
	        set: function (value) {
	            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object3D.DefaultUp = new Vector3(0, 1, 0);
	    Object3D.DefaultMatrixAutoUpdate = true;
	    Object3D._rotateOnAxis_q1 = new Quaternion();
	    Object3D._rotateX_v1 = new Vector3(1, 0, 0);
	    Object3D._rotateY_v1 = new Vector3(0, 1, 0);
	    Object3D._rotateZ_v1 = new Vector3(0, 0, 1);
	    Object3D._translateOnAxis_v1 = new Vector3();
	    Object3D._translateX_v1 = new Vector3(1, 0, 0);
	    Object3D._translateY_v1 = new Vector3(0, 1, 0);
	    Object3D._translateZ_v1 = new Vector3(0, 0, 1);
	    Object3D._worldToLocal_m1 = new Matrix4();
	    Object3D._lookAt_m1 = new Matrix4();
	    Object3D._getWorldQuaternion_position = new Vector3();
	    Object3D._getWorldQuaternion_scale = new Vector3();
	    Object3D._getWorldRotation_quaternion = new Quaternion();
	    Object3D._getWorldScale_position = new Vector3();
	    Object3D._getWorldScale_quaternion = new Quaternion();
	    Object3D._getWorldDirection_quaternion = new Quaternion();
	    return Object3D;
	}(EventDispatcher));
	var count$2 = 0;
	function Object3DIdCount() { return count$2++; }

	/**
	 * @author bhouston / http://clara.io
	 */
	var Ray = /** @class */ (function () {
	    function Ray(origin, direction) {
	        if (origin === void 0) { origin = new Vector3(); }
	        if (direction === void 0) { direction = new Vector3(); }
	        this.origin = origin;
	        this.direction = direction;
	    }
	    Ray.prototype.set = function (origin, direction) {
	        this.origin.copy(origin);
	        this.direction.copy(direction);
	        return this;
	    };
	    Ray.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Ray.prototype.copy = function (ray) {
	        this.origin.copy(ray.origin);
	        this.direction.copy(ray.direction);
	        return this;
	    };
	    Ray.prototype.at = function (t, result) {
	        if (result === void 0) { result = new Vector3(); }
	        return result.copy(this.direction).multiplyScalar(t).add(this.origin);
	    };
	    Ray.prototype.lookAt = function (v) {
	        this.direction.copy(v).sub(this.origin).normalize();
	        return this;
	    };
	    Ray.prototype.recast = function (t) {
	        var v1 = Ray.recast_v1;
	        this.origin.copy(this.at(t, v1));
	        return this;
	    };
	    Ray.prototype.closestPointToPoint = function (point, result) {
	        if (result === void 0) { result = new Vector3(); }
	        result.subVectors(point, this.origin);
	        var directionDistance = result.dot(this.direction);
	        if (directionDistance < 0) {
	            return result.copy(this.origin);
	        }
	        return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
	    };
	    Ray.prototype.distanceToPoint = function (point) {
	        return Math.sqrt(this.distanceSqToPoint(point));
	    };
	    Ray.prototype.distanceSqToPoint = function (point) {
	        var v1 = Ray.distanceSqToPoint_v1;
	        var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
	        // point behind the ray
	        if (directionDistance < 0) {
	            return this.origin.distanceToSquared(point);
	        }
	        v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
	        return v1.distanceToSquared(point);
	    };
	    Ray.prototype.distanceSqToSegment = function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
	        var segCenter = Ray.distanceSqToSegment_segCenter;
	        var segDir = Ray.distanceSqToSegment_segDir;
	        var diff = Ray.distanceSqToSegment_diff;
	        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
	        // It returns the min distance between the ray and the segment
	        // defined by v0 and v1
	        // It can also set two optional targets :
	        // - The closest point on the ray
	        // - The closest point on the segment
	        segCenter.copy(v0).add(v1).multiplyScalar(0.5);
	        segDir.copy(v1).sub(v0).normalize();
	        diff.copy(this.origin).sub(segCenter);
	        var segExtent = v0.distanceTo(v1) * 0.5;
	        var a01 = -this.direction.dot(segDir);
	        var b0 = diff.dot(this.direction);
	        var b1 = -diff.dot(segDir);
	        var c = diff.lengthSq();
	        var det = Math.abs(1 - a01 * a01);
	        var s0, s1, sqrDist, extDet;
	        if (det > 0) {
	            // The ray and segment are not parallel.
	            s0 = a01 * b1 - b0;
	            s1 = a01 * b0 - b1;
	            extDet = segExtent * det;
	            if (s0 >= 0) {
	                if (s1 >= -extDet) {
	                    if (s1 <= extDet) {
	                        // region 0
	                        // Minimum at interior points of ray and segment.
	                        var invDet = 1 / det;
	                        s0 *= invDet;
	                        s1 *= invDet;
	                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
	                    }
	                    else {
	                        // region 1
	                        s1 = segExtent;
	                        s0 = Math.max(0, -(a01 * s1 + b0));
	                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
	                    }
	                }
	                else {
	                    // region 5
	                    s1 = -segExtent;
	                    s0 = Math.max(0, -(a01 * s1 + b0));
	                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
	                }
	            }
	            else {
	                if (s1 <= -extDet) {
	                    // region 4
	                    s0 = Math.max(0, -(-a01 * segExtent + b0));
	                    s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
	                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
	                }
	                else if (s1 <= extDet) {
	                    // region 3
	                    s0 = 0;
	                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
	                    sqrDist = s1 * (s1 + 2 * b1) + c;
	                }
	                else {
	                    // region 2
	                    s0 = Math.max(0, -(a01 * segExtent + b0));
	                    s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
	                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
	                }
	            }
	        }
	        else {
	            // Ray and segment are parallel.
	            s1 = (a01 > 0) ? -segExtent : segExtent;
	            s0 = Math.max(0, -(a01 * s1 + b0));
	            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
	        }
	        if (optionalPointOnRay) {
	            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
	        }
	        if (optionalPointOnSegment) {
	            optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
	        }
	        return sqrDist;
	    };
	    Ray.prototype.intersectSphere = function (sphere, optionalTarget) {
	        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
	        var v1 = Ray.intersectSphere_v1;
	        v1.subVectors(sphere.center, this.origin);
	        var tca = v1.dot(this.direction);
	        var d2 = v1.dot(v1) - tca * tca;
	        var radius2 = sphere.radius * sphere.radius;
	        if (d2 > radius2)
	            return null;
	        var thc = Math.sqrt(radius2 - d2);
	        // t0 = first intersect point - entrance on front of sphere
	        var t0 = tca - thc;
	        // t1 = second intersect point - exit point on back of sphere
	        var t1 = tca + thc;
	        // test to see if both t0 and t1 are behind the ray - if so, return null
	        if (t0 < 0 && t1 < 0)
	            return null;
	        // test to see if t0 is behind the ray:
	        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
	        // in order to always return an intersect point that is in front of the ray.
	        if (t0 < 0)
	            return this.at(t1, optionalTarget);
	        // else t0 is in front of the ray, so return the first collision point scaled by t0
	        return this.at(t0, optionalTarget);
	    };
	    Ray.prototype.intersectsSphere = function (sphere) {
	        return this.distanceToPoint(sphere.center) <= sphere.radius;
	    };
	    Ray.prototype.distanceToPlane = function (plane) {
	        var denominator = plane.normal.dot(this.direction);
	        if (denominator === 0) {
	            // line is coplanar, return origin
	            if (plane.distanceToPoint(this.origin) === 0) {
	                return 0;
	            }
	            // Null is preferable to undefined since undefined means.... it is undefined
	            return null;
	        }
	        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
	        // Return if the ray never intersects the plane
	        return t >= 0 ? t : null;
	    };
	    Ray.prototype.intersectPlane = function (plane, optionalTarget) {
	        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
	        var t = this.distanceToPlane(plane);
	        if (t === null) {
	            return null;
	        }
	        return this.at(t, optionalTarget);
	    };
	    Ray.prototype.intersectsPlane = function (plane) {
	        // check if the ray lies on the plane first
	        var distToPoint = plane.distanceToPoint(this.origin);
	        if (distToPoint === 0) {
	            return true;
	        }
	        var denominator = plane.normal.dot(this.direction);
	        if (denominator * distToPoint < 0) {
	            return true;
	        }
	        // ray origin is behind the plane (and is pointing behind it)
	        return false;
	    };
	    Ray.prototype.intersectBox = function (box, optionalTarget) {
	        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
	        var tmin, tmax, tymin, tymax, tzmin, tzmax;
	        var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
	        var origin = this.origin;
	        if (invdirx >= 0) {
	            tmin = (box.min.x - origin.x) * invdirx;
	            tmax = (box.max.x - origin.x) * invdirx;
	        }
	        else {
	            tmin = (box.max.x - origin.x) * invdirx;
	            tmax = (box.min.x - origin.x) * invdirx;
	        }
	        if (invdiry >= 0) {
	            tymin = (box.min.y - origin.y) * invdiry;
	            tymax = (box.max.y - origin.y) * invdiry;
	        }
	        else {
	            tymin = (box.max.y - origin.y) * invdiry;
	            tymax = (box.min.y - origin.y) * invdiry;
	        }
	        if ((tmin > tymax) || (tymin > tmax))
	            return null;
	        // These lines also handle the case where tmin or tmax is NaN
	        // (result of 0 * Infinity). x !== x returns true if x is NaN
	        if (tymin > tmin || tmin !== tmin)
	            tmin = tymin;
	        if (tymax < tmax || tmax !== tmax)
	            tmax = tymax;
	        if (invdirz >= 0) {
	            tzmin = (box.min.z - origin.z) * invdirz;
	            tzmax = (box.max.z - origin.z) * invdirz;
	        }
	        else {
	            tzmin = (box.max.z - origin.z) * invdirz;
	            tzmax = (box.min.z - origin.z) * invdirz;
	        }
	        if ((tmin > tzmax) || (tzmin > tmax))
	            return null;
	        if (tzmin > tmin || tmin !== tmin)
	            tmin = tzmin;
	        if (tzmax < tmax || tmax !== tmax)
	            tmax = tzmax;
	        //return point closest to the ray (positive side)
	        if (tmax < 0)
	            return null;
	        return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
	    };
	    Ray.prototype.intersectsBox = function (box) {
	        var v = Ray.intersectsBox_v;
	        return this.intersectBox(box, v) !== null;
	    };
	    Ray.prototype.intersectTriangle = function (a, b, c, backfaceCulling, optionalTarget) {
	        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
	        // Compute the offset origin, edges, and normal.
	        var diff = Ray.intersectTriangle_diff;
	        var edge1 = Ray.intersectTriangle_edge1;
	        var edge2 = Ray.intersectTriangle_edge2;
	        var normal = Ray.intersectTriangle_normal;
	        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
	        edge1.subVectors(b, a);
	        edge2.subVectors(c, a);
	        normal.crossVectors(edge1, edge2);
	        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
	        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
	        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
	        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
	        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
	        var DdN = this.direction.dot(normal);
	        var sign;
	        if (DdN > 0) {
	            if (backfaceCulling)
	                return null;
	            sign = 1;
	        }
	        else if (DdN < 0) {
	            sign = -1;
	            DdN = -DdN;
	        }
	        else {
	            return null;
	        }
	        diff.subVectors(this.origin, a);
	        var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
	        // b1 < 0, no intersection
	        if (DdQxE2 < 0) {
	            return null;
	        }
	        var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
	        // b2 < 0, no intersection
	        if (DdE1xQ < 0) {
	            return null;
	        }
	        // b1+b2 > 1, no intersection
	        if (DdQxE2 + DdE1xQ > DdN) {
	            return null;
	        }
	        // Line intersects triangle, check if ray does.
	        var QdN = -sign * diff.dot(normal);
	        // t < 0, no intersection
	        if (QdN < 0) {
	            return null;
	        }
	        // Ray intersects triangle.
	        return this.at(QdN / DdN, optionalTarget);
	    };
	    Ray.prototype.applyMatrix4 = function (matrix4) {
	        this.direction.add(this.origin).applyMatrix4(matrix4);
	        this.origin.applyMatrix4(matrix4);
	        this.direction.sub(this.origin);
	        this.direction.normalize();
	        return this;
	    };
	    Ray.prototype.equals = function (ray) {
	        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
	    };
	    Ray.prototype.isIntersectionBox = function (box) {
	        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
	        return this.intersectsBox(box);
	    };
	    Ray.prototype.isIntersectionPlane = function (plane) {
	        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
	        return this.intersectsPlane(plane);
	    };
	    Ray.prototype.isIntersectionSphere = function (sphere) {
	        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
	        return this.intersectsSphere(sphere);
	    };
	    Ray.recast_v1 = new Vector3();
	    Ray.distanceSqToPoint_v1 = new Vector3();
	    Ray.distanceSqToSegment_segCenter = new Vector3();
	    Ray.distanceSqToSegment_segDir = new Vector3();
	    Ray.distanceSqToSegment_diff = new Vector3();
	    Ray.intersectSphere_v1 = new Vector3();
	    Ray.intersectsBox_v = new Vector3();
	    Ray.intersectTriangle_diff = new Vector3();
	    Ray.intersectTriangle_edge1 = new Vector3();
	    Ray.intersectTriangle_edge2 = new Vector3();
	    Ray.intersectTriangle_normal = new Vector3();
	    return Ray;
	}());

	/**
	 * @author bhouston / http://clara.io
	 */
	var Line3 = /** @class */ (function () {
	    function Line3(start, end) {
	        if (start === void 0) { start = new Vector3(); }
	        if (end === void 0) { end = new Vector3(); }
	        this.start = start;
	        this.end = end;
	    }
	    Line3.prototype.set = function (start, end) {
	        this.start.copy(start);
	        this.end.copy(end);
	        return this;
	    };
	    Line3.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Line3.prototype.copy = function (line) {
	        this.start.copy(line.start);
	        this.end.copy(line.end);
	        return this;
	    };
	    Line3.prototype.getCenter = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        return result.addVectors(this.start, this.end).multiplyScalar(0.5);
	    };
	    Line3.prototype.delta = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        return result.subVectors(this.end, this.start);
	    };
	    Line3.prototype.distanceSq = function () {
	        return this.start.distanceToSquared(this.end);
	    };
	    Line3.prototype.distance = function () {
	        return this.start.distanceTo(this.end);
	    };
	    Line3.prototype.at = function (t, result) {
	        if (result === void 0) { result = new Vector3(); }
	        return this.delta(result).multiplyScalar(t).add(this.start);
	    };
	    Line3.prototype.closestPointToPointParameter = function (point, clampToLine) {
	        var startP = Line3.closestPointToPointParameter_startP;
	        var startEnd = Line3.closestPointToPointParameter_startEnd;
	        startP.subVectors(point, this.start);
	        startEnd.subVectors(this.end, this.start);
	        var startEnd2 = startEnd.dot(startEnd);
	        var startEnd_startP = startEnd.dot(startP);
	        var t = startEnd_startP / startEnd2;
	        if (clampToLine) {
	            t = _Math.clamp(t, 0, 1);
	        }
	        return t;
	    };
	    Line3.prototype.closestPointToPoint = function (point, clampToLine, result) {
	        if (result === void 0) { result = new Vector3(); }
	        var t = this.closestPointToPointParameter(point, clampToLine);
	        return this.delta(result).multiplyScalar(t).add(this.start);
	    };
	    Line3.prototype.applyMatrix4 = function (matrix) {
	        this.start.applyMatrix4(matrix);
	        this.end.applyMatrix4(matrix);
	        return this;
	    };
	    Line3.prototype.equals = function (line) {
	        return line.start.equals(this.start) && line.end.equals(this.end);
	    };
	    Line3.prototype.center = function (result) {
	        console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
	        return this.getCenter(result);
	    };
	    Line3.closestPointToPointParameter_startP = new Vector3();
	    Line3.closestPointToPointParameter_startEnd = new Vector3();
	    return Line3;
	}());

	/**
	 * @author bhouston / http://clara.io
	 */
	var Plane = /** @class */ (function () {
	    function Plane(normal, constant) {
	        if (normal === void 0) { normal = new Vector3(1, 0, 0); }
	        if (constant === void 0) { constant = 0; }
	        this.normal = normal;
	        this.constant = constant;
	    }
	    Plane.prototype.set = function (normal, constant) {
	        this.normal.copy(normal);
	        this.constant = constant;
	        return this;
	    };
	    Plane.prototype.setComponents = function (x, y, z, w) {
	        this.normal.set(x, y, z);
	        this.constant = w;
	        return this;
	    };
	    Plane.prototype.setFromNormalAndCoplanarPoint = function (normal, point) {
	        this.normal.copy(normal);
	        this.constant = -point.dot(this.normal); // must be this.normal, not normal, as this.normal is normalized
	        return this;
	    };
	    Plane.prototype.setFromCoplanarPoints = function (a, b, c) {
	        var v1 = Plane.setFromCoplanarPoints_v1;
	        var v2 = Plane.setFromCoplanarPoints_v2;
	        var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
	        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	        this.setFromNormalAndCoplanarPoint(normal, a);
	        return this;
	    };
	    Plane.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Plane.prototype.copy = function (plane) {
	        this.normal.copy(plane.normal);
	        this.constant = plane.constant;
	        return this;
	    };
	    Plane.prototype.normalize = function () {
	        // Note: will lead to a divide by zero if the plane is invalid.
	        var inverseNormalLength = 1.0 / this.normal.length();
	        this.normal.multiplyScalar(inverseNormalLength);
	        this.constant *= inverseNormalLength;
	        return this;
	    };
	    Plane.prototype.negate = function () {
	        this.constant *= -1;
	        this.normal.negate();
	        return this;
	    };
	    Plane.prototype.distanceToPoint = function (point) {
	        return this.normal.dot(point) + this.constant;
	    };
	    Plane.prototype.distanceToSphere = function (sphere) {
	        return this.distanceToPoint(sphere.center) - sphere.radius;
	    };
	    Plane.prototype.projectPoint = function (point, result) {
	        if (result === void 0) { result = new Vector3(); }
	        return this.orthoPoint(point, result).sub(point).negate();
	    };
	    Plane.prototype.orthoPoint = function (point, result) {
	        if (result === void 0) { result = new Vector3(); }
	        var perpendicularMagnitude = this.distanceToPoint(point);
	        return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
	    };
	    Plane.prototype.intersectLine = function (line, result) {
	        if (result === void 0) { result = new Vector3(); }
	        var v1 = Plane.intersectLine_v1;
	        var direction = line.delta(v1);
	        var denominator = this.normal.dot(direction);
	        if (denominator === 0) {
	            // line is coplanar, return origin
	            if (this.distanceToPoint(line.start) === 0) {
	                return result.copy(line.start);
	            }
	            // Unsure if this is the correct method to handle this case.
	            return undefined;
	        }
	        var t = -(line.start.dot(this.normal) + this.constant) / denominator;
	        if (t < 0 || t > 1) {
	            return undefined;
	        }
	        return result.copy(direction).multiplyScalar(t).add(line.start);
	    };
	    Plane.prototype.intersectsLine = function (line) {
	        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	        var startSign = this.distanceToPoint(line.start);
	        var endSign = this.distanceToPoint(line.end);
	        return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
	    };
	    Plane.prototype.intersectsBox = function (box) {
	        return box.intersectsPlane(this);
	    };
	    Plane.prototype.intersectsSphere = function (sphere) {
	        return sphere.intersectsPlane(this);
	    };
	    Plane.prototype.coplanarPoint = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        return result.copy(this.normal).multiplyScalar(-this.constant);
	    };
	    Plane.prototype.applyMatrix4 = function (matrix, optionalNormalMatrix) {
	        var v1 = Plane.applyMatrix4_v1;
	        var m1 = Plane.applyMatrix4_m1;
	        var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
	        // transform normal based on theory here:
	        // http://www.songho.ca/opengl/gl_normaltransform.html
	        var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
	        var normal = this.normal.applyMatrix3(normalMatrix).normalize();
	        // recalculate constant (like in setFromNormalAndCoplanarPoint)
	        this.constant = -referencePoint.dot(normal);
	        return this;
	    };
	    Plane.prototype.translate = function (offset) {
	        this.constant = this.constant - offset.dot(this.normal);
	        return this;
	    };
	    Plane.prototype.equals = function (plane) {
	        return plane.normal.equals(this.normal) && (plane.constant === this.constant);
	    };
	    Plane.prototype.isIntersectionLine = function (line) {
	        console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
	        return this.intersectsLine(line);
	    };
	    Plane.setFromCoplanarPoints_v1 = new Vector3();
	    Plane.setFromCoplanarPoints_v2 = new Vector3();
	    Plane.intersectLine_v1 = new Vector3();
	    Plane.applyMatrix4_v1 = new Vector3();
	    Plane.applyMatrix4_m1 = new Matrix3();
	    return Plane;
	}());

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Triangle = /** @class */ (function () {
	    function Triangle(a, b, c) {
	        if (a === void 0) { a = new Vector3(); }
	        if (b === void 0) { b = new Vector3(); }
	        if (c === void 0) { c = new Vector3(); }
	        this.a = a;
	        this.b = b;
	        this.c = c;
	    }
	    Triangle.normal = function (a, b, c, result) {
	        if (result === void 0) { result = new Vector3(); }
	        var v0 = Triangle.normal_v0;
	        result.subVectors(c, b);
	        v0.subVectors(a, b);
	        result.cross(v0);
	        var resultLengthSq = result.lengthSq();
	        if (resultLengthSq > 0) {
	            return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
	        }
	        return result.set(0, 0, 0);
	    };
	    // static/instance method to calculate barycentric coordinates
	    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	    Triangle.barycoordFromPoint = function (point, a, b, c, result) {
	        if (result === void 0) { result = new Vector3(); }
	        var v0 = new Vector3();
	        var v1 = new Vector3();
	        var v2 = new Vector3();
	        v0.subVectors(c, a);
	        v1.subVectors(b, a);
	        v2.subVectors(point, a);
	        var dot00 = v0.dot(v0);
	        var dot01 = v0.dot(v1);
	        var dot02 = v0.dot(v2);
	        var dot11 = v1.dot(v1);
	        var dot12 = v1.dot(v2);
	        var denom = (dot00 * dot11 - dot01 * dot01);
	        // collinear or singular triangle
	        if (denom === 0) {
	            // arbitrary location outside of triangle?
	            // not sure if this is the best idea, maybe should be returning undefined
	            return result.set(-2, -1, -1);
	        }
	        var invDenom = 1 / denom;
	        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
	        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
	        // barycentric coordinates must always sum to 1
	        return result.set(1 - u - v, v, u);
	    };
	    Triangle.containsPoint = function (point, a, b, c) {
	        var v1 = new Vector3();
	        var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
	        return (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);
	    };
	    Triangle.prototype.set = function (a, b, c) {
	        this.a.copy(a);
	        this.b.copy(b);
	        this.c.copy(c);
	        return this;
	    };
	    Triangle.prototype.setFromPointsAndIndices = function (points, i0, i1, i2) {
	        this.a.copy(points[i0]);
	        this.b.copy(points[i1]);
	        this.c.copy(points[i2]);
	        return this;
	    };
	    Triangle.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Triangle.prototype.copy = function (triangle) {
	        this.a.copy(triangle.a);
	        this.b.copy(triangle.b);
	        this.c.copy(triangle.c);
	        return this;
	    };
	    Triangle.prototype.area = function () {
	        var v0 = new Vector3();
	        var v1 = new Vector3();
	        v0.subVectors(this.c, this.b);
	        v1.subVectors(this.a, this.b);
	        return v0.cross(v1).length() * 0.5;
	    };
	    Triangle.prototype.midpoint = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
	    };
	    Triangle.prototype.normal = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        return Triangle.normal(this.a, this.b, this.c, result);
	    };
	    Triangle.prototype.plane = function (result) {
	        if (result === void 0) { result = new Plane(); }
	        return result.setFromCoplanarPoints(this.a, this.b, this.c);
	    };
	    Triangle.prototype.barycoordFromPoint = function (point, result) {
	        if (result === void 0) { result = new Vector3(); }
	        return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, result);
	    };
	    Triangle.prototype.containsPoint = function (point) {
	        return Triangle.containsPoint(point, this.a, this.b, this.c);
	    };
	    Triangle.prototype.closestPointToPoint = function (point, result) {
	        if (result === void 0) { result = new Vector3(); }
	        var plane = new Plane();
	        var edgeList = [new Line3(), new Line3(), new Line3()];
	        var projectedPoint = new Vector3();
	        var closestPoint = new Vector3();
	        var minDistance = Infinity;
	        // project the point onto the plane of the triangle
	        plane.setFromCoplanarPoints(this.a, this.b, this.c);
	        plane.projectPoint(point, projectedPoint);
	        // check if the projection lies within the triangle
	        if (this.containsPoint(projectedPoint) === true) {
	            // if so, this is the closest point
	            result.copy(projectedPoint);
	        }
	        else {
	            // if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
	            edgeList[0].set(this.a, this.b);
	            edgeList[1].set(this.b, this.c);
	            edgeList[2].set(this.c, this.a);
	            for (var i = 0; i < edgeList.length; i++) {
	                edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
	                var distance = projectedPoint.distanceToSquared(closestPoint);
	                if (distance < minDistance) {
	                    minDistance = distance;
	                    result.copy(closestPoint);
	                }
	            }
	        }
	        return result;
	    };
	    Triangle.prototype.equals = function (triangle) {
	        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
	    };
	    Triangle.normal_v0 = new Vector3();
	    return Triangle;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var MultiMaterial = /** @class */ (function () {
	    function MultiMaterial(materials) {
	        if (materials === void 0) { materials = []; }
	        this.uuid = _Math.generateUUID();
	        this.type = 'MultiMaterial';
	        this.visible = true;
	        this.isMultiMaterial = true;
	        this.materials = materials;
	    }
	    // }
	    MultiMaterial.prototype.dispose = function () { };
	    MultiMaterial.prototype.toJSON = function (meta) {
	        var output = {
	            metadata: {
	                version: 4.2,
	                type: 'material',
	                generator: 'MaterialExporter'
	            },
	            uuid: this.uuid,
	            type: this.type,
	            materials: []
	        };
	        var materials = this.materials;
	        for (var i = 0, l = materials.length; i < l; i++) {
	            var material = materials[i].toJSON(meta);
	            delete material.metadata;
	            output.materials.push(material);
	        }
	        output.visible = this.visible;
	        return output;
	    };
	    MultiMaterial.prototype.clone = function () {
	        var material = new this.constructor();
	        for (var i = 0; i < this.materials.length; i++) {
	            material.materials.push(this.materials[i].clone());
	        }
	        material.visible = this.visible;
	        return material;
	    };
	    return MultiMaterial;
	}());

	var MeshBasicMaterial = /** @class */ (function (_super) {
	    __extends(MeshBasicMaterial, _super);
	    function MeshBasicMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        _this.isMeshBasicMaterial = true;
	        _this.type = 'MeshBasicMaterial';
	        _this.color = new Color(0xffffff); // emissive
	        _this.map = null;
	        _this.aoMap = null;
	        _this.aoMapIntensity = 1.0;
	        _this.specularMap = null;
	        _this.alphaMap = null;
	        _this.envMap = null;
	        _this.combine = exports.BlendingOperation.Multiply;
	        _this.reflectivity = 1;
	        _this.refractionRatio = 0.98;
	        _this.wireframe = false;
	        _this.wireframeLinewidth = 1;
	        _this.wireframeLinecap = 'round';
	        _this.wireframeLinejoin = 'round';
	        _this.skinning = false;
	        _this.morphTargets = false;
	        _this.lights = false;
	        _this.setValues(parameters);
	        return _this;
	    }
	    MeshBasicMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.color.copy(source.color);
	        this.map = source.map;
	        this.aoMap = source.aoMap;
	        this.aoMapIntensity = source.aoMapIntensity;
	        this.specularMap = source.specularMap;
	        this.alphaMap = source.alphaMap;
	        this.envMap = source.envMap;
	        this.combine = source.combine;
	        this.reflectivity = source.reflectivity;
	        this.refractionRatio = source.refractionRatio;
	        this.wireframe = source.wireframe;
	        this.wireframeLinewidth = source.wireframeLinewidth;
	        this.wireframeLinecap = source.wireframeLinecap;
	        this.wireframeLinejoin = source.wireframeLinejoin;
	        this.skinning = source.skinning;
	        this.morphTargets = source.morphTargets;
	        return this;
	    };
	    return MeshBasicMaterial;
	}(Material));

	var BufferAttribute = /** @class */ (function () {
	    function BufferAttribute(array, itemSize, normalized) {
	        if (normalized === void 0) { normalized = false; }
	        this.uuid = _Math.generateUUID();
	        this.dynamic = false;
	        this.updateRange = { offset: 0, count: -1 };
	        this.version = 0;
	        this.isBufferAttribute = true;
	        this.isInterleavedBufferAttribute = false;
	        if (Array.isArray(array)) {
	            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
	        }
	        this.array = array;
	        this.itemSize = itemSize;
	        this.count = array !== undefined ? array.length / itemSize : 0;
	        this.normalized = normalized === true;
	    }
	    Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
	        set: function (value) {
	            if (value === true)
	                this.version++;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BufferAttribute.prototype.setArray = function (array) {
	        if (Array.isArray(array)) {
	            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
	        }
	        this.count = array !== undefined ? array.length / this.itemSize : 0;
	        this.array = array;
	    };
	    BufferAttribute.prototype.setDynamic = function (value) {
	        this.dynamic = value;
	        return this;
	    };
	    BufferAttribute.prototype.copy = function (source) {
	        this.array = new source.array.constructor(source.array);
	        this.itemSize = source.itemSize;
	        this.count = source.count;
	        this.normalized = source.normalized;
	        this.dynamic = source.dynamic;
	        return this;
	    };
	    BufferAttribute.prototype.copyAt = function (index1, attribute, index2) {
	        index1 *= this.itemSize;
	        index2 *= attribute.itemSize;
	        for (var i = 0, l = this.itemSize; i < l; i++) {
	            this.array[index1 + i] = attribute.array[index2 + i];
	        }
	        return this;
	    };
	    BufferAttribute.prototype.copyArray = function (array) {
	        this.array.set(array, 0);
	        return this;
	    };
	    BufferAttribute.prototype.copyColorsArray = function (colors) {
	        var array = this.array;
	        var offset = 0;
	        for (var i = 0, l = colors.length; i < l; i++) {
	            var color = colors[i];
	            if (color === undefined) {
	                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
	                color = new Color();
	            }
	            array[offset++] = color.r;
	            array[offset++] = color.g;
	            array[offset++] = color.b;
	        }
	        return this;
	    };
	    BufferAttribute.prototype.copyIndicesArray = function (indices) {
	        var array = this.array;
	        var offset = 0;
	        for (var i = 0, l = indices.length; i < l; i++) {
	            var index = indices[i];
	            array[offset++] = index.a;
	            array[offset++] = index.b;
	            array[offset++] = index.c;
	        }
	        return this;
	    };
	    BufferAttribute.prototype.copyVector2sArray = function (vectors) {
	        var array = this.array;
	        var offset = 0;
	        for (var i = 0, l = vectors.length; i < l; i++) {
	            var vector = vectors[i];
	            if (vector === undefined) {
	                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
	                vector = new Vector2();
	            }
	            array[offset++] = vector.x;
	            array[offset++] = vector.y;
	        }
	        return this;
	    };
	    BufferAttribute.prototype.copyVector3sArray = function (vectors) {
	        var array = this.array;
	        var offset = 0;
	        for (var i = 0, l = vectors.length; i < l; i++) {
	            var vector = vectors[i];
	            if (vector === undefined) {
	                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
	                vector = new Vector3();
	            }
	            array[offset++] = vector.x;
	            array[offset++] = vector.y;
	            array[offset++] = vector.z;
	        }
	        return this;
	    };
	    BufferAttribute.prototype.copyVector4sArray = function (vectors) {
	        var array = this.array;
	        var offset = 0;
	        for (var i = 0, l = vectors.length; i < l; i++) {
	            var vector = vectors[i];
	            if (vector === undefined) {
	                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
	                vector = new Vector4();
	            }
	            array[offset++] = vector.x;
	            array[offset++] = vector.y;
	            array[offset++] = vector.z;
	            array[offset++] = vector.w;
	        }
	        return this;
	    };
	    BufferAttribute.prototype.set = function (value, offset) {
	        if (offset === void 0) { offset = 0; }
	        this.array.set(value, offset);
	        return this;
	    };
	    BufferAttribute.prototype.getX = function (index) {
	        return this.array[index * this.itemSize];
	    };
	    BufferAttribute.prototype.setX = function (index, x) {
	        this.array[index * this.itemSize] = x;
	        return this;
	    };
	    BufferAttribute.prototype.getY = function (index) {
	        return this.array[index * this.itemSize + 1];
	    };
	    BufferAttribute.prototype.setY = function (index, y) {
	        this.array[index * this.itemSize + 1] = y;
	        return this;
	    };
	    BufferAttribute.prototype.getZ = function (index) {
	        return this.array[index * this.itemSize + 2];
	    };
	    BufferAttribute.prototype.setZ = function (index, z) {
	        this.array[index * this.itemSize + 2] = z;
	        return this;
	    };
	    BufferAttribute.prototype.getW = function (index) {
	        return this.array[index * this.itemSize + 3];
	    };
	    BufferAttribute.prototype.setW = function (index, w) {
	        this.array[index * this.itemSize + 3] = w;
	        return this;
	    };
	    BufferAttribute.prototype.setXY = function (index, x, y) {
	        index *= this.itemSize;
	        this.array[index + 0] = x;
	        this.array[index + 1] = y;
	        return this;
	    };
	    BufferAttribute.prototype.setXYZ = function (index, x, y, z) {
	        index *= this.itemSize;
	        this.array[index + 0] = x;
	        this.array[index + 1] = y;
	        this.array[index + 2] = z;
	        return this;
	    };
	    BufferAttribute.prototype.setXYZW = function (index, x, y, z, w) {
	        index *= this.itemSize;
	        this.array[index + 0] = x;
	        this.array[index + 1] = y;
	        this.array[index + 2] = z;
	        this.array[index + 3] = w;
	        return this;
	    };
	    BufferAttribute.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Object.defineProperty(BufferAttribute.prototype, "length", {
	        get: function () {
	            console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count.");
	            return this.array.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return BufferAttribute;
	}());
	//
	function Int8Attribute(array, itemSize) {
	    return new BufferAttribute(new Int8Array(array), itemSize);
	}
	function Uint8Attribute(array, itemSize) {
	    return new BufferAttribute(new Uint8Array(array), itemSize);
	}
	function Uint8ClampedAttribute(array, itemSize) {
	    return new BufferAttribute(new Uint8ClampedArray(array), itemSize);
	}
	function Int16Attribute(array, itemSize) {
	    return new BufferAttribute(new Int16Array(array), itemSize);
	}
	function Uint16Attribute(array, itemSize) {
	    return new BufferAttribute(new Uint16Array(array), itemSize);
	}
	function Int32Attribute(array, itemSize) {
	    return new BufferAttribute(new Int32Array(array), itemSize);
	}
	function Uint32Attribute(array, itemSize) {
	    return new BufferAttribute(new Uint32Array(array), itemSize);
	}
	function Float32Attribute(array, itemSize) {
	    return new BufferAttribute(new Float32Array(array), itemSize);
	}
	function Float64Attribute(array, itemSize) {
	    return new BufferAttribute(new Float64Array(array), itemSize);
	}
	// Deprecated
	function DynamicBufferAttribute(array, itemSize) {
	    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic(true) instead.');
	    return new BufferAttribute(array, itemSize).setDynamic(true);
	}

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	var InterleavedBufferAttribute = /** @class */ (function () {
	    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
	        this.uuid = _Math.generateUUID();
	        this.isInterleavedBufferAttribute = true;
	        this.data = interleavedBuffer;
	        this.itemSize = itemSize;
	        this.offset = offset;
	        this.normalized = normalized === true;
	    }
	    Object.defineProperty(InterleavedBufferAttribute.prototype, "count", {
	        get: function () {
	            return this.data.count;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InterleavedBufferAttribute.prototype, "array", {
	        get: function () {
	            return this.data.array;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    InterleavedBufferAttribute.prototype.setX = function (index, x) {
	        this.data.array[index * this.data.stride + this.offset] = x;
	        return this;
	    };
	    InterleavedBufferAttribute.prototype.setY = function (index, y) {
	        this.data.array[index * this.data.stride + this.offset + 1] = y;
	        return this;
	    };
	    InterleavedBufferAttribute.prototype.setZ = function (index, z) {
	        this.data.array[index * this.data.stride + this.offset + 2] = z;
	        return this;
	    };
	    InterleavedBufferAttribute.prototype.setW = function (index, w) {
	        this.data.array[index * this.data.stride + this.offset + 3] = w;
	        return this;
	    };
	    InterleavedBufferAttribute.prototype.getX = function (index) {
	        return this.data.array[index * this.data.stride + this.offset];
	    };
	    InterleavedBufferAttribute.prototype.getY = function (index) {
	        return this.data.array[index * this.data.stride + this.offset + 1];
	    };
	    InterleavedBufferAttribute.prototype.getZ = function (index) {
	        return this.data.array[index * this.data.stride + this.offset + 2];
	    };
	    InterleavedBufferAttribute.prototype.getW = function (index) {
	        return this.data.array[index * this.data.stride + this.offset + 3];
	    };
	    InterleavedBufferAttribute.prototype.setXY = function (index, x, y) {
	        index = index * this.data.stride + this.offset;
	        this.data.array[index + 0] = x;
	        this.data.array[index + 1] = y;
	        return this;
	    };
	    InterleavedBufferAttribute.prototype.setXYZ = function (index, x, y, z) {
	        index = index * this.data.stride + this.offset;
	        this.data.array[index + 0] = x;
	        this.data.array[index + 1] = y;
	        this.data.array[index + 2] = z;
	        return this;
	    };
	    InterleavedBufferAttribute.prototype.setXYZW = function (index, x, y, z, w) {
	        index = index * this.data.stride + this.offset;
	        this.data.array[index + 0] = x;
	        this.data.array[index + 1] = y;
	        this.data.array[index + 2] = z;
	        this.data.array[index + 3] = w;
	        return this;
	    };
	    return InterleavedBufferAttribute;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var DirectGeometry = /** @class */ (function (_super) {
	    __extends(DirectGeometry, _super);
	    function DirectGeometry() {
	        var _this = _super.call(this) || this;
	        _this.id = GeometryIdCount();
	        _this.uuid = _Math.generateUUID();
	        _this.name = '';
	        _this.type = 'DirectGeometry';
	        _this.indices = [];
	        _this.vertices = [];
	        _this.normals = [];
	        _this.colors = [];
	        _this.uvs = [];
	        _this.uvs2 = [];
	        _this.groups = [];
	        _this.morphTargets = { position: undefined, normal: undefined };
	        _this.skinWeights = [];
	        _this.skinIndices = [];
	        // lineDistances: number[] = [];
	        _this.boundingBox = null;
	        _this.boundingSphere = null;
	        // update flags
	        _this.verticesNeedUpdate = false;
	        _this.normalsNeedUpdate = false;
	        _this.colorsNeedUpdate = false;
	        _this.uvsNeedUpdate = false;
	        _this.groupsNeedUpdate = false;
	        return _this;
	    }
	    DirectGeometry.prototype.computeBoundingBox = function () {
	        if (this.boundingBox === null) {
	            this.boundingBox = new Box3();
	        }
	        this.boundingBox.setFromPoints(this.vertices);
	    };
	    DirectGeometry.prototype.computeBoundingSphere = function () {
	        if (this.boundingSphere === null) {
	            this.boundingSphere = new Sphere();
	        }
	        this.boundingSphere.setFromPoints(this.vertices);
	    };
	    DirectGeometry.prototype.computeFaceNormals = function () {
	        console.warn('THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.');
	    };
	    DirectGeometry.prototype.computeVertexNormals = function () {
	        console.warn('THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.');
	    };
	    DirectGeometry.prototype.computeGroups = function (geometry) {
	        var group;
	        var groups = [];
	        var materialIndex;
	        var faces = geometry.faces;
	        var i;
	        for (i = 0; i < faces.length; i++) {
	            var face = faces[i];
	            // materials
	            if (face.materialIndex !== materialIndex) {
	                materialIndex = face.materialIndex;
	                if (group !== undefined) {
	                    group.count = (i * 3) - group.start;
	                    groups.push(group);
	                }
	                group = {
	                    start: i * 3,
	                    materialIndex: materialIndex
	                };
	            }
	        }
	        if (group !== undefined) {
	            group.count = (i * 3) - group.start;
	            groups.push(group);
	        }
	        this.groups = groups;
	    };
	    DirectGeometry.prototype.fromGeometry = function (geometry) {
	        var faces = geometry.faces;
	        var vertices = geometry.vertices;
	        var faceVertexUvs = geometry.faceVertexUvs;
	        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
	        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
	        // morphs
	        var morphTargets = geometry.morphTargets;
	        var morphTargetsLength = morphTargets.length;
	        var morphTargetsPosition;
	        if (morphTargetsLength > 0) {
	            morphTargetsPosition = [];
	            for (var i = 0; i < morphTargetsLength; i++) {
	                morphTargetsPosition[i] = [];
	            }
	            this.morphTargets.position = morphTargetsPosition;
	        }
	        var morphNormals = geometry.morphNormals;
	        var morphNormalsLength = morphNormals.length;
	        var morphTargetsNormal;
	        if (morphNormalsLength > 0) {
	            morphTargetsNormal = [];
	            for (var i = 0; i < morphNormalsLength; i++) {
	                morphTargetsNormal[i] = [];
	            }
	            this.morphTargets.normal = morphTargetsNormal;
	        }
	        // skins
	        var skinIndices = geometry.skinIndices;
	        var skinWeights = geometry.skinWeights;
	        var hasSkinIndices = skinIndices.length === vertices.length;
	        var hasSkinWeights = skinWeights.length === vertices.length;
	        //
	        for (var i = 0; i < faces.length; i++) {
	            var face = faces[i];
	            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
	            var vertexNormals = face.vertexNormals;
	            if (vertexNormals.length === 3) {
	                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
	            }
	            else {
	                var normal = face.normal;
	                this.normals.push(normal, normal, normal);
	            }
	            var vertexColors = face.vertexColors;
	            if (vertexColors.length === 3) {
	                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
	            }
	            else {
	                var color = face.color;
	                this.colors.push(color, color, color);
	            }
	            if (hasFaceVertexUv === true) {
	                var vertexUvs = faceVertexUvs[0][i];
	                if (vertexUvs !== undefined) {
	                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
	                }
	                else {
	                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
	                    this.uvs.push(new Vector2(), new Vector2(), new Vector2());
	                }
	            }
	            if (hasFaceVertexUv2 === true) {
	                var vertexUvs = faceVertexUvs[1][i];
	                if (vertexUvs !== undefined) {
	                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
	                }
	                else {
	                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
	                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
	                }
	            }
	            // morphs
	            for (var j = 0; j < morphTargetsLength; j++) {
	                var morphTarget = morphTargets[j].vertices;
	                morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
	            }
	            for (var j = 0; j < morphNormalsLength; j++) {
	                var morphNormal = morphNormals[j].vertexNormals[i];
	                morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
	            }
	            // skins
	            if (hasSkinIndices) {
	                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
	            }
	            if (hasSkinWeights) {
	                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
	            }
	        }
	        this.computeGroups(geometry);
	        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
	        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
	        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
	        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
	        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	        return this;
	    };
	    DirectGeometry.prototype.dispose = function () {
	        this.dispatchEvent({ type: 'dispose' });
	    };
	    return DirectGeometry;
	}(EventDispatcher));

	var PointsMaterial = /** @class */ (function (_super) {
	    __extends(PointsMaterial, _super);
	    function PointsMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        _this.isPointsMaterial = true;
	        _this.type = 'PointsMaterial';
	        _this.color = new Color(0xffffff);
	        _this.map = null;
	        _this.size = 1;
	        _this.sizeAttenuation = true;
	        _this.lights = false;
	        _this.setValues(parameters);
	        return _this;
	    }
	    PointsMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.color.copy(source.color);
	        this.map = source.map;
	        this.size = source.size;
	        this.sizeAttenuation = source.sizeAttenuation;
	        return this;
	    };
	    return PointsMaterial;
	}(Material));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	var Points = /** @class */ (function (_super) {
	    __extends(Points, _super);
	    function Points(geometry, material) {
	        if (geometry === void 0) { geometry = new BufferGeometry(); }
	        if (material === void 0) { material = new PointsMaterial({ color: Math.random() * 0xffffff }); }
	        var _this = _super.call(this) || this;
	        _this.isPoints = true;
	        _this.type = 'Points';
	        _this.geometry = geometry;
	        _this.material = material;
	        return _this;
	    }
	    Points.prototype.raycast = function (raycaster, intersects) {
	        var inverseMatrix = new Matrix4();
	        var ray = new Ray();
	        var sphere = new Sphere();
	        //return function raycast(raycaster, intersects) {
	        var object = this;
	        var geometry = this.geometry;
	        var matrixWorld = this.matrixWorld;
	        var threshold = raycaster.params.Points.threshold;
	        // Checking boundingSphere distance to ray
	        if (geometry.boundingSphere === null)
	            geometry.computeBoundingSphere();
	        sphere.copy(geometry.boundingSphere);
	        sphere.applyMatrix4(matrixWorld);
	        if (raycaster.ray.intersectsSphere(sphere) === false)
	            return intersects;
	        //
	        inverseMatrix.getInverse(matrixWorld);
	        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
	        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
	        var localThresholdSq = localThreshold * localThreshold;
	        var position = new Vector3();
	        function testPoint(point, index) {
	            var rayPointDistanceSq = ray.distanceSqToPoint(point);
	            if (rayPointDistanceSq < localThresholdSq) {
	                var intersectPoint = ray.closestPointToPoint(point);
	                intersectPoint.applyMatrix4(matrixWorld);
	                var distance = raycaster.ray.origin.distanceTo(intersectPoint);
	                if (distance < raycaster.near || distance > raycaster.far)
	                    return;
	                intersects.push({
	                    distance: distance,
	                    distanceToRay: Math.sqrt(rayPointDistanceSq),
	                    point: intersectPoint.clone(),
	                    index: index,
	                    face: null,
	                    object: object
	                });
	            }
	        }
	        if ((geometry && geometry instanceof BufferGeometry)) {
	            var index = geometry.index;
	            var attributes = geometry.attributes;
	            var positions = attributes.position.array;
	            if (index !== null) {
	                var indices = index.array;
	                for (var i = 0, il = indices.length; i < il; i++) {
	                    var a = indices[i];
	                    position.fromArray(positions, a * 3);
	                    testPoint(position, a);
	                }
	            }
	            else {
	                for (var i = 0, l = positions.length / 3; i < l; i++) {
	                    position.fromArray(positions, i * 3);
	                    testPoint(position, i);
	                }
	            }
	        }
	        else if (geometry && geometry instanceof Geometry) {
	            var vertices = geometry.vertices;
	            for (var i = 0, l = vertices.length; i < l; i++) {
	                testPoint(vertices[i], i);
	            }
	        }
	        return intersects;
	        //};
	    };
	    Points.prototype.clone = function () {
	        return new this.constructor(this.geometry, this.material).copy(this);
	    };
	    return Points;
	}(Object3D));

	var LineBasicMaterial = /** @class */ (function (_super) {
	    __extends(LineBasicMaterial, _super);
	    function LineBasicMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        _this.isLineBasicMaterial = true;
	        _this.type = 'LineBasicMaterial';
	        _this.color = new Color(0xffffff);
	        _this.linewidth = 1;
	        _this.linecap = 'round';
	        _this.linejoin = 'round';
	        _this.lights = false;
	        _this.setValues(parameters);
	        return _this;
	    }
	    LineBasicMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.color.copy(source.color);
	        this.linewidth = source.linewidth;
	        this.linecap = source.linecap;
	        this.linejoin = source.linejoin;
	        return this;
	    };
	    return LineBasicMaterial;
	}(Material));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Line = /** @class */ (function (_super) {
	    __extends(Line, _super);
	    function Line(geometry, material, mode) {
	        if (geometry === void 0) { geometry = new BufferGeometry(); }
	        if (material === void 0) { material = new LineBasicMaterial({ color: Math.random() * 0xffffff }); }
	        var _this = _super.call(this) || this;
	        _this._step = 1;
	        _this.isLine = true;
	        _this.isLineSegments = false;
	        if (mode === 1) {
	            console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
	            //return new LineSegments(geometry, material);
	        }
	        _this.type = 'Line';
	        _this.geometry = geometry;
	        _this.material = material;
	        return _this;
	    }
	    Line.prototype.raycast = function (raycaster, intersects) {
	        var inverseMatrix = new Matrix4();
	        var ray = new Ray();
	        var sphere = new Sphere();
	        //return function raycast(raycaster, intersects) {
	        var precision = raycaster.linePrecision;
	        var precisionSq = precision * precision;
	        var geometry = this.geometry;
	        var matrixWorld = this.matrixWorld;
	        // Checking boundingSphere distance to ray
	        if (geometry.boundingSphere === null)
	            geometry.computeBoundingSphere();
	        sphere.copy(geometry.boundingSphere);
	        sphere.applyMatrix4(matrixWorld);
	        if (raycaster.ray.intersectsSphere(sphere) === false)
	            return intersects;
	        //
	        inverseMatrix.getInverse(matrixWorld);
	        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
	        var vStart = new Vector3();
	        var vEnd = new Vector3();
	        var interSegment = new Vector3();
	        var interRay = new Vector3();
	        var step = this._step; //(this && this instanceof LineSegments) ? 2 : 1;
	        if ((geometry && geometry instanceof BufferGeometry)) {
	            var index = geometry.index;
	            var attributes = geometry.attributes;
	            var positions = attributes.position.array;
	            if (index !== null) {
	                var indices = index.array;
	                for (var i = 0, l = indices.length - 1; i < l; i += step) {
	                    var a = indices[i];
	                    var b = indices[i + 1];
	                    vStart.fromArray(positions, a * 3);
	                    vEnd.fromArray(positions, b * 3);
	                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
	                    if (distSq > precisionSq)
	                        continue;
	                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
	                    var distance = raycaster.ray.origin.distanceTo(interRay);
	                    if (distance < raycaster.near || distance > raycaster.far)
	                        continue;
	                    intersects.push({
	                        distance: distance,
	                        // What do we want? intersection point on the ray or on the segment??
	                        // point: raycaster.ray.at(distance),
	                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
	                        index: i,
	                        face: null,
	                        faceIndex: null,
	                        object: this
	                    });
	                }
	            }
	            else {
	                for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
	                    vStart.fromArray(positions, 3 * i);
	                    vEnd.fromArray(positions, 3 * i + 3);
	                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
	                    if (distSq > precisionSq)
	                        continue;
	                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
	                    var distance = raycaster.ray.origin.distanceTo(interRay);
	                    if (distance < raycaster.near || distance > raycaster.far)
	                        continue;
	                    intersects.push({
	                        distance: distance,
	                        // What do we want? intersection point on the ray or on the segment??
	                        // point: raycaster.ray.at(distance),
	                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
	                        index: i,
	                        face: null,
	                        faceIndex: null,
	                        object: this
	                    });
	                }
	            }
	        }
	        else if ((geometry && geometry instanceof Geometry)) {
	            var vertices = geometry.vertices;
	            var nbVertices = vertices.length;
	            for (var i = 0; i < nbVertices - 1; i += step) {
	                var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
	                if (distSq > precisionSq)
	                    continue;
	                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
	                var distance = raycaster.ray.origin.distanceTo(interRay);
	                if (distance < raycaster.near || distance > raycaster.far)
	                    continue;
	                intersects.push({
	                    distance: distance,
	                    // What do we want? intersection point on the ray or on the segment??
	                    // point: raycaster.ray.at(distance),
	                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
	                    index: i,
	                    face: null,
	                    faceIndex: null,
	                    object: this
	                });
	            }
	        }
	        return intersects;
	        //};
	    };
	    Line.prototype.clone = function () {
	        return new this.constructor(this.geometry, this.material).copy(this);
	    };
	    return Line;
	}(Object3D));

	var BufferGeometry = /** @class */ (function (_super) {
	    __extends(BufferGeometry, _super);
	    function BufferGeometry() {
	        var _this = _super.call(this) || this;
	        _this.id = GeometryIdCount();
	        _this.uuid = _Math.generateUUID();
	        _this.name = '';
	        _this.type = 'BufferGeometry';
	        _this.index = null;
	        _this.attributes = {};
	        _this.parameters = undefined;
	        _this.morphAttributes = {};
	        _this.groups = [];
	        _this.boundingBox = null;
	        _this.boundingSphere = null;
	        _this.drawRange = { start: 0, count: Infinity };
	        // }
	        _this.isGeometry = false;
	        _this.isBufferGeometry = true;
	        return _this;
	    }
	    BufferGeometry.prototype.getIndex = function () {
	        return this.index;
	    };
	    BufferGeometry.prototype.setIndex = function (index) {
	        this.index = index;
	    };
	    BufferGeometry.prototype.addAttribute = function (name, attribute) {
	        if ((attribute && attribute instanceof BufferAttribute) === false && (attribute && attribute instanceof InterleavedBufferAttribute) === false) {
	            console.warn('THREE.BufferGeometry: .addAttribute() now expects (name, attribute).');
	            this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
	            return this;
	        }
	        if (name === 'index') {
	            console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
	            this.setIndex(attribute);
	            return this;
	        }
	        this.attributes[name] = attribute;
	        return this;
	    };
	    BufferGeometry.prototype.getAttribute = function (name) {
	        return this.attributes[name];
	    };
	    BufferGeometry.prototype.removeAttribute = function (name) {
	        delete this.attributes[name];
	        return this;
	    };
	    BufferGeometry.prototype.addGroup = function (start, count, materialIndex) {
	        if (materialIndex === void 0) { materialIndex = 0; }
	        this.groups.push({
	            start: start,
	            count: count,
	            materialIndex: materialIndex
	        });
	    };
	    BufferGeometry.prototype.clearGroups = function () {
	        this.groups = [];
	    };
	    BufferGeometry.prototype.setDrawRange = function (start, count) {
	        this.drawRange.start = start;
	        this.drawRange.count = count;
	    };
	    BufferGeometry.prototype.applyMatrix = function (matrix) {
	        var position = this.attributes.position;
	        if (position !== undefined) {
	            matrix.applyToVector3Array(position.array);
	            position.needsUpdate = true;
	        }
	        var normal = this.attributes.normal;
	        if (normal !== undefined) {
	            var normalMatrix = new Matrix3().getNormalMatrix(matrix);
	            normalMatrix.applyToVector3Array(normal.array);
	            normal.needsUpdate = true;
	        }
	        if (this.boundingBox !== null) {
	            this.computeBoundingBox();
	        }
	        if (this.boundingSphere !== null) {
	            this.computeBoundingSphere();
	        }
	        return this;
	    };
	    BufferGeometry.prototype.rotateX = function (angle) {
	        // rotate geometry around world x-axis
	        var m1 = new Matrix4();
	        //return function rotateX(angle) {
	        m1.makeRotationX(angle);
	        this.applyMatrix(m1);
	        return this;
	        //};
	    };
	    BufferGeometry.prototype.rotateY = function (angle) {
	        // rotate geometry around world y-axis
	        var m1 = new Matrix4();
	        //return function rotateY(angle) {
	        m1.makeRotationY(angle);
	        this.applyMatrix(m1);
	        return this;
	        //};
	    };
	    BufferGeometry.prototype.rotateZ = function (angle) {
	        // rotate geometry around world z-axis
	        var m1 = new Matrix4();
	        //return function rotateZ(angle) {
	        m1.makeRotationZ(angle);
	        this.applyMatrix(m1);
	        return this;
	        //};
	    };
	    BufferGeometry.prototype.translate = function (x, y, z) {
	        // translate geometry
	        var m1 = new Matrix4();
	        //return function translate(x, y, z) {
	        m1.makeTranslation(x, y, z);
	        this.applyMatrix(m1);
	        return this;
	        //};
	    };
	    BufferGeometry.prototype.scale = function (x, y, z) {
	        // scale geometry
	        var m1 = new Matrix4();
	        //return function scale(x, y, z) {
	        m1.makeScale(x, y, z);
	        this.applyMatrix(m1);
	        return this;
	        //};
	    };
	    BufferGeometry.prototype.lookAt = function (vector) {
	        var obj = new Object3D();
	        //return function lookAt(vector) {
	        obj.lookAt(vector);
	        obj.updateMatrix();
	        this.applyMatrix(obj.matrix);
	        //};
	    };
	    BufferGeometry.prototype.center = function () {
	        this.computeBoundingBox();
	        var offset = this.boundingBox.getCenter().negate();
	        this.translate(offset.x, offset.y, offset.z);
	        return offset;
	    };
	    BufferGeometry.prototype.setFromObject = function (object) {
	        // console.log('THREE.BufferGeometry.setFromObject(). Converting', object, this);
	        var geometry = object.geometry;
	        if ((object && object instanceof Points) || (object && object instanceof Line)) {
	            var positions = Float32Attribute(geometry.vertices.length * 3, 3);
	            var colors = Float32Attribute(geometry.colors.length * 3, 3);
	            this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
	            this.addAttribute('color', colors.copyColorsArray(geometry.colors));
	            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
	                var lineDistances = Float32Attribute(geometry.lineDistances.length, 1);
	                this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
	            }
	            if (geometry.boundingSphere !== null) {
	                this.boundingSphere = geometry.boundingSphere.clone();
	            }
	            if (geometry.boundingBox !== null) {
	                this.boundingBox = geometry.boundingBox.clone();
	            }
	        }
	        else if ((object && object instanceof Mesh)) {
	            if ((geometry && geometry instanceof Geometry)) {
	                this.fromGeometry(geometry);
	            }
	        }
	        return this;
	    };
	    BufferGeometry.prototype.updateFromObject = function (object) {
	        var geometry = object.geometry;
	        if ((object && object instanceof Mesh)) {
	            var direct = geometry.__directGeometry;
	            if (geometry.elementsNeedUpdate === true) {
	                direct = undefined;
	                geometry.elementsNeedUpdate = false;
	            }
	            if (direct === undefined) {
	                return this.fromGeometry(geometry);
	            }
	            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
	            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
	            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
	            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
	            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
	            geometry.verticesNeedUpdate = false;
	            geometry.normalsNeedUpdate = false;
	            geometry.colorsNeedUpdate = false;
	            geometry.uvsNeedUpdate = false;
	            geometry.groupsNeedUpdate = false;
	            geometry = direct;
	        }
	        var attribute;
	        if (geometry.verticesNeedUpdate === true) {
	            attribute = this.attributes.position;
	            if (attribute !== undefined) {
	                attribute.copyVector3sArray(geometry.vertices);
	                attribute.needsUpdate = true;
	            }
	            geometry.verticesNeedUpdate = false;
	        }
	        if (geometry.normalsNeedUpdate === true) {
	            attribute = this.attributes.normal;
	            if (attribute !== undefined) {
	                attribute.copyVector3sArray(geometry.normals);
	                attribute.needsUpdate = true;
	            }
	            geometry.normalsNeedUpdate = false;
	        }
	        if (geometry.colorsNeedUpdate === true) {
	            attribute = this.attributes.color;
	            if (attribute !== undefined) {
	                attribute.copyColorsArray(geometry.colors);
	                attribute.needsUpdate = true;
	            }
	            geometry.colorsNeedUpdate = false;
	        }
	        if (geometry.uvsNeedUpdate) {
	            attribute = this.attributes.uv;
	            if (attribute !== undefined) {
	                attribute.copyVector2sArray(geometry.uvs);
	                attribute.needsUpdate = true;
	            }
	            geometry.uvsNeedUpdate = false;
	        }
	        if (geometry.lineDistancesNeedUpdate) {
	            attribute = this.attributes.lineDistance;
	            if (attribute !== undefined) {
	                attribute.copyArray(geometry.lineDistances);
	                attribute.needsUpdate = true;
	            }
	            geometry.lineDistancesNeedUpdate = false;
	        }
	        if (geometry.groupsNeedUpdate) {
	            geometry.computeGroups(object.geometry);
	            this.groups = geometry.groups;
	            geometry.groupsNeedUpdate = false;
	        }
	        return this;
	    };
	    BufferGeometry.prototype.fromGeometry = function (geometry) {
	        geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
	        return this.fromDirectGeometry(geometry.__directGeometry);
	    };
	    BufferGeometry.prototype.fromDirectGeometry = function (geometry) {
	        var positions = new Float32Array(geometry.vertices.length * 3);
	        this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
	        if (geometry.normals.length > 0) {
	            var normals = new Float32Array(geometry.normals.length * 3);
	            this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
	        }
	        if (geometry.colors.length > 0) {
	            var colors = new Float32Array(geometry.colors.length * 3);
	            this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
	        }
	        if (geometry.uvs.length > 0) {
	            var uvs = new Float32Array(geometry.uvs.length * 2);
	            this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
	        }
	        if (geometry.uvs2.length > 0) {
	            var uvs2 = new Float32Array(geometry.uvs2.length * 2);
	            this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
	        }
	        if (geometry.indices.length > 0) {
	            var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
	            var indices = new TypeArray(geometry.indices.length * 3);
	            this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
	        }
	        // groups
	        this.groups = geometry.groups;
	        // morphs
	        for (var name in geometry.morphTargets) {
	            if (!geometry.morphTargets[name])
	                continue;
	            var array = [];
	            var morphTargets = geometry.morphTargets[name];
	            for (var i = 0, l = morphTargets.length; i < l; i++) {
	                var morphTarget = morphTargets[i];
	                var attribute = Float32Attribute(morphTarget.length * 3, 3);
	                array.push(attribute.copyVector3sArray(morphTarget));
	            }
	            this.morphAttributes[name] = array;
	        }
	        // skinning
	        if (geometry.skinIndices.length > 0) {
	            var skinIndices = Float32Attribute(geometry.skinIndices.length * 4, 4);
	            this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
	        }
	        if (geometry.skinWeights.length > 0) {
	            var skinWeights = Float32Attribute(geometry.skinWeights.length * 4, 4);
	            this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
	        }
	        //
	        if (geometry.boundingSphere !== null) {
	            this.boundingSphere = geometry.boundingSphere.clone();
	        }
	        if (geometry.boundingBox !== null) {
	            this.boundingBox = geometry.boundingBox.clone();
	        }
	        return this;
	    };
	    BufferGeometry.prototype.computeBoundingBox = function () {
	        if (this.boundingBox === null) {
	            this.boundingBox = new Box3();
	        }
	        var positions = this.attributes.position.array;
	        if (positions !== undefined) {
	            this.boundingBox.setFromArray(positions);
	        }
	        else {
	            this.boundingBox.makeEmpty();
	        }
	        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
	            console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
	        }
	    };
	    BufferGeometry.prototype.computeBoundingSphere = function () {
	        var box = new Box3();
	        var vector = new Vector3();
	        //return function computeBoundingSphere() {
	        if (this.boundingSphere === null) {
	            this.boundingSphere = new Sphere();
	        }
	        var positions = this.attributes.position;
	        if (positions) {
	            var array = positions.array;
	            var center = this.boundingSphere.center;
	            box.setFromArray(array);
	            box.getCenter(center);
	            // hoping to find a boundingSphere with a radius smaller than the
	            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	            var maxRadiusSq = 0;
	            for (var i = 0, il = array.length; i < il; i += 3) {
	                vector.fromArray(array, i);
	                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
	            }
	            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
	            if (isNaN(this.boundingSphere.radius)) {
	                console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
	            }
	        }
	        //};
	    };
	    BufferGeometry.prototype.computeFaceNormals = function () {
	        // backwards compatibility
	    };
	    BufferGeometry.prototype.computeVertexNormals = function () {
	        var index = this.index;
	        var attributes = this.attributes;
	        var groups = this.groups;
	        if (attributes.position) {
	            var positions = attributes.position.array;
	            if (attributes.normal === undefined) {
	                this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
	            }
	            else {
	                // reset existing normals to zero
	                var array = attributes.normal.array;
	                for (var i = 0, il = array.length; i < il; i++) {
	                    array[i] = 0;
	                }
	            }
	            var normals = attributes.normal.array;
	            var vA = void 0, vB = void 0, vC = void 0, pA = new Vector3(), pB = new Vector3(), pC = new Vector3(), cb = new Vector3(), ab = new Vector3();
	            // indexed elements
	            if (index) {
	                var indices = index.array;
	                if (groups.length === 0) {
	                    this.addGroup(0, indices.length);
	                }
	                for (var j = 0, jl = groups.length; j < jl; ++j) {
	                    var group = groups[j];
	                    var start = group.start;
	                    var count = group.count;
	                    for (var i = start, il = start + count; i < il; i += 3) {
	                        vA = indices[i + 0] * 3;
	                        vB = indices[i + 1] * 3;
	                        vC = indices[i + 2] * 3;
	                        pA.fromArray(positions, vA);
	                        pB.fromArray(positions, vB);
	                        pC.fromArray(positions, vC);
	                        cb.subVectors(pC, pB);
	                        ab.subVectors(pA, pB);
	                        cb.cross(ab);
	                        normals[vA] += cb.x;
	                        normals[vA + 1] += cb.y;
	                        normals[vA + 2] += cb.z;
	                        normals[vB] += cb.x;
	                        normals[vB + 1] += cb.y;
	                        normals[vB + 2] += cb.z;
	                        normals[vC] += cb.x;
	                        normals[vC + 1] += cb.y;
	                        normals[vC + 2] += cb.z;
	                    }
	                }
	            }
	            else {
	                // non-indexed elements (unconnected triangle soup)
	                for (var i = 0, il = positions.length; i < il; i += 9) {
	                    pA.fromArray(positions, i);
	                    pB.fromArray(positions, i + 3);
	                    pC.fromArray(positions, i + 6);
	                    cb.subVectors(pC, pB);
	                    ab.subVectors(pA, pB);
	                    cb.cross(ab);
	                    normals[i] = cb.x;
	                    normals[i + 1] = cb.y;
	                    normals[i + 2] = cb.z;
	                    normals[i + 3] = cb.x;
	                    normals[i + 4] = cb.y;
	                    normals[i + 5] = cb.z;
	                    normals[i + 6] = cb.x;
	                    normals[i + 7] = cb.y;
	                    normals[i + 8] = cb.z;
	                }
	            }
	            this.normalizeNormals();
	            attributes.normal.needsUpdate = true;
	        }
	    };
	    BufferGeometry.prototype.merge = function (geometry, offset) {
	        if (offset === void 0) { offset = 0; }
	        if ((geometry && geometry instanceof BufferGeometry) === false) {
	            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
	            return this;
	        }
	        var attributes = this.attributes;
	        for (var key in attributes) {
	            var attribute1 = attributes[key];
	            if (attribute1 === undefined)
	                continue;
	            var attributeArray1 = attribute1.array;
	            var attribute2 = geometry.attributes[key];
	            if (attribute2 === undefined)
	                continue;
	            var attributeArray2 = attribute2.array;
	            var attributeSize = attribute2.itemSize;
	            for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
	                attributeArray1[j] = attributeArray2[i];
	            }
	        }
	        return this;
	    };
	    BufferGeometry.prototype.normalizeNormals = function () {
	        var normals = this.attributes.normal.array;
	        for (var i = 0, il = normals.length; i < il; i += 3) {
	            var x = normals[i];
	            var y = normals[i + 1];
	            var z = normals[i + 2];
	            var n = 1.0 / Math.sqrt(x * x + y * y + z * z);
	            normals[i] *= n;
	            normals[i + 1] *= n;
	            normals[i + 2] *= n;
	        }
	    };
	    BufferGeometry.prototype.toNonIndexed = function () {
	        if (this.index === null) {
	            console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
	            return this;
	        }
	        var geometry2 = new BufferGeometry();
	        var indices = this.index.array;
	        var attributes = this.attributes;
	        for (var name in attributes) {
	            var attribute = attributes[name];
	            if (attribute === undefined)
	                continue;
	            var array = attribute.array;
	            var itemSize = attribute.itemSize;
	            var array2 = new array.constructor(indices.length * itemSize);
	            var index = 0, index2 = 0;
	            for (var i = 0, l = indices.length; i < l; i++) {
	                index = indices[i] * itemSize;
	                for (var j = 0; j < itemSize; j++) {
	                    array2[index2++] = array[index++];
	                }
	            }
	            geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
	        }
	        return geometry2;
	    };
	    BufferGeometry.prototype.toJSON = function (meta) {
	        var data = {
	            metadata: {
	                version: 4.4,
	                type: 'BufferGeometry',
	                generator: 'BufferGeometry.toJSON'
	            }
	        };
	        // standard BufferGeometry serialization
	        data.uuid = this.uuid;
	        data.type = this.type;
	        if (this.name !== '')
	            data.name = this.name;
	        if (this.parameters !== undefined) {
	            var parameters = this.parameters;
	            for (var key in parameters) {
	                if (parameters[key] !== undefined)
	                    data[key] = parameters[key];
	            }
	            return data;
	        }
	        data.data = { attributes: {} };
	        var index = this.index;
	        if (index !== null) {
	            var array = Array.prototype.slice.call(index.array);
	            data.data.index = {
	                type: index.array.constructor.name,
	                array: array
	            };
	        }
	        var attributes = this.attributes;
	        for (var key in attributes) {
	            var attribute = attributes[key];
	            if (attribute === undefined)
	                continue;
	            var array = Array.prototype.slice.call(attribute.array);
	            data.data.attributes[key] = {
	                itemSize: attribute.itemSize,
	                type: attribute.array.constructor.name,
	                array: array,
	                normalized: attribute.normalized
	            };
	        }
	        var groups = this.groups;
	        if (groups.length > 0) {
	            data.data.groups = JSON.parse(JSON.stringify(groups));
	        }
	        var boundingSphere = this.boundingSphere;
	        if (boundingSphere !== null) {
	            data.data.boundingSphere = {
	                center: boundingSphere.center.toArray(),
	                radius: boundingSphere.radius
	            };
	        }
	        return data;
	    };
	    BufferGeometry.prototype.clone = function () {
	        /*
	        // Handle primitives
	        const parameters = this.parameters;
	        if (parameters !== undefined) {
	          const values = [];
	          for (let key in parameters) {
	            values.push(parameters[key]);
	          }
	          const geometry = Object.create(this.constructor.prototype);
	          this.constructor.apply(geometry, values);
	          return geometry;
	        }
	        return new this.constructor().copy(this);
	        */
	        return new this.constructor().copy(this);
	    };
	    BufferGeometry.prototype.copy = function (source) {
	        var index = source.index;
	        if (index !== null) {
	            this.setIndex(index.clone());
	        }
	        var attributes = source.attributes;
	        for (var name in attributes) {
	            var attribute = attributes[name];
	            if (attribute === undefined)
	                continue;
	            this.addAttribute(name, attribute.clone());
	        }
	        var groups = source.groups;
	        for (var i = 0, l = groups.length; i < l; i++) {
	            var group = groups[i];
	            this.addGroup(group.start, group.count, group.materialIndex);
	        }
	        return this;
	    };
	    BufferGeometry.prototype.dispose = function () {
	        this.dispatchEvent({ type: 'dispose' });
	    };
	    BufferGeometry.prototype.addIndex = function (index) {
	        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
	        this.setIndex(index);
	    };
	    BufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {
	        if (indexOffset !== undefined) {
	            console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
	        }
	        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
	        this.addGroup(start, count);
	    };
	    BufferGeometry.prototype.clearDrawCalls = function () {
	        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
	        this.clearGroups();
	    };
	    BufferGeometry.prototype.computeTangents = function () {
	        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
	    };
	    BufferGeometry.prototype.computeOffsets = function () {
	        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
	    };
	    Object.defineProperty(BufferGeometry.prototype, "drawcalls", {
	        get: function () {
	            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
	            return this.groups;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BufferGeometry.prototype, "offsets", {
	        get: function () {
	            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
	            return this.groups;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BufferGeometry.MaxIndex = 65535;
	    return BufferGeometry;
	}(EventDispatcher));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */
	var Mesh = /** @class */ (function (_super) {
	    __extends(Mesh, _super);
	    function Mesh(geometry, material) {
	        if (geometry === void 0) { geometry = new BufferGeometry(); }
	        if (material === void 0) { material = new MeshBasicMaterial({ color: Math.random() * 0xffffff }); }
	        var _this = _super.call(this) || this;
	        _this.drawMode = exports.DrawMode.Triangles;
	        _this.isMesh = true;
	        _this.type = 'Mesh';
	        _this.geometry = geometry;
	        _this.material = material;
	        _this.updateMorphTargets();
	        return _this;
	    }
	    Mesh.prototype.setDrawMode = function (value) {
	        this.drawMode = value;
	    };
	    Mesh.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.drawMode = source.drawMode;
	        return this;
	    };
	    Mesh.prototype.updateMorphTargets = function () {
	        var morphTargets = this.geometry.morphTargets;
	        if (morphTargets !== undefined && morphTargets.length > 0) {
	            this.morphTargetInfluences = [];
	            this.morphTargetDictionary = {};
	            for (var m = 0, ml = morphTargets.length; m < ml; m++) {
	                this.morphTargetInfluences.push(0);
	                this.morphTargetDictionary[morphTargets[m].name] = m;
	            }
	        }
	    };
	    Mesh.prototype.raycast = function (raycaster, intersects) {
	        var inverseMatrix = new Matrix4();
	        var ray = new Ray();
	        var sphere = new Sphere();
	        var vA = new Vector3();
	        var vB = new Vector3();
	        var vC = new Vector3();
	        var tempA = new Vector3();
	        var tempB = new Vector3();
	        var tempC = new Vector3();
	        var uvA = new Vector2();
	        var uvB = new Vector2();
	        var uvC = new Vector2();
	        var barycoord = new Vector3();
	        var intersectionPoint = new Vector3();
	        var intersectionPointWorld = new Vector3();
	        function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
	            Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
	            uv1.multiplyScalar(barycoord.x);
	            uv2.multiplyScalar(barycoord.y);
	            uv3.multiplyScalar(barycoord.z);
	            uv1.add(uv2).add(uv3);
	            return uv1.clone();
	        }
	        function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
	            var intersect;
	            var material = object.material;
	            if (material.side === exports.SideMode.Back) {
	                intersect = ray.intersectTriangle(pC, pB, pA, true, point);
	            }
	            else {
	                intersect = ray.intersectTriangle(pA, pB, pC, material.side !== exports.SideMode.Double, point);
	            }
	            if (intersect === null)
	                return null;
	            intersectionPointWorld.copy(point);
	            intersectionPointWorld.applyMatrix4(object.matrixWorld);
	            var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
	            if (distance < raycaster.near || distance > raycaster.far)
	                return null;
	            return {
	                distance: distance,
	                point: intersectionPointWorld.clone(),
	                index: 0,
	                face: null,
	                faceIndex: 0,
	                uv: null,
	                object: object
	            };
	        }
	        function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
	            vA.fromArray(positions, a * 3);
	            vB.fromArray(positions, b * 3);
	            vC.fromArray(positions, c * 3);
	            var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
	            if (intersection) {
	                if (uvs) {
	                    uvA.fromArray(uvs, a * 2);
	                    uvB.fromArray(uvs, b * 2);
	                    uvC.fromArray(uvs, c * 2);
	                    intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
	                }
	                intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
	                intersection.faceIndex = a;
	            }
	            return intersection;
	        }
	        //return function raycast(raycaster, intersects) {
	        var geometry = this.geometry;
	        var material = this.material;
	        var matrixWorld = this.matrixWorld;
	        if (material === undefined)
	            return intersects;
	        // Checking boundingSphere distance to ray
	        if (geometry.boundingSphere === null)
	            geometry.computeBoundingSphere();
	        sphere.copy(geometry.boundingSphere);
	        sphere.applyMatrix4(matrixWorld);
	        if (raycaster.ray.intersectsSphere(sphere) === false)
	            return intersects;
	        //
	        inverseMatrix.getInverse(matrixWorld);
	        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
	        // Check boundingBox before continuing
	        if (geometry.boundingBox !== null) {
	            if (ray.intersectsBox(geometry.boundingBox) === false)
	                return intersects;
	        }
	        var uvs, intersection;
	        if ((geometry && geometry instanceof BufferGeometry)) {
	            var a = void 0, b = void 0, c = void 0;
	            var index = geometry.index;
	            var attributes = geometry.attributes;
	            var positions = attributes.position.array;
	            if (attributes.uv !== undefined) {
	                uvs = attributes.uv.array;
	            }
	            if (index !== null) {
	                var indices = index.array;
	                for (var i = 0, l = indices.length; i < l; i += 3) {
	                    a = indices[i];
	                    b = indices[i + 1];
	                    c = indices[i + 2];
	                    intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
	                    if (intersection) {
	                        intersection.faceIndex = Math.floor(i / 3); // triangle number in indices buffer semantics
	                        intersects.push(intersection);
	                    }
	                }
	            }
	            else {
	                for (var i = 0, l = positions.length; i < l; i += 9) {
	                    a = i / 3;
	                    b = a + 1;
	                    c = a + 2;
	                    intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
	                    if (intersection) {
	                        intersection.index = a; // triangle number in positions buffer semantics
	                        intersects.push(intersection);
	                    }
	                }
	            }
	        }
	        else if ((geometry && geometry instanceof Geometry)) {
	            var fvA = void 0, fvB = void 0, fvC = void 0;
	            var isFaceMaterial = (material && material instanceof MultiMaterial);
	            var materials = isFaceMaterial === true ? material.materials : null;
	            var vertices = geometry.vertices;
	            var faces = geometry.faces;
	            var faceVertexUvs = geometry.faceVertexUvs[0];
	            if (faceVertexUvs.length > 0)
	                uvs = faceVertexUvs;
	            for (var f = 0, fl = faces.length; f < fl; f++) {
	                var face = faces[f];
	                var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
	                if (faceMaterial === undefined)
	                    continue;
	                fvA = vertices[face.a];
	                fvB = vertices[face.b];
	                fvC = vertices[face.c];
	                if (faceMaterial.morphTargets === true) {
	                    var morphTargets = geometry.morphTargets;
	                    var morphInfluences = this.morphTargetInfluences;
	                    vA.set(0, 0, 0);
	                    vB.set(0, 0, 0);
	                    vC.set(0, 0, 0);
	                    for (var t = 0, tl = morphTargets.length; t < tl; t++) {
	                        var influence = morphInfluences[t];
	                        if (influence === 0)
	                            continue;
	                        var targets = morphTargets[t].vertices;
	                        vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
	                        vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
	                        vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
	                    }
	                    vA.add(fvA);
	                    vB.add(fvB);
	                    vC.add(fvC);
	                    fvA = vA;
	                    fvB = vB;
	                    fvC = vC;
	                }
	                intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
	                if (intersection) {
	                    if (uvs) {
	                        var uvs_f = uvs[f];
	                        uvA.copy(uvs_f[0]);
	                        uvB.copy(uvs_f[1]);
	                        uvC.copy(uvs_f[2]);
	                        intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
	                    }
	                    intersection.face = face;
	                    intersection.faceIndex = f;
	                    intersects.push(intersection);
	                }
	            }
	        }
	        return intersects;
	        //};
	    };
	    Mesh.prototype.clone = function () {
	        return new this.constructor(this.geometry, this.material).copy(this);
	    };
	    return Mesh;
	}(Object3D));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */
	var Geometry = /** @class */ (function (_super) {
	    __extends(Geometry, _super);
	    function Geometry() {
	        var _this = _super.call(this) || this;
	        _this.id = GeometryIdCount();
	        _this.uuid = _Math.generateUUID();
	        _this.name = '';
	        _this.type = 'Geometry';
	        _this.vertices = [];
	        _this.colors = [];
	        _this.faces = [];
	        _this.faceVertexUvs = [[]];
	        _this.morphTargets = [];
	        _this.morphNormals = [];
	        _this.skinWeights = [];
	        _this.skinIndices = [];
	        _this.lineDistances = [];
	        _this.boundingBox = null;
	        _this.boundingSphere = null;
	        // update flags
	        _this.elementsNeedUpdate = false;
	        _this.verticesNeedUpdate = false;
	        _this.uvsNeedUpdate = false;
	        _this.normalsNeedUpdate = false;
	        _this.colorsNeedUpdate = false;
	        _this.lineDistancesNeedUpdate = false;
	        _this.groupsNeedUpdate = false;
	        _this.parameters = undefined;
	        // }
	        _this.isGeometry = true;
	        _this.isBufferGeometry = false;
	        return _this;
	    }
	    Geometry.prototype.applyMatrix = function (matrix) {
	        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
	        for (var i = 0, il = this.vertices.length; i < il; i++) {
	            var vertex = this.vertices[i];
	            vertex.applyMatrix4(matrix);
	        }
	        for (var i = 0, il = this.faces.length; i < il; i++) {
	            var face = this.faces[i];
	            face.normal.applyMatrix3(normalMatrix).normalize();
	            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
	                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
	            }
	        }
	        if (this.boundingBox !== null) {
	            this.computeBoundingBox();
	        }
	        if (this.boundingSphere !== null) {
	            this.computeBoundingSphere();
	        }
	        this.verticesNeedUpdate = true;
	        this.normalsNeedUpdate = true;
	        return this;
	    };
	    Geometry.prototype.rotateX = function (angle) {
	        // rotate geometry around world x-axis
	        var m1 = new Matrix4();
	        //return function rotateX(angle) {
	        m1.makeRotationX(angle);
	        this.applyMatrix(m1);
	        return this;
	        //};
	    };
	    Geometry.prototype.rotateY = function (angle) {
	        // rotate geometry around world y-axis
	        var m1 = new Matrix4();
	        //return function rotateY(angle) {
	        m1.makeRotationY(angle);
	        this.applyMatrix(m1);
	        return this;
	        //};
	    };
	    Geometry.prototype.rotateZ = function (angle) {
	        // rotate geometry around world z-axis
	        var m1 = new Matrix4();
	        //return function rotateZ(angle) {
	        m1.makeRotationZ(angle);
	        this.applyMatrix(m1);
	        return this;
	        //};
	    };
	    Geometry.prototype.translate = function (x, y, z) {
	        // translate geometry
	        var m1 = new Matrix4();
	        //return function translate(x, y, z) {
	        m1.makeTranslation(x, y, z);
	        this.applyMatrix(m1);
	        return this;
	        //};
	    };
	    Geometry.prototype.scale = function (x, y, z) {
	        // scale geometry
	        var m1 = new Matrix4();
	        //return function scale(x, y, z) {
	        m1.makeScale(x, y, z);
	        this.applyMatrix(m1);
	        return this;
	        //};
	    };
	    Geometry.prototype.lookAt = function (vector) {
	        var obj = new Object3D();
	        //return function lookAt(vector) {
	        obj.lookAt(vector);
	        obj.updateMatrix();
	        this.applyMatrix(obj.matrix);
	        //};
	    };
	    Geometry.prototype.fromBufferGeometry = function (geometry) {
	        var scope = this;
	        var indices = geometry.index !== null ? geometry.index.array : undefined;
	        var attributes = geometry.attributes;
	        var positions = attributes.position.array;
	        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
	        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
	        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
	        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	        if (uvs2 !== undefined)
	            this.faceVertexUvs[1] = [];
	        var tempNormals = [];
	        var tempUVs = [];
	        var tempUVs2 = [];
	        for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
	            scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));
	            if (normals !== undefined) {
	                tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));
	            }
	            if (colors !== undefined) {
	                scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));
	            }
	            if (uvs !== undefined) {
	                tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
	            }
	            if (uvs2 !== undefined) {
	                tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
	            }
	        }
	        function addFace(a, b, c, materialIndex) {
	            var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
	            var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
	            var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
	            scope.faces.push(face);
	            if (uvs !== undefined) {
	                scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
	            }
	            if (uvs2 !== undefined) {
	                scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
	            }
	        }
	        if (indices !== undefined) {
	            var groups = geometry.groups;
	            if (groups.length > 0) {
	                for (var i = 0; i < groups.length; i++) {
	                    var group = groups[i];
	                    var start = group.start;
	                    var count_1 = group.count;
	                    for (var j = start, jl = start + count_1; j < jl; j += 3) {
	                        addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
	                    }
	                }
	            }
	            else {
	                for (var i = 0; i < indices.length; i += 3) {
	                    addFace(indices[i], indices[i + 1], indices[i + 2]);
	                }
	            }
	        }
	        else {
	            for (var i = 0; i < positions.length / 3; i += 3) {
	                addFace(i, i + 1, i + 2);
	            }
	        }
	        this.computeFaceNormals();
	        if (geometry.boundingBox !== null) {
	            this.boundingBox = geometry.boundingBox.clone();
	        }
	        if (geometry.boundingSphere !== null) {
	            this.boundingSphere = geometry.boundingSphere.clone();
	        }
	        return this;
	    };
	    Geometry.prototype.center = function () {
	        this.computeBoundingBox();
	        var offset = this.boundingBox.getCenter().negate();
	        this.translate(offset.x, offset.y, offset.z);
	        return offset;
	    };
	    Geometry.prototype.normalize = function () {
	        this.computeBoundingSphere();
	        var center = this.boundingSphere.center;
	        var radius = this.boundingSphere.radius;
	        var s = radius === 0 ? 1 : 1.0 / radius;
	        var matrix = new Matrix4();
	        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
	        this.applyMatrix(matrix);
	        return this;
	    };
	    Geometry.prototype.computeFaceNormals = function () {
	        var cb = new Vector3(), ab = new Vector3();
	        for (var f = 0, fl = this.faces.length; f < fl; f++) {
	            var face = this.faces[f];
	            var vA = this.vertices[face.a];
	            var vB = this.vertices[face.b];
	            var vC = this.vertices[face.c];
	            cb.subVectors(vC, vB);
	            ab.subVectors(vA, vB);
	            cb.cross(ab);
	            cb.normalize();
	            face.normal.copy(cb);
	        }
	    };
	    Geometry.prototype.computeVertexNormals = function (areaWeighted) {
	        if (areaWeighted === void 0) { areaWeighted = true; }
	        var v, vl, f, fl, face, vertices;
	        vertices = new Array(this.vertices.length);
	        for (v = 0, vl = this.vertices.length; v < vl; v++) {
	            vertices[v] = new Vector3();
	        }
	        if (areaWeighted) {
	            // vertex normals weighted by triangle areas
	            // http://www.iquilezles.org/www/articles/normals/normals.htm
	            var vA = void 0, vB = void 0, vC = void 0;
	            var cb = new Vector3(), ab = new Vector3();
	            for (f = 0, fl = this.faces.length; f < fl; f++) {
	                face = this.faces[f];
	                vA = this.vertices[face.a];
	                vB = this.vertices[face.b];
	                vC = this.vertices[face.c];
	                cb.subVectors(vC, vB);
	                ab.subVectors(vA, vB);
	                cb.cross(ab);
	                vertices[face.a].add(cb);
	                vertices[face.b].add(cb);
	                vertices[face.c].add(cb);
	            }
	        }
	        else {
	            this.computeFaceNormals();
	            for (f = 0, fl = this.faces.length; f < fl; f++) {
	                face = this.faces[f];
	                vertices[face.a].add(face.normal);
	                vertices[face.b].add(face.normal);
	                vertices[face.c].add(face.normal);
	            }
	        }
	        for (v = 0, vl = this.vertices.length; v < vl; v++) {
	            vertices[v].normalize();
	        }
	        for (f = 0, fl = this.faces.length; f < fl; f++) {
	            face = this.faces[f];
	            var vertexNormals = face.vertexNormals;
	            if (vertexNormals.length === 3) {
	                vertexNormals[0].copy(vertices[face.a]);
	                vertexNormals[1].copy(vertices[face.b]);
	                vertexNormals[2].copy(vertices[face.c]);
	            }
	            else {
	                vertexNormals[0] = vertices[face.a].clone();
	                vertexNormals[1] = vertices[face.b].clone();
	                vertexNormals[2] = vertices[face.c].clone();
	            }
	        }
	        if (this.faces.length > 0) {
	            this.normalsNeedUpdate = true;
	        }
	    };
	    Geometry.prototype.computeFlatVertexNormals = function () {
	        this.computeFaceNormals();
	        for (var f = 0, fl = this.faces.length; f < fl; f++) {
	            var face = this.faces[f];
	            var vertexNormals = face.vertexNormals;
	            if (vertexNormals.length === 3) {
	                vertexNormals[0].copy(face.normal);
	                vertexNormals[1].copy(face.normal);
	                vertexNormals[2].copy(face.normal);
	            }
	            else {
	                vertexNormals[0] = face.normal.clone();
	                vertexNormals[1] = face.normal.clone();
	                vertexNormals[2] = face.normal.clone();
	            }
	        }
	        if (this.faces.length > 0) {
	            this.normalsNeedUpdate = true;
	        }
	    };
	    Geometry.prototype.computeMorphNormals = function () {
	        var i, il, f, fl, face;
	        // save original normals
	        // - create temp variables on first access
	        //   otherwise just copy (for faster repeated calls)
	        for (f = 0, fl = this.faces.length; f < fl; f++) {
	            face = this.faces[f];
	            if (!face.__originalFaceNormal) {
	                face.__originalFaceNormal = face.normal.clone();
	            }
	            else {
	                face.__originalFaceNormal.copy(face.normal);
	            }
	            if (!face.__originalVertexNormals)
	                face.__originalVertexNormals = [];
	            for (i = 0, il = face.vertexNormals.length; i < il; i++) {
	                if (!face.__originalVertexNormals[i]) {
	                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
	                }
	                else {
	                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
	                }
	            }
	        }
	        // use temp geometry to compute face and vertex normals for each morph
	        var tmpGeo = new Geometry();
	        tmpGeo.faces = this.faces;
	        for (i = 0, il = this.morphTargets.length; i < il; i++) {
	            // create on first access
	            if (!this.morphNormals[i]) {
	                this.morphNormals[i] = {};
	                this.morphNormals[i].faceNormals = [];
	                this.morphNormals[i].vertexNormals = [];
	                var dstNormalsFace = this.morphNormals[i].faceNormals;
	                var dstNormalsVertex = this.morphNormals[i].vertexNormals;
	                var faceNormal_1 = void 0, vertexNormals_1 = void 0;
	                for (f = 0, fl = this.faces.length; f < fl; f++) {
	                    faceNormal_1 = new Vector3();
	                    vertexNormals_1 = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
	                    dstNormalsFace.push(faceNormal_1);
	                    dstNormalsVertex.push(vertexNormals_1);
	                }
	            }
	            var morphNormals = this.morphNormals[i];
	            // set vertices to morph target
	            tmpGeo.vertices = this.morphTargets[i].vertices;
	            // compute morph normals
	            tmpGeo.computeFaceNormals();
	            tmpGeo.computeVertexNormals();
	            // store morph normals
	            var faceNormal = void 0, vertexNormals = void 0;
	            for (f = 0, fl = this.faces.length; f < fl; f++) {
	                face = this.faces[f];
	                faceNormal = morphNormals.faceNormals[f];
	                vertexNormals = morphNormals.vertexNormals[f];
	                faceNormal.copy(face.normal);
	                vertexNormals.a.copy(face.vertexNormals[0]);
	                vertexNormals.b.copy(face.vertexNormals[1]);
	                vertexNormals.c.copy(face.vertexNormals[2]);
	            }
	        }
	        // restore original normals
	        for (f = 0, fl = this.faces.length; f < fl; f++) {
	            face = this.faces[f];
	            face.normal = face.__originalFaceNormal;
	            face.vertexNormals = face.__originalVertexNormals;
	        }
	    };
	    Geometry.prototype.computeTangents = function () {
	        console.warn('THREE.Geometry: .computeTangents() has been removed.');
	    };
	    Geometry.prototype.computeLineDistances = function () {
	        var d = 0;
	        var vertices = this.vertices;
	        for (var i = 0, il = vertices.length; i < il; i++) {
	            if (i > 0) {
	                d += vertices[i].distanceTo(vertices[i - 1]);
	            }
	            this.lineDistances[i] = d;
	        }
	    };
	    Geometry.prototype.computeBoundingBox = function () {
	        if (this.boundingBox === null) {
	            this.boundingBox = new Box3();
	        }
	        this.boundingBox.setFromPoints(this.vertices);
	    };
	    Geometry.prototype.computeBoundingSphere = function () {
	        if (this.boundingSphere === null) {
	            this.boundingSphere = new Sphere();
	        }
	        this.boundingSphere.setFromPoints(this.vertices);
	    };
	    Geometry.prototype.merge = function (geometry, matrix, materialIndexOffset) {
	        if (materialIndexOffset === void 0) { materialIndexOffset = 0; }
	        var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
	        if (matrix !== undefined) {
	            normalMatrix = new Matrix3().getNormalMatrix(matrix);
	        }
	        // vertices
	        for (var i = 0, il = vertices2.length; i < il; i++) {
	            var vertex = vertices2[i];
	            var vertexCopy = vertex.clone();
	            if (matrix !== undefined)
	                vertexCopy.applyMatrix4(matrix);
	            vertices1.push(vertexCopy);
	        }
	        // colors
	        for (var i = 0, il = colors2.length; i < il; i++) {
	            colors1.push(colors2[i].clone());
	        }
	        // faces
	        for (var i = 0, il = faces2.length; i < il; i++) {
	            var face = faces2[i], faceCopy = void 0, normal = void 0, color = void 0, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
	            faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
	            faceCopy.normal.copy(face.normal);
	            if (normalMatrix !== undefined) {
	                faceCopy.normal.applyMatrix3(normalMatrix).normalize();
	            }
	            for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
	                normal = faceVertexNormals[j].clone();
	                if (normalMatrix !== undefined) {
	                    normal.applyMatrix3(normalMatrix).normalize();
	                }
	                faceCopy.vertexNormals.push(normal);
	            }
	            faceCopy.color.copy(face.color);
	            for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
	                color = faceVertexColors[j];
	                faceCopy.vertexColors.push(color.clone());
	            }
	            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	            faces1.push(faceCopy);
	        }
	        // uvs
	        for (var i = 0, il = uvs2.length; i < il; i++) {
	            var uv = uvs2[i], uvCopy = [];
	            if (uv === undefined) {
	                continue;
	            }
	            for (var j = 0, jl = uv.length; j < jl; j++) {
	                uvCopy.push(uv[j].clone());
	            }
	            uvs1.push(uvCopy);
	        }
	    };
	    Geometry.prototype.mergeMesh = function (mesh) {
	        if ((mesh && mesh instanceof Mesh) === false) {
	            console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
	            return;
	        }
	        mesh.matrixAutoUpdate && mesh.updateMatrix();
	        if (mesh.geometry instanceof Geometry) {
	            this.merge(mesh.geometry, mesh.matrix);
	        }
	    };
	    /*
	     * Checks for duplicate vertices with hashmap.
	     * Duplicated vertices are removed
	     * and faces' vertices are updated.
	     */
	    Geometry.prototype.mergeVertices = function () {
	        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
	        var unique = [], changes = [];
	        var v, key;
	        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
	        var precision = Math.pow(10, precisionPoints);
	        var i, il, face;
	        var indices, j, jl;
	        for (i = 0, il = this.vertices.length; i < il; i++) {
	            v = this.vertices[i];
	            key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
	            if (verticesMap[key] === undefined) {
	                verticesMap[key] = i;
	                unique.push(this.vertices[i]);
	                changes[i] = unique.length - 1;
	            }
	            else {
	                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
	                changes[i] = changes[verticesMap[key]];
	            }
	        }
	        // if faces are completely degenerate after merging vertices, we
	        // have to remove them from the geometry.
	        var faceIndicesToRemove = [];
	        for (i = 0, il = this.faces.length; i < il; i++) {
	            face = this.faces[i];
	            face.a = changes[face.a];
	            face.b = changes[face.b];
	            face.c = changes[face.c];
	            indices = [face.a, face.b, face.c];
	            // if any duplicate vertices are found in a Face3
	            // we have to remove the face as nothing can be saved
	            for (var n = 0; n < 3; n++) {
	                if (indices[n] === indices[(n + 1) % 3]) {
	                    faceIndicesToRemove.push(i);
	                    break;
	                }
	            }
	        }
	        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
	            var idx = faceIndicesToRemove[i];
	            this.faces.splice(idx, 1);
	            for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
	                this.faceVertexUvs[j].splice(idx, 1);
	            }
	        }
	        // Use unique set of vertices
	        var diff = this.vertices.length - unique.length;
	        this.vertices = unique;
	        return diff;
	    };
	    Geometry.prototype.sortFacesByMaterialIndex = function () {
	        var faces = this.faces;
	        var length = faces.length;
	        // tag faces
	        for (var i = 0; i < length; i++) {
	            faces[i]._id = i;
	        }
	        // sort faces
	        function materialIndexSort(a, b) {
	            return a.materialIndex - b.materialIndex;
	        }
	        faces.sort(materialIndexSort);
	        // sort uvs
	        var uvs1 = this.faceVertexUvs[0];
	        var uvs2 = this.faceVertexUvs[1];
	        var newUvs1, newUvs2;
	        if (uvs1 && uvs1.length === length)
	            newUvs1 = [];
	        if (uvs2 && uvs2.length === length)
	            newUvs2 = [];
	        for (var i = 0; i < length; i++) {
	            var id = faces[i]._id;
	            if (newUvs1)
	                newUvs1.push(uvs1[id]);
	            if (newUvs2)
	                newUvs2.push(uvs2[id]);
	        }
	        if (newUvs1)
	            this.faceVertexUvs[0] = newUvs1;
	        if (newUvs2)
	            this.faceVertexUvs[1] = newUvs2;
	    };
	    Geometry.prototype.toJSON = function (meta) {
	        var data = {
	            metadata: {
	                version: 4.4,
	                type: 'Geometry',
	                generator: 'Geometry.toJSON'
	            }
	        };
	        // standard Geometry serialization
	        data.uuid = this.uuid;
	        data.type = this.type;
	        if (this.name !== '')
	            data.name = this.name;
	        if (this.parameters !== undefined) {
	            var parameters = this.parameters;
	            for (var key in parameters) {
	                if (parameters[key] !== undefined)
	                    data[key] = parameters[key];
	            }
	            return data;
	        }
	        var vertices = [];
	        for (var i = 0; i < this.vertices.length; i++) {
	            var vertex = this.vertices[i];
	            vertices.push(vertex.x, vertex.y, vertex.z);
	        }
	        var faces = [];
	        var normals = [];
	        var normalsHash = {};
	        var colors = [];
	        var colorsHash = {};
	        var uvs = [];
	        var uvsHash = {};
	        for (var i = 0; i < this.faces.length; i++) {
	            var face = this.faces[i];
	            var hasMaterial = true;
	            var hasFaceUv = false; // deprecated
	            var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
	            var hasFaceNormal = face.normal.length() > 0;
	            var hasFaceVertexNormal = face.vertexNormals.length > 0;
	            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
	            var hasFaceVertexColor = face.vertexColors.length > 0;
	            var faceType = 0;
	            faceType = setBit(faceType, 0, false); // isQuad
	            faceType = setBit(faceType, 1, hasMaterial);
	            faceType = setBit(faceType, 2, hasFaceUv);
	            faceType = setBit(faceType, 3, hasFaceVertexUv);
	            faceType = setBit(faceType, 4, hasFaceNormal);
	            faceType = setBit(faceType, 5, hasFaceVertexNormal);
	            faceType = setBit(faceType, 6, hasFaceColor);
	            faceType = setBit(faceType, 7, hasFaceVertexColor);
	            faces.push(faceType);
	            faces.push(face.a, face.b, face.c);
	            faces.push(face.materialIndex);
	            if (hasFaceVertexUv) {
	                var faceVertexUvs = this.faceVertexUvs[0][i];
	                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
	            }
	            if (hasFaceNormal) {
	                faces.push(getNormalIndex(face.normal));
	            }
	            if (hasFaceVertexNormal) {
	                var vertexNormals = face.vertexNormals;
	                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
	            }
	            if (hasFaceColor) {
	                faces.push(getColorIndex(face.color));
	            }
	            if (hasFaceVertexColor) {
	                var vertexColors = face.vertexColors;
	                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
	            }
	        }
	        function setBit(value, position, enabled) {
	            return enabled ? value | (1 << position) : value & (~(1 << position));
	        }
	        function getNormalIndex(normal) {
	            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	            if (normalsHash[hash] !== undefined) {
	                return normalsHash[hash];
	            }
	            normalsHash[hash] = normals.length / 3;
	            normals.push(normal.x, normal.y, normal.z);
	            return normalsHash[hash];
	        }
	        function getColorIndex(color) {
	            var hash = color.r.toString() + color.g.toString() + color.b.toString();
	            if (colorsHash[hash] !== undefined) {
	                return colorsHash[hash];
	            }
	            colorsHash[hash] = colors.length;
	            colors.push(color.getHex());
	            return colorsHash[hash];
	        }
	        function getUvIndex(uv) {
	            var hash = uv.x.toString() + uv.y.toString();
	            if (uvsHash[hash] !== undefined) {
	                return uvsHash[hash];
	            }
	            uvsHash[hash] = uvs.length / 2;
	            uvs.push(uv.x, uv.y);
	            return uvsHash[hash];
	        }
	        data.data = {};
	        data.data.vertices = vertices;
	        data.data.normals = normals;
	        if (colors.length > 0)
	            data.data.colors = colors;
	        if (uvs.length > 0)
	            data.data.uvs = [uvs]; // temporal backward compatibility
	        data.data.faces = faces;
	        return data;
	    };
	    Geometry.prototype.clone = function () {
	        /*
	        // Handle primitives
	        const parameters = this.parameters;
	        if (parameters !== undefined) {
	          const values = [];
	          for (let key in parameters) {
	            values.push(parameters[key]);
	          }
	          const geometry = Object.create(this.constructor.prototype);
	          this.constructor.apply(geometry, values);
	          return geometry;
	        }
	        return new this.constructor().copy(this);
	        */
	        return new this.constructor().copy(this);
	    };
	    Geometry.prototype.copy = function (source) {
	        this.vertices = [];
	        this.faces = [];
	        this.faceVertexUvs = [[]];
	        this.colors = [];
	        var vertices = source.vertices;
	        for (var i = 0, il = vertices.length; i < il; i++) {
	            this.vertices.push(vertices[i].clone());
	        }
	        var colors = source.colors;
	        for (var i = 0, il = colors.length; i < il; i++) {
	            this.colors.push(colors[i].clone());
	        }
	        var faces = source.faces;
	        for (var i = 0, il = faces.length; i < il; i++) {
	            this.faces.push(faces[i].clone());
	        }
	        for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {
	            var faceVertexUvs = source.faceVertexUvs[i];
	            if (this.faceVertexUvs[i] === undefined) {
	                this.faceVertexUvs[i] = [];
	            }
	            for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {
	                var uvs = faceVertexUvs[j], uvsCopy = [];
	                for (var k = 0, kl = uvs.length; k < kl; k++) {
	                    var uv = uvs[k];
	                    uvsCopy.push(uv.clone());
	                }
	                this.faceVertexUvs[i].push(uvsCopy);
	            }
	        }
	        return this;
	    };
	    Geometry.prototype.dispose = function () {
	        this.dispatchEvent({ type: 'dispose' });
	    };
	    return Geometry;
	}(EventDispatcher));
	var count$3 = 0;
	function GeometryIdCount() { return count$3++; }

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	var Box3 = /** @class */ (function () {
	    function Box3(min, max) {
	        if (min === void 0) { min = new Vector3(+Infinity, +Infinity, +Infinity); }
	        if (max === void 0) { max = new Vector3(-Infinity, -Infinity, -Infinity); }
	        this.isBox3 = true;
	        this.min = min;
	        this.max = max;
	    }
	    Box3.prototype.set = function (min, max) {
	        this.min.copy(min);
	        this.max.copy(max);
	        return this;
	    };
	    Box3.prototype.setFromArray = function (array) {
	        var minX = +Infinity;
	        var minY = +Infinity;
	        var minZ = +Infinity;
	        var maxX = -Infinity;
	        var maxY = -Infinity;
	        var maxZ = -Infinity;
	        for (var i = 0, l = array.length; i < l; i += 3) {
	            var x = array[i];
	            var y = array[i + 1];
	            var z = array[i + 2];
	            if (x < minX)
	                minX = x;
	            if (y < minY)
	                minY = y;
	            if (z < minZ)
	                minZ = z;
	            if (x > maxX)
	                maxX = x;
	            if (y > maxY)
	                maxY = y;
	            if (z > maxZ)
	                maxZ = z;
	        }
	        this.min.set(minX, minY, minZ);
	        this.max.set(maxX, maxY, maxZ);
	    };
	    Box3.prototype.setFromPoints = function (points) {
	        this.makeEmpty();
	        for (var i = 0, il = points.length; i < il; i++) {
	            this.expandByPoint(points[i]);
	        }
	        return this;
	    };
	    Box3.prototype.setFromCenterAndSize = function (center, size) {
	        var v1 = Box3._setFromCenterAndSize_v1;
	        var halfSize = v1.copy(size).multiplyScalar(0.5);
	        this.min.copy(center).sub(halfSize);
	        this.max.copy(center).add(halfSize);
	        return this;
	    };
	    Box3.prototype.setFromObject = function (object) {
	        // Computes the world-axis-aligned bounding box of an object (including its children),
	        // accounting for both the object's, and children's, world transforms
	        var v1 = Box3._setFromObject_v1;
	        var scope = this;
	        object.updateMatrixWorld(true);
	        this.makeEmpty();
	        object.traverse(function (node) {
	            var geometry = node.geometry;
	            if (geometry !== undefined) {
	                if ((geometry && geometry instanceof Geometry)) {
	                    var vertices = geometry.vertices;
	                    for (var i = 0, il = vertices.length; i < il; i++) {
	                        v1.copy(vertices[i]);
	                        v1.applyMatrix4(node.matrixWorld);
	                        scope.expandByPoint(v1);
	                    }
	                }
	                else if ((geometry && geometry instanceof BufferGeometry)) {
	                    var attribute = geometry.attributes.position;
	                    if (attribute !== undefined) {
	                        var array = void 0, offset = void 0, stride = void 0;
	                        if ((attribute && attribute instanceof InterleavedBufferAttribute)) {
	                            array = attribute.data.array;
	                            offset = attribute.offset;
	                            stride = attribute.data.stride;
	                        }
	                        else {
	                            array = attribute.array;
	                            offset = 0;
	                            stride = 3;
	                        }
	                        for (var i = offset, il = array.length; i < il; i += stride) {
	                            v1.fromArray(array, i);
	                            v1.applyMatrix4(node.matrixWorld);
	                            scope.expandByPoint(v1);
	                        }
	                    }
	                }
	            }
	        });
	        return this;
	    };
	    Box3.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Box3.prototype.copy = function (box) {
	        this.min.copy(box.min);
	        this.max.copy(box.max);
	        return this;
	    };
	    Box3.prototype.makeEmpty = function () {
	        this.min.x = this.min.y = this.min.z = +Infinity;
	        this.max.x = this.max.y = this.max.z = -Infinity;
	        return this;
	    };
	    Box3.prototype.isEmpty = function () {
	        // this is a more robust check for empty than (volume <= 0) because volume can get positive with two negative axes
	        return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
	    };
	    Box3.prototype.getCenter = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
	    };
	    Box3.prototype.getSize = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
	    };
	    Box3.prototype.expandByPoint = function (point) {
	        this.min.min(point);
	        this.max.max(point);
	        return this;
	    };
	    Box3.prototype.expandByVector = function (vector) {
	        this.min.sub(vector);
	        this.max.add(vector);
	        return this;
	    };
	    Box3.prototype.expandByScalar = function (scalar) {
	        this.min.addScalar(-scalar);
	        this.max.addScalar(scalar);
	        return this;
	    };
	    Box3.prototype.containsPoint = function (point) {
	        if (point.x < this.min.x || point.x > this.max.x ||
	            point.y < this.min.y || point.y > this.max.y ||
	            point.z < this.min.z || point.z > this.max.z) {
	            return false;
	        }
	        return true;
	    };
	    Box3.prototype.containsBox = function (box) {
	        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) &&
	            (this.min.y <= box.min.y) && (box.max.y <= this.max.y) &&
	            (this.min.z <= box.min.z) && (box.max.z <= this.max.z)) {
	            return true;
	        }
	        return false;
	    };
	    Box3.prototype.getParameter = function (point, result) {
	        if (result === void 0) { result = new Vector3(); }
	        // This can potentially have a divide by zero if the box
	        // has a size dimension of 0.
	        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
	    };
	    Box3.prototype.intersectsBox = function (box) {
	        // using 6 splitting planes to rule out intersections.
	        if (box.max.x < this.min.x || box.min.x > this.max.x ||
	            box.max.y < this.min.y || box.min.y > this.max.y ||
	            box.max.z < this.min.z || box.min.z > this.max.z) {
	            return false;
	        }
	        return true;
	    };
	    Box3.prototype.intersectsSphere = function (sphere) {
	        var closestPoint = Box3._intersectsSphere_closestPoint;
	        // Find the point on the AABB closest to the sphere center.
	        this.clampPoint(sphere.center, closestPoint);
	        // If that point is inside the sphere, the AABB and sphere intersect.
	        return closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
	    };
	    Box3.prototype.intersectsPlane = function (plane) {
	        // We compute the minimum and maximum dot product values. If those values
	        // are on the same side (back or front) of the plane, then there is no intersection.
	        var min, max;
	        if (plane.normal.x > 0) {
	            min = plane.normal.x * this.min.x;
	            max = plane.normal.x * this.max.x;
	        }
	        else {
	            min = plane.normal.x * this.max.x;
	            max = plane.normal.x * this.min.x;
	        }
	        if (plane.normal.y > 0) {
	            min += plane.normal.y * this.min.y;
	            max += plane.normal.y * this.max.y;
	        }
	        else {
	            min += plane.normal.y * this.max.y;
	            max += plane.normal.y * this.min.y;
	        }
	        if (plane.normal.z > 0) {
	            min += plane.normal.z * this.min.z;
	            max += plane.normal.z * this.max.z;
	        }
	        else {
	            min += plane.normal.z * this.max.z;
	            max += plane.normal.z * this.min.z;
	        }
	        return (min <= plane.constant && max >= plane.constant);
	    };
	    Box3.prototype.clampPoint = function (point, result) {
	        if (result === void 0) { result = new Vector3(); }
	        return result.copy(point).clamp(this.min, this.max);
	    };
	    Box3.prototype.distanceToPoint = function (point) {
	        var v1 = Box3._distanceToPoint_v1;
	        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
	        return clampedPoint.sub(point).length();
	    };
	    Box3.prototype.getBoundingSphere = function (result) {
	        if (result === void 0) { result = new Sphere(); }
	        var v1 = Box3._getBoundingSphere_v1;
	        this.getCenter(result.center);
	        result.radius = this.getSize(v1).length() * 0.5;
	        return result;
	    };
	    Box3.prototype.intersect = function (box) {
	        this.min.max(box.min);
	        this.max.min(box.max);
	        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
	        if (this.isEmpty())
	            this.makeEmpty();
	        return this;
	    };
	    Box3.prototype.union = function (box) {
	        this.min.min(box.min);
	        this.max.max(box.max);
	        return this;
	    };
	    Box3.prototype.applyMatrix4 = function (matrix) {
	        // transform of empty box is an empty box.
	        if (this.isEmpty())
	            return this;
	        var points = Box3._applyMatrix4_points;
	        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
	        points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
	        points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
	        points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
	        points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
	        points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
	        points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
	        points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
	        points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
	        this.setFromPoints(points);
	        return this;
	    };
	    Box3.prototype.translate = function (offset) {
	        this.min.add(offset);
	        this.max.add(offset);
	        return this;
	    };
	    Box3.prototype.equals = function (box) {
	        return box.min.equals(this.min) && box.max.equals(this.max);
	    };
	    Box3.prototype.center = function (optionalTarget) {
	        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
	        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
	        return this.getCenter(optionalTarget);
	    };
	    Box3.prototype.empty = function () {
	        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
	        return this.isEmpty();
	    };
	    Box3.prototype.isIntersectionBox = function (box) {
	        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
	        return this.intersectsBox(box);
	    };
	    Box3.prototype.isIntersectionSphere = function (sphere) {
	        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
	        return this.intersectsSphere(sphere);
	    };
	    Box3.prototype.size = function (optionalTarget) {
	        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
	        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
	        return this.getSize(optionalTarget);
	    };
	    Box3._setFromCenterAndSize_v1 = new Vector3();
	    Box3._setFromObject_v1 = new Vector3();
	    Box3._intersectsSphere_closestPoint = new Vector3();
	    Box3._distanceToPoint_v1 = new Vector3();
	    Box3._getBoundingSphere_v1 = new Vector3();
	    Box3._applyMatrix4_points = [
	        new Vector3(), new Vector3(), new Vector3(), new Vector3(),
	        new Vector3(), new Vector3(), new Vector3(), new Vector3()
	    ];
	    return Box3;
	}());

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Sphere = /** @class */ (function () {
	    function Sphere(center, radius) {
	        if (center === void 0) { center = new Vector3(); }
	        if (radius === void 0) { radius = 0; }
	        this.center = center;
	        this.radius = radius;
	    }
	    Sphere.prototype.set = function (center, radius) {
	        this.center.copy(center);
	        this.radius = radius;
	        return this;
	    };
	    Sphere.prototype.setFromPoints = function (points, optionalCenter) {
	        var box = Sphere.setFromPoints_box;
	        var center = this.center;
	        if (optionalCenter !== undefined) {
	            center.copy(optionalCenter);
	        }
	        else {
	            box.setFromPoints(points).getCenter(center);
	        }
	        var maxRadiusSq = 0;
	        for (var i = 0, il = points.length; i < il; i++) {
	            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
	        }
	        this.radius = Math.sqrt(maxRadiusSq);
	        return this;
	    };
	    Sphere.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Sphere.prototype.copy = function (sphere) {
	        this.center.copy(sphere.center);
	        this.radius = sphere.radius;
	        return this;
	    };
	    Sphere.prototype.empty = function () {
	        return (this.radius <= 0);
	    };
	    Sphere.prototype.containsPoint = function (point) {
	        return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
	    };
	    Sphere.prototype.distanceToPoint = function (point) {
	        return (point.distanceTo(this.center) - this.radius);
	    };
	    Sphere.prototype.intersectsSphere = function (sphere) {
	        var radiusSum = this.radius + sphere.radius;
	        return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
	    };
	    Sphere.prototype.intersectsBox = function (box) {
	        return box.intersectsSphere(this);
	    };
	    Sphere.prototype.intersectsPlane = function (plane) {
	        // We use the following equation to compute the signed distance from
	        // the center of the sphere to the plane.
	        //
	        // distance = q * n - d
	        //
	        // If this distance is greater than the radius of the sphere,
	        // then there is no intersection.
	        return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
	    };
	    Sphere.prototype.clampPoint = function (point, result) {
	        if (result === void 0) { result = new Vector3(); }
	        var deltaLengthSq = this.center.distanceToSquared(point);
	        result.copy(point);
	        if (deltaLengthSq > (this.radius * this.radius)) {
	            result.sub(this.center).normalize();
	            result.multiplyScalar(this.radius).add(this.center);
	        }
	        return result;
	    };
	    Sphere.prototype.getBoundingBox = function (box) {
	        if (box === void 0) { box = new Box3(); }
	        box.set(this.center, this.center);
	        box.expandByScalar(this.radius);
	        return box;
	    };
	    Sphere.prototype.applyMatrix4 = function (matrix) {
	        this.center.applyMatrix4(matrix);
	        this.radius = this.radius * matrix.getMaxScaleOnAxis();
	        return this;
	    };
	    Sphere.prototype.translate = function (offset) {
	        this.center.add(offset);
	        return this;
	    };
	    Sphere.prototype.equals = function (sphere) {
	        return sphere.center.equals(this.center) && (sphere.radius === this.radius);
	    };
	    Sphere.setFromPoints_box = new Box3();
	    return Sphere;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */
	var Frustum = /** @class */ (function () {
	    function Frustum(p0, p1, p2, p3, p4, p5) {
	        if (p0 === void 0) { p0 = new Plane(); }
	        if (p1 === void 0) { p1 = new Plane(); }
	        if (p2 === void 0) { p2 = new Plane(); }
	        if (p3 === void 0) { p3 = new Plane(); }
	        if (p4 === void 0) { p4 = new Plane(); }
	        if (p5 === void 0) { p5 = new Plane(); }
	        this.planes = [p0, p1, p2, p3, p4, p5];
	    }
	    Frustum.prototype.set = function (p0, p1, p2, p3, p4, p5) {
	        var planes = this.planes;
	        planes[0].copy(p0);
	        planes[1].copy(p1);
	        planes[2].copy(p2);
	        planes[3].copy(p3);
	        planes[4].copy(p4);
	        planes[5].copy(p5);
	        return this;
	    };
	    Frustum.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Frustum.prototype.copy = function (frustum) {
	        var planes = this.planes;
	        for (var i = 0; i < 6; i++) {
	            planes[i].copy(frustum.planes[i]);
	        }
	        return this;
	    };
	    Frustum.prototype.setFromMatrix = function (m) {
	        var planes = this.planes;
	        var me = m.elements;
	        var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
	        var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
	        var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
	        var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
	        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
	        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
	        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
	        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
	        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
	        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
	        return this;
	    };
	    Frustum.prototype.intersectsObject = function (object) {
	        var sphere = Frustum.intersectsObject_sphere;
	        var geometry = object.geometry;
	        if (geometry.boundingSphere === null)
	            geometry.computeBoundingSphere();
	        sphere.copy(geometry.boundingSphere)
	            .applyMatrix4(object.matrixWorld);
	        return this.intersectsSphere(sphere);
	    };
	    Frustum.prototype.intersectsSprite = function (sprite) {
	        var sphere = Frustum.intersectsSprite_sphere;
	        sphere.center.set(0, 0, 0);
	        sphere.radius = 0.7071067811865476;
	        sphere.applyMatrix4(sprite.matrixWorld);
	        return this.intersectsSphere(sphere);
	    };
	    Frustum.prototype.intersectsSphere = function (sphere) {
	        var planes = this.planes;
	        var center = sphere.center;
	        var negRadius = -sphere.radius;
	        for (var i = 0; i < 6; i++) {
	            var distance = planes[i].distanceToPoint(center);
	            if (distance < negRadius) {
	                return false;
	            }
	        }
	        return true;
	    };
	    Frustum.prototype.intersectsBox = function (box) {
	        var p1 = Frustum.intersectsBox_p1, p2 = Frustum.intersectsBox_p2;
	        var planes = this.planes;
	        for (var i = 0; i < 6; i++) {
	            var plane = planes[i];
	            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
	            p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
	            p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
	            p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
	            p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
	            p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	            var d1 = plane.distanceToPoint(p1);
	            var d2 = plane.distanceToPoint(p2);
	            // if both outside plane, no intersection
	            if (d1 < 0 && d2 < 0) {
	                return false;
	            }
	        }
	        return true;
	    };
	    Frustum.prototype.containsPoint = function (point) {
	        var planes = this.planes;
	        for (var i = 0; i < 6; i++) {
	            if (planes[i].distanceToPoint(point) < 0) {
	                return false;
	            }
	        }
	        return true;
	    };
	    Frustum.intersectsObject_sphere = new Sphere();
	    Frustum.intersectsSprite_sphere = new Sphere();
	    Frustum.intersectsBox_p1 = new Vector3();
	    Frustum.intersectsBox_p2 = new Vector3();
	    return Frustum;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	var Camera = /** @class */ (function (_super) {
	    __extends(Camera, _super);
	    function Camera() {
	        var _this = _super.call(this) || this;
	        _this.matrixWorldInverse = new Matrix4();
	        _this.projectionMatrix = new Matrix4();
	        // }
	        _this.isCamera = true;
	        _this.type = 'Camera';
	        return _this;
	    }
	    Camera.prototype.updateProjectionMatrix = function () { };
	    Camera.prototype.getWorldDirection = function (result) {
	        if (result === void 0) { result = new Vector3(); }
	        var quaternion = new Quaternion();
	        //return function getWorldDirection(result) {
	        this.getWorldQuaternion(quaternion);
	        return result.set(0, 0, -1).applyQuaternion(quaternion);
	        //};
	    };
	    Camera.prototype.lookAt = function (vector) {
	        // This routine does not support cameras with rotated and/or translated parent(s)
	        var m1 = new Matrix4();
	        //return function lookAt(vector) {
	        m1.lookAt(this.position, vector, this.up);
	        this.quaternion.setFromRotationMatrix(m1);
	        //};
	    };
	    Camera.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Camera.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.matrixWorldInverse.copy(source.matrixWorldInverse);
	        this.projectionMatrix.copy(source.projectionMatrix);
	        return this;
	    };
	    return Camera;
	}(Object3D));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */
	var OrthographicCamera = /** @class */ (function (_super) {
	    __extends(OrthographicCamera, _super);
	    function OrthographicCamera(left, right, top, bottom, near, far) {
	        if (near === void 0) { near = 0.1; }
	        if (far === void 0) { far = 2000; }
	        var _this = _super.call(this) || this;
	        _this.zoom = 1;
	        _this.view = null;
	        _this.isOrthographicCamera = true;
	        _this.type = 'OrthographicCamera';
	        _this.left = left;
	        _this.right = right;
	        _this.top = top;
	        _this.bottom = bottom;
	        _this.near = near;
	        _this.far = far;
	        _this.updateProjectionMatrix();
	        return _this;
	    }
	    OrthographicCamera.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.left = source.left;
	        this.right = source.right;
	        this.top = source.top;
	        this.bottom = source.bottom;
	        this.near = source.near;
	        this.far = source.far;
	        this.zoom = source.zoom;
	        this.view = source.view === null ? null : Object.assign({}, source.view);
	        return this;
	    };
	    OrthographicCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
	        this.view = {
	            fullWidth: fullWidth,
	            fullHeight: fullHeight,
	            offsetX: x,
	            offsetY: y,
	            width: width,
	            height: height
	        };
	        this.updateProjectionMatrix();
	    };
	    OrthographicCamera.prototype.clearViewOffset = function () {
	        this.view = null;
	        this.updateProjectionMatrix();
	    };
	    OrthographicCamera.prototype.updateProjectionMatrix = function () {
	        var dx = (this.right - this.left) / (2 * this.zoom);
	        var dy = (this.top - this.bottom) / (2 * this.zoom);
	        var cx = (this.right + this.left) / 2;
	        var cy = (this.top + this.bottom) / 2;
	        var left = cx - dx;
	        var right = cx + dx;
	        var top = cy + dy;
	        var bottom = cy - dy;
	        if (this.view !== null) {
	            var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
	            var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
	            var scaleW = (this.right - this.left) / this.view.width;
	            var scaleH = (this.top - this.bottom) / this.view.height;
	            left += scaleW * (this.view.offsetX / zoomW);
	            right = left + scaleW * (this.view.width / zoomW);
	            top -= scaleH * (this.view.offsetY / zoomH);
	            bottom = top - scaleH * (this.view.height / zoomH);
	        }
	        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
	    };
	    OrthographicCamera.prototype.toJSON = function (meta) {
	        var data = _super.prototype.toJSON.call(this, meta);
	        data.object.zoom = this.zoom;
	        data.object.left = this.left;
	        data.object.right = this.right;
	        data.object.top = this.top;
	        data.object.bottom = this.bottom;
	        data.object.near = this.near;
	        data.object.far = this.far;
	        if (this.view !== null)
	            data.object.view = Object.assign({}, this.view);
	        return data;
	    };
	    return OrthographicCamera;
	}(Camera));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */
	var PerspectiveCamera = /** @class */ (function (_super) {
	    __extends(PerspectiveCamera, _super);
	    function PerspectiveCamera(fov, aspect, near, far) {
	        if (fov === void 0) { fov = 50; }
	        if (aspect === void 0) { aspect = 1; }
	        if (near === void 0) { near = 0.1; }
	        if (far === void 0) { far = 2000; }
	        var _this = _super.call(this) || this;
	        _this.zoom = 1;
	        _this.focus = 10;
	        _this.view = null;
	        _this.filmGauge = 35; // width of the film (default in millimeters)
	        _this.filmOffset = 0; // horizontal film offset (same unit as gauge)
	        _this.isPerspectiveCamera = true;
	        _this.type = 'PerspectiveCamera';
	        _this.fov = fov;
	        _this.near = near;
	        _this.far = far;
	        _this.aspect = aspect;
	        _this.updateProjectionMatrix();
	        return _this;
	    }
	    PerspectiveCamera.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.fov = source.fov;
	        this.zoom = source.zoom;
	        this.near = source.near;
	        this.far = source.far;
	        this.focus = source.focus;
	        this.aspect = source.aspect;
	        this.view = source.view === null ? null : Object.assign({}, source.view);
	        this.filmGauge = source.filmGauge;
	        this.filmOffset = source.filmOffset;
	        return this;
	    };
	    PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
	        console.warn("THREE.PerspectiveCamera.setLens is deprecated. " +
	            "Use .setFocalLength and .filmGauge for a photographic setup.");
	        if (filmGauge !== undefined)
	            this.filmGauge = filmGauge;
	        this.setFocalLength(focalLength);
	    };
	    /**
	     * Sets the FOV by focal length in respect to the current .filmGauge.
	     *
	     * The default film gauge is 35, so that the focal length can be specified for
	     * a 35mm (full frame) camera.
	     *
	     * Values for focal length and film gauge must have the same unit.
	     */
	    PerspectiveCamera.prototype.setFocalLength = function (focalLength) {
	        // see http://www.bobatkins.com/photography/technical/field_of_view.html
	        var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
	        this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
	        this.updateProjectionMatrix();
	    };
	    /**
	     * Calculates the focal length from the current .fov and .filmGauge.
	     */
	    PerspectiveCamera.prototype.getFocalLength = function () {
	        var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
	        return 0.5 * this.getFilmHeight() / vExtentSlope;
	    };
	    PerspectiveCamera.prototype.getEffectiveFOV = function () {
	        return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
	    };
	    PerspectiveCamera.prototype.getFilmWidth = function () {
	        // film not completely covered in portrait format (aspect < 1)
	        return this.filmGauge * Math.min(this.aspect, 1);
	    };
	    PerspectiveCamera.prototype.getFilmHeight = function () {
	        // film not completely covered in landscape format (aspect > 1)
	        return this.filmGauge / Math.max(this.aspect, 1);
	    };
	    /**
	     * Sets an offset in a larger frustum. This is useful for multi-window or
	     * multi-monitor/multi-machine setups.
	     *
	     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	     * the monitors are in grid like this
	     *
	     *   +---+---+---+
	     *   | A | B | C |
	     *   +---+---+---+
	     *   | D | E | F |
	     *   +---+---+---+
	     *
	     * then for each monitor you would call it like this
	     *
	     *   let w = 1920;
	     *   let h = 1080;
	     *   let fullWidth = w * 3;
	     *   let fullHeight = h * 2;
	     *
	     *   --A--
	     *   camera.setOffset(fullWidth, fullHeight, w * 0, h * 0, w, h);
	     *   --B--
	     *   camera.setOffset(fullWidth, fullHeight, w * 1, h * 0, w, h);
	     *   --C--
	     *   camera.setOffset(fullWidth, fullHeight, w * 2, h * 0, w, h);
	     *   --D--
	     *   camera.setOffset(fullWidth, fullHeight, w * 0, h * 1, w, h);
	     *   --E--
	     *   camera.setOffset(fullWidth, fullHeight, w * 1, h * 1, w, h);
	     *   --F--
	     *   camera.setOffset(fullWidth, fullHeight, w * 2, h * 1, w, h);
	     *
	     *   Note there is no reason monitors have to be the same size or in a grid.
	     */
	    PerspectiveCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
	        this.aspect = fullWidth / fullHeight;
	        this.view = {
	            fullWidth: fullWidth,
	            fullHeight: fullHeight,
	            offsetX: x,
	            offsetY: y,
	            width: width,
	            height: height
	        };
	        this.updateProjectionMatrix();
	    };
	    PerspectiveCamera.prototype.clearViewOffset = function () {
	        this.view = null;
	        this.updateProjectionMatrix();
	    };
	    PerspectiveCamera.prototype.updateProjectionMatrix = function () {
	        var near = this.near;
	        var top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom;
	        var height = 2 * top;
	        var width = this.aspect * height;
	        var left = -0.5 * width;
	        var view = this.view;
	        if (view !== null) {
	            var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
	            left += view.offsetX * width / fullWidth;
	            top -= view.offsetY * height / fullHeight;
	            width *= view.width / fullWidth;
	            height *= view.height / fullHeight;
	        }
	        var skew = this.filmOffset;
	        if (skew !== 0)
	            left += near * skew / this.getFilmWidth();
	        this.projectionMatrix.makeFrustum(left, left + width, top - height, top, near, this.far);
	    };
	    PerspectiveCamera.prototype.toJSON = function (meta) {
	        var data = _super.prototype.toJSON.call(this, meta);
	        data.object.fov = this.fov;
	        data.object.zoom = this.zoom;
	        data.object.near = this.near;
	        data.object.far = this.far;
	        data.object.focus = this.focus;
	        data.object.aspect = this.aspect;
	        if (this.view !== null)
	            data.object.view = Object.assign({}, this.view);
	        data.object.filmGauge = this.filmGauge;
	        data.object.filmOffset = this.filmOffset;
	        return data;
	    };
	    return PerspectiveCamera;
	}(Camera));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var Light = /** @class */ (function (_super) {
	    __extends(Light, _super);
	    function Light(color, intensity) {
	        if (intensity === void 0) { intensity = 1; }
	        var _this = _super.call(this) || this;
	        _this.isLight = true;
	        _this.type = 'Light';
	        _this.color = new Color(color);
	        _this.intensity = intensity !== undefined ? intensity : 1;
	        _this.receiveShadow = undefined;
	        return _this;
	    }
	    Light.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.color.copy(source.color);
	        this.intensity = source.intensity;
	        return this;
	    };
	    Light.prototype.toJSON = function (meta) {
	        var data = _super.prototype.toJSON.call(this, meta);
	        data.object.color = this.color.getHex();
	        data.object.intensity = this.intensity;
	        if (this.groundColor !== undefined)
	            data.object.groundColor = this.groundColor.getHex();
	        if (this.distance !== undefined)
	            data.object.distance = this.distance;
	        if (this.angle !== undefined)
	            data.object.angle = this.angle;
	        if (this.decay !== undefined)
	            data.object.decay = this.decay;
	        if (this.penumbra !== undefined)
	            data.object.penumbra = this.penumbra;
	        if (this.shadow !== undefined)
	            data.object.shadow = this.shadow.toJSON();
	        return data;
	    };
	    Object.defineProperty(Light.prototype, "onlyShadow", {
	        set: function (value) {
	            console.warn("THREE.Light: .onlyShadow has been removed.");
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowCameraFov", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
	            if (this.shadow.camera instanceof PerspectiveCamera) {
	                this.shadow.camera.fov = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowCameraLeft", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
	            if (this.shadow.camera instanceof OrthographicCamera) {
	                this.shadow.camera.left = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowCameraRight", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
	            if (this.shadow.camera instanceof OrthographicCamera) {
	                this.shadow.camera.right = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowCameraTop", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
	            if (this.shadow.camera instanceof OrthographicCamera) {
	                this.shadow.camera.top = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowCameraBottom", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
	            if (this.shadow.camera instanceof OrthographicCamera) {
	                this.shadow.camera.bottom = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowCameraNear", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
	            if (this.shadow.camera instanceof OrthographicCamera) {
	                this.shadow.camera.near = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowCameraFar", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
	            if (this.shadow.camera instanceof OrthographicCamera) {
	                this.shadow.camera.far = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowCameraVisible", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper(light.shadow.camera) instead.");
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowBias", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
	            this.shadow.bias = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowDarkness", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowDarkness has been removed.");
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowMapWidth", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
	            this.shadow.mapSize.width = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Light.prototype, "shadowMapHeight", {
	        set: function (value) {
	            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
	            this.shadow.mapSize.height = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Light;
	}(Object3D));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var LightShadow = /** @class */ (function () {
	    function LightShadow(camera) {
	        this.bias = 0;
	        this.radius = 1;
	        this.mapSize = new Vector2(512, 512);
	        this.map = null;
	        this.matrix = new Matrix4();
	        this.camera = camera;
	    }
	    LightShadow.prototype.copy = function (source) {
	        this.camera = source.camera.clone();
	        this.bias = source.bias;
	        this.radius = source.radius;
	        this.mapSize.copy(source.mapSize);
	        return this;
	    };
	    LightShadow.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    LightShadow.prototype.toJSON = function () {
	        var object = {};
	        if (this.bias !== 0)
	            object.bias = this.bias;
	        if (this.radius !== 1)
	            object.radius = this.radius;
	        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
	            object.mapSize = this.mapSize.toArray();
	        object.camera = this.camera.toJSON(false).object;
	        delete object.camera.matrix;
	        return object;
	    };
	    return LightShadow;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var PointLight = /** @class */ (function (_super) {
	    __extends(PointLight, _super);
	    function PointLight(color, intensity, distance, decay) {
	        if (distance === void 0) { distance = 0; }
	        if (decay === void 0) { decay = 1; }
	        var _this = _super.call(this, color, intensity) || this;
	        _this.isPointLight = true;
	        _this.type = 'PointLight';
	        _this.distance = distance;
	        _this.decay = decay; // for physically correct lights, should be 2.
	        _this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
	        return _this;
	    }
	    Object.defineProperty(PointLight.prototype, "power", {
	        get: function () {
	            // intensity = power per solid angle.
	            // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
	            return this.intensity * 4 * Math.PI;
	        },
	        set: function (value) {
	            // intensity = power per solid angle.
	            // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
	            this.intensity = value / (4 * Math.PI);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PointLight.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.distance = source.distance;
	        this.decay = source.decay;
	        this.shadow = source.shadow.clone();
	        return this;
	    };
	    return PointLight;
	}(Light));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var SpotLightShadow = /** @class */ (function (_super) {
	    __extends(SpotLightShadow, _super);
	    function SpotLightShadow() {
	        var _this = _super.call(this, new PerspectiveCamera(50, 1, 0.5, 500)) || this;
	        _this.isSpotLightShadow = true;
	        return _this;
	    }
	    SpotLightShadow.prototype.update = function (light) {
	        var fov = _Math.RAD2DEG * 2 * light.angle;
	        var aspect = this.mapSize.width / this.mapSize.height;
	        var far = light.distance || 500;
	        var camera = this.camera;
	        if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
	            camera.fov = fov;
	            camera.aspect = aspect;
	            camera.far = far;
	            camera.updateProjectionMatrix();
	        }
	    };
	    return SpotLightShadow;
	}(LightShadow));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	var DataTexture = /** @class */ (function (_super) {
	    __extends(DataTexture, _super);
	    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
	        if (magFilter === void 0) { magFilter = exports.TextureFilter.Nearest; }
	        if (minFilter === void 0) { minFilter = exports.TextureFilter.Nearest; }
	        var _this = _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
	        _this.isDataTexture = true;
	        _this.image = { data: data, width: width, height: height };
	        _this.magFilter = magFilter;
	        _this.minFilter = minFilter;
	        _this.generateMipmaps = false;
	        _this.flipY = false;
	        _this.unpackAlignment = 1;
	        return _this;
	    }
	    return DataTexture;
	}(Texture));

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	var Bone = /** @class */ (function (_super) {
	    __extends(Bone, _super);
	    function Bone(skin) {
	        var _this = _super.call(this) || this;
	        _this.isBone = true;
	        _this.type = 'Bone';
	        _this.skin = skin;
	        return _this;
	    }
	    Bone.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.skin = source.skin;
	        return this;
	    };
	    return Bone;
	}(Object3D));

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */
	var Skeleton = /** @class */ (function () {
	    function Skeleton(bones, boneInverses, useVertexTexture) {
	        if (bones === void 0) { bones = []; }
	        if (useVertexTexture === void 0) { useVertexTexture = true; }
	        this.identityMatrix = new Matrix4();
	        this.useVertexTexture = useVertexTexture;
	        // copy the bone array
	        this.bones = bones.slice(0);
	        // create a bone texture or an array of floats
	        if (this.useVertexTexture) {
	            // layout (1 matrix = 4 pixels)
	            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
	            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
	            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
	            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
	            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	            var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
	            size = _Math.nextPowerOfTwo(Math.ceil(size));
	            size = Math.max(size, 4);
	            this.boneTextureWidth = size;
	            this.boneTextureHeight = size;
	            this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4); // 4 floats per RGBA pixel
	            this.boneTexture = new DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, exports.TextureFormat.RGBA, exports.TextureType.Float);
	        }
	        else {
	            this.boneMatrices = new Float32Array(16 * this.bones.length);
	        }
	        // use the supplied bone inverses or calculate the inverses
	        if (boneInverses === undefined) {
	            this.calculateInverses();
	        }
	        else {
	            if (this.bones.length === boneInverses.length) {
	                this.boneInverses = boneInverses.slice(0);
	            }
	            else {
	                console.warn('THREE.Skeleton bonInverses is the wrong length.');
	                this.boneInverses = [];
	                for (var b = 0, bl = this.bones.length; b < bl; b++) {
	                    this.boneInverses.push(new Matrix4());
	                }
	            }
	        }
	    }
	    Skeleton.prototype.calculateInverses = function () {
	        this.boneInverses = [];
	        for (var b = 0, bl = this.bones.length; b < bl; b++) {
	            var inverse = new Matrix4();
	            if (this.bones[b]) {
	                inverse.getInverse(this.bones[b].matrixWorld);
	            }
	            this.boneInverses.push(inverse);
	        }
	    };
	    Skeleton.prototype.pose = function () {
	        var bone;
	        // recover the bind-time world matrices
	        for (var b = 0, bl = this.bones.length; b < bl; b++) {
	            bone = this.bones[b];
	            if (bone) {
	                bone.matrixWorld.getInverse(this.boneInverses[b]);
	            }
	        }
	        // compute the local matrices, positions, rotations and scales
	        for (var b = 0, bl = this.bones.length; b < bl; b++) {
	            bone = this.bones[b];
	            if (bone) {
	                if ((bone.parent && bone.parent instanceof Bone)) {
	                    bone.matrix.getInverse(bone.parent.matrixWorld);
	                    bone.matrix.multiply(bone.matrixWorld);
	                }
	                else {
	                    bone.matrix.copy(bone.matrixWorld);
	                }
	                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
	            }
	        }
	    };
	    Skeleton.prototype.update = function () {
	        var offsetMatrix = Skeleton.update_offsetMatrix;
	        //return function update() {
	        // flatten bone matrices to array
	        for (var b = 0, bl = this.bones.length; b < bl; b++) {
	            // compute the offset between the current and the original transform
	            var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
	            offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
	            offsetMatrix.toArray(this.boneMatrices, b * 16);
	        }
	        if (this.useVertexTexture) {
	            this.boneTexture.needsUpdate = true;
	        }
	        //};
	    };
	    Skeleton.prototype.clone = function () {
	        return new this.constructor(this.bones, this.boneInverses, this.useVertexTexture);
	    };
	    Skeleton.update_offsetMatrix = new Matrix4();
	    return Skeleton;
	}());

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	var SkinnedMesh = /** @class */ (function (_super) {
	    __extends(SkinnedMesh, _super);
	    function SkinnedMesh(geometry, material, useVertexTexture) {
	        if (useVertexTexture === void 0) { useVertexTexture = true; }
	        var _this = _super.call(this, geometry, material) || this;
	        _this.bindMode = "attached";
	        _this.bindMatrix = new Matrix4();
	        _this.bindMatrixInverse = new Matrix4();
	        _this.isSkinnedMesh = true;
	        _this.type = 'SkinnedMesh';
	        // init bones
	        // TODO: remove bone creation as there is no reason (other than
	        // convenience) for THREE.SkinnedMesh to do this.
	        var bones = [];
	        if (_this.geometry && _this.geometry.bones !== undefined) {
	            var bone = void 0, gbone = void 0;
	            for (var b = 0, bl = _this.geometry.bones.length; b < bl; ++b) {
	                gbone = _this.geometry.bones[b];
	                bone = new Bone(_this);
	                bones.push(bone);
	                bone.name = gbone.name;
	                bone.position.fromArray(gbone.pos);
	                bone.quaternion.fromArray(gbone.rotq);
	                if (gbone.scl !== undefined)
	                    bone.scale.fromArray(gbone.scl);
	            }
	            for (var b = 0, bl = _this.geometry.bones.length; b < bl; ++b) {
	                gbone = _this.geometry.bones[b];
	                if (gbone.parent !== -1 && gbone.parent !== null &&
	                    bones[gbone.parent] !== undefined) {
	                    bones[gbone.parent].add(bones[b]);
	                }
	                else {
	                    _this.add(bones[b]);
	                }
	            }
	        }
	        _this.normalizeSkinWeights();
	        _this.updateMatrixWorld(true);
	        _this.bind(new Skeleton(bones, undefined, useVertexTexture), _this.matrixWorld);
	        return _this;
	    }
	    SkinnedMesh.prototype.bind = function (skeleton, bindMatrix) {
	        this.skeleton = skeleton;
	        if (bindMatrix === undefined) {
	            this.updateMatrixWorld(true);
	            this.skeleton.calculateInverses();
	            bindMatrix = this.matrixWorld;
	        }
	        this.bindMatrix.copy(bindMatrix);
	        this.bindMatrixInverse.getInverse(bindMatrix);
	    };
	    SkinnedMesh.prototype.pose = function () {
	        this.skeleton.pose();
	    };
	    SkinnedMesh.prototype.normalizeSkinWeights = function () {
	        if ((this.geometry && this.geometry instanceof Geometry)) {
	            for (var i = 0; i < this.geometry.skinWeights.length; i++) {
	                var sw = this.geometry.skinWeights[i];
	                var scale = 1.0 / sw.lengthManhattan();
	                if (scale !== Infinity) {
	                    sw.multiplyScalar(scale);
	                }
	                else {
	                    sw.set(1, 0, 0, 0); // do something reasonable
	                }
	            }
	        }
	        else if ((this.geometry && this.geometry instanceof BufferGeometry)) {
	            var vec = new Vector4();
	            var skinWeight = this.geometry.attributes.skinWeight;
	            for (var i = 0; i < skinWeight.count; i++) {
	                vec.x = skinWeight.getX(i);
	                vec.y = skinWeight.getY(i);
	                vec.z = skinWeight.getZ(i);
	                vec.w = skinWeight.getW(i);
	                var scale = 1.0 / vec.lengthManhattan();
	                if (scale !== Infinity) {
	                    vec.multiplyScalar(scale);
	                }
	                else {
	                    vec.set(1, 0, 0, 0); // do something reasonable
	                }
	                skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
	            }
	        }
	    };
	    SkinnedMesh.prototype.updateMatrixWorld = function (force) {
	        _super.prototype.updateMatrixWorld.call(this, true);
	        if (this.bindMode === "attached") {
	            this.bindMatrixInverse.getInverse(this.matrixWorld);
	        }
	        else if (this.bindMode === "detached") {
	            this.bindMatrixInverse.getInverse(this.bindMatrix);
	        }
	        else {
	            console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);
	        }
	    };
	    SkinnedMesh.prototype.clone = function () {
	        return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this);
	    };
	    return SkinnedMesh;
	}(Mesh));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	var WebGLShadowMap = /** @class */ (function () {
	    function WebGLShadowMap(_renderer, _lights, _objects, capabilities) {
	        this._renderer = _renderer;
	        this._lights = _lights;
	        this._objects = _objects;
	        this.capabilities = capabilities;
	        this._gl = _renderer.context;
	        this._state = _renderer.state;
	        this._frustum = new Frustum();
	        this._projScreenMatrix = new Matrix4();
	        this._lightShadows = _lights.shadows;
	        this._shadowMapSize = new Vector2();
	        this._maxShadowMapSize = new Vector2(capabilities.maxTextureSize, capabilities.maxTextureSize);
	        this._lookTarget = new Vector3();
	        this._lightPositionWorld = new Vector3();
	        this._renderList = [];
	        this._MorphingFlag = 1;
	        this._SkinningFlag = 2;
	        this._NumberOfMaterialVariants = (this._MorphingFlag | this._SkinningFlag) + 1;
	        this._depthMaterials = new Array(this._NumberOfMaterialVariants);
	        this._distanceMaterials = new Array(this._NumberOfMaterialVariants);
	        this._materialCache = {};
	        this.cubeDirections = [
	            new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1),
	            new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)
	        ];
	        this.cubeUps = [
	            new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),
	            new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)
	        ];
	        this.cube2DViewPorts = [
	            new Vector4(), new Vector4(), new Vector4(),
	            new Vector4(), new Vector4(), new Vector4()
	        ];
	        // init
	        var depthMaterialTemplate = new MeshDepthMaterial();
	        depthMaterialTemplate.depthPacking = exports.DepthPacking.RGBA;
	        depthMaterialTemplate.clipping = true;
	        var distanceShader = ShaderLib["distanceRGBA"];
	        var distanceUniforms = UniformsUtils.clone(distanceShader.uniforms);
	        for (var i = 0; i !== this._NumberOfMaterialVariants; ++i) {
	            var useMorphing = (i & this._MorphingFlag) !== 0;
	            var useSkinning = (i & this._SkinningFlag) !== 0;
	            var depthMaterial = depthMaterialTemplate.clone();
	            depthMaterial.morphTargets = useMorphing;
	            depthMaterial.skinning = useSkinning;
	            this._depthMaterials[i] = depthMaterial;
	            var distanceMaterial = new ShaderMaterial({
	                defines: {
	                    'USE_SHADOWMAP': ''
	                },
	                uniforms: distanceUniforms,
	                vertexShader: distanceShader.vertexShader,
	                fragmentShader: distanceShader.fragmentShader,
	                morphTargets: useMorphing,
	                skinning: useSkinning,
	                clipping: true
	            });
	            this._distanceMaterials[i] = distanceMaterial;
	        }
	        //
	        this.enabled = false;
	        this.autoUpdate = true;
	        this.needsUpdate = false;
	        this.type = exports.ShadowMap.PCF;
	        this.renderReverseSided = true;
	        this.renderSingleSided = true;
	    }
	    WebGLShadowMap.prototype.render = function (scene, camera) {
	        if (this.enabled === false)
	            return;
	        if (this.autoUpdate === false && this.needsUpdate === false)
	            return;
	        if (this._lightShadows.length === 0)
	            return;
	        // Set GL state for depth map.
	        this._state.clearColor(1, 1, 1, 1);
	        this._state.disable(this._gl.BLEND);
	        this._state.setDepthTest(true);
	        this._state.setScissorTest(false);
	        // render depth map
	        var faceCount, isPointLight;
	        for (var i = 0, il = this._lightShadows.length; i < il; i++) {
	            var light = this._lightShadows[i];
	            var shadow = light.shadow;
	            if (shadow === undefined) {
	                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
	                continue;
	            }
	            var shadowCamera = shadow.camera;
	            this._shadowMapSize.copy(shadow.mapSize);
	            this._shadowMapSize.min(this._maxShadowMapSize);
	            if ((light && light instanceof PointLight)) {
	                faceCount = 6;
	                isPointLight = true;
	                var vpWidth = this._shadowMapSize.x;
	                var vpHeight = this._shadowMapSize.y;
	                // These viewports map a cube-map onto a 2D texture with the
	                // following orientation:
	                //
	                //  xzXZ
	                //   y Y
	                //
	                // X - Positive x direction
	                // x - Negative x direction
	                // Y - Positive y direction
	                // y - Negative y direction
	                // Z - Positive z direction
	                // z - Negative z direction
	                // positive X
	                this.cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
	                // negative X
	                this.cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
	                // positive Z
	                this.cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
	                // negative Z
	                this.cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
	                // positive Y
	                this.cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
	                // negative Y
	                this.cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
	                this._shadowMapSize.x *= 4.0;
	                this._shadowMapSize.y *= 2.0;
	            }
	            else {
	                faceCount = 1;
	                isPointLight = false;
	            }
	            if (shadow.map === null) {
	                var pars = { minFilter: exports.TextureFilter.Nearest, magFilter: exports.TextureFilter.Nearest, format: exports.TextureFormat.RGBA };
	                shadow.map = new WebGLRenderTarget(this._shadowMapSize.x, this._shadowMapSize.y, pars);
	                shadowCamera.updateProjectionMatrix();
	            }
	            if ((shadow && shadow instanceof SpotLightShadow)) {
	                shadow.update(light);
	            }
	            var shadowMap = shadow.map;
	            var shadowMatrix = shadow.matrix;
	            this._lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
	            shadowCamera.position.copy(this._lightPositionWorld);
	            this._renderer.setRenderTarget(shadowMap);
	            this._renderer.clear();
	            // render shadow map for each cube face (if omni-directional) or
	            // run a single pass if not
	            for (var face = 0; face < faceCount; face++) {
	                if (isPointLight) {
	                    this._lookTarget.copy(shadowCamera.position);
	                    this._lookTarget.add(this.cubeDirections[face]);
	                    shadowCamera.up.copy(this.cubeUps[face]);
	                    shadowCamera.lookAt(this._lookTarget);
	                    var vpDimensions = this.cube2DViewPorts[face];
	                    this._state.viewport(vpDimensions);
	                }
	                else {
	                    this._lookTarget.setFromMatrixPosition(light.target.matrixWorld);
	                    shadowCamera.lookAt(this._lookTarget);
	                }
	                shadowCamera.updateMatrixWorld();
	                shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
	                // compute shadow matrix
	                shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
	                shadowMatrix.multiply(shadowCamera.projectionMatrix);
	                shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
	                // update camera matrices and frustum
	                this._projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
	                this._frustum.setFromMatrix(this._projScreenMatrix);
	                // set object matrices & frustum culling
	                this._renderList.length = 0;
	                this.projectObject(scene, camera, shadowCamera);
	                // render shadow map
	                // render regular objects
	                for (var j = 0, jl = this._renderList.length; j < jl; j++) {
	                    var object = this._renderList[j];
	                    var geometry = this._objects.update(object);
	                    var material = object.material;
	                    if ((material && material instanceof MultiMaterial)) {
	                        var groups = geometry.groups;
	                        var materials = material.materials;
	                        for (var k = 0, kl = groups.length; k < kl; k++) {
	                            var group = groups[k];
	                            var groupMaterial = materials[group.materialIndex];
	                            if (groupMaterial.visible === true) {
	                                var depthMaterial = this.getDepthMaterial(object, groupMaterial, isPointLight, this._lightPositionWorld);
	                                this._renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
	                            }
	                        }
	                    }
	                    else {
	                        var depthMaterial = this.getDepthMaterial(object, material, isPointLight, this._lightPositionWorld);
	                        this._renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
	                    }
	                }
	            }
	        }
	        // Restore GL state.
	        var clearColor = this._renderer.getClearColor(), clearAlpha = this._renderer.getClearAlpha();
	        this._renderer.setClearColor(clearColor, clearAlpha);
	        this.needsUpdate = false;
	    };
	    WebGLShadowMap.prototype.getDepthMaterial = function (object, material, isPointLight, lightPositionWorld) {
	        var geometry = object.geometry;
	        var result = null;
	        var materialVariants = this._depthMaterials;
	        var customMaterial = object.customDepthMaterial;
	        if (isPointLight) {
	            materialVariants = this._distanceMaterials;
	            customMaterial = object.customDistanceMaterial;
	        }
	        if (!customMaterial) {
	            var useMorphing = false;
	            if (material.morphTargets) {
	                if ((geometry && geometry instanceof BufferGeometry)) {
	                    useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
	                }
	                else if ((geometry && geometry instanceof Geometry)) {
	                    useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
	                }
	            }
	            var useSkinning = object instanceof SkinnedMesh && material.skinning;
	            var variantIndex = 0;
	            if (useMorphing)
	                variantIndex |= this._MorphingFlag;
	            if (useSkinning)
	                variantIndex |= this._SkinningFlag;
	            result = materialVariants[variantIndex];
	        }
	        else {
	            result = customMaterial;
	        }
	        if (this._renderer.localClippingEnabled &&
	            material.clipShadows === true &&
	            material.clippingPlanes.length !== 0) {
	            // in this case we need a unique material instance reflecting the
	            // appropriate state
	            var keyA = result.uuid, keyB = material.uuid;
	            var materialsForVariant = this._materialCache[keyA];
	            if (materialsForVariant === undefined) {
	                materialsForVariant = {};
	                this._materialCache[keyA] = materialsForVariant;
	            }
	            var cachedMaterial = materialsForVariant[keyB];
	            if (cachedMaterial === undefined) {
	                cachedMaterial = result.clone();
	                materialsForVariant[keyB] = cachedMaterial;
	            }
	            result = cachedMaterial;
	        }
	        result.visible = material.visible;
	        result.wireframe = material.wireframe;
	        var side = material.side;
	        if (this.renderSingleSided && side === exports.SideMode.Double) {
	            side = exports.SideMode.Front;
	        }
	        if (this.renderReverseSided) {
	            if (side === exports.SideMode.Front)
	                side = exports.SideMode.Back;
	            else if (side === exports.SideMode.Back)
	                side = exports.SideMode.Front;
	        }
	        result.side = side;
	        result.clipShadows = material.clipShadows;
	        result.clippingPlanes = material.clippingPlanes;
	        result.wireframeLinewidth = material.wireframeLinewidth;
	        result.linewidth = material.linewidth;
	        if (isPointLight && result.uniforms.lightPos !== undefined) {
	            result.uniforms.lightPos.value.copy(lightPositionWorld);
	        }
	        return result;
	    };
	    WebGLShadowMap.prototype.projectObject = function (object, camera, shadowCamera) {
	        if (object.visible === false)
	            return;
	        var visible = (object.layers.mask & camera.layers.mask) !== 0;
	        if (visible && (object instanceof Mesh || object instanceof Line || object instanceof Points)) {
	            if (object.castShadow && (object.frustumCulled === false || this._frustum.intersectsObject(object) === true)) {
	                var material = object.material;
	                if (material.visible === true) {
	                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
	                    this._renderList.push(object);
	                }
	            }
	        }
	        var children = object.children;
	        for (var i = 0, l = children.length; i < l; i++) {
	            this.projectObject(children[i], camera, shadowCamera);
	        }
	    };
	    Object.defineProperty(WebGLShadowMap.prototype, "cullFace", {
	        get: function () {
	            return this.renderReverseSided ? exports.CullFace.Front : exports.CullFace.Back;
	        },
	        set: function (cullFace) {
	            var value = (cullFace !== exports.CullFace.Back);
	            console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + ".");
	            this.renderReverseSided = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return WebGLShadowMap;
	}());

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	var BoxBufferGeometry = /** @class */ (function (_super) {
	    __extends(BoxBufferGeometry, _super);
	    function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
	        var _this = _super.call(this) || this;
	        _this.type = 'BoxBufferGeometry';
	        _this.parameters = {
	            width: width,
	            height: height,
	            depth: depth,
	            widthSegments: widthSegments,
	            heightSegments: heightSegments,
	            depthSegments: depthSegments
	        };
	        var scope = _this;
	        // segments
	        widthSegments = Math.floor(widthSegments) || 1;
	        heightSegments = Math.floor(heightSegments) || 1;
	        depthSegments = Math.floor(depthSegments) || 1;
	        // these are used to calculate buffer length
	        var vertexCount = calculateVertexCount(widthSegments, heightSegments, depthSegments);
	        var indexCount = calculateIndexCount(widthSegments, heightSegments, depthSegments);
	        // buffers
	        var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
	        var vertices = new Float32Array(vertexCount * 3);
	        var normals = new Float32Array(vertexCount * 3);
	        var uvs = new Float32Array(vertexCount * 2);
	        // offset variables
	        var vertexBufferOffset = 0;
	        var uvBufferOffset = 0;
	        var indexBufferOffset = 0;
	        var numberOfVertices = 0;
	        // group variables
	        var groupStart = 0;
	        // build each side of the box geometry
	        buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
	        buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
	        buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
	        buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
	        buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
	        buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
	        // build geometry
	        _this.setIndex(new BufferAttribute(indices, 1));
	        _this.addAttribute('position', new BufferAttribute(vertices, 3));
	        _this.addAttribute('normal', new BufferAttribute(normals, 3));
	        _this.addAttribute('uv', new BufferAttribute(uvs, 2));
	        // helper functions
	        function calculateVertexCount(w, h, d) {
	            var vertices = 0;
	            // calculate the amount of vertices for each side (plane)
	            vertices += (w + 1) * (h + 1) * 2; // xy
	            vertices += (w + 1) * (d + 1) * 2; // xz
	            vertices += (d + 1) * (h + 1) * 2; // zy
	            return vertices;
	        }
	        function calculateIndexCount(w, h, d) {
	            var index = 0;
	            // calculate the amount of squares for each side
	            index += w * h * 2; // xy
	            index += w * d * 2; // xz
	            index += d * h * 2; // zy
	            return index * 6; // two triangles per square => six vertices per square
	        }
	        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
	            var segmentWidth = width / gridX;
	            var segmentHeight = height / gridY;
	            var widthHalf = width / 2;
	            var heightHalf = height / 2;
	            var depthHalf = depth / 2;
	            var gridX1 = gridX + 1;
	            var gridY1 = gridY + 1;
	            var vertexCounter = 0;
	            var groupCount = 0;
	            var vector = new Vector3();
	            // generate vertices, normals and uvs
	            for (var iy = 0; iy < gridY1; iy++) {
	                var y = iy * segmentHeight - heightHalf;
	                for (var ix = 0; ix < gridX1; ix++) {
	                    var x = ix * segmentWidth - widthHalf;
	                    // set values to correct vector component
	                    vector[u] = x * udir;
	                    vector[v] = y * vdir;
	                    vector[w] = depthHalf;
	                    // now apply vector to vertex buffer
	                    vertices[vertexBufferOffset] = vector.x;
	                    vertices[vertexBufferOffset + 1] = vector.y;
	                    vertices[vertexBufferOffset + 2] = vector.z;
	                    // set values to correct vector component
	                    vector[u] = 0;
	                    vector[v] = 0;
	                    vector[w] = depth > 0 ? 1 : -1;
	                    // now apply vector to normal buffer
	                    normals[vertexBufferOffset] = vector.x;
	                    normals[vertexBufferOffset + 1] = vector.y;
	                    normals[vertexBufferOffset + 2] = vector.z;
	                    // uvs
	                    uvs[uvBufferOffset] = ix / gridX;
	                    uvs[uvBufferOffset + 1] = 1 - (iy / gridY);
	                    // update offsets and counters
	                    vertexBufferOffset += 3;
	                    uvBufferOffset += 2;
	                    vertexCounter += 1;
	                }
	            }
	            // 1. you need three indices to draw a single face
	            // 2. a single segment consists of two faces
	            // 3. so we need to generate six (2*3) indices per segment
	            for (var iy = 0; iy < gridY; iy++) {
	                for (var ix = 0; ix < gridX; ix++) {
	                    // indices
	                    var a = numberOfVertices + ix + gridX1 * iy;
	                    var b = numberOfVertices + ix + gridX1 * (iy + 1);
	                    var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
	                    var d = numberOfVertices + (ix + 1) + gridX1 * iy;
	                    // face one
	                    indices[indexBufferOffset] = a;
	                    indices[indexBufferOffset + 1] = b;
	                    indices[indexBufferOffset + 2] = d;
	                    // face two
	                    indices[indexBufferOffset + 3] = b;
	                    indices[indexBufferOffset + 4] = c;
	                    indices[indexBufferOffset + 5] = d;
	                    // update offsets and counters
	                    indexBufferOffset += 6;
	                    groupCount += 6;
	                }
	            }
	            // add a group to the geometry. this will ensure multi material support
	            scope.addGroup(groupStart, groupCount, materialIndex);
	            // calculate new start value for groups
	            groupStart += groupCount;
	            // update total number of vertices
	            numberOfVertices += vertexCounter;
	        }
	        return _this;
	    }
	    return BoxBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	var PlaneBufferGeometry = /** @class */ (function (_super) {
	    __extends(PlaneBufferGeometry, _super);
	    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
	        var _this = _super.call(this) || this;
	        _this.type = 'PlaneBufferGeometry';
	        _this.parameters = {
	            width: width,
	            height: height,
	            widthSegments: widthSegments,
	            heightSegments: heightSegments
	        };
	        var width_half = width / 2;
	        var height_half = height / 2;
	        var gridX = Math.floor(widthSegments) || 1;
	        var gridY = Math.floor(heightSegments) || 1;
	        var gridX1 = gridX + 1;
	        var gridY1 = gridY + 1;
	        var segment_width = width / gridX;
	        var segment_height = height / gridY;
	        var vertices = new Float32Array(gridX1 * gridY1 * 3);
	        var normals = new Float32Array(gridX1 * gridY1 * 3);
	        var uvs = new Float32Array(gridX1 * gridY1 * 2);
	        var offset = 0;
	        var offset2 = 0;
	        for (var iy = 0; iy < gridY1; iy++) {
	            var y = iy * segment_height - height_half;
	            for (var ix = 0; ix < gridX1; ix++) {
	                var x = ix * segment_width - width_half;
	                vertices[offset] = x;
	                vertices[offset + 1] = -y;
	                normals[offset + 2] = 1;
	                uvs[offset2] = ix / gridX;
	                uvs[offset2 + 1] = 1 - (iy / gridY);
	                offset += 3;
	                offset2 += 2;
	            }
	        }
	        offset = 0;
	        var indices = new ((vertices.length / 3) > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
	        for (var iy = 0; iy < gridY; iy++) {
	            for (var ix = 0; ix < gridX; ix++) {
	                var a = ix + gridX1 * iy;
	                var b = ix + gridX1 * (iy + 1);
	                var c = (ix + 1) + gridX1 * (iy + 1);
	                var d = (ix + 1) + gridX1 * iy;
	                indices[offset] = a;
	                indices[offset + 1] = b;
	                indices[offset + 2] = d;
	                indices[offset + 3] = b;
	                indices[offset + 4] = c;
	                indices[offset + 5] = d;
	                offset += 6;
	            }
	        }
	        _this.setIndex(new BufferAttribute(indices, 1));
	        _this.addAttribute('position', new BufferAttribute(vertices, 3));
	        _this.addAttribute('normal', new BufferAttribute(normals, 3));
	        _this.addAttribute('uv', new BufferAttribute(uvs, 2));
	        return _this;
	    }
	    return PlaneBufferGeometry;
	}(BufferGeometry));

	var MeshPhongMaterial = /** @class */ (function (_super) {
	    __extends(MeshPhongMaterial, _super);
	    function MeshPhongMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        _this.isMeshPhongMaterial = true;
	        _this.type = 'MeshPhongMaterial';
	        _this.color = new Color(0xffffff); // diffuse
	        _this.specular = new Color(0x111111);
	        _this.shininess = 30;
	        _this.map = null;
	        _this.lightMap = null;
	        _this.lightMapIntensity = 1.0;
	        _this.aoMap = null;
	        _this.aoMapIntensity = 1.0;
	        _this.emissive = new Color(0x000000);
	        _this.emissiveIntensity = 1.0;
	        _this.emissiveMap = null;
	        _this.bumpMap = null;
	        _this.bumpScale = 1;
	        _this.normalMap = null;
	        _this.normalScale = new Vector2(1, 1);
	        _this.displacementMap = null;
	        _this.displacementScale = 1;
	        _this.displacementBias = 0;
	        _this.specularMap = null;
	        _this.alphaMap = null;
	        _this.envMap = null;
	        _this.combine = exports.BlendingOperation.Multiply;
	        _this.reflectivity = 1;
	        _this.refractionRatio = 0.98;
	        _this.wireframe = false;
	        _this.wireframeLinewidth = 1;
	        _this.wireframeLinecap = 'round';
	        _this.wireframeLinejoin = 'round';
	        _this.skinning = false;
	        _this.morphTargets = false;
	        _this.morphNormals = false;
	        _this.setValues(parameters);
	        return _this;
	    }
	    MeshPhongMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.color.copy(source.color);
	        this.specular.copy(source.specular);
	        this.shininess = source.shininess;
	        this.map = source.map;
	        this.lightMap = source.lightMap;
	        this.lightMapIntensity = source.lightMapIntensity;
	        this.aoMap = source.aoMap;
	        this.aoMapIntensity = source.aoMapIntensity;
	        this.emissive.copy(source.emissive);
	        this.emissiveMap = source.emissiveMap;
	        this.emissiveIntensity = source.emissiveIntensity;
	        this.bumpMap = source.bumpMap;
	        this.bumpScale = source.bumpScale;
	        this.normalMap = source.normalMap;
	        this.normalScale.copy(source.normalScale);
	        this.displacementMap = source.displacementMap;
	        this.displacementScale = source.displacementScale;
	        this.displacementBias = source.displacementBias;
	        this.specularMap = source.specularMap;
	        this.alphaMap = source.alphaMap;
	        this.envMap = source.envMap;
	        this.combine = source.combine;
	        this.reflectivity = source.reflectivity;
	        this.refractionRatio = source.refractionRatio;
	        this.wireframe = source.wireframe;
	        this.wireframeLinewidth = source.wireframeLinewidth;
	        this.wireframeLinecap = source.wireframeLinecap;
	        this.wireframeLinejoin = source.wireframeLinejoin;
	        this.skinning = source.skinning;
	        this.morphTargets = source.morphTargets;
	        this.morphNormals = source.morphNormals;
	        return this;
	    };
	    Object.defineProperty(MeshPhongMaterial.prototype, "metal", {
	        get: function () {
	            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
	            return false;
	        },
	        set: function (value) {
	            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return MeshPhongMaterial;
	}(Material));

	var MeshStandardMaterial = /** @class */ (function (_super) {
	    __extends(MeshStandardMaterial, _super);
	    function MeshStandardMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        _this.isMeshStandardMaterial = true;
	        _this.defines = { 'STANDARD': '' };
	        _this.type = 'MeshStandardMaterial';
	        _this.color = new Color(0xffffff); // diffuse
	        _this.roughness = 0.5;
	        _this.metalness = 0.5;
	        _this.map = null;
	        _this.lightMap = null;
	        _this.lightMapIntensity = 1.0;
	        _this.aoMap = null;
	        _this.aoMapIntensity = 1.0;
	        _this.emissive = new Color(0x000000);
	        _this.emissiveIntensity = 1.0;
	        _this.emissiveMap = null;
	        _this.bumpMap = null;
	        _this.bumpScale = 1;
	        _this.normalMap = null;
	        _this.normalScale = new Vector2(1, 1);
	        _this.displacementMap = null;
	        _this.displacementScale = 1;
	        _this.displacementBias = 0;
	        _this.roughnessMap = null;
	        _this.metalnessMap = null;
	        _this.alphaMap = null;
	        _this.envMap = null;
	        _this.envMapIntensity = 1.0;
	        _this.refractionRatio = 0.98;
	        _this.wireframe = false;
	        _this.wireframeLinewidth = 1;
	        _this.wireframeLinecap = 'round';
	        _this.wireframeLinejoin = 'round';
	        _this.skinning = false;
	        _this.morphTargets = false;
	        _this.morphNormals = false;
	        _this.setValues(parameters);
	        return _this;
	    }
	    MeshStandardMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.defines = { 'STANDARD': '' };
	        this.color.copy(source.color);
	        this.roughness = source.roughness;
	        this.metalness = source.metalness;
	        this.map = source.map;
	        this.lightMap = source.lightMap;
	        this.lightMapIntensity = source.lightMapIntensity;
	        this.aoMap = source.aoMap;
	        this.aoMapIntensity = source.aoMapIntensity;
	        this.emissive.copy(source.emissive);
	        this.emissiveMap = source.emissiveMap;
	        this.emissiveIntensity = source.emissiveIntensity;
	        this.bumpMap = source.bumpMap;
	        this.bumpScale = source.bumpScale;
	        this.normalMap = source.normalMap;
	        this.normalScale.copy(source.normalScale);
	        this.displacementMap = source.displacementMap;
	        this.displacementScale = source.displacementScale;
	        this.displacementBias = source.displacementBias;
	        this.roughnessMap = source.roughnessMap;
	        this.metalnessMap = source.metalnessMap;
	        this.alphaMap = source.alphaMap;
	        this.envMap = source.envMap;
	        this.envMapIntensity = source.envMapIntensity;
	        this.refractionRatio = source.refractionRatio;
	        this.wireframe = source.wireframe;
	        this.wireframeLinewidth = source.wireframeLinewidth;
	        this.wireframeLinecap = source.wireframeLinecap;
	        this.wireframeLinejoin = source.wireframeLinejoin;
	        this.skinning = source.skinning;
	        this.morphTargets = source.morphTargets;
	        this.morphNormals = source.morphNormals;
	        return this;
	    };
	    return MeshStandardMaterial;
	}(Material));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture(<Image>),
	 *
	 *  lightMap: new THREE.Texture(<Image>),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture(<Image>),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture(<Image>),
	 *
	 *  specularMap: new THREE.Texture(<Image>),
	 *
	 *  alphaMap: new THREE.Texture(<Image>),
	 *
	 *  envMap: new THREE.TextureCube([posx, negx, posy, negy, posz, negz]),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	var MeshLambertMaterial = /** @class */ (function (_super) {
	    __extends(MeshLambertMaterial, _super);
	    function MeshLambertMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        _this.isMeshLambertMaterial = true;
	        _this.type = 'MeshLambertMaterial';
	        _this.color = new Color(0xffffff); // diffuse
	        _this.map = null;
	        _this.lightMap = null;
	        _this.lightMapIntensity = 1.0;
	        _this.aoMap = null;
	        _this.aoMapIntensity = 1.0;
	        _this.emissive = new Color(0x000000);
	        _this.emissiveIntensity = 1.0;
	        _this.emissiveMap = null;
	        _this.specularMap = null;
	        _this.alphaMap = null;
	        _this.envMap = null;
	        _this.combine = exports.BlendingOperation.Multiply;
	        _this.reflectivity = 1;
	        _this.refractionRatio = 0.98;
	        _this.wireframe = false;
	        _this.wireframeLinewidth = 1;
	        _this.wireframeLinecap = 'round';
	        _this.wireframeLinejoin = 'round';
	        _this.skinning = false;
	        _this.morphTargets = false;
	        _this.morphNormals = false;
	        _this.setValues(parameters);
	        return _this;
	    }
	    MeshLambertMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.color.copy(source.color);
	        this.map = source.map;
	        this.lightMap = source.lightMap;
	        this.lightMapIntensity = source.lightMapIntensity;
	        this.aoMap = source.aoMap;
	        this.aoMapIntensity = source.aoMapIntensity;
	        this.emissive.copy(source.emissive);
	        this.emissiveMap = source.emissiveMap;
	        this.emissiveIntensity = source.emissiveIntensity;
	        this.specularMap = source.specularMap;
	        this.alphaMap = source.alphaMap;
	        this.envMap = source.envMap;
	        this.combine = source.combine;
	        this.reflectivity = source.reflectivity;
	        this.refractionRatio = source.refractionRatio;
	        this.wireframe = source.wireframe;
	        this.wireframeLinewidth = source.wireframeLinewidth;
	        this.wireframeLinecap = source.wireframeLinecap;
	        this.wireframeLinejoin = source.wireframeLinejoin;
	        this.skinning = source.skinning;
	        this.morphTargets = source.morphTargets;
	        this.morphNormals = source.morphNormals;
	        return this;
	    };
	    return MeshLambertMaterial;
	}(Material));

	var MeshPhysicalMaterial = /** @class */ (function (_super) {
	    __extends(MeshPhysicalMaterial, _super);
	    function MeshPhysicalMaterial(parameters) {
	        var _this = _super.call(this, parameters) || this;
	        _this.isMeshPhysicalMaterial = true;
	        _this.defines = { 'PHYSICAL': '' };
	        _this.type = 'MeshPhysicalMaterial';
	        _this.reflectivity = 0.5; // maps to F0 = 0.04
	        _this.clearCoat = 0.0;
	        _this.clearCoatRoughness = 0.0;
	        _this.setValues(parameters);
	        return _this;
	    }
	    MeshPhysicalMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.defines = { 'PHYSICAL': '' };
	        this.reflectivity = source.reflectivity;
	        this.clearCoat = source.clearCoat;
	        this.clearCoatRoughness = source.clearCoatRoughness;
	        return this;
	    };
	    return MeshPhysicalMaterial;
	}(MeshStandardMaterial));

	var MeshNormalMaterial = /** @class */ (function (_super) {
	    __extends(MeshNormalMaterial, _super);
	    function MeshNormalMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        _this.isMeshNormalMaterial = true;
	        _this.type = 'MeshNormalMaterial';
	        _this.wireframe = false;
	        _this.wireframeLinewidth = 1;
	        _this.fog = false;
	        _this.lights = false;
	        _this.morphTargets = false;
	        _this.setValues(parameters);
	        return _this;
	    }
	    MeshNormalMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.wireframe = source.wireframe;
	        this.wireframeLinewidth = source.wireframeLinewidth;
	        return this;
	    };
	    return MeshNormalMaterial;
	}(Material));

	var RawShaderMaterial = /** @class */ (function (_super) {
	    __extends(RawShaderMaterial, _super);
	    function RawShaderMaterial(parameters) {
	        var _this = _super.call(this, parameters) || this;
	        _this.isRawShaderMaterial = true;
	        _this.type = 'RawShaderMaterial';
	        return _this;
	    }
	    return RawShaderMaterial;
	}(ShaderMaterial));

	var LineDashedMaterial = /** @class */ (function (_super) {
	    __extends(LineDashedMaterial, _super);
	    function LineDashedMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        _this.isLineDashedMaterial = true;
	        _this.type = 'LineDashedMaterial';
	        _this.color = new Color(0xffffff);
	        _this.linewidth = 1;
	        _this.scale = 1;
	        _this.dashSize = 3;
	        _this.gapSize = 1;
	        _this.lights = false;
	        _this.setValues(parameters);
	        return _this;
	    }
	    LineDashedMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.color.copy(source.color);
	        this.linewidth = source.linewidth;
	        this.scale = source.scale;
	        this.dashSize = source.dashSize;
	        this.gapSize = source.gapSize;
	        return this;
	    };
	    return LineDashedMaterial;
	}(Material));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var WebGLIndexedBufferRenderer = /** @class */ (function () {
	    function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
	        this.gl = gl;
	        this.extensions = extensions;
	        this.infoRender = infoRender;
	    }
	    WebGLIndexedBufferRenderer.prototype.setMode = function (value) {
	        this.mode = value;
	    };
	    WebGLIndexedBufferRenderer.prototype.setIndex = function (index) {
	        if (index.array instanceof Uint32Array && this.extensions.get('OES_element_index_uint')) {
	            this.type = this.gl.UNSIGNED_INT;
	            this.size = 4;
	        }
	        else {
	            this.type = this.gl.UNSIGNED_SHORT;
	            this.size = 2;
	        }
	    };
	    WebGLIndexedBufferRenderer.prototype.render = function (start, count) {
	        this.gl.drawElements(this.mode, count, this.type, start * this.size);
	        this.infoRender.calls++;
	        this.infoRender.vertices += count;
	        if (this.mode === this.gl.TRIANGLES)
	            this.infoRender.faces += count / 3;
	    };
	    WebGLIndexedBufferRenderer.prototype.renderInstances = function (geometry, start, count) {
	        var extension = this.extensions.get('ANGLE_instanced_arrays');
	        if (extension === null) {
	            console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
	            return;
	        }
	        extension.drawElementsInstancedANGLE(this.mode, count, this.type, start * this.size, geometry.maxInstancedCount);
	        this.infoRender.calls++;
	        this.infoRender.vertices += count * geometry.maxInstancedCount;
	        if (this.mode === this.gl.TRIANGLES)
	            this.infoRender.faces += geometry.maxInstancedCount * count / 3;
	    };
	    return WebGLIndexedBufferRenderer;
	}());

	var WebGLBufferRenderer = /** @class */ (function () {
	    function WebGLBufferRenderer(gl, extensions, infoRender) {
	        this.gl = gl;
	        this.extensions = extensions;
	        this.infoRender = infoRender;
	    }
	    WebGLBufferRenderer.prototype.setMode = function (value) {
	        this.mode = value;
	    };
	    WebGLBufferRenderer.prototype.render = function (start, count) {
	        var gl = this.gl;
	        gl.drawArrays(this.mode, start, count);
	        this.infoRender.calls++;
	        this.infoRender.vertices += count;
	        if (this.mode === gl.TRIANGLES)
	            this.infoRender.faces += count / 3;
	    };
	    WebGLBufferRenderer.prototype.renderInstances = function (geometry) {
	        var gl = this.gl;
	        var extension = this.extensions.get('ANGLE_instanced_arrays');
	        if (extension === null) {
	            console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
	            return;
	        }
	        var position = geometry.attributes.position;
	        var count = 0;
	        if ((position && position instanceof InterleavedBufferAttribute)) {
	            count = position.data.count;
	            extension.drawArraysInstancedANGLE(this.mode, 0, count, geometry.maxInstancedCount);
	        }
	        else {
	            count = position.count;
	            extension.drawArraysInstancedANGLE(this.mode, 0, count, geometry.maxInstancedCount);
	        }
	        this.infoRender.calls++;
	        this.infoRender.vertices += count * geometry.maxInstancedCount;
	        if (this.mode === gl.TRIANGLES)
	            this.infoRender.faces += geometry.maxInstancedCount * count / 3;
	    };
	    return WebGLBufferRenderer;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var WebGLLights = /** @class */ (function () {
	    function WebGLLights() {
	        this.lights = {};
	    }
	    WebGLLights.prototype.get = function (light) {
	        if (this.lights[light.id] !== undefined) {
	            return this.lights[light.id];
	        }
	        var uniforms;
	        switch (light.type) {
	            case 'DirectionalLight':
	                uniforms = {
	                    direction: new Vector3(),
	                    color: new Color(),
	                    shadow: false,
	                    shadowBias: 0,
	                    shadowRadius: 1,
	                    shadowMapSize: new Vector2()
	                };
	                break;
	            case 'SpotLight':
	                uniforms = {
	                    position: new Vector3(),
	                    direction: new Vector3(),
	                    color: new Color(),
	                    distance: 0,
	                    coneCos: 0,
	                    penumbraCos: 0,
	                    decay: 0,
	                    shadow: false,
	                    shadowBias: 0,
	                    shadowRadius: 1,
	                    shadowMapSize: new Vector2()
	                };
	                break;
	            case 'PointLight':
	                uniforms = {
	                    position: new Vector3(),
	                    color: new Color(),
	                    distance: 0,
	                    decay: 0,
	                    shadow: false,
	                    shadowBias: 0,
	                    shadowRadius: 1,
	                    shadowMapSize: new Vector2()
	                };
	                break;
	            case 'HemisphereLight':
	                uniforms = {
	                    direction: new Vector3(),
	                    skyColor: new Color(),
	                    groundColor: new Color()
	                };
	                break;
	        }
	        this.lights[light.id] = uniforms;
	        return uniforms;
	    };
	    return WebGLLights;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	function addLineNumbers(code) {
	    var lines = code.split('\n');
	    for (var i = 0; i < lines.length; i++) {
	        lines[i] = (i + 1) + ': ' + lines[i];
	    }
	    return lines.join('\n');
	}
	function WebGLShader(gl, type, code) {
	    var shader = gl.createShader(type);
	    gl.shaderSource(shader, code);
	    gl.compileShader(shader);
	    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
	        console.error('THREE.WebGLShader: Shader couldn\'t compile.');
	    }
	    if (gl.getShaderInfoLog(shader) !== '') {
	        console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(code));
	    }
	    // --enable-privileged-webgl-extension
	    // console.log(type, gl.getExtension('WEBGL_debug_shaders').getTranslatedShaderSource(shader));
	    return shader;
	}

	var programIdCount = 0;
	function getEncodingComponents(encoding) {
	    switch (encoding) {
	        case exports.TextureEncoding.Linear:
	            return ['Linear', '(value)'];
	        case exports.TextureEncoding.sRGB:
	            return ['sRGB', '(value)'];
	        case exports.TextureEncoding.RGBE:
	            return ['RGBE', '(value)'];
	        case exports.TextureEncoding.RGBM7:
	            return ['RGBM', '(value, 7.0)'];
	        case exports.TextureEncoding.RGBM16:
	            return ['RGBM', '(value, 16.0)'];
	        case exports.TextureEncoding.RGBD:
	            return ['RGBD', '(value, 256.0)'];
	        case exports.TextureEncoding.Gamma:
	            return ['Gamma', '(value, float(GAMMA_FACTOR))'];
	        default:
	            throw new Error('unsupported encoding: ' + encoding);
	    }
	}
	function getTexelDecodingFunction(functionName, encoding) {
	    var components = getEncodingComponents(encoding);
	    return "vec4 " + functionName + "(vec4 value) { return " + components[0] + "ToLinear" + components[1] + "; }";
	}
	function getTexelEncodingFunction(functionName, encoding) {
	    var components = getEncodingComponents(encoding);
	    return "vec4 " + functionName + "(vec4 value) { return LinearTo" + components[0] + components[1] + "; }";
	}
	function getToneMappingFunction(functionName, toneMapping) {
	    var toneMappingName;
	    switch (toneMapping) {
	        case exports.ToneMapping.Linear:
	            toneMappingName = "Linear";
	            break;
	        case exports.ToneMapping.Reinhard:
	            toneMappingName = "Reinhard";
	            break;
	        case exports.ToneMapping.Uncharted2:
	            toneMappingName = "Uncharted2";
	            break;
	        case exports.ToneMapping.Cineon:
	            toneMappingName = "OptimizedCineon";
	            break;
	        default:
	            throw new Error('unsupported toneMapping: ' + toneMapping);
	    }
	    return "vec3 " + functionName + "(vec3 color) { return " + toneMappingName + "ToneMapping(color); }";
	}
	function generateExtensions(extensions, parameters, rendererExtensions) {
	    extensions = extensions || {};
	    var chunks = [
	        (extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '',
	        (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',
	        (extensions.drawBuffers) && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',
	        (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : '',
	    ];
	    return chunks.filter(filterEmptyLine).join('\n');
	}
	function generateDefines(defines) {
	    var chunks = [];
	    for (var name in defines) {
	        var value = defines[name];
	        if (value === false)
	            continue;
	        chunks.push('#define ' + name + ' ' + value);
	    }
	    return chunks.join('\n');
	}
	function fetchAttributeLocations(gl, program, identifiers) {
	    var attributes = {};
	    var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
	    for (var i = 0; i < n; i++) {
	        var info = gl.getActiveAttrib(program, i);
	        var name = info.name;
	        // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i);
	        attributes[name] = gl.getAttribLocation(program, name);
	    }
	    return attributes;
	}
	function filterEmptyLine(code) {
	    return code !== '';
	}
	function replaceLightNums(code, parameters) {
	    return code
	        .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
	        .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
	        .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
	        .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
	}
	function parseIncludes(code) {
	    var pattern = /#include +<([\w\d.]+)>/g;
	    function replace(match, include) {
	        var replace = ShaderChunk[include];
	        if (replace === undefined) {
	            throw new Error('Can not resolve #include <' + include + '>');
	        }
	        return parseIncludes(replace);
	    }
	    return code.replace(pattern, replace);
	}
	function unrollLoops(code) {
	    var pattern = /for \(int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	    function replace(match, start, end, snippet) {
	        var unroll = '';
	        for (var i = parseInt(start); i < parseInt(end); i++) {
	            unroll += snippet.replace(/\[i \]/g, '[' + i + ']');
	        }
	        return unroll;
	    }
	    return code.replace(pattern, replace);
	}
	var WebGLProgram = /** @class */ (function () {
	    function WebGLProgram(renderer, code, material, parameters) {
	        this.renderer = renderer;
	        var gl = this.gl = renderer.context;
	        var extensions = material.extensions;
	        var defines = material.defines;
	        var vertexShader = material.__webglShader.vertexShader;
	        var fragmentShader = material.__webglShader.fragmentShader;
	        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	        if (parameters.shadowMapType === exports.ShadowMap.PCF) {
	            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	        }
	        else if (parameters.shadowMapType === exports.ShadowMap.PCFSoft) {
	            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	        }
	        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
	        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
	        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	        if (parameters.envMap) {
	            switch (material.envMap.mapping) {
	                case exports.TextureMapping.CubeReflection:
	                case exports.TextureMapping.CubeRefraction:
	                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
	                    break;
	                case exports.TextureMapping.CubeUVReflection:
	                case exports.TextureMapping.CubeUVRefraction:
	                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
	                    break;
	                case exports.TextureMapping.EquirectangularReflection:
	                case exports.TextureMapping.EquirectangularRefraction:
	                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
	                    break;
	                case exports.TextureMapping.SphericalReflection:
	                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
	                    break;
	            }
	            switch (material.envMap.mapping) {
	                case exports.TextureMapping.CubeRefraction:
	                case exports.TextureMapping.EquirectangularRefraction:
	                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
	                    break;
	            }
	            switch (material.combine) {
	                case exports.BlendingOperation.Multiply:
	                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	                    break;
	                case exports.BlendingOperation.Mix:
	                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
	                    break;
	                case exports.BlendingOperation.Add:
	                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
	                    break;
	            }
	        }
	        var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
	        // console.log('building new program ');
	        //
	        var customExtensions = generateExtensions(extensions, parameters, renderer.extensions);
	        var customDefines = generateDefines(defines);
	        //
	        var program = gl.createProgram();
	        var prefixVertex, prefixFragment;
	        if (material instanceof RawShaderMaterial) {
	            prefixVertex = [
	                customDefines,
	                '\n'
	            ].filter(filterEmptyLine).join('\n');
	            prefixFragment = [
	                customExtensions,
	                customDefines,
	                '\n'
	            ].filter(filterEmptyLine).join('\n');
	        }
	        else {
	            prefixVertex = [
	                'precision ' + parameters.precision + ' float;',
	                'precision ' + parameters.precision + ' int;',
	                '#define SHADER_NAME ' + material.__webglShader.name,
	                customDefines,
	                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	                '#define GAMMA_FACTOR ' + gammaFactorDefine,
	                '#define MAX_BONES ' + parameters.maxBones,
	                parameters.map ? '#define USE_MAP' : '',
	                parameters.envMap ? '#define USE_ENVMAP' : '',
	                parameters.envMap ? '#define ' + envMapModeDefine : '',
	                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
	                parameters.aoMap ? '#define USE_AOMAP' : '',
	                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
	                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
	                parameters.normalMap ? '#define USE_NORMALMAP' : '',
	                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
	                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
	                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
	                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
	                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
	                parameters.vertexColors ? '#define USE_COLOR' : '',
	                parameters.flatShading ? '#define FLAT_SHADED' : '',
	                parameters.skinning ? '#define USE_SKINNING' : '',
	                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
	                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
	                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
	                parameters.flipSided ? '#define FLIP_SIDED' : '',
	                '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
	                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
	                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
	                parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
	                'uniform mat4 modelMatrix;',
	                'uniform mat4 modelViewMatrix;',
	                'uniform mat4 projectionMatrix;',
	                'uniform mat4 viewMatrix;',
	                'uniform mat3 normalMatrix;',
	                'uniform vec3 cameraPosition;',
	                'attribute vec3 position;',
	                'attribute vec3 normal;',
	                'attribute vec2 uv;',
	                '#ifdef USE_COLOR',
	                '  attribute vec3 color;',
	                '#endif',
	                '#ifdef USE_MORPHTARGETS',
	                '  attribute vec3 morphTarget0;',
	                '  attribute vec3 morphTarget1;',
	                '  attribute vec3 morphTarget2;',
	                '  attribute vec3 morphTarget3;',
	                '  #ifdef USE_MORPHNORMALS',
	                '    attribute vec3 morphNormal0;',
	                '    attribute vec3 morphNormal1;',
	                '    attribute vec3 morphNormal2;',
	                '    attribute vec3 morphNormal3;',
	                '  #else',
	                '    attribute vec3 morphTarget4;',
	                '    attribute vec3 morphTarget5;',
	                '    attribute vec3 morphTarget6;',
	                '    attribute vec3 morphTarget7;',
	                '  #endif',
	                '#endif',
	                '#ifdef USE_SKINNING',
	                '  attribute vec4 skinIndex;',
	                '  attribute vec4 skinWeight;',
	                '#endif',
	                '\n'
	            ].filter(filterEmptyLine).join('\n');
	            prefixFragment = [
	                customExtensions,
	                'precision ' + parameters.precision + ' float;',
	                'precision ' + parameters.precision + ' int;',
	                '#define SHADER_NAME ' + material.__webglShader.name,
	                customDefines,
	                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
	                '#define GAMMA_FACTOR ' + gammaFactorDefine,
	                (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
	                (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',
	                parameters.map ? '#define USE_MAP' : '',
	                parameters.envMap ? '#define USE_ENVMAP' : '',
	                parameters.envMap ? '#define ' + envMapTypeDefine : '',
	                parameters.envMap ? '#define ' + envMapModeDefine : '',
	                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
	                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
	                parameters.aoMap ? '#define USE_AOMAP' : '',
	                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
	                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
	                parameters.normalMap ? '#define USE_NORMALMAP' : '',
	                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
	                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
	                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
	                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
	                parameters.vertexColors ? '#define USE_COLOR' : '',
	                parameters.flatShading ? '#define FLAT_SHADED' : '',
	                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
	                parameters.flipSided ? '#define FLIP_SIDED' : '',
	                '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
	                '#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),
	                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
	                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	                parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',
	                parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',
	                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
	                parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
	                parameters.envMap && renderer.extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '',
	                'uniform mat4 viewMatrix;',
	                'uniform vec3 cameraPosition;',
	                (parameters.toneMapping !== exports.ToneMapping.None) ? "#define TONE_MAPPING" : '',
	                (parameters.toneMapping !== exports.ToneMapping.None) ? ShaderChunk['tonemapping_pars_fragment'] : '',
	                (parameters.toneMapping !== exports.ToneMapping.None) ? getToneMappingFunction("toneMapping", parameters.toneMapping) : '',
	                (parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding) ? ShaderChunk['encodings_pars_fragment'] : '',
	                parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
	                parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
	                parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
	                parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : '',
	                parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',
	                '\n'
	            ].filter(filterEmptyLine).join('\n');
	        }
	        vertexShader = parseIncludes(vertexShader /*, parameters*/);
	        vertexShader = replaceLightNums(vertexShader, parameters);
	        fragmentShader = parseIncludes(fragmentShader /*, parameters*/);
	        fragmentShader = replaceLightNums(fragmentShader, parameters);
	        if (!(material instanceof ShaderMaterial)) {
	            vertexShader = unrollLoops(vertexShader);
	            fragmentShader = unrollLoops(fragmentShader);
	        }
	        var vertexGlsl = prefixVertex + vertexShader;
	        var fragmentGlsl = prefixFragment + fragmentShader;
	        // console.log('*VERTEX*', vertexGlsl);
	        // console.log('*FRAGMENT*', fragmentGlsl);
	        var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
	        var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
	        gl.attachShader(program, glVertexShader);
	        gl.attachShader(program, glFragmentShader);
	        // Force a particular attribute to index 0.
	        if (material.index0AttributeName !== undefined) {
	            gl.bindAttribLocation(program, 0, material.index0AttributeName);
	        }
	        else if (parameters.morphTargets === true) {
	            // programs with morphTargets displace position out of attribute 0
	            gl.bindAttribLocation(program, 0, 'position');
	        }
	        gl.linkProgram(program);
	        var programLog = gl.getProgramInfoLog(program);
	        var vertexLog = gl.getShaderInfoLog(glVertexShader);
	        var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
	        var runnable = true;
	        var haveDiagnostics = true;
	        // console.log('**VERTEX**', gl.getExtension('WEBGL_debug_shaders').getTranslatedShaderSource(glVertexShader));
	        // console.log('**FRAGMENT**', gl.getExtension('WEBGL_debug_shaders').getTranslatedShaderSource(glFragmentShader));
	        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
	            runnable = false;
	            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
	        }
	        else if (programLog !== '') {
	            console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
	        }
	        else if (vertexLog === '' || fragmentLog === '') {
	            haveDiagnostics = false;
	        }
	        if (haveDiagnostics) {
	            this.diagnostics = {
	                runnable: runnable,
	                material: material,
	                programLog: programLog,
	                vertexShader: {
	                    log: vertexLog,
	                    prefix: prefixVertex
	                },
	                fragmentShader: {
	                    log: fragmentLog,
	                    prefix: prefixFragment
	                }
	            };
	        }
	        // clean up
	        gl.deleteShader(glVertexShader);
	        gl.deleteShader(glFragmentShader);
	        //
	        this.id = programIdCount++;
	        this.code = code;
	        this.usedTimes = 1;
	        this.program = program;
	        this.vertexShader = glVertexShader;
	        this.fragmentShader = glFragmentShader;
	    }
	    // set up caching for uniform locations
	    WebGLProgram.prototype.getUniforms = function () {
	        var gl = this.gl;
	        if (this.cachedUniforms === undefined) {
	            this.cachedUniforms = new WebGLUniforms(gl, this.program, this.renderer);
	        }
	        return this.cachedUniforms;
	    };
	    // set up caching for attribute locations
	    WebGLProgram.prototype.getAttributes = function () {
	        var gl = this.gl;
	        if (this.cachedAttributes === undefined) {
	            this.cachedAttributes = fetchAttributeLocations(gl, this.program);
	        }
	        return this.cachedAttributes;
	    };
	    // free resource
	    WebGLProgram.prototype.destroy = function () {
	        var gl = this.gl;
	        gl.deleteProgram(this.program);
	        this.program = undefined;
	    };
	    Object.defineProperty(WebGLProgram.prototype, "uniforms", {
	        // DEPRECATED
	        get: function () {
	            console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
	            return this.getUniforms();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLProgram.prototype, "attributes", {
	        get: function () {
	            console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
	            return this.getAttributes();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return WebGLProgram;
	}());

	var WebGLPrograms = /** @class */ (function () {
	    function WebGLPrograms(renderer, capabilities) {
	        this.renderer = renderer;
	        this.capabilities = capabilities;
	        var programs = [];
	        // Exposed for resource monitoring & error feedback via renderer.info:
	        this.programs = programs;
	    }
	    WebGLPrograms.prototype.getParameters = function (material, lights, fog, nClipPlanes, nClipIntersection, object) {
	        var capabilities = this.capabilities;
	        function allocateBones(object) {
	            if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
	                return 1024;
	            }
	            else {
	                // default for when object is not specified
	                // (for example when prebuilding shader to be used with multiple objects)
	                //
	                //  - leave some extra space for other uniforms
	                //  - limit here is ANGLE's 254 max uniform vectors
	                //    (up to 54 should be safe)
	                var nVertexUniforms = capabilities.maxVertexUniforms;
	                var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
	                var maxBones_1 = nVertexMatrices;
	                if (object !== undefined && (object && object instanceof SkinnedMesh)) {
	                    maxBones_1 = Math.min(object.skeleton.bones.length, maxBones_1);
	                    if (maxBones_1 < object.skeleton.bones.length) {
	                        console.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones_1 + ' (try OpenGL instead of ANGLE)');
	                    }
	                }
	                return maxBones_1;
	            }
	        }
	        function getTextureEncodingFromMap(map, gammaOverrideLinear) {
	            var encoding;
	            if (!map) {
	                encoding = exports.TextureEncoding.Linear;
	            }
	            else if ((map && map instanceof Texture)) {
	                encoding = map.encoding;
	            }
	            else if ((map && map instanceof WebGLRenderTarget)) {
	                console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
	                encoding = map.texture.encoding;
	            }
	            // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
	            if (encoding === exports.TextureEncoding.Linear && gammaOverrideLinear) {
	                encoding = exports.TextureEncoding.Gamma;
	            }
	            return encoding;
	        }
	        var shaderIDs = {
	            MeshDepthMaterial: 'depth',
	            MeshNormalMaterial: 'normal',
	            MeshBasicMaterial: 'basic',
	            MeshLambertMaterial: 'lambert',
	            MeshPhongMaterial: 'phong',
	            MeshStandardMaterial: 'physical',
	            MeshPhysicalMaterial: 'physical',
	            LineBasicMaterial: 'basic',
	            LineDashedMaterial: 'dashed',
	            PointsMaterial: 'points'
	        };
	        var shaderID = shaderIDs[material.type];
	        // heuristics to create shader parameters according to lights in the scene
	        // (not to blow over maxLights budget)
	        var maxBones = allocateBones(object);
	        var precision = this.renderer.getPrecision();
	        if (material.precision !== null) {
	            precision = capabilities.getMaxPrecision(material.precision);
	            if (precision !== material.precision) {
	                console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
	            }
	        }
	        var currentRenderTarget = this.renderer.getCurrentRenderTarget();
	        var parameters = {
	            shaderID: shaderID,
	            precision: precision,
	            supportsVertexTextures: capabilities.vertexTextures,
	            outputEncoding: getTextureEncodingFromMap((!currentRenderTarget) ? null : currentRenderTarget.texture, this.renderer.gammaOutput),
	            map: !!material.map,
	            mapEncoding: getTextureEncodingFromMap(material.map, this.renderer.gammaInput),
	            envMap: !!material.envMap,
	            envMapMode: material.envMap && material.envMap.mapping,
	            envMapEncoding: getTextureEncodingFromMap(material.envMap, this.renderer.gammaInput),
	            envMapCubeUV: (!!material.envMap) && ((material.envMap.mapping === exports.TextureMapping.CubeUVReflection) || (material.envMap.mapping === exports.TextureMapping.CubeUVRefraction)),
	            lightMap: !!material.lightMap,
	            aoMap: !!material.aoMap,
	            emissiveMap: !!material.emissiveMap,
	            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, this.renderer.gammaInput),
	            bumpMap: !!material.bumpMap,
	            normalMap: !!material.normalMap,
	            displacementMap: !!material.displacementMap,
	            roughnessMap: !!material.roughnessMap,
	            metalnessMap: !!material.metalnessMap,
	            specularMap: !!material.specularMap,
	            alphaMap: !!material.alphaMap,
	            combine: material.combine,
	            vertexColors: material.vertexColors,
	            fog: !!fog,
	            useFog: material.fog,
	            fogExp: (fog && fog instanceof FogExp2),
	            flatShading: material.shading === exports.ShadingMode.Flat,
	            sizeAttenuation: material.sizeAttenuation,
	            logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
	            skinning: material.skinning,
	            maxBones: maxBones,
	            useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
	            morphTargets: material.morphTargets,
	            morphNormals: material.morphNormals,
	            maxMorphTargets: this.renderer.maxMorphTargets,
	            maxMorphNormals: this.renderer.maxMorphNormals,
	            numDirLights: lights.directional.length,
	            numPointLights: lights.point.length,
	            numSpotLights: lights.spot.length,
	            numHemiLights: lights.hemi.length,
	            numClippingPlanes: nClipPlanes,
	            numClipIntersection: nClipIntersection,
	            shadowMapEnabled: this.renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
	            shadowMapType: this.renderer.shadowMap.type,
	            toneMapping: this.renderer.toneMapping,
	            physicallyCorrectLights: this.renderer.physicallyCorrectLights,
	            premultipliedAlpha: material.premultipliedAlpha,
	            alphaTest: material.alphaTest,
	            doubleSided: material.side === exports.SideMode.Double,
	            flipSided: material.side === exports.SideMode.Back,
	            depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false
	        };
	        return parameters;
	    };
	    WebGLPrograms.prototype.getProgramCode = function (material /*Material*/, parameters) {
	        var parameterNames = [
	            "precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
	            "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
	            "roughnessMap", "metalnessMap",
	            "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
	            "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
	            "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
	            "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
	            "numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
	            "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
	            "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking"
	        ];
	        var array = [];
	        if (parameters.shaderID) {
	            array.push(parameters.shaderID);
	        }
	        else {
	            array.push(material.fragmentShader);
	            array.push(material.vertexShader);
	        }
	        if (material.defines !== undefined) {
	            for (var name in material.defines) {
	                array.push(name);
	                array.push(material.defines[name]);
	            }
	        }
	        for (var i = 0; i < parameterNames.length; i++) {
	            array.push(parameters[parameterNames[i]]);
	        }
	        return array.join();
	    };
	    WebGLPrograms.prototype.acquireProgram = function (material /*Material*/, parameters, code) {
	        var program;
	        // Check if code has been already compiled
	        for (var p = 0, pl = this.programs.length; p < pl; p++) {
	            var programInfo = this.programs[p];
	            if (programInfo.code === code) {
	                program = programInfo;
	                ++program.usedTimes;
	                break;
	            }
	        }
	        if (program === undefined) {
	            program = new WebGLProgram(this.renderer, code, material, parameters);
	            this.programs.push(program);
	        }
	        return program;
	    };
	    WebGLPrograms.prototype.releaseProgram = function (program) {
	        if (--program.usedTimes === 0) {
	            // Remove from unordered set
	            var i = this.programs.indexOf(program);
	            this.programs[i] = this.programs[this.programs.length - 1];
	            this.programs.pop();
	            // Free WebGL resources
	            program.destroy();
	        }
	    };
	    return WebGLPrograms;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var WebGLGeometries = /** @class */ (function () {
	    function WebGLGeometries(gl, properties, info) {
	        this.geometries = {};
	        this.gl = gl;
	        this.properties = properties;
	        this.info = info;
	    }
	    WebGLGeometries.prototype.get = function (object) {
	        var gl = this.gl;
	        var properties = this.properties;
	        var info = this.info;
	        var geometries = this.geometries;
	        var geometry = object.geometry;
	        if (geometries[geometry.id] !== undefined) {
	            return geometries[geometry.id];
	        }
	        geometry.addEventListener('dispose', onGeometryDispose);
	        function onGeometryDispose(event) {
	            var geometry = event.target;
	            var buffergeometry = geometries[geometry.id];
	            if (buffergeometry.index !== null) {
	                deleteAttribute(buffergeometry.index);
	            }
	            deleteAttributes(buffergeometry.attributes);
	            geometry.removeEventListener('dispose', onGeometryDispose);
	            delete geometries[geometry.id];
	            // TODO
	            var property = properties.get(geometry);
	            if (property.wireframe) {
	                deleteAttribute(property.wireframe);
	            }
	            properties.delete(geometry);
	            var bufferproperty = properties.get(buffergeometry);
	            if (bufferproperty.wireframe) {
	                deleteAttribute(bufferproperty.wireframe);
	            }
	            properties.delete(buffergeometry);
	            //
	            info.memory.geometries--;
	        }
	        function getAttributeBuffer(attribute) {
	            if (attribute instanceof InterleavedBufferAttribute) {
	                return properties.get(attribute.data).__webglBuffer;
	            }
	            return properties.get(attribute).__webglBuffer;
	        }
	        function deleteAttribute(attribute) {
	            var buffer = getAttributeBuffer(attribute);
	            if (buffer !== undefined) {
	                gl.deleteBuffer(buffer);
	                removeAttributeBuffer(attribute);
	            }
	        }
	        function deleteAttributes(attributes) {
	            for (var name in attributes) {
	                var attribute = attributes[name];
	                if (attribute === undefined)
	                    continue;
	                deleteAttribute(attribute);
	            }
	        }
	        function removeAttributeBuffer(attribute) {
	            if (attribute instanceof InterleavedBufferAttribute) {
	                properties.delete(attribute.data);
	            }
	            else {
	                properties.delete(attribute);
	            }
	        }
	        var buffergeometry;
	        if (geometry instanceof BufferGeometry) {
	            buffergeometry = geometry;
	        }
	        else if (geometry instanceof Geometry) {
	            if (geometry._bufferGeometry === undefined) {
	                geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
	            }
	            buffergeometry = geometry._bufferGeometry;
	        }
	        geometries[geometry.id] = buffergeometry;
	        info.memory.geometries++;
	        return buffergeometry;
	    };
	    return WebGLGeometries;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var WebGLObjects = /** @class */ (function () {
	    function WebGLObjects(gl, properties, info) {
	        this.gl = gl;
	        this.properties = properties;
	        this.info = info;
	        this.geometries = new WebGLGeometries(gl, properties, info);
	    }
	    //
	    WebGLObjects.prototype.update = function (object) {
	        var gl = this.gl;
	        // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
	        var geometry = this.geometries.get(object);
	        if (object.geometry instanceof Geometry) {
	            geometry.updateFromObject(object);
	        }
	        var index = geometry.index;
	        var attributes = geometry.attributes;
	        if (index !== null) {
	            this.updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
	        }
	        for (var name in attributes) {
	            var attribute = attributes[name];
	            if (attribute === undefined)
	                continue;
	            this.updateAttribute(attribute, gl.ARRAY_BUFFER);
	        }
	        // morph targets
	        var morphAttributes = geometry.morphAttributes;
	        for (var name in morphAttributes) {
	            var array = morphAttributes[name];
	            for (var i = 0, l = array.length; i < l; i++) {
	                this.updateAttribute(array[i], gl.ARRAY_BUFFER);
	            }
	        }
	        return geometry;
	    };
	    WebGLObjects.prototype.updateAttribute = function (attribute, bufferType) {
	        if (!attribute)
	            return;
	        var data = (attribute instanceof InterleavedBufferAttribute) ? attribute.data : attribute;
	        var attributeProperties = this.properties.get(data);
	        if (attributeProperties.__webglBuffer === undefined) {
	            this.createBuffer(attributeProperties, data, bufferType);
	        }
	        else if (attributeProperties.version !== data.version) {
	            this.updateBuffer(attributeProperties, data, bufferType);
	        }
	    };
	    WebGLObjects.prototype.createBuffer = function (attributeProperties, data, bufferType) {
	        var gl = this.gl;
	        attributeProperties.__webglBuffer = gl.createBuffer();
	        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
	        var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	        gl.bufferData(bufferType, data.array, usage);
	        attributeProperties.version = data.version;
	    };
	    WebGLObjects.prototype.updateBuffer = function (attributeProperties, data, bufferType) {
	        var gl = this.gl;
	        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
	        if (data.dynamic === false) {
	            gl.bufferData(bufferType, data.array, gl.STATIC_DRAW);
	        }
	        else if (data.updateRange.count === -1) {
	            // Not using update ranges
	            gl.bufferSubData(bufferType, 0, data.array);
	        }
	        else if (data.updateRange.count === 0) {
	            console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
	        }
	        else {
	            gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));
	            data.updateRange.count = 0; // reset range
	        }
	        attributeProperties.version = data.version;
	    };
	    WebGLObjects.prototype.getAttributeBuffer = function (attribute) {
	        if (attribute instanceof InterleavedBufferAttribute) {
	            return this.properties.get(attribute.data).__webglBuffer;
	        }
	        return this.properties.get(attribute).__webglBuffer;
	    };
	    WebGLObjects.prototype.getWireframeAttribute = function (geometry) {
	        var gl = this.gl;
	        var property = this.properties.get(geometry);
	        if (property.wireframe !== undefined) {
	            return property.wireframe;
	        }
	        var indices = [];
	        var index = geometry.index;
	        var attributes = geometry.attributes;
	        var position = attributes.position;
	        // console.time('wireframe');
	        if (index !== null) {
	            //const edges = {};
	            var array = index.array;
	            for (var i = 0, l = array.length; i < l; i += 3) {
	                var a = array[i + 0];
	                var b = array[i + 1];
	                var c = array[i + 2];
	                indices.push(a, b, b, c, c, a);
	            }
	        }
	        else {
	            var array = attributes.position.array;
	            for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {
	                var a = i + 0;
	                var b = i + 1;
	                var c = i + 2;
	                indices.push(a, b, b, c, c, a);
	            }
	        }
	        // console.timeEnd('wireframe');
	        var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
	        var attribute = new BufferAttribute(new TypeArray(indices), 1);
	        this.updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
	        property.wireframe = attribute;
	        return attribute;
	    };
	    return WebGLObjects;
	}());

	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */
	var DepthTexture = /** @class */ (function (_super) {
	    __extends(DepthTexture, _super);
	    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
	        if (type === void 0) { type = exports.TextureType.UnsignedShort; }
	        if (magFilter === void 0) { magFilter = exports.TextureFilter.Nearest; }
	        if (minFilter === void 0) { minFilter = exports.TextureFilter.Nearest; }
	        if (format === void 0) { format = exports.TextureFormat.Depth; }
	        var _this = _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
	        _this.isDepthTexture = true;
	        if (format !== exports.TextureFormat.Depth && format !== exports.TextureFormat.DepthStencil) {
	            throw new Error('DepthTexture format must be either THREE.TextureFormat.Depth or THREE.TextureFormat.DepthStencil');
	        }
	        _this.image = { width: width, height: height };
	        _this.type = type;
	        _this.magFilter = magFilter;
	        _this.minFilter = minFilter;
	        _this.flipY = false;
	        _this.generateMipmaps = false;
	        return _this;
	    }
	    return DepthTexture;
	}(Texture));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	var CompressedTexture = /** @class */ (function (_super) {
	    __extends(CompressedTexture, _super);
	    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
	        var _this = _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
	        _this.isCompressedTexture = true;
	        _this.image = { width: width, height: height };
	        _this.mipmaps = mipmaps;
	        // no flipping for cube textures
	        // (also flipping doesn't work for compressed textures)
	        _this.flipY = false;
	        // can't generate mipmaps for compressed textures
	        // mips must be embedded in DDS files
	        _this.generateMipmaps = false;
	        return _this;
	    }
	    return CompressedTexture;
	}(Texture));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var WebGLTextures = /** @class */ (function () {
	    function WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, info) {
	        this._gl = _gl;
	        this.extensions = extensions;
	        this.state = state;
	        this.properties = properties;
	        this.capabilities = capabilities;
	        this.paramThreeToGL = paramThreeToGL;
	        this.info = info;
	        this._infoMemory = info.memory;
	        this._isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext);
	    }
	    //
	    WebGLTextures.clampToMaxSize = function (image, maxSize) {
	        if (image.width > maxSize || image.height > maxSize) {
	            // Warning: Scaling through the canvas will only work with images that use
	            // premultiplied alpha.
	            var scale = maxSize / Math.max(image.width, image.height);
	            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
	            canvas.width = Math.floor(image.width * scale);
	            canvas.height = Math.floor(image.height * scale);
	            var context = canvas.getContext('2d');
	            context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
	            console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
	            return canvas;
	        }
	        return image;
	    };
	    WebGLTextures.isPowerOfTwo = function (image) {
	        return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
	    };
	    WebGLTextures.makePowerOfTwo = function (image) {
	        if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
	            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
	            canvas.width = _Math.nearestPowerOfTwo(image.width);
	            canvas.height = _Math.nearestPowerOfTwo(image.height);
	            var context = canvas.getContext('2d');
	            context.drawImage(image, 0, 0, canvas.width, canvas.height);
	            console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
	            return canvas;
	        }
	        return image;
	    };
	    WebGLTextures.textureNeedsPowerOfTwo = function (texture) {
	        if (texture.wrapS !== exports.TextureWrapping.ClampToEdge || texture.wrapT !== exports.TextureWrapping.ClampToEdge)
	            return true;
	        if (texture.minFilter !== exports.TextureFilter.Nearest && texture.minFilter !== exports.TextureFilter.Linear)
	            return true;
	        return false;
	    };
	    // Fallback filters for non-power-of-2 textures
	    WebGLTextures.prototype.filterFallback = function (f) {
	        var _gl = this._gl;
	        if (f === exports.TextureFilter.Nearest || f === exports.TextureFilter.NearestMipMapNearest || f === exports.TextureFilter.NearestMipMapLinear) {
	            return _gl.NEAREST;
	        }
	        return _gl.LINEAR;
	    };
	    //
	    WebGLTextures.prototype.onTextureDispose = function (event) {
	        var texture = event.target;
	        texture.removeEventListener('dispose', this.onTextureDispose.bind(this));
	        this.deallocateTexture(texture);
	        this._infoMemory.textures--;
	    };
	    WebGLTextures.prototype.onRenderTargetDispose = function (event) {
	        var renderTarget = event.target;
	        renderTarget.removeEventListener('dispose', this.onRenderTargetDispose.bind(this));
	        this.deallocateRenderTarget(renderTarget);
	        this._infoMemory.textures--;
	    };
	    //
	    WebGLTextures.prototype.deallocateTexture = function (texture) {
	        var _gl = this._gl;
	        var textureProperties = this.properties.get(texture);
	        if (texture.image && textureProperties.__image__webglTextureCube) {
	            // cube texture
	            _gl.deleteTexture(textureProperties.__image__webglTextureCube);
	        }
	        else {
	            // 2D texture
	            if (textureProperties.__webglInit === undefined)
	                return;
	            _gl.deleteTexture(textureProperties.__webglTexture);
	        }
	        // remove all webgl this.properties
	        this.properties.delete(texture);
	    };
	    WebGLTextures.prototype.deallocateRenderTarget = function (renderTarget) {
	        var _gl = this._gl;
	        var renderTargetProperties = this.properties.get(renderTarget);
	        var textureProperties = this.properties.get(renderTarget.texture);
	        if (!renderTarget)
	            return;
	        if (textureProperties.__webglTexture !== undefined) {
	            _gl.deleteTexture(textureProperties.__webglTexture);
	        }
	        if (renderTarget.depthTexture) {
	            renderTarget.depthTexture.dispose();
	        }
	        if ((renderTarget && renderTarget instanceof WebGLRenderTargetCube)) {
	            for (var i = 0; i < 6; i++) {
	                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
	                if (renderTargetProperties.__webglDepthbuffer)
	                    _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
	            }
	        }
	        else {
	            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
	            if (renderTargetProperties.__webglDepthbuffer)
	                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
	        }
	        this.properties.delete(renderTarget.texture);
	        this.properties.delete(renderTarget);
	    };
	    //
	    WebGLTextures.prototype.setTexture2D = function (texture, slot) {
	        var _gl = this._gl;
	        var textureProperties = this.properties.get(texture);
	        if (texture.version > 0 && textureProperties.__version !== texture.version) {
	            var image = texture.image;
	            if (image === undefined) {
	                console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
	            }
	            else if (image.complete === false) {
	                console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
	            }
	            else {
	                this.uploadTexture(textureProperties, texture, slot);
	                return;
	            }
	        }
	        this.state.activeTexture(_gl.TEXTURE0 + slot);
	        this.state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
	    };
	    WebGLTextures.prototype.setTextureCube = function (texture, slot) {
	        var _gl = this._gl;
	        var textureProperties = this.properties.get(texture);
	        if (texture.image.length === 6) {
	            if (texture.version > 0 && textureProperties.__version !== texture.version) {
	                if (!textureProperties.__image__webglTextureCube) {
	                    texture.addEventListener('dispose', this.onTextureDispose.bind(this));
	                    textureProperties.__image__webglTextureCube = _gl.createTexture();
	                    this._infoMemory.textures++;
	                }
	                this.state.activeTexture(_gl.TEXTURE0 + slot);
	                this.state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
	                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
	                var isCompressed = (texture && texture instanceof CompressedTexture);
	                var isDataTexture = (texture.image[0] && texture.image[0] instanceof DataTexture);
	                var cubeImage = [];
	                for (var i = 0; i < 6; i++) {
	                    if (!isCompressed && !isDataTexture) {
	                        cubeImage[i] = WebGLTextures.clampToMaxSize(texture.image[i], this.capabilities.maxCubemapSize);
	                    }
	                    else {
	                        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
	                    }
	                }
	                var image = cubeImage[0], isPowerOfTwoImage = WebGLTextures.isPowerOfTwo(image), glFormat = this.paramThreeToGL(texture.format), glType = this.paramThreeToGL(texture.type);
	                this.setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
	                for (var i = 0; i < 6; i++) {
	                    if (!isCompressed) {
	                        if (isDataTexture) {
	                            this.state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
	                        }
	                        else {
	                            this.state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
	                        }
	                    }
	                    else {
	                        var mipmap = void 0;
	                        var mipmaps = cubeImage[i].mipmaps;
	                        for (var j = 0, jl = mipmaps.length; j < jl; j++) {
	                            mipmap = mipmaps[j];
	                            if (texture.format !== exports.TextureFormat.RGBA && texture.format !== exports.TextureFormat.RGB) {
	                                if (this.state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
	                                    this.state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
	                                }
	                                else {
	                                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
	                                }
	                            }
	                            else {
	                                this.state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
	                            }
	                        }
	                    }
	                }
	                if (texture.generateMipmaps && isPowerOfTwoImage) {
	                    _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
	                }
	                textureProperties.__version = texture.version;
	                if (texture.onUpdate)
	                    texture.onUpdate(texture);
	            }
	            else {
	                this.state.activeTexture(_gl.TEXTURE0 + slot);
	                this.state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
	            }
	        }
	    };
	    WebGLTextures.prototype.setTextureCubeDynamic = function (texture, slot) {
	        var _gl = this._gl;
	        this.state.activeTexture(_gl.TEXTURE0 + slot);
	        this.state.bindTexture(_gl.TEXTURE_CUBE_MAP, this.properties.get(texture).__webglTexture);
	    };
	    WebGLTextures.prototype.setTextureParameters = function (textureType, texture, isPowerOfTwoImage) {
	        var _gl = this._gl;
	        var extension;
	        if (isPowerOfTwoImage) {
	            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, this.paramThreeToGL(texture.wrapS));
	            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, this.paramThreeToGL(texture.wrapT));
	            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, this.paramThreeToGL(texture.magFilter));
	            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, this.paramThreeToGL(texture.minFilter));
	        }
	        else {
	            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
	            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
	            if (texture.wrapS !== exports.TextureWrapping.ClampToEdge || texture.wrapT !== exports.TextureWrapping.ClampToEdge) {
	                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.TextureWrapping.ClampToEdge.', texture);
	            }
	            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, this.filterFallback(texture.magFilter));
	            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, this.filterFallback(texture.minFilter));
	            if (texture.minFilter !== exports.TextureFilter.Nearest && texture.minFilter !== exports.TextureFilter.Linear) {
	                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.TextureFilter.Nearest or THREE.TextureFilter.Linear.', texture);
	            }
	        }
	        extension = this.extensions.get('EXT_texture_filter_anisotropic');
	        if (extension) {
	            if (texture.type === exports.TextureType.Float && this.extensions.get('OES_texture_float_linear') === null)
	                return;
	            if (texture.type === exports.TextureType.HalfFloat && this.extensions.get('OES_texture_half_float_linear') === null)
	                return;
	            if (texture.anisotropy > 1 || this.properties.get(texture).__currentAnisotropy) {
	                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, this.capabilities.getMaxAnisotropy()));
	                this.properties.get(texture).__currentAnisotropy = texture.anisotropy;
	            }
	        }
	    };
	    WebGLTextures.prototype.uploadTexture = function (textureProperties, texture, slot) {
	        var _gl = this._gl;
	        if (textureProperties.__webglInit === undefined) {
	            textureProperties.__webglInit = true;
	            texture.addEventListener('dispose', this.onTextureDispose.bind(this));
	            textureProperties.__webglTexture = _gl.createTexture();
	            this._infoMemory.textures++;
	        }
	        this.state.activeTexture(_gl.TEXTURE0 + slot);
	        this.state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
	        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
	        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
	        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
	        var image = WebGLTextures.clampToMaxSize(texture.image, this.capabilities.maxTextureSize);
	        if (WebGLTextures.textureNeedsPowerOfTwo(texture) && WebGLTextures.isPowerOfTwo(image) === false) {
	            image = WebGLTextures.makePowerOfTwo(image);
	        }
	        var isPowerOfTwoImage = WebGLTextures.isPowerOfTwo(image), glFormat = this.paramThreeToGL(texture.format), glType = this.paramThreeToGL(texture.type);
	        this.setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
	        var mipmap;
	        var mipmaps = texture.mipmaps;
	        if ((texture && texture instanceof DepthTexture)) {
	            // populate depth texture with dummy data
	            var internalFormat = _gl.DEPTH_COMPONENT;
	            if (texture.type === exports.TextureType.Float) {
	                if (!this._isWebGL2)
	                    throw new Error('Float Depth Texture only supported in WebGL2.0');
	                internalFormat = _gl.DEPTH_COMPONENT32F;
	            }
	            else if (this._isWebGL2) {
	                // WebGL 2.0 requires signed internalformat for glTexImage2D
	                internalFormat = _gl.DEPTH_COMPONENT16;
	            }
	            // Depth stencil textures need the DEPTH_STENCIL internal format
	            // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
	            if (texture.format === exports.TextureFormat.DepthStencil) {
	                internalFormat = _gl.DEPTH_STENCIL;
	            }
	            this.state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
	        }
	        else if ((texture && texture instanceof DataTexture)) {
	            // use manually created mipmaps if available
	            // if there are no manual mipmaps
	            // set 0 level mipmap and then use GL to generate other mipmap levels
	            if (mipmaps.length > 0 && isPowerOfTwoImage) {
	                for (var i = 0, il = mipmaps.length; i < il; i++) {
	                    mipmap = mipmaps[i];
	                    this.state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
	                }
	                texture.generateMipmaps = false;
	            }
	            else {
	                this.state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
	            }
	        }
	        else if ((texture && texture instanceof CompressedTexture)) {
	            for (var i = 0, il = mipmaps.length; i < il; i++) {
	                mipmap = mipmaps[i];
	                if (texture.format !== exports.TextureFormat.RGBA && texture.format !== exports.TextureFormat.RGB) {
	                    if (this.state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
	                        this.state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
	                    }
	                    else {
	                        console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
	                    }
	                }
	                else {
	                    this.state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
	                }
	            }
	        }
	        else {
	            // regular Texture (image, video, canvas)
	            // use manually created mipmaps if available
	            // if there are no manual mipmaps
	            // set 0 level mipmap and then use GL to generate other mipmap levels
	            if (mipmaps.length > 0 && isPowerOfTwoImage) {
	                for (var i = 0, il = mipmaps.length; i < il; i++) {
	                    mipmap = mipmaps[i];
	                    this.state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
	                }
	                texture.generateMipmaps = false;
	            }
	            else {
	                this.state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
	            }
	        }
	        if (texture.generateMipmaps && isPowerOfTwoImage)
	            _gl.generateMipmap(_gl.TEXTURE_2D);
	        textureProperties.__version = texture.version;
	        if (texture.onUpdate)
	            texture.onUpdate(texture);
	    };
	    // Render targets
	    // Setup storage for target texture and bind it to correct framebuffer
	    WebGLTextures.prototype.setupFrameBufferTexture = function (framebuffer, renderTarget, attachment, textureTarget) {
	        var _gl = this._gl;
	        var glFormat = this.paramThreeToGL(renderTarget.texture.format);
	        var glType = this.paramThreeToGL(renderTarget.texture.type);
	        this.state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
	        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
	        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, this.properties.get(renderTarget.texture).__webglTexture, 0);
	        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
	    };
	    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	    WebGLTextures.prototype.setupRenderBufferStorage = function (renderbuffer, renderTarget) {
	        var _gl = this._gl;
	        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
	        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
	            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
	            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
	        }
	        else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
	            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
	            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
	        }
	        else {
	            // FIXME: We don't support !depth !stencil
	            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
	        }
	        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
	    };
	    // Setup resources for a Depth Texture for a FBO (needs an extension)
	    WebGLTextures.prototype.setupDepthTexture = function (framebuffer, renderTarget) {
	        var _gl = this._gl;
	        var isCube = ((renderTarget && renderTarget instanceof WebGLRenderTargetCube));
	        if (isCube)
	            throw new Error('Depth Texture with cube render targets is not supported!');
	        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
	        if (!((renderTarget.depthTexture && renderTarget.depthTexture instanceof DepthTexture))) {
	            throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
	        }
	        // upload an empty depth texture with framebuffer size
	        if (!this.properties.get(renderTarget.depthTexture).__webglTexture ||
	            renderTarget.depthTexture.image.width !== renderTarget.width ||
	            renderTarget.depthTexture.image.height !== renderTarget.height) {
	            renderTarget.depthTexture.image.width = renderTarget.width;
	            renderTarget.depthTexture.image.height = renderTarget.height;
	            renderTarget.depthTexture.needsUpdate = true;
	        }
	        this.setTexture2D(renderTarget.depthTexture, 0);
	        var webglDepthTexture = this.properties.get(renderTarget.depthTexture).__webglTexture;
	        if (renderTarget.depthTexture.format === exports.TextureFormat.Depth) {
	            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
	        }
	        else if (renderTarget.depthTexture.format === exports.TextureFormat.DepthStencil) {
	            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
	        }
	        else {
	            throw new Error('Unknown depthTexture format');
	        }
	    };
	    // Setup GL resources for a non-texture depth buffer
	    WebGLTextures.prototype.setupDepthRenderbuffer = function (renderTarget) {
	        var _gl = this._gl;
	        var renderTargetProperties = this.properties.get(renderTarget);
	        var isCube = ((renderTarget && renderTarget instanceof WebGLRenderTargetCube));
	        if (renderTarget.depthTexture) {
	            if (isCube)
	                throw new Error('target.depthTexture not supported in Cube render targets');
	            this.setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
	        }
	        else {
	            if (isCube) {
	                renderTargetProperties.__webglDepthbuffer = [];
	                for (var i = 0; i < 6; i++) {
	                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
	                    renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
	                    this.setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
	                }
	            }
	            else {
	                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
	                renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
	                this.setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
	            }
	        }
	        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
	    };
	    // Set up GL resources for the render target
	    WebGLTextures.prototype.setupRenderTarget = function (renderTarget) {
	        var _gl = this._gl;
	        var renderTargetProperties = this.properties.get(renderTarget);
	        var textureProperties = this.properties.get(renderTarget.texture);
	        renderTarget.addEventListener('dispose', this.onRenderTargetDispose.bind(this));
	        textureProperties.__webglTexture = _gl.createTexture();
	        this._infoMemory.textures++;
	        var isCube = ((renderTarget && renderTarget instanceof WebGLRenderTargetCube));
	        var isTargetPowerOfTwo = WebGLTextures.isPowerOfTwo(renderTarget);
	        // Setup framebuffer
	        if (isCube) {
	            renderTargetProperties.__webglFramebuffer = [];
	            for (var i = 0; i < 6; i++) {
	                renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
	            }
	        }
	        else {
	            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	        }
	        // Setup color buffer
	        if (isCube) {
	            this.state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
	            this.setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
	            for (var i = 0; i < 6; i++) {
	                this.setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
	            }
	            if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
	                _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
	            this.state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
	        }
	        else {
	            this.state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
	            this.setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
	            this.setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
	            if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
	                _gl.generateMipmap(_gl.TEXTURE_2D);
	            this.state.bindTexture(_gl.TEXTURE_2D, null);
	        }
	        // Setup depth and stencil buffers
	        if (renderTarget.depthBuffer) {
	            this.setupDepthRenderbuffer(renderTarget);
	        }
	    };
	    WebGLTextures.prototype.updateRenderTargetMipmap = function (renderTarget) {
	        var _gl = this._gl;
	        var texture = renderTarget.texture;
	        if (texture.generateMipmaps && WebGLTextures.isPowerOfTwo(renderTarget) &&
	            texture.minFilter !== exports.TextureFilter.Nearest &&
	            texture.minFilter !== exports.TextureFilter.Linear) {
	            var target = (renderTarget && renderTarget instanceof WebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
	            var webglTexture = this.properties.get(texture).__webglTexture;
	            this.state.bindTexture(target, webglTexture);
	            _gl.generateMipmap(target);
	            this.state.bindTexture(target, null);
	        }
	    };
	    return WebGLTextures;
	}());

	/**
	 * @author fordacious / fordacious.github.io
	 */
	var WebGLProperties = /** @class */ (function () {
	    function WebGLProperties() {
	        this.properties = {};
	    }
	    WebGLProperties.prototype.get = function (object) {
	        var uuid = object.uuid;
	        var map = this.properties[uuid];
	        if (map === undefined) {
	            map = {};
	            this.properties[uuid] = map;
	        }
	        return map;
	    };
	    WebGLProperties.prototype.delete = function (object) {
	        delete this.properties[object.uuid];
	    };
	    WebGLProperties.prototype.clear = function () {
	        this.properties = {};
	    };
	    return WebGLProperties;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var ColorBuffer = /** @class */ (function () {
	    function ColorBuffer(state) {
	        this.locked = false;
	        this.color = new Vector4();
	        this.currentColorMask = null;
	        this.currentColorClear = new Vector4();
	        this.state = state;
	    }
	    ColorBuffer.prototype.setMask = function (colorMask) {
	        if (this.currentColorMask !== colorMask && !this.locked) {
	            this.state.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
	            this.currentColorMask = colorMask;
	        }
	    };
	    ColorBuffer.prototype.setLocked = function (lock) {
	        this.locked = lock;
	    };
	    ColorBuffer.prototype.setClear = function (r, g, b, a) {
	        this.color.set(r, g, b, a);
	        if (this.currentColorClear.equals(this.color) === false) {
	            this.state.gl.clearColor(r, g, b, a);
	            this.currentColorClear.copy(this.color);
	        }
	    };
	    ColorBuffer.prototype.reset = function () {
	        this.locked = false;
	        this.currentColorMask = null;
	        this.currentColorClear.set(0, 0, 0, 1);
	    };
	    return ColorBuffer;
	}());
	var DepthBuffer = /** @class */ (function () {
	    function DepthBuffer(state) {
	        this.locked = false;
	        this.currentDepthMask = null;
	        this.currentDepthFunc = null;
	        this.currentDepthClear = null;
	        this.state = state;
	    }
	    DepthBuffer.prototype.setTest = function (depthTest) {
	        var gl = this.state.gl;
	        if (depthTest) {
	            this.state.enable(gl.DEPTH_TEST);
	        }
	        else {
	            this.state.disable(gl.DEPTH_TEST);
	        }
	    };
	    DepthBuffer.prototype.setMask = function (depthMask) {
	        var gl = this.state.gl;
	        if (this.currentDepthMask !== depthMask && !this.locked) {
	            gl.depthMask(depthMask);
	            this.currentDepthMask = depthMask;
	        }
	    };
	    DepthBuffer.prototype.setFunc = function (depthFunc) {
	        var gl = this.state.gl;
	        if (this.currentDepthFunc !== depthFunc) {
	            if (depthFunc) {
	                switch (depthFunc) {
	                    case exports.DepthFunction.Never:
	                        gl.depthFunc(gl.NEVER);
	                        break;
	                    case exports.DepthFunction.Always:
	                        gl.depthFunc(gl.ALWAYS);
	                        break;
	                    case exports.DepthFunction.Less:
	                        gl.depthFunc(gl.LESS);
	                        break;
	                    case exports.DepthFunction.LessEqual:
	                        gl.depthFunc(gl.LEQUAL);
	                        break;
	                    case exports.DepthFunction.Equal:
	                        gl.depthFunc(gl.EQUAL);
	                        break;
	                    case exports.DepthFunction.GreaterEqual:
	                        gl.depthFunc(gl.GEQUAL);
	                        break;
	                    case exports.DepthFunction.Greater:
	                        gl.depthFunc(gl.GREATER);
	                        break;
	                    case exports.DepthFunction.NotEqual:
	                        gl.depthFunc(gl.NOTEQUAL);
	                        break;
	                    default:
	                        gl.depthFunc(gl.LEQUAL);
	                }
	            }
	            else {
	                gl.depthFunc(gl.LEQUAL);
	            }
	            this.currentDepthFunc = depthFunc;
	        }
	    };
	    DepthBuffer.prototype.setLocked = function (lock) {
	        this.locked = lock;
	    };
	    DepthBuffer.prototype.setClear = function (depth) {
	        var gl = this.state.gl;
	        if (this.currentDepthClear !== depth) {
	            gl.clearDepth(depth);
	            this.currentDepthClear = depth;
	        }
	    };
	    DepthBuffer.prototype.reset = function () {
	        this.locked = false;
	        this.currentDepthMask = null;
	        this.currentDepthFunc = null;
	        this.currentDepthClear = null;
	    };
	    return DepthBuffer;
	}());
	var StencilBuffer = /** @class */ (function () {
	    function StencilBuffer(state) {
	        this.locked = false;
	        this.currentStencilMask = null;
	        this.currentStencilFunc = null;
	        this.currentStencilRef = null;
	        this.currentStencilFuncMask = null;
	        this.currentStencilFail = null;
	        this.currentStencilZFail = null;
	        this.currentStencilZPass = null;
	        this.currentStencilClear = null;
	        this.state = state;
	    }
	    StencilBuffer.prototype.setTest = function (stencilTest) {
	        var gl = this.state.gl;
	        if (stencilTest) {
	            this.state.enable(gl.STENCIL_TEST);
	        }
	        else {
	            this.state.disable(gl.STENCIL_TEST);
	        }
	    };
	    StencilBuffer.prototype.setMask = function (stencilMask) {
	        var gl = this.state.gl;
	        if (this.currentStencilMask !== stencilMask && !this.locked) {
	            gl.stencilMask(stencilMask);
	            this.currentStencilMask = stencilMask;
	        }
	    };
	    StencilBuffer.prototype.setFunc = function (stencilFunc, stencilRef, stencilMask) {
	        var gl = this.state.gl;
	        if (this.currentStencilFunc !== stencilFunc ||
	            this.currentStencilRef !== stencilRef ||
	            this.currentStencilFuncMask !== stencilMask) {
	            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
	            this.currentStencilFunc = stencilFunc;
	            this.currentStencilRef = stencilRef;
	            this.currentStencilFuncMask = stencilMask;
	        }
	    };
	    StencilBuffer.prototype.setOp = function (stencilFail, stencilZFail, stencilZPass) {
	        var gl = this.state.gl;
	        if (this.currentStencilFail !== stencilFail ||
	            this.currentStencilZFail !== stencilZFail ||
	            this.currentStencilZPass !== stencilZPass) {
	            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
	            this.currentStencilFail = stencilFail;
	            this.currentStencilZFail = stencilZFail;
	            this.currentStencilZPass = stencilZPass;
	        }
	    };
	    StencilBuffer.prototype.setLocked = function (lock) {
	        this.locked = lock;
	    };
	    StencilBuffer.prototype.setClear = function (stencil) {
	        var gl = this.state.gl;
	        if (this.currentStencilClear !== stencil) {
	            gl.clearStencil(stencil);
	            this.currentStencilClear = stencil;
	        }
	    };
	    StencilBuffer.prototype.reset = function () {
	        this.locked = false;
	        this.currentStencilMask = null;
	        this.currentStencilFunc = null;
	        this.currentStencilRef = null;
	        this.currentStencilFuncMask = null;
	        this.currentStencilFail = null;
	        this.currentStencilZFail = null;
	        this.currentStencilZPass = null;
	        this.currentStencilClear = null;
	    };
	    return StencilBuffer;
	}());
	var WebGLState = /** @class */ (function () {
	    function WebGLState(gl, extensions, paramThreeToGL) {
	        this.capabilities = {};
	        this.compressedTextureFormats = null;
	        this.currentBlending = null;
	        this.currentBlendEquation = null;
	        this.currentBlendSrc = null;
	        this.currentBlendDst = null;
	        this.currentBlendEquationAlpha = null;
	        this.currentBlendSrcAlpha = null;
	        this.currentBlendDstAlpha = null;
	        this.currentPremultipledAlpha = false;
	        this.currentFlipSided = null;
	        this.currentCullFace = null;
	        this.currentLineWidth = null;
	        this.currentPolygonOffsetFactor = null;
	        this.currentPolygonOffsetUnits = null;
	        this.currentScissorTest = null;
	        this.currentTextureSlot = null;
	        this.currentBoundTextures = {};
	        this.currentScissor = new Vector4();
	        this.currentViewport = new Vector4();
	        this.emptyTextures = {};
	        this.gl = gl;
	        this.extensions = extensions;
	        this.paramThreeToGL = paramThreeToGL;
	        this.colorBuffer = new ColorBuffer(this);
	        this.depthBuffer = new DepthBuffer(this);
	        this.stencilBuffer = new StencilBuffer(this);
	        this.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	        this.newAttributes = new Uint8Array(this.maxVertexAttributes);
	        this.enabledAttributes = new Uint8Array(this.maxVertexAttributes);
	        this.attributeDivisors = new Uint8Array(this.maxVertexAttributes);
	        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	        this.emptyTextures[gl.TEXTURE_2D] = this.createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
	        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = this.createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
	        this.buffers = {
	            color: this.colorBuffer,
	            depth: this.depthBuffer,
	            stencil: this.stencilBuffer
	        };
	    }
	    WebGLState.prototype.createTexture = function (type, target, count) {
	        var gl = this.gl;
	        var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
	        var texture = gl.createTexture();
	        gl.bindTexture(type, texture);
	        gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	        gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        for (var i = 0; i < count; i++) {
	            gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	        }
	        return texture;
	    };
	    //
	    WebGLState.prototype.init = function () {
	        var gl = this.gl;
	        this.clearColor(0, 0, 0, 1);
	        this.clearDepth(1);
	        this.clearStencil(0);
	        this.enable(gl.DEPTH_TEST);
	        this.setDepthFunc(exports.DepthFunction.LessEqual);
	        this.setFlipSided(false);
	        this.setCullFace(exports.CullFace.Back);
	        this.enable(gl.CULL_FACE);
	        this.enable(gl.BLEND);
	        this.setBlending(exports.BlendingMode.Normal);
	    };
	    WebGLState.prototype.initAttributes = function () {
	        for (var i = 0, l = this.newAttributes.length; i < l; i++) {
	            this.newAttributes[i] = 0;
	        }
	    };
	    WebGLState.prototype.enableAttribute = function (attribute) {
	        var gl = this.gl;
	        this.newAttributes[attribute] = 1;
	        if (this.enabledAttributes[attribute] === 0) {
	            gl.enableVertexAttribArray(attribute);
	            this.enabledAttributes[attribute] = 1;
	        }
	        if (this.attributeDivisors[attribute] !== 0) {
	            var extension = this.extensions.get('ANGLE_instanced_arrays');
	            extension.vertexAttribDivisorANGLE(attribute, 0);
	            this.attributeDivisors[attribute] = 0;
	        }
	    };
	    WebGLState.prototype.enableAttributeAndDivisor = function (attribute, meshPerAttribute, extension) {
	        var gl = this.gl;
	        this.newAttributes[attribute] = 1;
	        if (this.enabledAttributes[attribute] === 0) {
	            gl.enableVertexAttribArray(attribute);
	            this.enabledAttributes[attribute] = 1;
	        }
	        if (this.attributeDivisors[attribute] !== meshPerAttribute) {
	            extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
	            this.attributeDivisors[attribute] = meshPerAttribute;
	        }
	    };
	    WebGLState.prototype.disableUnusedAttributes = function () {
	        var gl = this.gl;
	        for (var i = 0, l = this.enabledAttributes.length; i !== l; ++i) {
	            if (this.enabledAttributes[i] !== this.newAttributes[i]) {
	                gl.disableVertexAttribArray(i);
	                this.enabledAttributes[i] = 0;
	            }
	        }
	    };
	    WebGLState.prototype.enable = function (id) {
	        var gl = this.gl;
	        if (this.capabilities[id] !== true) {
	            gl.enable(id);
	            this.capabilities[id] = true;
	        }
	    };
	    WebGLState.prototype.disable = function (id) {
	        var gl = this.gl;
	        if (this.capabilities[id] !== false) {
	            gl.disable(id);
	            this.capabilities[id] = false;
	        }
	    };
	    WebGLState.prototype.getCompressedTextureFormats = function () {
	        var gl = this.gl;
	        if (this.compressedTextureFormats === null) {
	            this.compressedTextureFormats = [];
	            if (this.extensions.get('WEBGL_compressed_texture_pvrtc') ||
	                this.extensions.get('WEBGL_compressed_texture_s3tc') ||
	                this.extensions.get('WEBGL_compressed_texture_etc1')) {
	                var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
	                for (var i = 0; i < formats.length; i++) {
	                    this.compressedTextureFormats.push(formats[i]);
	                }
	            }
	        }
	        return this.compressedTextureFormats;
	    };
	    WebGLState.prototype.setBlending = function (blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
	        var gl = this.gl;
	        if (blending !== exports.BlendingMode.None) {
	            this.enable(gl.BLEND);
	        }
	        else {
	            this.disable(gl.BLEND);
	        }
	        if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
	            if (blending === exports.BlendingMode.Additive) {
	                if (premultipliedAlpha) {
	                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	                    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
	                }
	                else {
	                    gl.blendEquation(gl.FUNC_ADD);
	                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
	                }
	            }
	            else if (blending === exports.BlendingMode.Subtractive) {
	                if (premultipliedAlpha) {
	                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	                    gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
	                }
	                else {
	                    gl.blendEquation(gl.FUNC_ADD);
	                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
	                }
	            }
	            else if (blending === exports.BlendingMode.Multiply) {
	                if (premultipliedAlpha) {
	                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	                    gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
	                }
	                else {
	                    gl.blendEquation(gl.FUNC_ADD);
	                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
	                }
	            }
	            else {
	                if (premultipliedAlpha) {
	                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	                    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	                }
	                else {
	                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
	                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	                }
	            }
	            this.currentBlending = blending;
	            this.currentPremultipledAlpha = premultipliedAlpha;
	        }
	        if (blending === exports.BlendingMode.Custom) {
	            blendEquationAlpha = blendEquationAlpha || blendEquation;
	            blendSrcAlpha = blendSrcAlpha || blendSrc;
	            blendDstAlpha = blendDstAlpha || blendDst;
	            if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
	                gl.blendEquationSeparate(this.paramThreeToGL(blendEquation), this.paramThreeToGL(blendEquationAlpha));
	                this.currentBlendEquation = blendEquation;
	                this.currentBlendEquationAlpha = blendEquationAlpha;
	            }
	            if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {
	                gl.blendFuncSeparate(this.paramThreeToGL(blendSrc), this.paramThreeToGL(blendDst), this.paramThreeToGL(blendSrcAlpha), this.paramThreeToGL(blendDstAlpha));
	                this.currentBlendSrc = blendSrc;
	                this.currentBlendDst = blendDst;
	                this.currentBlendSrcAlpha = blendSrcAlpha;
	                this.currentBlendDstAlpha = blendDstAlpha;
	            }
	        }
	        else {
	            this.currentBlendEquation = null;
	            this.currentBlendSrc = null;
	            this.currentBlendDst = null;
	            this.currentBlendEquationAlpha = null;
	            this.currentBlendSrcAlpha = null;
	            this.currentBlendDstAlpha = null;
	        }
	    };
	    // TODO Deprecate
	    WebGLState.prototype.setColorWrite = function (colorWrite) {
	        this.colorBuffer.setMask(colorWrite);
	    };
	    WebGLState.prototype.setDepthTest = function (depthTest) {
	        this.depthBuffer.setTest(depthTest);
	    };
	    WebGLState.prototype.setDepthWrite = function (depthWrite) {
	        this.depthBuffer.setMask(depthWrite);
	    };
	    WebGLState.prototype.setDepthFunc = function (depthFunc) {
	        this.depthBuffer.setFunc(depthFunc);
	    };
	    WebGLState.prototype.setStencilTest = function (stencilTest) {
	        this.stencilBuffer.setTest(stencilTest);
	    };
	    WebGLState.prototype.setStencilWrite = function (stencilWrite) {
	        this.stencilBuffer.setMask(stencilWrite);
	    };
	    WebGLState.prototype.setStencilFunc = function (stencilFunc, stencilRef, stencilMask) {
	        this.stencilBuffer.setFunc(stencilFunc, stencilRef, stencilMask);
	    };
	    WebGLState.prototype.setStencilOp = function (stencilFail, stencilZFail, stencilZPass) {
	        this.stencilBuffer.setOp(stencilFail, stencilZFail, stencilZPass);
	    };
	    //
	    WebGLState.prototype.setFlipSided = function (flipSided) {
	        var gl = this.gl;
	        if (this.currentFlipSided !== flipSided) {
	            if (flipSided) {
	                gl.frontFace(gl.CW);
	            }
	            else {
	                gl.frontFace(gl.CCW);
	            }
	            this.currentFlipSided = flipSided;
	        }
	    };
	    WebGLState.prototype.setCullFace = function (cullFace) {
	        var gl = this.gl;
	        if (cullFace !== exports.CullFace.None) {
	            gl.enable(gl.CULL_FACE);
	            if (cullFace !== this.currentCullFace) {
	                if (cullFace === exports.CullFace.Back) {
	                    gl.cullFace(gl.BACK);
	                }
	                else if (cullFace === exports.CullFace.Front) {
	                    gl.cullFace(gl.FRONT);
	                }
	                else {
	                    gl.cullFace(gl.FRONT_AND_BACK);
	                }
	            }
	        }
	        else {
	            this.disable(gl.CULL_FACE);
	        }
	        this.currentCullFace = cullFace;
	    };
	    WebGLState.prototype.setLineWidth = function (width) {
	        var gl = this.gl;
	        if (width !== this.currentLineWidth) {
	            gl.lineWidth(width);
	            this.currentLineWidth = width;
	        }
	    };
	    WebGLState.prototype.setPolygonOffset = function (polygonOffset, factor, units) {
	        var gl = this.gl;
	        if (polygonOffset) {
	            this.enable(gl.POLYGON_OFFSET_FILL);
	            if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
	                gl.polygonOffset(factor, units);
	                this.currentPolygonOffsetFactor = factor;
	                this.currentPolygonOffsetUnits = units;
	            }
	        }
	        else {
	            this.disable(gl.POLYGON_OFFSET_FILL);
	        }
	    };
	    WebGLState.prototype.getScissorTest = function () {
	        return this.currentScissorTest;
	    };
	    WebGLState.prototype.setScissorTest = function (scissorTest) {
	        var gl = this.gl;
	        this.currentScissorTest = scissorTest;
	        if (scissorTest) {
	            this.enable(gl.SCISSOR_TEST);
	        }
	        else {
	            this.disable(gl.SCISSOR_TEST);
	        }
	    };
	    // texture
	    WebGLState.prototype.activeTexture = function (webglSlot) {
	        var gl = this.gl;
	        if (webglSlot === undefined)
	            webglSlot = gl.TEXTURE0 + this.maxTextures - 1;
	        if (this.currentTextureSlot !== webglSlot) {
	            gl.activeTexture(webglSlot);
	            this.currentTextureSlot = webglSlot;
	        }
	    };
	    WebGLState.prototype.bindTexture = function (webglType, webglTexture) {
	        var gl = this.gl;
	        if (this.currentTextureSlot === null) {
	            this.activeTexture();
	        }
	        var boundTexture = this.currentBoundTextures[this.currentTextureSlot];
	        if (boundTexture === undefined) {
	            boundTexture = { type: undefined, texture: undefined };
	            this.currentBoundTextures[this.currentTextureSlot] = boundTexture;
	        }
	        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
	            gl.bindTexture(webglType, webglTexture || this.emptyTextures[webglType]);
	            boundTexture.type = webglType;
	            boundTexture.texture = webglTexture;
	        }
	    };
	    WebGLState.prototype.compressedTexImage2D = function () {
	        var gl = this.gl;
	        try {
	            gl.compressedTexImage2D.apply(gl, arguments);
	        }
	        catch (error) {
	            console.error(error);
	        }
	    };
	    WebGLState.prototype.texImage2D = function () {
	        var gl = this.gl;
	        try {
	            gl.texImage2D.apply(gl, arguments);
	        }
	        catch (error) {
	            console.error(error);
	        }
	    };
	    // TODO Deprecate
	    WebGLState.prototype.clearColor = function (r, g, b, a) {
	        this.colorBuffer.setClear(r, g, b, a);
	    };
	    WebGLState.prototype.clearDepth = function (depth) {
	        this.depthBuffer.setClear(depth);
	    };
	    WebGLState.prototype.clearStencil = function (stencil) {
	        this.stencilBuffer.setClear(stencil);
	    };
	    //
	    WebGLState.prototype.scissor = function (scissor) {
	        var gl = this.gl;
	        if (this.currentScissor.equals(scissor) === false) {
	            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
	            this.currentScissor.copy(scissor);
	        }
	    };
	    WebGLState.prototype.viewport = function (viewport) {
	        var gl = this.gl;
	        if (this.currentViewport.equals(viewport) === false) {
	            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
	            this.currentViewport.copy(viewport);
	        }
	    };
	    //
	    WebGLState.prototype.reset = function () {
	        var gl = this.gl;
	        for (var i = 0; i < this.enabledAttributes.length; i++) {
	            if (this.enabledAttributes[i] === 1) {
	                gl.disableVertexAttribArray(i);
	                this.enabledAttributes[i] = 0;
	            }
	        }
	        this.capabilities = {};
	        this.compressedTextureFormats = null;
	        this.currentTextureSlot = null;
	        this.currentBoundTextures = {};
	        this.currentBlending = null;
	        this.currentFlipSided = null;
	        this.currentCullFace = null;
	        this.colorBuffer.reset();
	        this.depthBuffer.reset();
	        this.stencilBuffer.reset();
	    };
	    return WebGLState;
	}());

	var WebGLCapabilities = /** @class */ (function () {
	    function WebGLCapabilities(gl, extensions, parameters) {
	        this.gl = gl;
	        this.extensions = extensions;
	        this.parameters = parameters;
	        this.precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	        this.maxPrecision = this.getMaxPrecision(this.precision);
	        if (this.maxPrecision !== this.precision) {
	            console.warn('THREE.WebGLRenderer:', this.precision, 'not supported, using', this.maxPrecision, 'instead.');
	            this.precision = this.maxPrecision;
	        }
	        this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !!extensions.get('EXT_frag_depth');
	        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	        this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
	        this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	        this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
	        this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	        this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
	        this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
	        this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
	        this.vertexTextures = this.maxVertexTextures > 0;
	        this.floatFragmentTextures = !!extensions.get('OES_texture_float');
	        this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
	    }
	    WebGLCapabilities.prototype.getMaxAnisotropy = function () {
	        var gl = this.gl;
	        if (this.maxAnisotropy !== undefined)
	            return this.maxAnisotropy;
	        var extension = this.extensions.get('EXT_texture_filter_anisotropic');
	        if (extension !== null) {
	            this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
	        }
	        else {
	            this.maxAnisotropy = 0;
	        }
	        return this.maxAnisotropy;
	    };
	    WebGLCapabilities.prototype.getMaxPrecision = function (precision) {
	        var gl = this.gl;
	        if (precision === 'highp') {
	            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
	                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
	                return 'highp';
	            }
	            precision = 'mediump';
	        }
	        if (precision === 'mediump') {
	            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
	                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
	                return 'mediump';
	            }
	        }
	        return 'lowp';
	    };
	    return WebGLCapabilities;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var WebGLExtensions = /** @class */ (function () {
	    function WebGLExtensions(gl) {
	        this.extensions = {};
	        this.gl = gl;
	    }
	    WebGLExtensions.prototype.get = function (name) {
	        var gl = this.gl;
	        var extensions = this.extensions;
	        if (extensions[name] !== undefined) {
	            return extensions[name];
	        }
	        var extension;
	        switch (name) {
	            case 'WEBGL_depth_texture':
	                extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
	                break;
	            case 'EXT_texture_filter_anisotropic':
	                extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
	                break;
	            case 'WEBGL_compressed_texture_s3tc':
	                extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
	                break;
	            case 'WEBGL_compressed_texture_pvrtc':
	                extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
	                break;
	            case 'WEBGL_compressed_texture_etc1':
	                extension = gl.getExtension('WEBGL_compressed_texture_etc1');
	                break;
	            default:
	                extension = gl.getExtension(name);
	        }
	        if (extension === null) {
	            console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
	        }
	        extensions[name] = extension;
	        return extension;
	    };
	    return WebGLExtensions;
	}());

	/**
	 * @author tschw
	 */
	var WebGLClipping = /** @class */ (function () {
	    function WebGLClipping() {
	        this.globalState = null;
	        this.numGlobalPlanes = 0;
	        this.localClippingEnabled = false;
	        this.renderingShadows = false;
	        this.plane = new Plane();
	        this.viewNormalMatrix = new Matrix3();
	        this.uniform = { value: null, needsUpdate: false };
	        this.numPlanes = 0;
	        this.numIntersection = 0;
	    }
	    WebGLClipping.prototype.init = function (planes, enableLocalClipping, camera) {
	        var enabled = planes.length !== 0 ||
	            enableLocalClipping ||
	            // enable state of previous frame - the clipping code has to
	            // run another frame in order to reset the state:
	            this.numGlobalPlanes !== 0 ||
	            this.localClippingEnabled;
	        this.localClippingEnabled = enableLocalClipping;
	        this.globalState = this.projectPlanes(planes, camera, 0);
	        this.numGlobalPlanes = planes.length;
	        return enabled;
	    };
	    WebGLClipping.prototype.beginShadows = function () {
	        this.renderingShadows = true;
	        this.projectPlanes(null);
	    };
	    WebGLClipping.prototype.endShadows = function () {
	        this.renderingShadows = false;
	        this.resetGlobalState();
	    };
	    WebGLClipping.prototype.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
	        if (!this.localClippingEnabled ||
	            planes === null || planes.length === 0 ||
	            this.renderingShadows && !clipShadows) {
	            // there's no local clipping
	            if (this.renderingShadows) {
	                // there's no global clipping
	                this.projectPlanes(null);
	            }
	            else {
	                this.resetGlobalState();
	            }
	        }
	        else {
	            var nGlobal = this.renderingShadows ? 0 : this.numGlobalPlanes;
	            var lGlobal = nGlobal * 4;
	            var dstArray = cache.clippingState || null;
	            this.uniform.value = dstArray; // ensure unique state
	            dstArray = this.projectPlanes(planes, camera, lGlobal, fromCache);
	            for (var i = 0; i !== lGlobal; ++i) {
	                dstArray[i] = this.globalState[i];
	            }
	            cache.clippingState = dstArray;
	            this.numIntersection = clipIntersection ? this.numPlanes : 0;
	            this.numPlanes += nGlobal;
	        }
	    };
	    WebGLClipping.prototype.resetGlobalState = function () {
	        if (this.uniform.value !== this.globalState) {
	            this.uniform.value = this.globalState;
	            this.uniform.needsUpdate = this.numGlobalPlanes > 0;
	        }
	        this.numPlanes = this.numGlobalPlanes;
	        this.numIntersection = 0;
	    };
	    WebGLClipping.prototype.projectPlanes = function (planes, camera, dstOffset, skipTransform) {
	        var nPlanes = planes !== null ? planes.length : 0;
	        var dstArray = null;
	        if (nPlanes !== 0) {
	            dstArray = this.uniform.value;
	            if (skipTransform !== true || dstArray === null) {
	                var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
	                this.viewNormalMatrix.getNormalMatrix(viewMatrix);
	                if (dstArray === null || dstArray.length < flatSize) {
	                    dstArray = new Float32Array(flatSize);
	                }
	                for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
	                    this.plane.copy(planes[i]).
	                        applyMatrix4(viewMatrix, this.viewNormalMatrix);
	                    this.plane.normal.toArray(dstArray, i4);
	                    dstArray[i4 + 3] = this.plane.constant;
	                }
	            }
	            this.uniform.value = dstArray;
	            this.uniform.needsUpdate = true;
	        }
	        this.numPlanes = nPlanes;
	        return dstArray;
	    };
	    return WebGLClipping;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var AmbientLight = /** @class */ (function (_super) {
	    __extends(AmbientLight, _super);
	    function AmbientLight(color, intensity) {
	        var _this = _super.call(this, color, intensity) || this;
	        _this.isAmbientLight = true;
	        _this.type = 'AmbientLight';
	        _this.castShadow = undefined;
	        return _this;
	    }
	    return AmbientLight;
	}(Light));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var DirectionalLightShadow = /** @class */ (function (_super) {
	    __extends(DirectionalLightShadow, _super);
	    function DirectionalLightShadow(light) {
	        return _super.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)) || this;
	    }
	    return DirectionalLightShadow;
	}(LightShadow));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var DirectionalLight = /** @class */ (function (_super) {
	    __extends(DirectionalLight, _super);
	    function DirectionalLight(color, intensity) {
	        var _this = _super.call(this, color, intensity) || this;
	        _this.target = new Object3D();
	        _this.isDirectionalLight = true;
	        _this.type = 'DirectionalLight';
	        _this.position.copy(Object3D.DefaultUp);
	        _this.updateMatrix();
	        _this.shadow = new DirectionalLightShadow();
	        return _this;
	    }
	    DirectionalLight.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.target = source.target.clone();
	        this.shadow = source.shadow.clone();
	        return this;
	    };
	    return DirectionalLight;
	}(Light));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	var HemisphereLight = /** @class */ (function (_super) {
	    __extends(HemisphereLight, _super);
	    function HemisphereLight(skyColor, groundColor, intensity) {
	        var _this = _super.call(this, skyColor, intensity) || this;
	        _this.isHemisphereLight = true;
	        _this.type = 'HemisphereLight';
	        _this.castShadow = undefined;
	        _this.position.copy(Object3D.DefaultUp);
	        _this.updateMatrix();
	        _this.groundColor = new Color(groundColor);
	        return _this;
	    }
	    HemisphereLight.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.groundColor.copy(source.groundColor);
	        return this;
	    };
	    return HemisphereLight;
	}(Light));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	var SpotLight = /** @class */ (function (_super) {
	    __extends(SpotLight, _super);
	    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
	        if (distance === void 0) { distance = 0; }
	        if (angle === void 0) { angle = Math.PI / 3; }
	        if (penumbra === void 0) { penumbra = 0; }
	        if (decay === void 0) { decay = 1; }
	        var _this = _super.call(this, color, intensity) || this;
	        _this.target = new Object3D();
	        _this.isSpotLight = true;
	        _this.type = 'SpotLight';
	        _this.position.copy(Object3D.DefaultUp);
	        _this.updateMatrix();
	        _this.distance = distance;
	        _this.angle = angle;
	        _this.penumbra = penumbra;
	        _this.decay = decay; // for physically correct lights, should be 2.
	        _this.shadow = new SpotLightShadow();
	        return _this;
	    }
	    Object.defineProperty(SpotLight.prototype, "power", {
	        get: function () {
	            // intensity = power per solid angle.
	            // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
	            return this.intensity * Math.PI;
	        },
	        set: function (value) {
	            // intensity = power per solid angle.
	            // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
	            this.intensity = value / Math.PI;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SpotLight.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.distance = source.distance;
	        this.angle = source.angle;
	        this.penumbra = source.penumbra;
	        this.decay = source.decay;
	        this.target = source.target.clone();
	        this.shadow = source.shadow.clone();
	        return this;
	    };
	    return SpotLight;
	}(Light));

	var SpriteMaterial = /** @class */ (function (_super) {
	    __extends(SpriteMaterial, _super);
	    function SpriteMaterial(parameters) {
	        var _this = _super.call(this) || this;
	        _this.isSpriteMaterial = true;
	        _this.type = 'SpriteMaterial';
	        _this.color = new Color(0xffffff);
	        _this.map = null;
	        _this.rotation = 0;
	        _this.fog = false;
	        _this.lights = false;
	        _this.setValues(parameters);
	        return _this;
	    }
	    SpriteMaterial.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.color.copy(source.color);
	        this.map = source.map;
	        this.rotation = source.rotation;
	        return this;
	    };
	    return SpriteMaterial;
	}(Material));

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var Sprite = /** @class */ (function (_super) {
	    __extends(Sprite, _super);
	    function Sprite(material) {
	        if (material === void 0) { material = new SpriteMaterial(); }
	        var _this = _super.call(this) || this;
	        _this.isSprite = true;
	        _this.type = 'Sprite';
	        _this.material = material;
	        return _this;
	    }
	    Sprite.prototype.raycast = function (raycaster, intersects) {
	        var matrixPosition = Sprite.raycast_matrixPosition;
	        //return function raycast(raycaster, intersects) {
	        matrixPosition.setFromMatrixPosition(this.matrixWorld);
	        var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
	        var guessSizeSq = this.scale.x * this.scale.y / 4;
	        if (distanceSq > guessSizeSq) {
	            return intersects;
	        }
	        intersects.push({
	            distance: Math.sqrt(distanceSq),
	            point: this.position,
	            index: 0,
	            face: null,
	            faceIndex: 0,
	            uv: null,
	            object: this
	        });
	        return intersects;
	        //};
	    };
	    Sprite.prototype.clone = function () {
	        return new this.constructor(this.material).copy(this);
	    };
	    Sprite.raycast_matrixPosition = new Vector3();
	    return Sprite;
	}(Object3D));

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var LensFlare = /** @class */ (function (_super) {
	    __extends(LensFlare, _super);
	    function LensFlare(texture, size, distance, blending, color) {
	        var _this = _super.call(this) || this;
	        _this.lensFlares = [];
	        _this.positionScreen = new Vector3();
	        _this.isLensFlare = true;
	        if (texture !== undefined) {
	            _this.addFlare(texture, size, distance, blending, color);
	        }
	        return _this;
	    }
	    LensFlare.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.positionScreen.copy(source.positionScreen);
	        this.customUpdateCallback = source.customUpdateCallback;
	        for (var i = 0, l = source.lensFlares.length; i < l; i++) {
	            this.lensFlares.push(source.lensFlares[i]);
	        }
	        return this;
	    };
	    LensFlare.prototype.add = function (object) {
	        if (object instanceof Texture) {
	            console.warn("LensFlare:add is now LensFlare:addFlare");
	            return this.addFlare.call(this, arguments);
	        }
	        return _super.prototype.add.call(this, object);
	    };
	    LensFlare.prototype.addFlare = function (texture, size, distance, blending, color, opacity) {
	        if (size === void 0) { size = -1; }
	        if (distance === void 0) { distance = 0; }
	        if (blending === void 0) { blending = exports.BlendingMode.Normal; }
	        if (color === void 0) { color = new Color(0xffffff); }
	        if (opacity === void 0) { opacity = 1; }
	        distance = Math.min(distance, Math.max(0, distance));
	        this.lensFlares.push({
	            texture: texture,
	            size: size,
	            distance: distance,
	            x: 0, y: 0, z: 0,
	            scale: 1,
	            rotation: 0,
	            opacity: opacity,
	            color: color,
	            blending: blending // blending
	        });
	    };
	    /*
	     * Update lens flares update positions on all flares based on the screen position
	     * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	     */
	    LensFlare.prototype.updateLensFlares = function () {
	        var f, fl = this.lensFlares.length;
	        var flare;
	        var vecX = -this.positionScreen.x * 2;
	        var vecY = -this.positionScreen.y * 2;
	        for (f = 0; f < fl; f++) {
	            flare = this.lensFlares[f];
	            flare.x = this.positionScreen.x + vecX * flare.distance;
	            flare.y = this.positionScreen.y + vecY * flare.distance;
	            flare.wantedRotation = flare.x * Math.PI * 0.25;
	            flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
	        }
	    };
	    return LensFlare;
	}(Object3D));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	var ImmediateRenderObject = /** @class */ (function (_super) {
	    __extends(ImmediateRenderObject, _super);
	    function ImmediateRenderObject(material) {
	        var _this = _super.call(this) || this;
	        _this.isImmediateRenderObject = true;
	        _this.material = material;
	        return _this;
	    }
	    ImmediateRenderObject.prototype.render = function (renderCallback) {
	    };
	    return ImmediateRenderObject;
	}(Object3D));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var LineSegments = /** @class */ (function (_super) {
	    __extends(LineSegments, _super);
	    function LineSegments(geometry, material) {
	        var _this = _super.call(this, geometry, material) || this;
	        _this.isLineSegments = true;
	        _this.type = 'LineSegments';
	        _this._step = 2; // Line:raycast step
	        return _this;
	    }
	    return LineSegments;
	}(Line));

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	var InstancedBufferGeometry = /** @class */ (function (_super) {
	    __extends(InstancedBufferGeometry, _super);
	    function InstancedBufferGeometry() {
	        var _this = _super.call(this) || this;
	        _this.type = 'InstancedBufferGeometry';
	        _this.maxInstancedCount = undefined;
	        _this.isInstancedBufferGeometry = true;
	        return _this;
	    }
	    InstancedBufferGeometry.prototype.addGroup = function (start, count, materialIndex) {
	        this.groups.push({
	            start: start,
	            count: count,
	            materialIndex: materialIndex
	        });
	    };
	    InstancedBufferGeometry.prototype.copy = function (source) {
	        var index = source.index;
	        if (index !== null) {
	            this.setIndex(index.clone());
	        }
	        var attributes = source.attributes;
	        for (var name in attributes) {
	            var attribute = attributes[name];
	            if (attribute === undefined)
	                continue;
	            this.addAttribute(name, attribute.clone());
	        }
	        var groups = source.groups;
	        for (var i = 0, l = groups.length; i < l; i++) {
	            var group = groups[i];
	            this.addGroup(group.start, group.count, group.materialIndex);
	        }
	        return this;
	    };
	    return InstancedBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	var InstancedBufferAttribute = /** @class */ (function (_super) {
	    __extends(InstancedBufferAttribute, _super);
	    function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
	        if (meshPerAttribute === void 0) { meshPerAttribute = 1; }
	        var _this = _super.call(this, array, itemSize) || this;
	        _this.isInstancedBufferAttribute = true;
	        _this.meshPerAttribute = meshPerAttribute;
	        return _this;
	    }
	    InstancedBufferAttribute.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.meshPerAttribute = source.meshPerAttribute;
	        return this;
	    };
	    return InstancedBufferAttribute;
	}(BufferAttribute));

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	var InterleavedBuffer = /** @class */ (function () {
	    function InterleavedBuffer(array, stride) {
	        this.uuid = _Math.generateUUID();
	        this.isInterleavedBuffer = true;
	        this.array = array;
	        this.stride = stride;
	        this.count = array !== undefined ? array.length / stride : 0;
	        this.dynamic = false;
	        this.updateRange = { offset: 0, count: -1 };
	        this.version = 0;
	    }
	    Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
	        set: function (value) {
	            if (value === true)
	                this.version++;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    InterleavedBuffer.prototype.setArray = function (array) {
	        if (Array.isArray(array)) {
	            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
	        }
	        this.count = array !== undefined ? array.length / this.stride : 0;
	        this.array = array;
	    };
	    InterleavedBuffer.prototype.setDynamic = function (value) {
	        this.dynamic = value;
	        return this;
	    };
	    InterleavedBuffer.prototype.copy = function (source) {
	        this.array = new source.array.constructor(source.array);
	        this.count = source.count;
	        this.stride = source.stride;
	        this.dynamic = source.dynamic;
	        return this;
	    };
	    InterleavedBuffer.prototype.copyAt = function (index1, attribute, index2) {
	        index1 *= this.stride;
	        index2 *= attribute.stride;
	        for (var i = 0, l = this.stride; i < l; i++) {
	            this.array[index1 + i] = attribute.array[index2 + i];
	        }
	        return this;
	    };
	    InterleavedBuffer.prototype.set = function (value, offset) {
	        if (offset === void 0) { offset = 0; }
	        this.array.set(value, offset);
	        return this;
	    };
	    InterleavedBuffer.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    return InterleavedBuffer;
	}());

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	var InstancedInterleavedBuffer = /** @class */ (function (_super) {
	    __extends(InstancedInterleavedBuffer, _super);
	    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
	        if (meshPerAttribute === void 0) { meshPerAttribute = 1; }
	        var _this = _super.call(this, array, stride) || this;
	        _this.isInstancedInterleavedBuffer = true;
	        _this.meshPerAttribute = meshPerAttribute;
	        return _this;
	    }
	    InstancedInterleavedBuffer.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source);
	        this.meshPerAttribute = source.meshPerAttribute;
	        return this;
	    };
	    return InstancedInterleavedBuffer;
	}(InterleavedBuffer));

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */
	var WebGLRenderer = /** @class */ (function () {
	    function WebGLRenderer(parameters) {
	        this.lights = [];
	        this.opaqueObjects = [];
	        this.opaqueObjectsLastIndex = -1;
	        this.transparentObjects = [];
	        this.transparentObjectsLastIndex = -1;
	        this.morphInfluences = new Float32Array(8);
	        this.sprites = [];
	        this.lensFlares = [];
	        this.context = null;
	        // clearing
	        this.autoClear = true;
	        this.autoClearColor = true;
	        this.autoClearDepth = true;
	        this.autoClearStencil = true;
	        // scene graph
	        this.sortObjects = true;
	        // user-defined clipping
	        this.clippingPlanes = [];
	        this.localClippingEnabled = false;
	        // physically based shading
	        this.gammaFactor = 2.0; // for backwards compatibility
	        this.gammaInput = false;
	        this.gammaOutput = false;
	        // physical lights
	        this.physicallyCorrectLights = false;
	        // tone mapping
	        this.toneMapping = exports.ToneMapping.Linear;
	        this.toneMappingExposure = 1.0;
	        this.toneMappingWhitePoint = 1.0;
	        // morphs
	        this.maxMorphTargets = 8;
	        this.maxMorphNormals = 4;
	        // internal state cache
	        this._currentProgram = null;
	        this._currentRenderTarget = null;
	        this._currentFramebuffer = null;
	        this._currentMaterialId = -1;
	        this._currentGeometryProgram = '';
	        this._currentCamera = null;
	        this._currentScissor = new Vector4();
	        this._currentScissorTest = null;
	        this._currentViewport = new Vector4();
	        //
	        this._usedTextureUnits = 0;
	        //
	        this._clearColor = new Color(0x000000);
	        this._clearAlpha = 0;
	        this._pixelRatio = 1;
	        this._scissorTest = false;
	        // frustum
	        this._frustum = new Frustum();
	        // clipping
	        this._clipping = new WebGLClipping();
	        this._clippingEnabled = false;
	        this._localClippingEnabled = false;
	        this._sphere = new Sphere();
	        // camera matrices cache
	        this._projScreenMatrix = new Matrix4();
	        this._vector3 = new Vector3();
	        // light arrays cache
	        this._lights = {
	            hash: '',
	            ambient: [0, 0, 0],
	            directional: [],
	            directionalShadowMap: [],
	            directionalShadowMatrix: [],
	            spot: [],
	            spotShadowMap: [],
	            spotShadowMatrix: [],
	            point: [],
	            pointShadowMap: [],
	            pointShadowMatrix: [],
	            hemi: [],
	            shadows: []
	        };
	        // info
	        this.info = {
	            render: {
	                calls: 0,
	                vertices: 0,
	                faces: 0,
	                points: 0
	            },
	            memory: {
	                geometries: 0,
	                textures: 0
	            },
	            programs: null
	        };
	        this._infoRender = this.info.render;
	        console.log('THREE.WebGLRenderer', REVISION);
	        parameters = parameters || {};
	        this._canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
	        this._context = parameters.context !== undefined ? parameters.context : null;
	        this._alpha = parameters.alpha !== undefined ? parameters.alpha : false, this._depth = parameters.depth !== undefined ? parameters.depth : true, this._stencil = parameters.stencil !== undefined ? parameters.stencil : true, this._antialias = parameters.antialias !== undefined ? parameters.antialias : false, this._premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, this._preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
	        this.domElement = this._canvas;
	        this._width = this._canvas.width;
	        this._height = this._canvas.height;
	        this._scissor = new Vector4(0, 0, this._width, this._height);
	        this._viewport = new Vector4(0, 0, this._width, this._height);
	        // initialize
	        ///let _gl;
	        try {
	            var attributes = {
	                alpha: this._alpha,
	                depth: this._depth,
	                stencil: this._stencil,
	                antialias: this._antialias,
	                premultipliedAlpha: this._premultipliedAlpha,
	                preserveDrawingBuffer: this._preserveDrawingBuffer
	            };
	            this._gl = (this._context || this._canvas.getContext('webgl', attributes) || this._canvas.getContext('experimental-webgl', attributes));
	            if (this._gl === null) {
	                if (this._canvas.getContext('webgl') !== null) {
	                    throw 'Error creating WebGL context with your selected attributes.';
	                }
	                else {
	                    throw 'Error creating WebGL context.';
	                }
	            }
	            // Some experimental-webgl implementations do not have getShaderPrecisionFormat
	            if (this._gl.getShaderPrecisionFormat === undefined) {
	                this._gl.getShaderPrecisionFormat = function () {
	                    return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
	                };
	            }
	            this._canvas.addEventListener('webglcontextlost', this.onContextLost.bind(this), false);
	        }
	        catch (error) {
	            console.error('THREE.WebGLRenderer: ' + error);
	        }
	        this.extensions = new WebGLExtensions(this._gl);
	        this.extensions.get('WEBGL_depth_texture');
	        this.extensions.get('OES_texture_float');
	        this.extensions.get('OES_texture_float_linear');
	        this.extensions.get('OES_texture_half_float');
	        this.extensions.get('OES_texture_half_float_linear');
	        this.extensions.get('OES_standard_derivatives');
	        this.extensions.get('ANGLE_instanced_arrays');
	        if (this.extensions.get('OES_element_index_uint')) {
	            BufferGeometry.MaxIndex = 4294967296;
	        }
	        this.capabilities = new WebGLCapabilities(this._gl, this.extensions, parameters);
	        this.state = new WebGLState(this._gl, this.extensions, this.paramThreeToGL.bind(this));
	        this.properties = new WebGLProperties();
	        this.textures = new WebGLTextures(this._gl, this.extensions, this.state, this.properties, this.capabilities, this.paramThreeToGL.bind(this), this.info);
	        this.objects = new WebGLObjects(this._gl, this.properties, this.info);
	        this.programCache = new WebGLPrograms(this, this.capabilities);
	        this.lightCache = new WebGLLights();
	        this.info.programs = this.programCache.programs;
	        this.bufferRenderer = new WebGLBufferRenderer(this._gl, this.extensions, this._infoRender);
	        this.indexedBufferRenderer = new WebGLIndexedBufferRenderer(this._gl, this.extensions, this._infoRender);
	        //
	        this.backgroundCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
	        this.backgroundCamera2 = new PerspectiveCamera();
	        this.backgroundPlaneMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({ depthTest: false, depthWrite: false, fog: false }));
	        this.backgroundBoxShader = ShaderLib['cube'];
	        this.backgroundBoxMesh = new Mesh(new BoxBufferGeometry(5, 5, 5), new ShaderMaterial({
	            uniforms: this.backgroundBoxShader.uniforms,
	            vertexShader: this.backgroundBoxShader.vertexShader,
	            fragmentShader: this.backgroundBoxShader.fragmentShader,
	            side: exports.SideMode.Back,
	            depthTest: false,
	            depthWrite: false,
	            fog: false
	        }));
	        this.setDefaultGLState();
	        this.context = this._gl;
	        // shadow map
	        this.shadowMap = new WebGLShadowMap(this, this._lights, this.objects, this.capabilities);
	        // Plugins
	        this.spritePlugin = new SpritePlugin(this, this.sprites);
	        this.lensFlarePlugin = new LensFlarePlugin(this, this.lensFlares);
	    }
	    WebGLRenderer.prototype.getTargetPixelRatio = function () {
	        return this._currentRenderTarget === null ? this._pixelRatio : 1;
	    };
	    WebGLRenderer.prototype.glClearColor = function (r, g, b, a) {
	        if (this._premultipliedAlpha === true) {
	            r *= a;
	            g *= a;
	            b *= a;
	        }
	        this.state.clearColor(r, g, b, a);
	    };
	    WebGLRenderer.prototype.setDefaultGLState = function () {
	        this.state.init();
	        this.state.scissor(this._currentScissor.copy(this._scissor).multiplyScalar(this._pixelRatio));
	        this.state.viewport(this._currentViewport.copy(this._viewport).multiplyScalar(this._pixelRatio));
	        this.glClearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
	    };
	    WebGLRenderer.prototype.resetGLState = function () {
	        this._currentProgram = null;
	        this._currentCamera = null;
	        this._currentGeometryProgram = '';
	        this._currentMaterialId = -1;
	        this.state.reset();
	    };
	    // API
	    WebGLRenderer.prototype.getContext = function () {
	        return this._gl;
	    };
	    WebGLRenderer.prototype.getContextAttributes = function () {
	        return this._gl.getContextAttributes();
	    };
	    WebGLRenderer.prototype.forceContextLoss = function () {
	        this.extensions.get('WEBGL_lose_context').loseContext();
	    };
	    WebGLRenderer.prototype.getMaxAnisotropy = function () {
	        return this.capabilities.getMaxAnisotropy();
	    };
	    WebGLRenderer.prototype.getPrecision = function () {
	        return this.capabilities.precision;
	    };
	    WebGLRenderer.prototype.getPixelRatio = function () {
	        return this._pixelRatio;
	    };
	    WebGLRenderer.prototype.setPixelRatio = function (value) {
	        if (value === undefined)
	            return;
	        this._pixelRatio = value;
	        this.setSize(this._viewport.z, this._viewport.w, false);
	    };
	    WebGLRenderer.prototype.getSize = function () {
	        return {
	            width: this._width,
	            height: this._height
	        };
	    };
	    WebGLRenderer.prototype.setSize = function (width, height, updateStyle) {
	        this._width = width;
	        this._height = height;
	        this._canvas.width = width * this._pixelRatio;
	        this._canvas.height = height * this._pixelRatio;
	        if (updateStyle !== false) {
	            this._canvas.style.width = width + 'px';
	            this._canvas.style.height = height + 'px';
	        }
	        this.setViewport(0, 0, width, height);
	    };
	    WebGLRenderer.prototype.setViewport = function (x, y, width, height) {
	        this.state.viewport(this._viewport.set(x, y, width, height));
	    };
	    WebGLRenderer.prototype.setScissor = function (x, y, width, height) {
	        this.state.scissor(this._scissor.set(x, y, width, height));
	    };
	    WebGLRenderer.prototype.setScissorTest = function (test) {
	        this.state.setScissorTest(this._scissorTest = test);
	    };
	    // Clearing
	    WebGLRenderer.prototype.getClearColor = function () {
	        return this._clearColor;
	    };
	    WebGLRenderer.prototype.setClearColor = function (color, alpha) {
	        if (alpha === void 0) { alpha = 1; }
	        this._clearColor.set(color);
	        this._clearAlpha = alpha;
	        this.glClearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
	    };
	    WebGLRenderer.prototype.getClearAlpha = function () {
	        return this._clearAlpha;
	    };
	    WebGLRenderer.prototype.setClearAlpha = function (alpha) {
	        this._clearAlpha = alpha;
	        this.glClearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
	    };
	    WebGLRenderer.prototype.clear = function (color, depth, stencil) {
	        var bits = 0;
	        if (color === undefined || color)
	            bits |= this._gl.COLOR_BUFFER_BIT;
	        if (depth === undefined || depth)
	            bits |= this._gl.DEPTH_BUFFER_BIT;
	        if (stencil === undefined || stencil)
	            bits |= this._gl.STENCIL_BUFFER_BIT;
	        this._gl.clear(bits);
	    };
	    WebGLRenderer.prototype.clearColor = function () {
	        this.clear(true, false, false);
	    };
	    WebGLRenderer.prototype.clearDepth = function () {
	        this.clear(false, true, false);
	    };
	    WebGLRenderer.prototype.clearStencil = function () {
	        this.clear(false, false, true);
	    };
	    WebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {
	        this.setRenderTarget(renderTarget);
	        this.clear(color, depth, stencil);
	    };
	    // Reset
	    ///this.resetGLState = resetGLState;
	    WebGLRenderer.prototype.dispose = function () {
	        this.transparentObjects = [];
	        this.transparentObjectsLastIndex = -1;
	        this.opaqueObjects = [];
	        this.opaqueObjectsLastIndex = -1;
	        this._canvas.removeEventListener('webglcontextlost', this.onContextLost.bind(this), false);
	    };
	    // Events
	    WebGLRenderer.prototype.onContextLost = function (event) {
	        event.preventDefault();
	        this.resetGLState();
	        this.setDefaultGLState();
	        this.properties.clear();
	    };
	    WebGLRenderer.prototype.onMaterialDispose = function (event) {
	        var material = event.target;
	        material.removeEventListener('dispose', this.onMaterialDispose.bind(this));
	        this.deallocateMaterial(material);
	    };
	    // Buffer deallocation
	    WebGLRenderer.prototype.deallocateMaterial = function (material) {
	        this.releaseMaterialProgramReference(material);
	        this.properties.delete(material);
	    };
	    WebGLRenderer.prototype.releaseMaterialProgramReference = function (material) {
	        var programInfo = this.properties.get(material).program;
	        material.program = undefined;
	        if (programInfo !== undefined) {
	            this.programCache.releaseProgram(programInfo);
	        }
	    };
	    // Buffer rendering
	    WebGLRenderer.prototype.renderBufferImmediate = function (object, program, material) {
	        this.state.initAttributes();
	        var buffers = this.properties.get(object);
	        if (object.hasPositions && !buffers.position)
	            buffers.position = this._gl.createBuffer();
	        if (object.hasNormals && !buffers.normal)
	            buffers.normal = this._gl.createBuffer();
	        if (object.hasUvs && !buffers.uv)
	            buffers.uv = this._gl.createBuffer();
	        if (object.hasColors && !buffers.color)
	            buffers.color = this._gl.createBuffer();
	        var attributes = program.getAttributes();
	        if (object.hasPositions) {
	            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.position);
	            this._gl.bufferData(this._gl.ARRAY_BUFFER, object.positionArray, this._gl.DYNAMIC_DRAW);
	            this.state.enableAttribute(attributes.position);
	            this._gl.vertexAttribPointer(attributes.position, 3, this._gl.FLOAT, false, 0, 0);
	        }
	        if (object.hasNormals) {
	            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.normal);
	            if (!(material instanceof MeshPhongMaterial) && !(material instanceof MeshStandardMaterial) && material.shading === exports.ShadingMode.Flat) {
	                for (var i = 0, l = object.count * 3; i < l; i += 9) {
	                    var array = object.normalArray;
	                    var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
	                    var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
	                    var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
	                    array[i + 0] = nx;
	                    array[i + 1] = ny;
	                    array[i + 2] = nz;
	                    array[i + 3] = nx;
	                    array[i + 4] = ny;
	                    array[i + 5] = nz;
	                    array[i + 6] = nx;
	                    array[i + 7] = ny;
	                    array[i + 8] = nz;
	                }
	            }
	            this._gl.bufferData(this._gl.ARRAY_BUFFER, object.normalArray, this._gl.DYNAMIC_DRAW);
	            this.state.enableAttribute(attributes.normal);
	            this._gl.vertexAttribPointer(attributes.normal, 3, this._gl.FLOAT, false, 0, 0);
	        }
	        if (object.hasUvs && material.map) {
	            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.uv);
	            this._gl.bufferData(this._gl.ARRAY_BUFFER, object.uvArray, this._gl.DYNAMIC_DRAW);
	            this.state.enableAttribute(attributes.uv);
	            this._gl.vertexAttribPointer(attributes.uv, 2, this._gl.FLOAT, false, 0, 0);
	        }
	        if (object.hasColors && material.vertexColors !== exports.ColorsMode.None) {
	            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.color);
	            this._gl.bufferData(this._gl.ARRAY_BUFFER, object.colorArray, this._gl.DYNAMIC_DRAW);
	            this.state.enableAttribute(attributes.color);
	            this._gl.vertexAttribPointer(attributes.color, 3, this._gl.FLOAT, false, 0, 0);
	        }
	        this.state.disableUnusedAttributes();
	        this._gl.drawArrays(this._gl.TRIANGLES, 0, object.count);
	        object.count = 0;
	    };
	    WebGLRenderer.prototype.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
	        var _gl = this._gl;
	        this.setMaterial(material);
	        var program = this.setProgram(camera, fog, material, object);
	        var updateBuffers = false;
	        var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
	        if (geometryProgram !== this._currentGeometryProgram) {
	            this._currentGeometryProgram = geometryProgram;
	            updateBuffers = true;
	        }
	        // morph targets
	        var morphTargetInfluences = object.morphTargetInfluences;
	        if (morphTargetInfluences !== undefined) {
	            var activeInfluences = [];
	            for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {
	                var influence = morphTargetInfluences[i];
	                activeInfluences.push([influence, i]);
	            }
	            activeInfluences.sort(WebGLRenderer.absNumericalSort);
	            if (activeInfluences.length > 8) {
	                activeInfluences.length = 8;
	            }
	            var morphAttributes = geometry.morphAttributes;
	            for (var i = 0, l = activeInfluences.length; i < l; i++) {
	                var influence = activeInfluences[i];
	                this.morphInfluences[i] = influence[0];
	                if (influence[0] !== 0) {
	                    var index_1 = influence[1];
	                    if (material.morphTargets === true && morphAttributes.position)
	                        geometry.addAttribute('morphTarget' + i, morphAttributes.position[index_1]);
	                    if (material.morphNormals === true && morphAttributes.normal)
	                        geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index_1]);
	                }
	                else {
	                    if (material.morphTargets === true)
	                        geometry.removeAttribute('morphTarget' + i);
	                    if (material.morphNormals === true)
	                        geometry.removeAttribute('morphNormal' + i);
	                }
	            }
	            for (var i = activeInfluences.length, il = this.morphInfluences.length; i < il; i++) {
	                this.morphInfluences[i] = 0.0;
	            }
	            program.getUniforms().setValue(this._gl, 'morphTargetInfluences', this.morphInfluences);
	            updateBuffers = true;
	        }
	        //
	        var index = geometry.index;
	        var position = geometry.attributes.position;
	        var rangeFactor = 1;
	        if (material.wireframe === true) {
	            index = this.objects.getWireframeAttribute(geometry);
	            rangeFactor = 2;
	        }
	        var renderer;
	        if (index !== null) {
	            renderer = this.indexedBufferRenderer;
	            renderer.setIndex(index);
	        }
	        else {
	            renderer = this.bufferRenderer;
	        }
	        if (updateBuffers) {
	            this.setupVertexAttributes(material, program, geometry);
	            if (index !== null) {
	                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this.objects.getAttributeBuffer(index));
	            }
	        }
	        //
	        var dataCount = 0;
	        if (index !== null) {
	            dataCount = index.count;
	        }
	        else if (position !== undefined) {
	            dataCount = position.count;
	        }
	        var rangeStart = geometry.drawRange.start * rangeFactor;
	        var rangeCount = geometry.drawRange.count * rangeFactor;
	        var groupStart = group !== null ? group.start * rangeFactor : 0;
	        var groupCount = group !== null ? group.count * rangeFactor : Infinity;
	        var drawStart = Math.max(rangeStart, groupStart);
	        var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
	        var drawCount = Math.max(0, drawEnd - drawStart + 1);
	        if (drawCount === 0)
	            return;
	        //
	        if (object instanceof Mesh) {
	            if (material.wireframe === true) {
	                this.state.setLineWidth(material.wireframeLinewidth * this.getTargetPixelRatio());
	                renderer.setMode(_gl.LINES);
	            }
	            else {
	                switch (object.drawMode) {
	                    case exports.DrawMode.Triangles:
	                        renderer.setMode(_gl.TRIANGLES);
	                        break;
	                    case exports.DrawMode.TriangleStrip:
	                        renderer.setMode(_gl.TRIANGLE_STRIP);
	                        break;
	                    case exports.DrawMode.TriangleFan:
	                        renderer.setMode(_gl.TRIANGLE_FAN);
	                        break;
	                }
	            }
	        }
	        else if (object instanceof Line) {
	            var lineWidth = material.linewidth;
	            if (lineWidth === undefined)
	                lineWidth = 1; // Not using Line*Material
	            this.state.setLineWidth(lineWidth * this.getTargetPixelRatio());
	            if (object instanceof LineSegments) {
	                renderer.setMode(_gl.LINES);
	            }
	            else {
	                renderer.setMode(_gl.LINE_STRIP);
	            }
	        }
	        else if (object instanceof Points) {
	            renderer.setMode(_gl.POINTS);
	        }
	        if (geometry && geometry instanceof InstancedBufferGeometry) {
	            if (geometry.maxInstancedCount > 0) {
	                renderer.renderInstances(geometry, drawStart, drawCount);
	            }
	        }
	        else {
	            renderer.render(drawStart, drawCount);
	        }
	    };
	    WebGLRenderer.prototype.setupVertexAttributes = function (material, program, geometry, startIndex) {
	        if (startIndex === void 0) { startIndex = 0; }
	        var _gl = this._gl;
	        var extension;
	        if (geometry && geometry instanceof InstancedBufferGeometry) {
	            extension = this.extensions.get('ANGLE_instanced_arrays');
	            if (extension === null) {
	                console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
	                return;
	            }
	        }
	        this.state.initAttributes();
	        var geometryAttributes = geometry.attributes;
	        var programAttributes = program.getAttributes();
	        var materialDefaultAttributeValues = material.defaultAttributeValues;
	        for (var name in programAttributes) {
	            var programAttribute = programAttributes[name];
	            if (programAttribute >= 0) {
	                var geometryAttribute = geometryAttributes[name];
	                if (geometryAttribute !== undefined) {
	                    var type = _gl.FLOAT;
	                    var array = geometryAttribute.array;
	                    var normalized = geometryAttribute.normalized;
	                    if (array instanceof Float32Array) {
	                        type = _gl.FLOAT;
	                    }
	                    else if (array instanceof Float64Array) {
	                        console.warn("Unsupported data buffer format: Float64Array");
	                    }
	                    else if (array instanceof Uint16Array) {
	                        type = _gl.UNSIGNED_SHORT;
	                    }
	                    else if (array instanceof Int16Array) {
	                        type = _gl.SHORT;
	                    }
	                    else if (array instanceof Uint32Array) {
	                        type = _gl.UNSIGNED_INT;
	                    }
	                    else if (array instanceof Int32Array) {
	                        type = _gl.INT;
	                    }
	                    else if (array instanceof Int8Array) {
	                        type = _gl.BYTE;
	                    }
	                    else if (array instanceof Uint8Array) {
	                        type = _gl.UNSIGNED_BYTE;
	                    }
	                    var size = geometryAttribute.itemSize;
	                    var buffer = this.objects.getAttributeBuffer(geometryAttribute);
	                    if (geometryAttribute instanceof InterleavedBufferAttribute) {
	                        var data = geometryAttribute.data;
	                        var stride = data.stride;
	                        var offset = geometryAttribute.offset;
	                        if (data && data instanceof InstancedInterleavedBuffer) {
	                            this.state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
	                            if (geometry.maxInstancedCount === undefined) {
	                                geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	                            }
	                        }
	                        else {
	                            this.state.enableAttribute(programAttribute);
	                        }
	                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
	                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
	                    }
	                    else {
	                        if (geometryAttribute instanceof InstancedBufferAttribute) {
	                            this.state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
	                            if (geometry.maxInstancedCount === undefined) {
	                                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	                            }
	                        }
	                        else {
	                            this.state.enableAttribute(programAttribute);
	                        }
	                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
	                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT);
	                    }
	                }
	                else if (materialDefaultAttributeValues !== undefined) {
	                    var value = materialDefaultAttributeValues[name];
	                    if (value !== undefined) {
	                        switch (value.length) {
	                            case 2:
	                                _gl.vertexAttrib2fv(programAttribute, value);
	                                break;
	                            case 3:
	                                _gl.vertexAttrib3fv(programAttribute, value);
	                                break;
	                            case 4:
	                                _gl.vertexAttrib4fv(programAttribute, value);
	                                break;
	                            default:
	                                _gl.vertexAttrib1fv(programAttribute, value);
	                        }
	                    }
	                }
	            }
	        }
	        this.state.disableUnusedAttributes();
	    };
	    // Sorting
	    WebGLRenderer.absNumericalSort = function (a, b) {
	        return Math.abs(b[0]) - Math.abs(a[0]);
	    };
	    WebGLRenderer.painterSortStable = function (a, b) {
	        if (a.object.renderOrder !== b.object.renderOrder) {
	            return a.object.renderOrder - b.object.renderOrder;
	        }
	        else if (a.material.program && b.material.program && a.material.program !== b.material.program) {
	            return a.material.program.id - b.material.program.id;
	        }
	        else if (a.material.id !== b.material.id) {
	            return a.material.id - b.material.id;
	        }
	        else if (a.z !== b.z) {
	            return a.z - b.z;
	        }
	        else {
	            return a.id - b.id;
	        }
	    };
	    WebGLRenderer.reversePainterSortStable = function (a, b) {
	        if (a.object.renderOrder !== b.object.renderOrder) {
	            return a.object.renderOrder - b.object.renderOrder;
	        }
	        if (a.z !== b.z) {
	            return b.z - a.z;
	        }
	        else {
	            return a.id - b.id;
	        }
	    };
	    // Rendering
	    WebGLRenderer.prototype.render = function (scene, camera, renderTarget, forceClear) {
	        if (camera !== undefined && camera instanceof Camera !== true) {
	            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
	            return;
	        }
	        // reset caching for this frame
	        this._currentGeometryProgram = '';
	        this._currentMaterialId = -1;
	        this._currentCamera = null;
	        // update scene graph
	        if (scene.autoUpdate === true)
	            scene.updateMatrixWorld();
	        // update camera matrices and frustum
	        if (camera.parent === null)
	            camera.updateMatrixWorld();
	        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
	        this._projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
	        this._frustum.setFromMatrix(this._projScreenMatrix);
	        this.lights.length = 0;
	        this.opaqueObjectsLastIndex = -1;
	        this.transparentObjectsLastIndex = -1;
	        this.sprites.length = 0;
	        this.lensFlares.length = 0;
	        this._localClippingEnabled = this.localClippingEnabled;
	        this._clippingEnabled = this._clipping.init(this.clippingPlanes, this._localClippingEnabled, camera);
	        this.projectObject(scene, camera);
	        this.opaqueObjects.length = this.opaqueObjectsLastIndex + 1;
	        this.transparentObjects.length = this.transparentObjectsLastIndex + 1;
	        if (this.sortObjects === true) {
	            this.opaqueObjects.sort(WebGLRenderer.painterSortStable);
	            this.transparentObjects.sort(WebGLRenderer.reversePainterSortStable);
	        }
	        //
	        if (this._clippingEnabled)
	            this._clipping.beginShadows();
	        this.setupShadows(this.lights);
	        this.shadowMap.render(scene, camera);
	        this.setupLights(this.lights, camera);
	        if (this._clippingEnabled)
	            this._clipping.endShadows();
	        //
	        this._infoRender.calls = 0;
	        this._infoRender.vertices = 0;
	        this._infoRender.faces = 0;
	        this._infoRender.points = 0;
	        if (renderTarget === undefined) {
	            renderTarget = null;
	        }
	        this.setRenderTarget(renderTarget);
	        //
	        var background = scene.background;
	        if (background === null) {
	            this.glClearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
	        }
	        else if (background && background instanceof Color) {
	            this.glClearColor(background.r, background.g, background.b, 1);
	            forceClear = true;
	        }
	        if (this.autoClear || forceClear) {
	            this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
	        }
	        if (background && background instanceof CubeTexture) {
	            this.backgroundCamera2.projectionMatrix.copy(camera.projectionMatrix);
	            this.backgroundCamera2.matrixWorld.extractRotation(camera.matrixWorld);
	            this.backgroundCamera2.matrixWorldInverse.getInverse(this.backgroundCamera2.matrixWorld);
	            this.backgroundBoxMesh.material.uniforms["tCube"].value = background;
	            this.backgroundBoxMesh.modelViewMatrix.multiplyMatrices(this.backgroundCamera2.matrixWorldInverse, this.backgroundBoxMesh.matrixWorld);
	            this.objects.update(this.backgroundBoxMesh);
	            this.renderBufferDirect(this.backgroundCamera2, null, this.backgroundBoxMesh.geometry, this.backgroundBoxMesh.material, this.backgroundBoxMesh, null);
	        }
	        else if (background && background instanceof Texture) {
	            this.backgroundPlaneMesh.material.map = background;
	            this.objects.update(this.backgroundPlaneMesh);
	            this.renderBufferDirect(this.backgroundCamera, null, this.backgroundPlaneMesh.geometry, this.backgroundPlaneMesh.material, this.backgroundPlaneMesh, null);
	        }
	        //
	        if (scene.overrideMaterial) {
	            var overrideMaterial = scene.overrideMaterial;
	            this.renderObjects(this.opaqueObjects, camera, scene, overrideMaterial);
	            this.renderObjects(this.transparentObjects, camera, scene, overrideMaterial);
	        }
	        else {
	            // opaque pass (front-to-back order)
	            this.state.setBlending(exports.BlendingMode.None);
	            this.renderObjects(this.opaqueObjects, camera, scene);
	            // transparent pass (back-to-front order)
	            this.renderObjects(this.transparentObjects, camera, scene);
	        }
	        // custom render plugins (post pass)
	        this.spritePlugin.render(scene, camera);
	        this.lensFlarePlugin.render(scene, camera, this._currentViewport);
	        // Generate mipmap if we're using any kind of mipmap filtering
	        if (renderTarget) {
	            this.textures.updateRenderTargetMipmap(renderTarget);
	        }
	        // Ensure depth buffer writing is enabled so it can be cleared on next render
	        this.state.setDepthTest(true);
	        this.state.setDepthWrite(true);
	        this.state.setColorWrite(true);
	        // _gl.finish();
	    };
	    WebGLRenderer.prototype.pushRenderItem = function (object, geometry, material, z, group) {
	        var array, index;
	        // allocate the next position in the appropriate array
	        if (material.transparent) {
	            array = this.transparentObjects;
	            index = ++this.transparentObjectsLastIndex;
	        }
	        else {
	            array = this.opaqueObjects;
	            index = ++this.opaqueObjectsLastIndex;
	        }
	        // recycle existing render item or grow the array
	        var renderItem = array[index];
	        if (renderItem !== undefined) {
	            renderItem.id = object.id;
	            renderItem.object = object;
	            renderItem.geometry = geometry;
	            renderItem.material = material;
	            renderItem.z = this._vector3.z;
	            renderItem.group = group;
	        }
	        else {
	            renderItem = {
	                id: object.id,
	                object: object,
	                geometry: geometry,
	                material: material,
	                z: this._vector3.z,
	                group: group
	            };
	            // assert(index === array.length);
	            array.push(renderItem);
	        }
	    };
	    // TODO Duplicated code (Frustum)
	    WebGLRenderer.prototype.isObjectViewable = function (object) {
	        var geometry = object.geometry;
	        if (geometry.boundingSphere === null)
	            geometry.computeBoundingSphere();
	        this._sphere.copy(geometry.boundingSphere).
	            applyMatrix4(object.matrixWorld);
	        return this.isSphereViewable(this._sphere);
	    };
	    WebGLRenderer.prototype.isSpriteViewable = function (sprite) {
	        this._sphere.center.set(0, 0, 0);
	        this._sphere.radius = 0.7071067811865476;
	        this._sphere.applyMatrix4(sprite.matrixWorld);
	        return this.isSphereViewable(this._sphere);
	    };
	    WebGLRenderer.prototype.isSphereViewable = function (sphere) {
	        if (!this._frustum.intersectsSphere(sphere))
	            return false;
	        var numPlanes = this._clipping.numPlanes;
	        if (numPlanes === 0)
	            return true;
	        var planes = this.clippingPlanes;
	        var center = sphere.center;
	        var negRad = -sphere.radius;
	        var i = 0;
	        do {
	            // out when deeper than radius in the negative halfspace
	            if (planes[i].distanceToPoint(center) < negRad)
	                return false;
	        } while (++i !== numPlanes);
	        return true;
	    };
	    WebGLRenderer.prototype.projectObject = function (object, camera) {
	        if (object.visible === false)
	            return;
	        var visible = (object.layers.mask & camera.layers.mask) !== 0;
	        if (visible) {
	            if (object instanceof Light) {
	                this.lights.push(object);
	            }
	            else if (object instanceof Sprite) {
	                if (object.frustumCulled === false || this.isSpriteViewable(object) === true) {
	                    this.sprites.push(object);
	                }
	            }
	            else if (object instanceof LensFlare) {
	                this.lensFlares.push(object);
	            }
	            else if (object instanceof ImmediateRenderObject) {
	                if (this.sortObjects === true) {
	                    this._vector3.setFromMatrixPosition(object.matrixWorld);
	                    this._vector3.applyProjection(this._projScreenMatrix);
	                }
	                this.pushRenderItem(object, null, object.material, this._vector3.z, null);
	            }
	            else if (object instanceof Mesh || object instanceof Line || object instanceof Points) {
	                if (object instanceof SkinnedMesh) {
	                    object.skeleton.update();
	                }
	                if (object.frustumCulled === false || this.isObjectViewable(object) === true) {
	                    var material = object.material;
	                    if (material.visible === true) {
	                        if (this.sortObjects === true) {
	                            this._vector3.setFromMatrixPosition(object.matrixWorld);
	                            this._vector3.applyProjection(this._projScreenMatrix);
	                        }
	                        var geometry = this.objects.update(object);
	                        if (material instanceof MultiMaterial) {
	                            var groups = geometry.groups;
	                            var materials = material.materials;
	                            for (var i = 0, l = groups.length; i < l; i++) {
	                                var group = groups[i];
	                                var groupMaterial = materials[group.materialIndex];
	                                if (!groupMaterial)
	                                    continue; /// HACK
	                                if (groupMaterial.visible === true) {
	                                    this.pushRenderItem(object, geometry, groupMaterial, this._vector3.z, group);
	                                }
	                            }
	                        }
	                        else {
	                            this.pushRenderItem(object, geometry, material, this._vector3.z, null);
	                        }
	                    }
	                }
	            }
	        }
	        var children = object.children;
	        for (var i = 0, l = children.length; i < l; i++) {
	            this.projectObject(children[i], camera);
	        }
	    };
	    WebGLRenderer.prototype.renderObjects = function (renderList, camera, scene, overrideMaterial) {
	        var _loop_1 = function (i, l) {
	            var renderItem = renderList[i];
	            var object = renderItem.object;
	            var geometry = renderItem.geometry;
	            var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
	            var group = renderItem.group;
	            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
	            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
	            object.onBeforeRender(this_1, scene, camera, geometry, material, group);
	            if (object instanceof ImmediateRenderObject) {
	                this_1.setMaterial(material);
	                var program_1 = this_1.setProgram(camera, scene.fog, material, object);
	                this_1._currentGeometryProgram = '';
	                var that_1 = this_1;
	                object.render(function (object) {
	                    that_1.renderBufferImmediate(object, program_1, material);
	                });
	            }
	            else {
	                this_1.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
	            }
	            object.onAfterRender(this_1, scene, camera, geometry, material, group);
	        };
	        var this_1 = this;
	        for (var i = 0, l = renderList.length; i < l; i++) {
	            _loop_1(i, l);
	        }
	    };
	    WebGLRenderer.prototype.initMaterial = function (material, fog, object) {
	        var materialProperties = this.properties.get(material);
	        var parameters = this.programCache.getParameters(material, this._lights, fog, this._clipping.numPlanes, this._clipping.numIntersection, object);
	        var code = this.programCache.getProgramCode(material, parameters);
	        var program = materialProperties.program;
	        var programChange = true;
	        if (program === undefined) {
	            // new material
	            material.addEventListener('dispose', this.onMaterialDispose.bind(this));
	        }
	        else if (program.code !== code) {
	            // changed glsl or parameters
	            this.releaseMaterialProgramReference(material);
	        }
	        else if (parameters.shaderID !== undefined) {
	            // same glsl and uniform list
	            return;
	        }
	        else {
	            // only rebuild uniform list
	            programChange = false;
	        }
	        if (programChange) {
	            if (parameters.shaderID) {
	                var shader = ShaderLib[parameters.shaderID];
	                materialProperties.__webglShader = {
	                    name: material.type,
	                    uniforms: UniformsUtils.clone(shader.uniforms),
	                    vertexShader: shader.vertexShader,
	                    fragmentShader: shader.fragmentShader
	                };
	            }
	            else {
	                materialProperties.__webglShader = {
	                    name: material.type,
	                    uniforms: material.uniforms,
	                    vertexShader: material.vertexShader,
	                    fragmentShader: material.fragmentShader
	                };
	            }
	            material.__webglShader = materialProperties.__webglShader;
	            program = this.programCache.acquireProgram(material, parameters, code);
	            materialProperties.program = program;
	            material.program = program;
	        }
	        var attributes = program.getAttributes();
	        if (material.morphTargets) {
	            material.numSupportedMorphTargets = 0;
	            for (var i = 0; i < this.maxMorphTargets; i++) {
	                if (attributes['morphTarget' + i] >= 0) {
	                    material.numSupportedMorphTargets++;
	                }
	            }
	        }
	        if (material.morphNormals) {
	            material.numSupportedMorphNormals = 0;
	            for (var i = 0; i < this.maxMorphNormals; i++) {
	                if (attributes['morphNormal' + i] >= 0) {
	                    material.numSupportedMorphNormals++;
	                }
	            }
	        }
	        var uniforms = materialProperties.__webglShader.uniforms;
	        if (!(material instanceof ShaderMaterial) &&
	            !(material instanceof RawShaderMaterial) ||
	            material.clipping === true) {
	            materialProperties.numClippingPlanes = this._clipping.numPlanes;
	            materialProperties.numIntersection = this._clipping.numIntersection;
	            uniforms.clippingPlanes = this._clipping.uniform;
	        }
	        materialProperties.fog = fog;
	        // store the light setup it was created for
	        materialProperties.lightsHash = this._lights.hash;
	        if (material.lights) {
	            // wire up the material to this renderer's lighting state
	            uniforms.ambientLightColor.value = this._lights.ambient;
	            uniforms.directionalLights.value = this._lights.directional;
	            uniforms.spotLights.value = this._lights.spot;
	            uniforms.pointLights.value = this._lights.point;
	            uniforms.hemisphereLights.value = this._lights.hemi;
	            uniforms.directionalShadowMap.value = this._lights.directionalShadowMap;
	            uniforms.directionalShadowMatrix.value = this._lights.directionalShadowMatrix;
	            uniforms.spotShadowMap.value = this._lights.spotShadowMap;
	            uniforms.spotShadowMatrix.value = this._lights.spotShadowMatrix;
	            uniforms.pointShadowMap.value = this._lights.pointShadowMap;
	            uniforms.pointShadowMatrix.value = this._lights.pointShadowMatrix;
	        }
	        var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
	        materialProperties.uniformsList = uniformsList;
	    };
	    WebGLRenderer.prototype.setMaterial = function (material) {
	        material.side === exports.SideMode.Double
	            ? this.state.disable(this._gl.CULL_FACE)
	            : this.state.enable(this._gl.CULL_FACE);
	        this.state.setFlipSided(material.side === exports.SideMode.Back);
	        material.transparent === true
	            ? this.state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha)
	            : this.state.setBlending(exports.BlendingMode.None);
	        this.state.setDepthFunc(material.depthFunc);
	        this.state.setDepthTest(material.depthTest);
	        this.state.setDepthWrite(material.depthWrite);
	        this.state.setColorWrite(material.colorWrite);
	        this.state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
	    };
	    WebGLRenderer.prototype.setProgram = function (camera, fog, material, object) {
	        this._usedTextureUnits = 0;
	        var materialProperties = this.properties.get(material);
	        if (this._clippingEnabled) {
	            if (this._localClippingEnabled || camera !== this._currentCamera) {
	                var useCache = camera === this._currentCamera &&
	                    material.id === this._currentMaterialId;
	                // we might want to call this function with some ClippingGroup
	                // object instead of the material, once it becomes feasible
	                // (#8465, #8379)
	                this._clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
	            }
	        }
	        if (material.needsUpdate === false) {
	            if (materialProperties.program === undefined) {
	                material.needsUpdate = true;
	            }
	            else if (material.fog && materialProperties.fog !== fog) {
	                material.needsUpdate = true;
	            }
	            else if (material.lights && materialProperties.lightsHash !== this._lights.hash) {
	                material.needsUpdate = true;
	            }
	            else if (materialProperties.numClippingPlanes !== undefined &&
	                (materialProperties.numClippingPlanes !== this._clipping.numPlanes ||
	                    materialProperties.numIntersection !== this._clipping.numIntersection)) {
	                material.needsUpdate = true;
	            }
	        }
	        if (material.needsUpdate) {
	            this.initMaterial(material, fog, object);
	            material.needsUpdate = false;
	        }
	        var refreshProgram = false;
	        var refreshMaterial = false;
	        var refreshLights = false;
	        var program = materialProperties.program;
	        var p_uniforms = program.getUniforms();
	        var m_uniforms = materialProperties.__webglShader.uniforms;
	        if (program.id !== this._currentProgram) {
	            this._gl.useProgram(program.program);
	            this._currentProgram = program.id;
	            refreshProgram = true;
	            refreshMaterial = true;
	            refreshLights = true;
	        }
	        if (material.id !== this._currentMaterialId) {
	            this._currentMaterialId = material.id;
	            refreshMaterial = true;
	        }
	        if (refreshProgram || camera !== this._currentCamera) {
	            p_uniforms.set(this._gl, camera, 'projectionMatrix');
	            if (this.capabilities.logarithmicDepthBuffer) {
	                p_uniforms.setValue(this._gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
	            }
	            if (camera !== this._currentCamera) {
	                this._currentCamera = camera;
	                // lighting uniforms depend on the camera so enforce an update
	                // now, in case this material supports lights - or later, when
	                // the next material that does gets activated:
	                refreshMaterial = true; // set to true on material change
	                refreshLights = true; // remains set until update done
	            }
	            // load material specific uniforms
	            // (shader material also gets them for the sake of genericity)
	            if (material instanceof ShaderMaterial ||
	                material instanceof MeshPhongMaterial ||
	                material instanceof MeshStandardMaterial ||
	                material.envMap) {
	                var uCamPos = p_uniforms.map.cameraPosition;
	                if (uCamPos !== undefined) {
	                    uCamPos.setValue(this._gl, this._vector3.setFromMatrixPosition(camera.matrixWorld));
	                }
	            }
	            if (material instanceof MeshPhongMaterial ||
	                material instanceof MeshLambertMaterial ||
	                material instanceof MeshBasicMaterial ||
	                material instanceof MeshStandardMaterial ||
	                material instanceof ShaderMaterial ||
	                material.skinning) {
	                p_uniforms.setValue(this._gl, 'viewMatrix', camera.matrixWorldInverse);
	            }
	            p_uniforms.set(this._gl, this, 'toneMappingExposure');
	            p_uniforms.set(this._gl, this, 'toneMappingWhitePoint');
	        }
	        // skinning uniforms must be set even if material didn't change
	        // auto-setting of texture unit for bone texture must go before other textures
	        // not sure why, but otherwise weird things happen
	        if (material.skinning) {
	            p_uniforms.setOptional(this._gl, object, 'bindMatrix');
	            p_uniforms.setOptional(this._gl, object, 'bindMatrixInverse');
	            var skeleton = object.skeleton;
	            if (skeleton) {
	                if (this.capabilities.floatVertexTextures && skeleton.useVertexTexture) {
	                    p_uniforms.set(this._gl, skeleton, 'boneTexture');
	                    p_uniforms.set(this._gl, skeleton, 'boneTextureWidth');
	                    p_uniforms.set(this._gl, skeleton, 'boneTextureHeight');
	                }
	                else {
	                    p_uniforms.setOptional(this._gl, skeleton, 'boneMatrices');
	                }
	            }
	        }
	        if (refreshMaterial) {
	            if (material.lights) {
	                // the current material requires lighting info
	                // note: all lighting uniforms are always set correctly
	                // they simply reference the renderer's state for their
	                // values
	                //
	                // use the current material's .needsUpdate flags to set
	                // the GL state when required
	                this.markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
	            }
	            // refresh uniforms common to several materials
	            if (fog && material.fog) {
	                this.refreshUniformsFog(m_uniforms, fog);
	            }
	            if (material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshDepthMaterial) {
	                this.refreshUniformsCommon(m_uniforms, material);
	            }
	            // refresh single material specific uniforms
	            if (material instanceof LineBasicMaterial) {
	                this.refreshUniformsLine(m_uniforms, material);
	            }
	            else if (material instanceof LineDashedMaterial) {
	                this.refreshUniformsLine(m_uniforms, material);
	                this.refreshUniformsDash(m_uniforms, material);
	            }
	            else if (material instanceof PointsMaterial) {
	                this.refreshUniformsPoints(m_uniforms, material);
	            }
	            else if (material instanceof MeshLambertMaterial) {
	                this.refreshUniformsLambert(m_uniforms, material);
	            }
	            else if (material instanceof MeshPhongMaterial) {
	                this.refreshUniformsPhong(m_uniforms, material);
	            }
	            else if (material instanceof MeshPhysicalMaterial) {
	                this.refreshUniformsPhysical(m_uniforms, material);
	            }
	            else if (material instanceof MeshStandardMaterial) {
	                this.refreshUniformsStandard(m_uniforms, material);
	            }
	            else if (material instanceof MeshDepthMaterial) {
	                if (material.displacementMap) {
	                    m_uniforms.displacementMap.value = material.displacementMap;
	                    m_uniforms.displacementScale.value = material.displacementScale;
	                    m_uniforms.displacementBias.value = material.displacementBias;
	                }
	            }
	            else if (material instanceof MeshNormalMaterial) {
	                m_uniforms.opacity.value = material.opacity;
	            }
	            WebGLUniforms.upload(this._gl, materialProperties.uniformsList, m_uniforms, this);
	        }
	        // common matrices
	        p_uniforms.set(this._gl, object, 'modelViewMatrix');
	        p_uniforms.set(this._gl, object, 'normalMatrix');
	        p_uniforms.setValue(this._gl, 'modelMatrix', object.matrixWorld);
	        return program;
	    };
	    // Uniforms (refresh uniforms objects)
	    WebGLRenderer.prototype.refreshUniformsCommon = function (uniforms, material) {
	        uniforms.opacity.value = material.opacity;
	        uniforms.diffuse.value = material.color;
	        if (material.emissive) {
	            uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
	        }
	        uniforms.map.value = material.map;
	        uniforms.specularMap.value = material.specularMap;
	        uniforms.alphaMap.value = material.alphaMap;
	        if (material.aoMap) {
	            uniforms.aoMap.value = material.aoMap;
	            uniforms.aoMapIntensity.value = material.aoMapIntensity;
	        }
	        // uv repeat and offset setting priorities
	        // 1. color map
	        // 2. specular map
	        // 3. normal map
	        // 4. bump map
	        // 5. alpha map
	        // 6. emissive map
	        var uvScaleMap;
	        if (material.map) {
	            uvScaleMap = material.map;
	        }
	        else if (material.specularMap) {
	            uvScaleMap = material.specularMap;
	        }
	        else if (material.displacementMap) {
	            uvScaleMap = material.displacementMap;
	        }
	        else if (material.normalMap) {
	            uvScaleMap = material.normalMap;
	        }
	        else if (material.bumpMap) {
	            uvScaleMap = material.bumpMap;
	        }
	        else if (material.roughnessMap) {
	            uvScaleMap = material.roughnessMap;
	        }
	        else if (material.metalnessMap) {
	            uvScaleMap = material.metalnessMap;
	        }
	        else if (material.alphaMap) {
	            uvScaleMap = material.alphaMap;
	        }
	        else if (material.emissiveMap) {
	            uvScaleMap = material.emissiveMap;
	        }
	        if (uvScaleMap !== undefined) {
	            // backwards compatibility
	            if (uvScaleMap instanceof WebGLRenderTarget) {
	                uvScaleMap = uvScaleMap.texture;
	            }
	            var offset = uvScaleMap.offset;
	            var repeat = uvScaleMap.repeat;
	            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
	        }
	        uniforms.envMap.value = material.envMap;
	        // don't flip CubeTexture envMaps, flip everything else:
	        //  WebGLRenderTargetCube will be flipped for backwards compatibility
	        //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
	        // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
	        uniforms.flipEnvMap.value = (!(material.envMap && material.envMap instanceof CubeTexture)) ? 1 : -1;
	        uniforms.reflectivity.value = material.reflectivity;
	        uniforms.refractionRatio.value = material.refractionRatio;
	    };
	    WebGLRenderer.prototype.refreshUniformsLine = function (uniforms, material) {
	        uniforms.diffuse.value = material.color;
	        uniforms.opacity.value = material.opacity;
	    };
	    WebGLRenderer.prototype.refreshUniformsDash = function (uniforms, material) {
	        uniforms.dashSize.value = material.dashSize;
	        uniforms.totalSize.value = material.dashSize + material.gapSize;
	        uniforms.scale.value = material.scale;
	    };
	    WebGLRenderer.prototype.refreshUniformsPoints = function (uniforms, material) {
	        uniforms.diffuse.value = material.color;
	        uniforms.opacity.value = material.opacity;
	        uniforms.size.value = material.size * this._pixelRatio;
	        uniforms.scale.value = this._height * 0.5;
	        uniforms.map.value = material.map;
	        if (material.map !== null) {
	            var offset = material.map.offset;
	            var repeat = material.map.repeat;
	            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
	        }
	    };
	    WebGLRenderer.prototype.refreshUniformsFog = function (uniforms, fog) {
	        uniforms.fogColor.value = fog.color;
	        if (fog instanceof Fog) {
	            uniforms.fogNear.value = fog.near;
	            uniforms.fogFar.value = fog.far;
	        }
	        else if (fog instanceof FogExp2) {
	            uniforms.fogDensity.value = fog.density;
	        }
	    };
	    WebGLRenderer.prototype.refreshUniformsLambert = function (uniforms, material) {
	        if (material.lightMap) {
	            uniforms.lightMap.value = material.lightMap;
	            uniforms.lightMapIntensity.value = material.lightMapIntensity;
	        }
	        if (material.emissiveMap) {
	            uniforms.emissiveMap.value = material.emissiveMap;
	        }
	    };
	    WebGLRenderer.prototype.refreshUniformsPhong = function (uniforms, material) {
	        uniforms.specular.value = material.specular;
	        uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow(0.0, 0.0)
	        if (material.lightMap) {
	            uniforms.lightMap.value = material.lightMap;
	            uniforms.lightMapIntensity.value = material.lightMapIntensity;
	        }
	        if (material.emissiveMap) {
	            uniforms.emissiveMap.value = material.emissiveMap;
	        }
	        if (material.bumpMap) {
	            uniforms.bumpMap.value = material.bumpMap;
	            uniforms.bumpScale.value = material.bumpScale;
	        }
	        if (material.normalMap) {
	            uniforms.normalMap.value = material.normalMap;
	            uniforms.normalScale.value.copy(material.normalScale);
	        }
	        if (material.displacementMap) {
	            uniforms.displacementMap.value = material.displacementMap;
	            uniforms.displacementScale.value = material.displacementScale;
	            uniforms.displacementBias.value = material.displacementBias;
	        }
	    };
	    WebGLRenderer.prototype.refreshUniformsStandard = function (uniforms, material) {
	        uniforms.roughness.value = material.roughness;
	        uniforms.metalness.value = material.metalness;
	        if (material.roughnessMap) {
	            uniforms.roughnessMap.value = material.roughnessMap;
	        }
	        if (material.metalnessMap) {
	            uniforms.metalnessMap.value = material.metalnessMap;
	        }
	        if (material.lightMap) {
	            uniforms.lightMap.value = material.lightMap;
	            uniforms.lightMapIntensity.value = material.lightMapIntensity;
	        }
	        if (material.emissiveMap) {
	            uniforms.emissiveMap.value = material.emissiveMap;
	        }
	        if (material.bumpMap) {
	            uniforms.bumpMap.value = material.bumpMap;
	            uniforms.bumpScale.value = material.bumpScale;
	        }
	        if (material.normalMap) {
	            uniforms.normalMap.value = material.normalMap;
	            uniforms.normalScale.value.copy(material.normalScale);
	        }
	        if (material.displacementMap) {
	            uniforms.displacementMap.value = material.displacementMap;
	            uniforms.displacementScale.value = material.displacementScale;
	            uniforms.displacementBias.value = material.displacementBias;
	        }
	        if (material.envMap) {
	            //uniforms.envMap.value = material.envMap; // part of uniforms common
	            uniforms.envMapIntensity.value = material.envMapIntensity;
	        }
	    };
	    WebGLRenderer.prototype.refreshUniformsPhysical = function (uniforms, material) {
	        uniforms.clearCoat.value = material.clearCoat;
	        uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
	        this.refreshUniformsStandard(uniforms, material);
	    };
	    // If uniforms are marked as clean, they don't need to be loaded to the GPU.
	    WebGLRenderer.prototype.markUniformsLightsNeedsUpdate = function (uniforms, value) {
	        uniforms.ambientLightColor.needsUpdate = value;
	        uniforms.directionalLights.needsUpdate = value;
	        uniforms.pointLights.needsUpdate = value;
	        uniforms.spotLights.needsUpdate = value;
	        uniforms.hemisphereLights.needsUpdate = value;
	    };
	    // Lighting
	    WebGLRenderer.prototype.setupShadows = function (lights) {
	        var lightShadowsLength = 0;
	        for (var i = 0, l = lights.length; i < l; i++) {
	            var light = lights[i];
	            if (light.castShadow) {
	                this._lights.shadows[lightShadowsLength++] = light;
	            }
	        }
	        this._lights.shadows.length = lightShadowsLength;
	    };
	    WebGLRenderer.prototype.setupLights = function (lights, camera) {
	        var r = 0, g = 0, b = 0;
	        var viewMatrix = camera.matrixWorldInverse;
	        var directionalLength = 0;
	        var pointLength = 0;
	        var spotLength = 0;
	        var hemiLength = 0;
	        for (var l = 0, ll = lights.length; l < ll; l++) {
	            var light = lights[l];
	            var color = light.color;
	            var intensity = light.intensity;
	            var distance = light.distance;
	            var shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;
	            if (light instanceof AmbientLight) {
	                r += color.r * intensity;
	                g += color.g * intensity;
	                b += color.b * intensity;
	            }
	            else if (light instanceof DirectionalLight) {
	                var uniforms = this.lightCache.get(light);
	                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
	                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
	                this._vector3.setFromMatrixPosition(light.target.matrixWorld);
	                uniforms.direction.sub(this._vector3);
	                uniforms.direction.transformDirection(viewMatrix);
	                uniforms.shadow = light.castShadow;
	                if (light.castShadow) {
	                    uniforms.shadowBias = light.shadow.bias;
	                    uniforms.shadowRadius = light.shadow.radius;
	                    uniforms.shadowMapSize = light.shadow.mapSize;
	                }
	                this._lights.directionalShadowMap[directionalLength] = shadowMap;
	                this._lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
	                this._lights.directional[directionalLength++] = uniforms;
	            }
	            else if (light instanceof SpotLight) {
	                var uniforms = this.lightCache.get(light);
	                uniforms.position.setFromMatrixPosition(light.matrixWorld);
	                uniforms.position.applyMatrix4(viewMatrix);
	                uniforms.color.copy(color).multiplyScalar(intensity);
	                uniforms.distance = distance;
	                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
	                this._vector3.setFromMatrixPosition(light.target.matrixWorld);
	                uniforms.direction.sub(this._vector3);
	                uniforms.direction.transformDirection(viewMatrix);
	                uniforms.coneCos = Math.cos(light.angle);
	                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
	                uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
	                uniforms.shadow = light.castShadow;
	                if (light.castShadow) {
	                    uniforms.shadowBias = light.shadow.bias;
	                    uniforms.shadowRadius = light.shadow.radius;
	                    uniforms.shadowMapSize = light.shadow.mapSize;
	                }
	                this._lights.spotShadowMap[spotLength] = shadowMap;
	                this._lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
	                this._lights.spot[spotLength++] = uniforms;
	            }
	            else if (light instanceof PointLight) {
	                var uniforms = this.lightCache.get(light);
	                uniforms.position.setFromMatrixPosition(light.matrixWorld);
	                uniforms.position.applyMatrix4(viewMatrix);
	                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
	                uniforms.distance = light.distance;
	                uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
	                uniforms.shadow = light.castShadow;
	                if (light.castShadow) {
	                    uniforms.shadowBias = light.shadow.bias;
	                    uniforms.shadowRadius = light.shadow.radius;
	                    uniforms.shadowMapSize = light.shadow.mapSize;
	                }
	                this._lights.pointShadowMap[pointLength] = shadowMap;
	                if (this._lights.pointShadowMatrix[pointLength] === undefined) {
	                    this._lights.pointShadowMatrix[pointLength] = new Matrix4();
	                }
	                // for point lights we set the shadow matrix to be a translation-only matrix
	                // equal to inverse of the light's position
	                this._vector3.setFromMatrixPosition(light.matrixWorld).negate();
	                this._lights.pointShadowMatrix[pointLength].identity().setPosition(this._vector3);
	                this._lights.point[pointLength++] = uniforms;
	            }
	            else if (light instanceof HemisphereLight) {
	                var uniforms = this.lightCache.get(light);
	                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
	                uniforms.direction.transformDirection(viewMatrix);
	                uniforms.direction.normalize();
	                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
	                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
	                this._lights.hemi[hemiLength++] = uniforms;
	            }
	        }
	        this._lights.ambient[0] = r;
	        this._lights.ambient[1] = g;
	        this._lights.ambient[2] = b;
	        this._lights.directional.length = directionalLength;
	        this._lights.spot.length = spotLength;
	        this._lights.point.length = pointLength;
	        this._lights.hemi.length = hemiLength;
	        this._lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + this._lights.shadows.length;
	    };
	    // GL state setting
	    WebGLRenderer.prototype.setFaceCulling = function (cullFace, frontFaceDirection) {
	        this.state.setCullFace(cullFace);
	        this.state.setFlipSided(frontFaceDirection === exports.FrontFaceDirection.CW);
	    };
	    // Textures
	    WebGLRenderer.prototype.allocTextureUnit = function () {
	        var textureUnit = this._usedTextureUnits;
	        if (textureUnit >= this.capabilities.maxTextures) {
	            console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + this.capabilities.maxTextures);
	        }
	        this._usedTextureUnits += 1;
	        return textureUnit;
	    };
	    ///this.allocTextureUnit = allocTextureUnit;
	    // this.setTexture2D = setTexture2D;
	    WebGLRenderer.prototype.setTexture2D = function (texture, slot) {
	        var warned = false;
	        // backwards compatibility: peel texture.texture
	        //return function setTexture2D(texture, slot) {
	        if (texture && texture instanceof WebGLRenderTarget) {
	            if (!warned) {
	                console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
	                warned = true;
	            }
	            texture = texture.texture;
	        }
	        this.textures.setTexture2D(texture, slot);
	        //};
	    };
	    WebGLRenderer.prototype.setTexture = function (texture, slot) {
	        var warned = false;
	        //return function setTexture(texture, slot) {
	        if (!warned) {
	            console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
	            warned = true;
	        }
	        this.textures.setTexture2D(texture, slot);
	        //};
	    };
	    WebGLRenderer.prototype.setTextureCube = function (texture, slot) {
	        var warned = false;
	        //return function setTextureCube(texture, slot) {
	        // backwards compatibility: peel texture.texture
	        if (texture && texture instanceof WebGLRenderTargetCube) {
	            if (!warned) {
	                console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
	                warned = true;
	            }
	            texture = texture.texture;
	        }
	        // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
	        // TODO: unify these code paths
	        if ((texture && texture instanceof CubeTexture) ||
	            (Array.isArray(texture.image) && texture.image.length === 6)) {
	            // CompressedTexture can have Array in image :/
	            // this function alone should take care of cube textures
	            this.textures.setTextureCube(texture, slot);
	        }
	        else {
	            // assumed: texture property of THREE.WebGLRenderTargetCube
	            this.textures.setTextureCubeDynamic(texture, slot);
	        }
	        //};
	    };
	    WebGLRenderer.prototype.getCurrentRenderTarget = function () {
	        return this._currentRenderTarget;
	    };
	    WebGLRenderer.prototype.setRenderTarget = function (renderTarget) {
	        var _gl = this._gl;
	        this._currentRenderTarget = renderTarget;
	        if (renderTarget && this.properties.get(renderTarget).__webglFramebuffer === undefined) {
	            this.textures.setupRenderTarget(renderTarget);
	        }
	        var framebuffer;
	        if (renderTarget) {
	            var renderTargetProperties = this.properties.get(renderTarget);
	            if (renderTarget && renderTarget instanceof WebGLRenderTargetCube) {
	                framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
	            }
	            else {
	                framebuffer = renderTargetProperties.__webglFramebuffer;
	            }
	            this._currentScissor.copy(renderTarget.scissor);
	            this._currentScissorTest = renderTarget.scissorTest;
	            this._currentViewport.copy(renderTarget.viewport);
	        }
	        else {
	            framebuffer = null;
	            this._currentScissor.copy(this._scissor).multiplyScalar(this._pixelRatio);
	            this._currentScissorTest = this._scissorTest;
	            this._currentViewport.copy(this._viewport).multiplyScalar(this._pixelRatio);
	        }
	        if (this._currentFramebuffer !== framebuffer) {
	            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
	            this._currentFramebuffer = framebuffer;
	        }
	        this.state.scissor(this._currentScissor);
	        this.state.setScissorTest(this._currentScissorTest);
	        this.state.viewport(this._currentViewport);
	        if (renderTarget && renderTarget instanceof WebGLRenderTargetCube) {
	            var textureProperties = this.properties.get(renderTarget.texture);
	            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
	        }
	    };
	    WebGLRenderer.prototype.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {
	        var _gl = this._gl;
	        if ((renderTarget && renderTarget instanceof WebGLRenderTarget) === false) {
	            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
	            return;
	        }
	        var framebuffer = this.properties.get(renderTarget).__webglFramebuffer;
	        if (framebuffer) {
	            var restore = false;
	            if (framebuffer !== this._currentFramebuffer) {
	                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
	                restore = true;
	            }
	            try {
	                var texture = renderTarget.texture;
	                var textureFormat = texture.format;
	                var textureType = texture.type;
	                if (textureFormat !== exports.TextureFormat.RGBA && this.paramThreeToGL(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
	                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
	                    return;
	                }
	                if (textureType !== exports.TextureType.UnsignedByte && this.paramThreeToGL(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
	                    !(textureType === exports.TextureType.Float && (this.extensions.get('OES_texture_float') || this.extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
	                    !(textureType === exports.TextureType.HalfFloat && this.extensions.get('EXT_color_buffer_half_float'))) {
	                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in TextureType.UnsignedByte or implementation defined type.');
	                    return;
	                }
	                if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
	                    // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	                    if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
	                        _gl.readPixels(x, y, width, height, this.paramThreeToGL(textureFormat), this.paramThreeToGL(textureType), buffer);
	                    }
	                }
	                else {
	                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
	                }
	            }
	            finally {
	                if (restore) {
	                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, this._currentFramebuffer);
	                }
	            }
	        }
	    };
	    // Map three.js constants to WebGL constants
	    WebGLRenderer.prototype.paramThreeToGL = function (p) {
	        var _gl = this._gl;
	        var extension;
	        if (p === exports.TextureWrapping.Repeat)
	            return _gl.REPEAT;
	        if (p === exports.TextureWrapping.ClampToEdge)
	            return _gl.CLAMP_TO_EDGE;
	        if (p === exports.TextureWrapping.MirroredRepeat)
	            return _gl.MIRRORED_REPEAT;
	        if (p === exports.TextureFilter.Nearest)
	            return _gl.NEAREST;
	        if (p === exports.TextureFilter.NearestMipMapNearest)
	            return _gl.NEAREST_MIPMAP_NEAREST;
	        if (p === exports.TextureFilter.NearestMipMapLinear)
	            return _gl.NEAREST_MIPMAP_LINEAR;
	        if (p === exports.TextureFilter.Linear)
	            return _gl.LINEAR;
	        if (p === exports.TextureFilter.LinearMipMapNearest)
	            return _gl.LINEAR_MIPMAP_NEAREST;
	        if (p === exports.TextureFilter.LinearMipMapLinear)
	            return _gl.LINEAR_MIPMAP_LINEAR;
	        if (p === exports.TextureType.UnsignedByte)
	            return _gl.UNSIGNED_BYTE;
	        if (p === exports.TextureType.UnsignedShort4444)
	            return _gl.UNSIGNED_SHORT_4_4_4_4;
	        if (p === exports.TextureType.UnsignedShort5551)
	            return _gl.UNSIGNED_SHORT_5_5_5_1;
	        if (p === exports.TextureType.UnsignedShort565)
	            return _gl.UNSIGNED_SHORT_5_6_5;
	        if (p === exports.TextureType.Byte)
	            return _gl.BYTE;
	        if (p === exports.TextureType.Short)
	            return _gl.SHORT;
	        if (p === exports.TextureType.UnsignedShort)
	            return _gl.UNSIGNED_SHORT;
	        if (p === exports.TextureType.Int)
	            return _gl.INT;
	        if (p === exports.TextureType.UnsignedInt)
	            return _gl.UNSIGNED_INT;
	        if (p === exports.TextureType.Float)
	            return _gl.FLOAT;
	        if (p === exports.TextureType.HalfFloat) {
	            extension = this.extensions.get('OES_texture_half_float');
	            if (extension !== null)
	                return extension.HALF_FLOAT_OES;
	        }
	        if (p === exports.TextureFormat.Alpha)
	            return _gl.ALPHA;
	        if (p === exports.TextureFormat.RGB)
	            return _gl.RGB;
	        if (p === exports.TextureFormat.RGBA)
	            return _gl.RGBA;
	        if (p === exports.TextureFormat.Luminance)
	            return _gl.LUMINANCE;
	        if (p === exports.TextureFormat.LuminanceAlpha)
	            return _gl.LUMINANCE_ALPHA;
	        if (p === exports.TextureFormat.Depth)
	            return _gl.DEPTH_COMPONENT;
	        if (p === exports.TextureFormat.DepthStencil)
	            return _gl.DEPTH_STENCIL;
	        if (p === exports.BlendingEquation.Add)
	            return _gl.FUNC_ADD;
	        if (p === exports.BlendingEquation.Subtract)
	            return _gl.FUNC_SUBTRACT;
	        if (p === exports.BlendingEquation.ReverseSubtract)
	            return _gl.FUNC_REVERSE_SUBTRACT;
	        if (p === exports.BlendingFactor.Zero)
	            return _gl.ZERO;
	        if (p === exports.BlendingFactor.One)
	            return _gl.ONE;
	        if (p === exports.BlendingFactor.SrcColor)
	            return _gl.SRC_COLOR;
	        if (p === exports.BlendingFactor.OneMinusSrcColor)
	            return _gl.ONE_MINUS_SRC_COLOR;
	        if (p === exports.BlendingFactor.SrcAlpha)
	            return _gl.SRC_ALPHA;
	        if (p === exports.BlendingFactor.OneMinusSrcAlpha)
	            return _gl.ONE_MINUS_SRC_ALPHA;
	        if (p === exports.BlendingFactor.DstAlpha)
	            return _gl.DST_ALPHA;
	        if (p === exports.BlendingFactor.OneMinusDstAlpha)
	            return _gl.ONE_MINUS_DST_ALPHA;
	        if (p === exports.BlendingFactor.DstColor)
	            return _gl.DST_COLOR;
	        if (p === exports.BlendingFactor.OneMinusDstColor)
	            return _gl.ONE_MINUS_DST_COLOR;
	        if (p === exports.BlendingFactor.SrcAlphaSaturate)
	            return _gl.SRC_ALPHA_SATURATE;
	        if (p === exports.TextureFormat.RGB_S3TC_DXT1 || p === exports.TextureFormat.RGBA_S3TC_DXT1 ||
	            p === exports.TextureFormat.RGBA_S3TC_DXT3 || p === exports.TextureFormat.RGBA_S3TC_DXT5) {
	            extension = this.extensions.get('WEBGL_compressed_texture_s3tc');
	            if (extension !== null) {
	                if (p === exports.TextureFormat.RGB_S3TC_DXT1)
	                    return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
	                if (p === exports.TextureFormat.RGBA_S3TC_DXT1)
	                    return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
	                if (p === exports.TextureFormat.RGBA_S3TC_DXT3)
	                    return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
	                if (p === exports.TextureFormat.RGBA_S3TC_DXT5)
	                    return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	            }
	        }
	        if (p === exports.TextureFormat.RGB_PVRTC_4BPPV1 || p === exports.TextureFormat.RGB_PVRTC_2BPPV1 ||
	            p === exports.TextureFormat.RGBA_PVRTC_4BPPV1 || p === exports.TextureFormat.RGBA_PVRTC_2BPPV1) {
	            extension = this.extensions.get('WEBGL_compressed_texture_pvrtc');
	            if (extension !== null) {
	                if (p === exports.TextureFormat.RGB_PVRTC_4BPPV1)
	                    return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
	                if (p === exports.TextureFormat.RGB_PVRTC_2BPPV1)
	                    return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
	                if (p === exports.TextureFormat.RGBA_PVRTC_4BPPV1)
	                    return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
	                if (p === exports.TextureFormat.RGBA_PVRTC_2BPPV1)
	                    return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	            }
	        }
	        if (p === exports.TextureFormat.RGB_ETC1) {
	            extension = this.extensions.get('WEBGL_compressed_texture_etc1');
	            if (extension !== null) {
	                if (p === exports.TextureFormat.RGB_ETC1)
	                    return extension.COMPRESSED_RGB_ETC1_WEBGL;
	            }
	        }
	        if (p === exports.BlendingEquation.Min || p === exports.BlendingEquation.Max) {
	            extension = this.extensions.get('EXT_blend_minmax');
	            if (extension !== null) {
	                if (p === exports.BlendingEquation.Min)
	                    return extension.MIN_EXT;
	                if (p === exports.BlendingEquation.Max)
	                    return extension.MAX_EXT;
	            }
	        }
	        if (p === exports.TextureType.UnsignedInt248) {
	            extension = this.extensions.get('WEBGL_depth_texture');
	            if (extension !== null)
	                return extension.UNSIGNED_INT_24_8_WEBGL;
	        }
	        return 0;
	    };
	    WebGLRenderer.prototype.supportsFloatTextures = function () {
	        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get(\"OES_texture_float\").");
	        return this.extensions.get("OES_texture_float");
	    };
	    WebGLRenderer.prototype.supportsHalfFloatTextures = function () {
	        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get(\"OES_texture_half_float\").");
	        return this.extensions.get("OES_texture_half_float");
	    };
	    WebGLRenderer.prototype.supportsStandardDerivatives = function () {
	        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get(\"OES_standard_derivatives\").");
	        return this.extensions.get("OES_standard_derivatives");
	    };
	    WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {
	        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get(\"WEBGL_compressed_texture_s3tc\").");
	        return this.extensions.get("WEBGL_compressed_texture_s3tc");
	    };
	    WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {
	        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get(\"WEBGL_compressed_texture_pvrtc\").");
	        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
	    };
	    WebGLRenderer.prototype.supportsBlendMinMax = function () {
	        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get(\"EXT_blend_minmax\").");
	        return this.extensions.get("EXT_blend_minmax");
	    };
	    WebGLRenderer.prototype.supportsVertexTextures = function () {
	        return this.capabilities.vertexTextures;
	    };
	    WebGLRenderer.prototype.supportsInstancedArrays = function () {
	        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get(\"ANGLE_instanced_arrays\").");
	        return this.extensions.get("ANGLE_instanced_arrays");
	    };
	    WebGLRenderer.prototype.enableScissorTest = function (test) {
	        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
	        this.setScissorTest(test);
	    };
	    //initMaterial() {
	    //  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
	    //}
	    WebGLRenderer.prototype.addPrePlugin = function () {
	        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
	    };
	    WebGLRenderer.prototype.addPostPlugin = function () {
	        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
	    };
	    WebGLRenderer.prototype.updateShadowMap = function () {
	        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
	    };
	    Object.defineProperty(WebGLRenderer.prototype, "shadowMapEnabled", {
	        get: function () {
	            return this.shadowMap.enabled;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
	            this.shadowMap.enabled = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderer.prototype, "shadowMapType", {
	        get: function () {
	            return this.shadowMap.type;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
	            this.shadowMap.type = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebGLRenderer.prototype, "shadowMapCullFace", {
	        get: function () {
	            return this.shadowMap.cullFace;
	        },
	        set: function (value) {
	            console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");
	            this.shadowMap.cullFace = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return WebGLRenderer;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Scene = /** @class */ (function (_super) {
	    __extends(Scene, _super);
	    function Scene() {
	        var _this = _super.call(this) || this;
	        _this.background = null;
	        _this.fog = null;
	        _this.overrideMaterial = null;
	        _this.autoUpdate = true; // checked by the renderer
	        _this.type = 'Scene';
	        return _this;
	    }
	    Scene.prototype.copy = function (source, recursive) {
	        _super.prototype.copy.call(this, source, recursive);
	        if (source.background !== null)
	            this.background = source.background.clone();
	        if (source.fog !== null)
	            this.fog = source.fog.clone();
	        if (source.overrideMaterial !== null)
	            this.overrideMaterial = source.overrideMaterial.clone();
	        this.autoUpdate = source.autoUpdate;
	        this.matrixAutoUpdate = source.matrixAutoUpdate;
	        return this;
	    };
	    Scene.prototype.toJSON = function (meta) {
	        var data = _super.prototype.toJSON.call(this, meta);
	        if (this.background !== null)
	            data.object.background = this.background.toJSON(meta);
	        if (this.fog !== null)
	            data.object.fog = this.fog.toJSON(meta);
	        return data;
	    };
	    return Scene;
	}(Object3D));

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	var LOD = /** @class */ (function (_super) {
	    __extends(LOD, _super);
	    function LOD() {
	        var _this = _super.call(this) || this;
	        _this.type = 'LOD';
	        _this.levels = [];
	        return _this;
	        //Object.defineProperties(this, {
	        //  levels: {
	        //    enumerable: true,
	        //    value: []
	        //  }
	        //});
	    }
	    LOD.prototype.copy = function (source) {
	        _super.prototype.copy.call(this, source, false);
	        var levels = source.levels;
	        for (var i = 0, l = levels.length; i < l; i++) {
	            var level = levels[i];
	            this.addLevel(level.object.clone(), level.distance);
	        }
	        return this;
	    };
	    LOD.prototype.addLevel = function (object, distance) {
	        if (distance === undefined)
	            distance = 0;
	        distance = Math.abs(distance);
	        var levels = this.levels;
	        var l;
	        for (l = 0; l < levels.length; l++) {
	            if (distance < levels[l].distance) {
	                break;
	            }
	        }
	        levels.splice(l, 0, { distance: distance, object: object });
	        this.add(object);
	    };
	    LOD.prototype.getObjectForDistance = function (distance) {
	        var levels = this.levels;
	        var i, l;
	        for (i = 1, l = levels.length; i < l; i++) {
	            if (distance < levels[i].distance) {
	                break;
	            }
	        }
	        return levels[i - 1].object;
	    };
	    LOD.prototype.raycast = function (raycaster, intersects) {
	        var matrixPosition = new Vector3();
	        //return function raycast(raycaster, intersects) {
	        matrixPosition.setFromMatrixPosition(this.matrixWorld);
	        var distance = raycaster.ray.origin.distanceTo(matrixPosition);
	        this.getObjectForDistance(distance).raycast(raycaster, intersects);
	        return intersects;
	        //};
	    };
	    LOD.prototype.update = function (camera) {
	        var v1 = new Vector3();
	        var v2 = new Vector3();
	        //return function update(camera) {
	        var levels = this.levels;
	        if (levels.length > 1) {
	            v1.setFromMatrixPosition(camera.matrixWorld);
	            v2.setFromMatrixPosition(this.matrixWorld);
	            var distance = v1.distanceTo(v2);
	            levels[0].object.visible = true;
	            var i = void 0, l = void 0;
	            for (i = 1, l = levels.length; i < l; i++) {
	                if (distance >= levels[i].distance) {
	                    levels[i - 1].object.visible = false;
	                    levels[i].object.visible = true;
	                }
	                else {
	                    break;
	                }
	            }
	            for (; i < l; i++) {
	                levels[i].object.visible = false;
	            }
	        }
	        //};
	    };
	    LOD.prototype.toJSON = function (meta) {
	        var data = _super.prototype.toJSON.call(this, meta);
	        data.object.levels = [];
	        var levels = this.levels;
	        for (var i = 0, l = levels.length; i < l; i++) {
	            var level = levels[i];
	            data.object.levels.push({
	                object: level.object.uuid,
	                distance: level.distance
	            });
	        }
	        return data;
	    };
	    Object.defineProperty(LOD.prototype, "objects", {
	        get: function () {
	            console.warn("THREE.LOD: .objects has been renamed to .levels.");
	            return this.levels;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return LOD;
	}(Object3D));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Group = /** @class */ (function (_super) {
	    __extends(Group, _super);
	    function Group() {
	        var _this = _super.call(this) || this;
	        _this.type = 'Group';
	        return _this;
	    }
	    return Group;
	}(Object3D));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var VideoTexture = /** @class */ (function (_super) {
	    __extends(VideoTexture, _super);
	    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
	        var _this = _super.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
	        _this.generateMipmaps = false;
	        var scope = _this;
	        function update() {
	            requestAnimationFrame(update);
	            if (video.readyState >= video.HAVE_CURRENT_DATA) {
	                scope.needsUpdate = true;
	            }
	        }
	        update();
	        return _this;
	    }
	    return VideoTexture;
	}(Texture));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var CanvasTexture = /** @class */ (function (_super) {
	    __extends(CanvasTexture, _super);
	    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
	        var _this = _super.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
	        _this.needsUpdate = true;
	        return _this;
	    }
	    return CanvasTexture;
	}(Texture));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var WireframeGeometry = /** @class */ (function (_super) {
	    __extends(WireframeGeometry, _super);
	    function WireframeGeometry(geometry) {
	        var _this = _super.call(this) || this;
	        var edge = [0, 0], hash = {};
	        function sortFunction(a, b) {
	            return a - b;
	        }
	        var keys = ['a', 'b', 'c'];
	        if (geometry && geometry instanceof Geometry) {
	            var vertices = geometry.vertices;
	            var faces = geometry.faces;
	            var numEdges = 0;
	            // allocate maximal size
	            var edges = new Uint32Array(6 * faces.length);
	            for (var i = 0, l = faces.length; i < l; i++) {
	                var face = faces[i];
	                for (var j = 0; j < 3; j++) {
	                    edge[0] = face[keys[j]];
	                    edge[1] = face[keys[(j + 1) % 3]];
	                    edge.sort(sortFunction);
	                    var key = edge.toString();
	                    if (hash[key] === undefined) {
	                        edges[2 * numEdges] = edge[0];
	                        edges[2 * numEdges + 1] = edge[1];
	                        hash[key] = true;
	                        numEdges++;
	                    }
	                }
	            }
	            var coords = new Float32Array(numEdges * 2 * 3);
	            for (var i = 0, l = numEdges; i < l; i++) {
	                for (var j = 0; j < 2; j++) {
	                    var vertex = vertices[edges[2 * i + j]];
	                    var index = 6 * i + 3 * j;
	                    coords[index + 0] = vertex.x;
	                    coords[index + 1] = vertex.y;
	                    coords[index + 2] = vertex.z;
	                }
	            }
	            _this.addAttribute('position', new BufferAttribute(coords, 3));
	        }
	        else if (geometry && geometry instanceof BufferGeometry) {
	            if (geometry.index !== null) {
	                // Indexed BufferGeometry
	                var indices = geometry.index.array;
	                var vertices = geometry.attributes.position;
	                var groups = geometry.groups;
	                var numEdges = 0;
	                if (groups.length === 0) {
	                    geometry.addGroup(0, indices.length);
	                }
	                // allocate maximal size
	                var edges = new Uint32Array(2 * indices.length);
	                for (var o = 0, ol = groups.length; o < ol; ++o) {
	                    var group = groups[o];
	                    var start = group.start;
	                    var count = group.count;
	                    for (var i = start, il = start + count; i < il; i += 3) {
	                        for (var j = 0; j < 3; j++) {
	                            edge[0] = indices[i + j];
	                            edge[1] = indices[i + (j + 1) % 3];
	                            edge.sort(sortFunction);
	                            var key = edge.toString();
	                            if (hash[key] === undefined) {
	                                edges[2 * numEdges] = edge[0];
	                                edges[2 * numEdges + 1] = edge[1];
	                                hash[key] = true;
	                                numEdges++;
	                            }
	                        }
	                    }
	                }
	                var coords = new Float32Array(numEdges * 2 * 3);
	                for (var i = 0, l = numEdges; i < l; i++) {
	                    for (var j = 0; j < 2; j++) {
	                        var index = 6 * i + 3 * j;
	                        var index2 = edges[2 * i + j];
	                        coords[index + 0] = vertices.getX(index2);
	                        coords[index + 1] = vertices.getY(index2);
	                        coords[index + 2] = vertices.getZ(index2);
	                    }
	                }
	                _this.addAttribute('position', new BufferAttribute(coords, 3));
	            }
	            else {
	                // non-indexed BufferGeometry
	                var vertices = geometry.attributes.position.array;
	                var numEdges = vertices.length / 3;
	                var numTris = numEdges / 3;
	                var coords = new Float32Array(numEdges * 2 * 3);
	                for (var i = 0, l = numTris; i < l; i++) {
	                    for (var j = 0; j < 3; j++) {
	                        var index = 18 * i + 6 * j;
	                        var index1 = 9 * i + 3 * j;
	                        coords[index + 0] = vertices[index1];
	                        coords[index + 1] = vertices[index1 + 1];
	                        coords[index + 2] = vertices[index1 + 2];
	                        var index2 = 9 * i + 3 * ((j + 1) % 3);
	                        coords[index + 3] = vertices[index2];
	                        coords[index + 4] = vertices[index2 + 1];
	                        coords[index + 5] = vertices[index2 + 2];
	                    }
	                }
	                _this.addAttribute('position', new BufferAttribute(coords, 3));
	            }
	        }
	        return _this;
	    }
	    return WireframeGeometry;
	}(BufferGeometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */
	var ParametricBufferGeometry = /** @class */ (function (_super) {
	    __extends(ParametricBufferGeometry, _super);
	    function ParametricBufferGeometry(func, slices, stacks) {
	        var _this = _super.call(this) || this;
	        _this.type = 'ParametricBufferGeometry';
	        _this.parameters = {
	            func: func,
	            slices: slices,
	            stacks: stacks
	        };
	        // generate vertices and uvs
	        var vertices = [];
	        var uvs = [];
	        var i, j, p;
	        var u, v;
	        var sliceCount = slices + 1;
	        for (i = 0; i <= stacks; i++) {
	            v = i / stacks;
	            for (j = 0; j <= slices; j++) {
	                u = j / slices;
	                p = func(u, v);
	                vertices.push(p.x, p.y, p.z);
	                uvs.push(u, v);
	            }
	        }
	        // generate indices
	        var indices = [];
	        var a, b, c, d;
	        for (i = 0; i < stacks; i++) {
	            for (j = 0; j < slices; j++) {
	                a = i * sliceCount + j;
	                b = i * sliceCount + j + 1;
	                c = (i + 1) * sliceCount + j + 1;
	                d = (i + 1) * sliceCount + j;
	                // faces one and two
	                indices.push(a, b, d);
	                indices.push(b, c, d);
	            }
	        }
	        // build geometry
	        _this.setIndex((indices.length > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
	        _this.addAttribute('position', Float32Attribute(vertices, 3));
	        _this.addAttribute('uv', Float32Attribute(uvs, 2));
	        // generate normals
	        _this.computeVertexNormals();
	        return _this;
	    }
	    return ParametricBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author zz85 / https://github.com/zz85
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */
	var ParametricGeometry = /** @class */ (function (_super) {
	    __extends(ParametricGeometry, _super);
	    function ParametricGeometry(func, slices, stacks) {
	        var _this = _super.call(this) || this;
	        _this.type = 'ParametricGeometry';
	        _this.parameters = {
	            func: func,
	            slices: slices,
	            stacks: stacks
	        };
	        _this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
	        _this.mergeVertices();
	        return _this;
	    }
	    return ParametricGeometry;
	}(Geometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	var PolyhedronBufferGeometry = /** @class */ (function (_super) {
	    __extends(PolyhedronBufferGeometry, _super);
	    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
	        var _this = _super.call(this) || this;
	        _this.type = 'PolyhedronBufferGeometry';
	        _this.parameters = {
	            vertices: vertices,
	            indices: indices,
	            radius: radius,
	            detail: detail
	        };
	        radius = radius || 1;
	        detail = detail || 0;
	        // default buffer data
	        var vertexBuffer = [];
	        var uvBuffer = [];
	        // the subdivision creates the vertex buffer data
	        subdivide(detail);
	        // all vertices should lie on a conceptual sphere with a given radius
	        appplyRadius(radius);
	        // finally, create the uv data
	        generateUVs();
	        // build non-indexed geometry
	        _this.addAttribute('position', Float32Attribute(vertexBuffer, 3));
	        _this.addAttribute('normal', Float32Attribute(vertexBuffer.slice(), 3));
	        _this.addAttribute('uv', Float32Attribute(uvBuffer, 2));
	        _this.normalizeNormals();
	        _this.boundingSphere = new Sphere(new Vector3(), radius);
	        // helper functions
	        function subdivide(detail) {
	            var a = new Vector3();
	            var b = new Vector3();
	            var c = new Vector3();
	            // iterate over all faces and apply a subdivison with the given detail value
	            for (var i = 0; i < indices.length; i += 3) {
	                // get the vertices of the face
	                getVertexByIndex(indices[i + 0], a);
	                getVertexByIndex(indices[i + 1], b);
	                getVertexByIndex(indices[i + 2], c);
	                // perform subdivision
	                subdivideFace(a, b, c, detail);
	            }
	        }
	        function subdivideFace(a, b, c, detail) {
	            var cols = Math.pow(2, detail);
	            // we use this multidimensional array as a data structure for creating the subdivision
	            var v = [];
	            var i, j;
	            // construct all of the vertices for this subdivision
	            for (i = 0; i <= cols; i++) {
	                v[i] = [];
	                var aj = a.clone().lerp(c, i / cols);
	                var bj = b.clone().lerp(c, i / cols);
	                var rows = cols - i;
	                for (j = 0; j <= rows; j++) {
	                    if (j === 0 && i === cols) {
	                        v[i][j] = aj;
	                    }
	                    else {
	                        v[i][j] = aj.clone().lerp(bj, j / rows);
	                    }
	                }
	            }
	            // construct all of the faces
	            for (i = 0; i < cols; i++) {
	                for (j = 0; j < 2 * (cols - i) - 1; j++) {
	                    var k = Math.floor(j / 2);
	                    if (j % 2 === 0) {
	                        pushVertex(v[i][k + 1]);
	                        pushVertex(v[i + 1][k]);
	                        pushVertex(v[i][k]);
	                    }
	                    else {
	                        pushVertex(v[i][k + 1]);
	                        pushVertex(v[i + 1][k + 1]);
	                        pushVertex(v[i + 1][k]);
	                    }
	                }
	            }
	        }
	        function appplyRadius(radius) {
	            var vertex = new Vector3();
	            // iterate over the entire buffer and apply the radius to each vertex
	            for (var i = 0; i < vertexBuffer.length; i += 3) {
	                vertex.x = vertexBuffer[i + 0];
	                vertex.y = vertexBuffer[i + 1];
	                vertex.z = vertexBuffer[i + 2];
	                vertex.normalize().multiplyScalar(radius);
	                vertexBuffer[i + 0] = vertex.x;
	                vertexBuffer[i + 1] = vertex.y;
	                vertexBuffer[i + 2] = vertex.z;
	            }
	        }
	        function generateUVs() {
	            var vertex = new Vector3();
	            for (var i = 0; i < vertexBuffer.length; i += 3) {
	                vertex.x = vertexBuffer[i + 0];
	                vertex.y = vertexBuffer[i + 1];
	                vertex.z = vertexBuffer[i + 2];
	                var u = azimuth(vertex) / 2 / Math.PI + 0.5;
	                var v = inclination(vertex) / Math.PI + 0.5;
	                uvBuffer.push(u, 1 - v);
	            }
	            correctUVs();
	            correctSeam();
	        }
	        function correctSeam() {
	            // handle case when face straddles the seam, see #3269
	            for (var i = 0; i < uvBuffer.length; i += 6) {
	                // uv data of a single face
	                var x0 = uvBuffer[i + 0];
	                var x1 = uvBuffer[i + 2];
	                var x2 = uvBuffer[i + 4];
	                var max = Math.max(x0, x1, x2);
	                var min = Math.min(x0, x1, x2);
	                // 0.9 is somewhat arbitrary
	                if (max > 0.9 && min < 0.1) {
	                    if (x0 < 0.2)
	                        uvBuffer[i + 0] += 1;
	                    if (x1 < 0.2)
	                        uvBuffer[i + 2] += 1;
	                    if (x2 < 0.2)
	                        uvBuffer[i + 4] += 1;
	                }
	            }
	        }
	        function pushVertex(vertex) {
	            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
	        }
	        function getVertexByIndex(index, vertex) {
	            var stride = index * 3;
	            vertex.x = vertices[stride + 0];
	            vertex.y = vertices[stride + 1];
	            vertex.z = vertices[stride + 2];
	        }
	        function correctUVs() {
	            var a = new Vector3();
	            var b = new Vector3();
	            var c = new Vector3();
	            var centroid = new Vector3();
	            var uvA = new Vector2();
	            var uvB = new Vector2();
	            var uvC = new Vector2();
	            for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
	                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
	                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
	                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
	                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
	                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
	                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
	                centroid.copy(a).add(b).add(c).divideScalar(3);
	                var azi = azimuth(centroid);
	                correctUV(uvA, j + 0, a, azi);
	                correctUV(uvB, j + 2, b, azi);
	                correctUV(uvC, j + 4, c, azi);
	            }
	        }
	        function correctUV(uv, stride, vector, azimuth) {
	            if ((azimuth < 0) && (uv.x === 1)) {
	                uvBuffer[stride] = uv.x - 1;
	            }
	            if ((vector.x === 0) && (vector.z === 0)) {
	                uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
	            }
	        }
	        // Angle around the Y axis, counter-clockwise when looking from above.
	        function azimuth(vector) {
	            return Math.atan2(vector.z, -vector.x);
	        }
	        // Angle above the XZ plane.
	        function inclination(vector) {
	            return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
	        }
	        return _this;
	    }
	    return PolyhedronBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	var TetrahedronBufferGeometry = /** @class */ (function (_super) {
	    __extends(TetrahedronBufferGeometry, _super);
	    function TetrahedronBufferGeometry(radius, detail) {
	        var _this = this;
	        var vertices = [
	            1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
	        ];
	        var indices = [
	            2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
	        ];
	        _this = _super.call(this, vertices, indices, radius, detail) || this;
	        _this.type = 'TetrahedronBufferGeometry';
	        _this.parameters = {
	            radius: radius,
	            detail: detail
	        };
	        return _this;
	    }
	    return TetrahedronBufferGeometry;
	}(PolyhedronBufferGeometry));

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	var TetrahedronGeometry = /** @class */ (function (_super) {
	    __extends(TetrahedronGeometry, _super);
	    function TetrahedronGeometry(radius, detail) {
	        var _this = _super.call(this) || this;
	        _this.type = 'TetrahedronGeometry';
	        _this.parameters = {
	            radius: radius,
	            detail: detail
	        };
	        _this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
	        _this.mergeVertices();
	        return _this;
	    }
	    return TetrahedronGeometry;
	}(Geometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	var OctahedronBufferGeometry = /** @class */ (function (_super) {
	    __extends(OctahedronBufferGeometry, _super);
	    function OctahedronBufferGeometry(radius, detail) {
	        var _this = this;
	        var vertices = [
	            1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1
	        ];
	        var indices = [
	            0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2
	        ];
	        _this = _super.call(this, vertices, indices, radius, detail) || this;
	        _this.type = 'OctahedronBufferGeometry';
	        _this.parameters = {
	            radius: radius,
	            detail: detail
	        };
	        return _this;
	    }
	    return OctahedronBufferGeometry;
	}(PolyhedronBufferGeometry));

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	var OctahedronGeometry = /** @class */ (function (_super) {
	    __extends(OctahedronGeometry, _super);
	    function OctahedronGeometry(radius, detail) {
	        var _this = _super.call(this) || this;
	        _this.type = 'OctahedronGeometry';
	        _this.parameters = {
	            radius: radius,
	            detail: detail
	        };
	        _this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
	        _this.mergeVertices();
	        return _this;
	    }
	    return OctahedronGeometry;
	}(Geometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	var IcosahedronBufferGeometry = /** @class */ (function (_super) {
	    __extends(IcosahedronBufferGeometry, _super);
	    function IcosahedronBufferGeometry(radius, detail) {
	        var _this = this;
	        var t = (1 + Math.sqrt(5)) / 2;
	        var vertices = [
	            -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
	            0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
	            t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
	        ];
	        var indices = [
	            0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
	            1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
	            3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
	            4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
	        ];
	        _this = _super.call(this, vertices, indices, radius, detail) || this;
	        _this.type = 'IcosahedronBufferGeometry';
	        _this.parameters = {
	            radius: radius,
	            detail: detail
	        };
	        return _this;
	    }
	    return IcosahedronBufferGeometry;
	}(PolyhedronBufferGeometry));

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	var IcosahedronGeometry = /** @class */ (function (_super) {
	    __extends(IcosahedronGeometry, _super);
	    function IcosahedronGeometry(radius, detail) {
	        var _this = _super.call(this) || this;
	        _this.type = 'IcosahedronGeometry';
	        _this.parameters = {
	            radius: radius,
	            detail: detail
	        };
	        _this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
	        _this.mergeVertices();
	        return _this;
	    }
	    return IcosahedronGeometry;
	}(Geometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	var DodecahedronBufferGeometry = /** @class */ (function (_super) {
	    __extends(DodecahedronBufferGeometry, _super);
	    function DodecahedronBufferGeometry(radius, detail) {
	        var _this = this;
	        var t = (1 + Math.sqrt(5)) / 2;
	        var r = 1 / t;
	        var vertices = [
	            // (±1, ±1, ±1)
	            -1, -1, -1, -1, -1, 1,
	            -1, 1, -1, -1, 1, 1,
	            1, -1, -1, 1, -1, 1,
	            1, 1, -1, 1, 1, 1,
	            // (0, ±1/φ, ±φ)
	            0, -r, -t, 0, -r, t,
	            0, r, -t, 0, r, t,
	            // (±1/φ, ±φ, 0)
	            -r, -t, 0, -r, t, 0,
	            r, -t, 0, r, t, 0,
	            // (±φ, 0, ±1/φ)
	            -t, 0, -r, t, 0, -r,
	            -t, 0, r, t, 0, r
	        ];
	        var indices = [
	            3, 11, 7, 3, 7, 15, 3, 15, 13,
	            7, 19, 17, 7, 17, 6, 7, 6, 15,
	            17, 4, 8, 17, 8, 10, 17, 10, 6,
	            8, 0, 16, 8, 16, 2, 8, 2, 10,
	            0, 12, 1, 0, 1, 18, 0, 18, 16,
	            6, 10, 2, 6, 2, 13, 6, 13, 15,
	            2, 16, 18, 2, 18, 3, 2, 3, 13,
	            18, 1, 9, 18, 9, 11, 18, 11, 3,
	            4, 14, 12, 4, 12, 0, 4, 0, 8,
	            11, 9, 5, 11, 5, 19, 11, 19, 7,
	            19, 5, 14, 19, 14, 4, 19, 4, 17,
	            1, 12, 14, 1, 14, 5, 1, 5, 9
	        ];
	        _this = _super.call(this, vertices, indices, radius, detail) || this;
	        _this.type = 'DodecahedronBufferGeometry';
	        _this.parameters = {
	            radius: radius,
	            detail: detail
	        };
	        return _this;
	    }
	    return DodecahedronBufferGeometry;
	}(PolyhedronBufferGeometry));

	/**
	 * @author Abe Pazos / https://hamoid.com
	 */
	var DodecahedronGeometry = /** @class */ (function (_super) {
	    __extends(DodecahedronGeometry, _super);
	    function DodecahedronGeometry(radius, detail) {
	        var _this = _super.call(this) || this;
	        _this.type = 'DodecahedronGeometry';
	        _this.parameters = {
	            radius: radius,
	            detail: detail
	        };
	        _this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
	        _this.mergeVertices();
	        return _this;
	    }
	    return DodecahedronGeometry;
	}(Geometry));

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/
	function PolyhedronGeometry(vertices, indices, radius, detail) {
	    Geometry.call(this);
	    this.type = 'PolyhedronGeometry';
	    this.parameters = {
	        vertices: vertices,
	        indices: indices,
	        radius: radius,
	        detail: detail
	    };
	    this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
	    this.mergeVertices();
	}
	PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Creates a tube which extrudes along a 3d spline.
	 *
	 */
	var TubeBufferGeometry = /** @class */ (function (_super) {
	    __extends(TubeBufferGeometry, _super);
	    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
	        var _this = _super.call(this) || this;
	        _this.type = 'TubeBufferGeometry';
	        _this.parameters = {
	            path: path,
	            tubularSegments: tubularSegments,
	            radius: radius,
	            radialSegments: radialSegments,
	            closed: closed
	        };
	        tubularSegments = tubularSegments || 64;
	        radius = radius || 1;
	        radialSegments = radialSegments || 8;
	        closed = closed || false;
	        var frames = path.computeFrenetFrames(tubularSegments, closed);
	        // expose internals
	        _this.tangents = frames.tangents;
	        _this.normals = frames.normals;
	        _this.binormals = frames.binormals;
	        // helper variables
	        var vertex = new Vector3();
	        var normal = new Vector3();
	        var uv = new Vector2();
	        // buffer
	        var vertices = [];
	        var normals = [];
	        var uvs = [];
	        var indices = [];
	        // create buffer data
	        generateBufferData();
	        // build geometry
	        _this.setIndex((indices.length > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
	        _this.addAttribute('position', Float32Attribute(vertices, 3));
	        _this.addAttribute('normal', Float32Attribute(normals, 3));
	        _this.addAttribute('uv', Float32Attribute(uvs, 2));
	        // functions
	        function generateBufferData() {
	            for (var i = 0; i < tubularSegments; i++) {
	                generateSegment(i);
	            }
	            // if the geometry is not closed, generate the last row of vertices and normals
	            // at the regular position on the given path
	            //
	            // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
	            generateSegment((closed === false) ? tubularSegments : 0);
	            // uvs are generated in a separate function.
	            // this makes it easy compute correct values for closed geometries
	            generateUVs();
	            // finally create faces
	            generateIndices();
	        }
	        function generateSegment(i) {
	            // we use getPointAt to sample evenly distributed points from the given path
	            var P = path.getPointAt(i / tubularSegments);
	            // retrieve corresponding normal and binormal
	            var N = frames.normals[i];
	            var B = frames.binormals[i];
	            // generate normals and vertices for the current segment
	            for (var j = 0; j <= radialSegments; j++) {
	                var v = j / radialSegments * Math.PI * 2;
	                var sin = Math.sin(v);
	                var cos = -Math.cos(v);
	                // normal
	                normal.x = (cos * N.x + sin * B.x);
	                normal.y = (cos * N.y + sin * B.y);
	                normal.z = (cos * N.z + sin * B.z);
	                normal.normalize();
	                normals.push(normal.x, normal.y, normal.z);
	                // vertex
	                vertex.x = P.x + radius * normal.x;
	                vertex.y = P.y + radius * normal.y;
	                vertex.z = P.z + radius * normal.z;
	                vertices.push(vertex.x, vertex.y, vertex.z);
	            }
	        }
	        function generateIndices() {
	            for (var j = 1; j <= tubularSegments; j++) {
	                for (var i = 1; i <= radialSegments; i++) {
	                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
	                    var b = (radialSegments + 1) * j + (i - 1);
	                    var c = (radialSegments + 1) * j + i;
	                    var d = (radialSegments + 1) * (j - 1) + i;
	                    // faces
	                    indices.push(a, b, d);
	                    indices.push(b, c, d);
	                }
	            }
	        }
	        function generateUVs() {
	            for (var i = 0; i <= tubularSegments; i++) {
	                for (var j = 0; j <= radialSegments; j++) {
	                    uv.x = i / tubularSegments;
	                    uv.y = j / radialSegments;
	                    uvs.push(uv.x, uv.y);
	                }
	            }
	        }
	        return _this;
	    }
	    return TubeBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author oosmoxiecode / https://github.com/oosmoxiecode
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Creates a tube which extrudes along a 3d spline.
	 */
	var TubeGeometry = /** @class */ (function (_super) {
	    __extends(TubeGeometry, _super);
	    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
	        var _this = _super.call(this) || this;
	        _this.type = 'TubeGeometry';
	        _this.parameters = {
	            path: path,
	            tubularSegments: tubularSegments,
	            radius: radius,
	            radialSegments: radialSegments,
	            closed: closed
	        };
	        if (taper !== undefined)
	            console.warn('THREE.TubeGeometry: taper has been removed.');
	        var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
	        // expose internals
	        _this.tangents = bufferGeometry.tangents;
	        _this.normals = bufferGeometry.normals;
	        _this.binormals = bufferGeometry.binormals;
	        // create geometry
	        _this.fromBufferGeometry(bufferGeometry);
	        _this.mergeVertices();
	        return _this;
	    }
	    return TubeGeometry;
	}(Geometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * see: http://www.blackpawn.com/texts/pqtorus/
	 */
	var TorusKnotBufferGeometry = /** @class */ (function (_super) {
	    __extends(TorusKnotBufferGeometry, _super);
	    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
	        var _this = _super.call(this) || this;
	        _this.type = 'TorusKnotBufferGeometry';
	        _this.parameters = {
	            radius: radius,
	            tube: tube,
	            tubularSegments: tubularSegments,
	            radialSegments: radialSegments,
	            p: p,
	            q: q
	        };
	        radius = radius || 100;
	        tube = tube || 40;
	        tubularSegments = Math.floor(tubularSegments) || 64;
	        radialSegments = Math.floor(radialSegments) || 8;
	        p = p || 2;
	        q = q || 3;
	        // used to calculate buffer length
	        var vertexCount = ((radialSegments + 1) * (tubularSegments + 1));
	        var indexCount = radialSegments * tubularSegments * 2 * 3;
	        // buffers
	        var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
	        var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
	        var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
	        var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
	        // helper variables
	        var index = 0, indexOffset = 0;
	        var vertex = new Vector3();
	        var normal = new Vector3();
	        var uv = new Vector2();
	        var P1 = new Vector3();
	        var P2 = new Vector3();
	        var B = new Vector3();
	        var T = new Vector3();
	        var N = new Vector3();
	        // generate vertices, normals and uvs
	        for (var i = 0; i <= tubularSegments; ++i) {
	            // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
	            var u = i / tubularSegments * p * Math.PI * 2;
	            // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
	            // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
	            calculatePositionOnCurve(u, p, q, radius, P1);
	            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
	            // calculate orthonormal basis
	            T.subVectors(P2, P1);
	            N.addVectors(P2, P1);
	            B.crossVectors(T, N);
	            N.crossVectors(B, T);
	            // normalize B, N. T can be ignored, we don't use it
	            B.normalize();
	            N.normalize();
	            for (var j = 0; j <= radialSegments; ++j) {
	                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
	                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
	                var v = j / radialSegments * Math.PI * 2;
	                var cx = -tube * Math.cos(v);
	                var cy = tube * Math.sin(v);
	                // now calculate the final vertex position.
	                // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
	                vertex.x = P1.x + (cx * N.x + cy * B.x);
	                vertex.y = P1.y + (cx * N.y + cy * B.y);
	                vertex.z = P1.z + (cx * N.z + cy * B.z);
	                // vertex
	                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
	                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
	                normal.subVectors(vertex, P1).normalize();
	                normals.setXYZ(index, normal.x, normal.y, normal.z);
	                // uv
	                uv.x = i / tubularSegments;
	                uv.y = j / radialSegments;
	                uvs.setXY(index, uv.x, uv.y);
	                // increase index
	                index++;
	            }
	        }
	        // generate indices
	        for (var j = 1; j <= tubularSegments; j++) {
	            for (var i = 1; i <= radialSegments; i++) {
	                // indices
	                var a = (radialSegments + 1) * (j - 1) + (i - 1);
	                var b = (radialSegments + 1) * j + (i - 1);
	                var c = (radialSegments + 1) * j + i;
	                var d = (radialSegments + 1) * (j - 1) + i;
	                // face one
	                indices.setX(indexOffset, a);
	                indexOffset++;
	                indices.setX(indexOffset, b);
	                indexOffset++;
	                indices.setX(indexOffset, d);
	                indexOffset++;
	                // face two
	                indices.setX(indexOffset, b);
	                indexOffset++;
	                indices.setX(indexOffset, c);
	                indexOffset++;
	                indices.setX(indexOffset, d);
	                indexOffset++;
	            }
	        }
	        // build geometry
	        _this.setIndex(indices);
	        _this.addAttribute('position', vertices);
	        _this.addAttribute('normal', normals);
	        _this.addAttribute('uv', uvs);
	        // this function calculates the current position on the torus curve
	        function calculatePositionOnCurve(u, p, q, radius, position) {
	            var cu = Math.cos(u);
	            var su = Math.sin(u);
	            var quOverP = q / p * u;
	            var cs = Math.cos(quOverP);
	            position.x = radius * (2 + cs) * 0.5 * cu;
	            position.y = radius * (2 + cs) * su * 0.5;
	            position.z = radius * Math.sin(quOverP) * 0.5;
	        }
	        return _this;
	    }
	    return TorusKnotBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author oosmoxiecode
	 */
	var TorusKnotGeometry = /** @class */ (function (_super) {
	    __extends(TorusKnotGeometry, _super);
	    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
	        var _this = _super.call(this) || this;
	        _this.type = 'TorusKnotGeometry';
	        _this.parameters = {
	            radius: radius,
	            tube: tube,
	            tubularSegments: tubularSegments,
	            radialSegments: radialSegments,
	            p: p,
	            q: q
	        };
	        if (heightScale !== undefined)
	            console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale(x, y, z) instead.');
	        _this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
	        _this.mergeVertices();
	        return _this;
	    }
	    return TorusKnotGeometry;
	}(Geometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	var TorusBufferGeometry = /** @class */ (function (_super) {
	    __extends(TorusBufferGeometry, _super);
	    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
	        var _this = _super.call(this) || this;
	        _this.type = 'TorusBufferGeometry';
	        _this.parameters = {
	            radius: radius,
	            tube: tube,
	            radialSegments: radialSegments,
	            tubularSegments: tubularSegments,
	            arc: arc
	        };
	        radius = radius || 100;
	        tube = tube || 40;
	        radialSegments = Math.floor(radialSegments) || 8;
	        tubularSegments = Math.floor(tubularSegments) || 6;
	        arc = arc || Math.PI * 2;
	        // used to calculate buffer length
	        var vertexCount = ((radialSegments + 1) * (tubularSegments + 1));
	        var indexCount = radialSegments * tubularSegments * 2 * 3;
	        // buffers
	        var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
	        var vertices = new Float32Array(vertexCount * 3);
	        var normals = new Float32Array(vertexCount * 3);
	        var uvs = new Float32Array(vertexCount * 2);
	        // offset variables
	        var vertexBufferOffset = 0;
	        var uvBufferOffset = 0;
	        var indexBufferOffset = 0;
	        // helper variables
	        var center = new Vector3();
	        var vertex = new Vector3();
	        var normal = new Vector3();
	        // generate vertices, normals and uvs
	        for (var j = 0; j <= radialSegments; j++) {
	            for (var i = 0; i <= tubularSegments; i++) {
	                var u = i / tubularSegments * arc;
	                var v = j / radialSegments * Math.PI * 2;
	                // vertex
	                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
	                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
	                vertex.z = tube * Math.sin(v);
	                vertices[vertexBufferOffset] = vertex.x;
	                vertices[vertexBufferOffset + 1] = vertex.y;
	                vertices[vertexBufferOffset + 2] = vertex.z;
	                // this vector is used to calculate the normal
	                center.x = radius * Math.cos(u);
	                center.y = radius * Math.sin(u);
	                // normal
	                normal.subVectors(vertex, center).normalize();
	                normals[vertexBufferOffset] = normal.x;
	                normals[vertexBufferOffset + 1] = normal.y;
	                normals[vertexBufferOffset + 2] = normal.z;
	                // uv
	                uvs[uvBufferOffset] = i / tubularSegments;
	                uvs[uvBufferOffset + 1] = j / radialSegments;
	                // update offsets
	                vertexBufferOffset += 3;
	                uvBufferOffset += 2;
	            }
	        }
	        // generate indices
	        for (var j = 1; j <= radialSegments; j++) {
	            for (var i = 1; i <= tubularSegments; i++) {
	                // indices
	                var a = (tubularSegments + 1) * j + i - 1;
	                var b = (tubularSegments + 1) * (j - 1) + i - 1;
	                var c = (tubularSegments + 1) * (j - 1) + i;
	                var d = (tubularSegments + 1) * j + i;
	                // face one
	                indices[indexBufferOffset] = a;
	                indices[indexBufferOffset + 1] = b;
	                indices[indexBufferOffset + 2] = d;
	                // face two
	                indices[indexBufferOffset + 3] = b;
	                indices[indexBufferOffset + 4] = c;
	                indices[indexBufferOffset + 5] = d;
	                // update offset
	                indexBufferOffset += 6;
	            }
	        }
	        // build geometry
	        _this.setIndex(new BufferAttribute(indices, 1));
	        _this.addAttribute('position', new BufferAttribute(vertices, 3));
	        _this.addAttribute('normal', new BufferAttribute(normals, 3));
	        _this.addAttribute('uv', new BufferAttribute(uvs, 2));
	        return _this;
	    }
	    return TorusBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */
	var TorusGeometry = /** @class */ (function (_super) {
	    __extends(TorusGeometry, _super);
	    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
	        var _this = _super.call(this) || this;
	        _this.type = 'TorusGeometry';
	        _this.parameters = {
	            radius: radius,
	            tube: tube,
	            radialSegments: radialSegments,
	            tubularSegments: tubularSegments,
	            arc: arc
	        };
	        _this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
	        return _this;
	    }
	    return TorusGeometry;
	}(Geometry));

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	var ShapeUtils = /** @class */ (function () {
	    function ShapeUtils() {
	    }
	    // calculate area of the contour polygon
	    ShapeUtils.area = function (contour) {
	        var n = contour.length;
	        var a = 0.0;
	        for (var p = n - 1, q = 0; q < n; p = q++) {
	            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
	        }
	        return a * 0.5;
	    };
	    ShapeUtils.triangulate = function (contour, indices) {
	        /**
	         * This code is a quick port of code written in C++ which was submitted to
	         * flipcode.com by John W. Ratcliff  // July 22, 2000
	         * See original code and more information here:
	         * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
	         *
	         * ported to actionscript by Zevan Rosser
	         * www.actionsnippet.com
	         *
	         * ported to javascript by Joshua Koo
	         * http://www.lab4games.net/zz85/blog
	         *
	         */
	        function snip(contour, u, v, w, n, verts) {
	            var p;
	            var ax, ay, bx, by;
	            var cx, cy, px, py;
	            ax = contour[verts[u]].x;
	            ay = contour[verts[u]].y;
	            bx = contour[verts[v]].x;
	            by = contour[verts[v]].y;
	            cx = contour[verts[w]].x;
	            cy = contour[verts[w]].y;
	            if ((bx - ax) * (cy - ay) - (by - ay) * (cx - ax) <= 0)
	                return false;
	            var aX, aY, bX, bY, cX, cY;
	            var apx, apy, bpx, bpy, cpx, cpy;
	            var cCROSSap, bCROSScp, aCROSSbp;
	            aX = cx - bx;
	            aY = cy - by;
	            bX = ax - cx;
	            bY = ay - cy;
	            cX = bx - ax;
	            cY = by - ay;
	            for (p = 0; p < n; p++) {
	                px = contour[verts[p]].x;
	                py = contour[verts[p]].y;
	                if (((px === ax) && (py === ay)) ||
	                    ((px === bx) && (py === by)) ||
	                    ((px === cx) && (py === cy)))
	                    continue;
	                apx = px - ax;
	                apy = py - ay;
	                bpx = px - bx;
	                bpy = py - by;
	                cpx = px - cx;
	                cpy = py - cy;
	                // see if p is inside triangle abc
	                aCROSSbp = aX * bpy - aY * bpx;
	                cCROSSap = cX * apy - cY * apx;
	                bCROSScp = bX * cpy - bY * cpx;
	                if ((aCROSSbp >= -Number.EPSILON) && (bCROSScp >= -Number.EPSILON) && (cCROSSap >= -Number.EPSILON))
	                    return false;
	            }
	            return true;
	        }
	        // takes in an contour array and returns
	        //return function triangulate(contour, indices) {
	        var n = contour.length;
	        if (n < 3)
	            return null;
	        var result = [];
	        var verts = [];
	        var vertIndices = [];
	        /* we want a counter-clockwise polygon in verts */
	        var u, v, w;
	        if (ShapeUtils.area(contour) > 0.0) {
	            for (v = 0; v < n; v++)
	                verts[v] = v;
	        }
	        else {
	            for (v = 0; v < n; v++)
	                verts[v] = (n - 1) - v;
	        }
	        var nv = n;
	        /*  remove nv - 2 vertices, creating 1 triangle every time */
	        var count = 2 * nv; /* error detection */
	        for (v = nv - 1; nv > 2;) {
	            /* if we loop, it is probably a non-simple polygon */
	            if ((count--) <= 0) {
	                //** Triangulate: ERROR - probable bad polygon!
	                //throw ("Warning, unable to triangulate polygon!");
	                //return null;
	                // Sometimes warning is fine, especially polygons are triangulated in reverse.
	                console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');
	                if (indices)
	                    return vertIndices;
	                return result;
	            }
	            /* three consecutive vertices in current polygon, <u,v,w> */
	            u = v;
	            if (nv <= u)
	                u = 0; /* previous */
	            v = u + 1;
	            if (nv <= v)
	                v = 0; /* new v    */
	            w = v + 1;
	            if (nv <= w)
	                w = 0; /* next     */
	            if (snip(contour, u, v, w, nv, verts)) {
	                var a = void 0, b = void 0, c = void 0, s = void 0, t = void 0;
	                /* true names of the vertices */
	                a = verts[u];
	                b = verts[v];
	                c = verts[w];
	                /* output Triangle */
	                result.push([contour[a], contour[b], contour[c]]);
	                vertIndices.push([verts[u], verts[v], verts[w]]);
	                /* remove v from the remaining polygon */
	                for (s = v, t = v + 1; t < nv; s++, t++) {
	                    verts[s] = verts[t];
	                }
	                nv--;
	                /* reset error detection counter */
	                count = 2 * nv;
	            }
	        }
	        if (indices)
	            return vertIndices;
	        return result;
	        //};
	    };
	    ShapeUtils.triangulateShape = function (contour, holes) {
	        function removeDupEndPts(points) {
	            var l = points.length;
	            if (l > 2 && points[l - 1].equals(points[0])) {
	                points.pop();
	            }
	        }
	        removeDupEndPts(contour);
	        holes.forEach(removeDupEndPts);
	        function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
	            // inOtherPt needs to be collinear to the inSegment
	            if (inSegPt1.x !== inSegPt2.x) {
	                if (inSegPt1.x < inSegPt2.x) {
	                    return ((inSegPt1.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt2.x));
	                }
	                else {
	                    return ((inSegPt2.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt1.x));
	                }
	            }
	            else {
	                if (inSegPt1.y < inSegPt2.y) {
	                    return ((inSegPt1.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt2.y));
	                }
	                else {
	                    return ((inSegPt2.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt1.y));
	                }
	            }
	        }
	        function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
	            var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
	            var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
	            var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
	            var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
	            var limit = seg1dy * seg2dx - seg1dx * seg2dy;
	            var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
	            if (Math.abs(limit) > Number.EPSILON) {
	                // not parallel
	                var perpSeg2 = void 0;
	                if (limit > 0) {
	                    if ((perpSeg1 < 0) || (perpSeg1 > limit))
	                        return [];
	                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
	                    if ((perpSeg2 < 0) || (perpSeg2 > limit))
	                        return [];
	                }
	                else {
	                    if ((perpSeg1 > 0) || (perpSeg1 < limit))
	                        return [];
	                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
	                    if ((perpSeg2 > 0) || (perpSeg2 < limit))
	                        return [];
	                }
	                // i.e. to reduce rounding errors
	                // intersection at endpoint of segment#1?
	                if (perpSeg2 === 0) {
	                    if ((inExcludeAdjacentSegs) &&
	                        ((perpSeg1 === 0) || (perpSeg1 === limit)))
	                        return [];
	                    return [inSeg1Pt1];
	                }
	                if (perpSeg2 === limit) {
	                    if ((inExcludeAdjacentSegs) &&
	                        ((perpSeg1 === 0) || (perpSeg1 === limit)))
	                        return [];
	                    return [inSeg1Pt2];
	                }
	                // intersection at endpoint of segment#2?
	                if (perpSeg1 === 0)
	                    return [inSeg2Pt1];
	                if (perpSeg1 === limit)
	                    return [inSeg2Pt2];
	                // return real intersection point
	                var factorSeg1 = perpSeg2 / limit;
	                return [new Vector2(inSeg1Pt1.x + factorSeg1 * seg1dx, inSeg1Pt1.y + factorSeg1 * seg1dy)];
	            }
	            else {
	                // parallel or collinear
	                if ((perpSeg1 !== 0) ||
	                    (seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy))
	                    return [];
	                // they are collinear or degenerate
	                var seg1Pt = ((seg1dx === 0) && (seg1dy === 0)); // segment1 is just a point?
	                var seg2Pt = ((seg2dx === 0) && (seg2dy === 0)); // segment2 is just a point?
	                // both segments are points
	                if (seg1Pt && seg2Pt) {
	                    if ((inSeg1Pt1.x !== inSeg2Pt1.x) || (inSeg1Pt1.y !== inSeg2Pt1.y))
	                        return []; // they are distinct  points
	                    return [inSeg1Pt1]; // they are the same point
	                }
	                // segment#1  is a single point
	                if (seg1Pt) {
	                    if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
	                        return []; // but not in segment#2
	                    return [inSeg1Pt1];
	                }
	                // segment#2  is a single point
	                if (seg2Pt) {
	                    if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
	                        return []; // but not in segment#1
	                    return [inSeg2Pt1];
	                }
	                // they are collinear segments, which might overlap
	                var seg1min = void 0, seg1max = void 0, seg1minVal = void 0, seg1maxVal = void 0;
	                var seg2min = void 0, seg2max = void 0, seg2minVal = void 0, seg2maxVal = void 0;
	                if (seg1dx !== 0) {
	                    // the segments are NOT on a vertical line
	                    if (inSeg1Pt1.x < inSeg1Pt2.x) {
	                        seg1min = inSeg1Pt1;
	                        seg1minVal = inSeg1Pt1.x;
	                        seg1max = inSeg1Pt2;
	                        seg1maxVal = inSeg1Pt2.x;
	                    }
	                    else {
	                        seg1min = inSeg1Pt2;
	                        seg1minVal = inSeg1Pt2.x;
	                        seg1max = inSeg1Pt1;
	                        seg1maxVal = inSeg1Pt1.x;
	                    }
	                    if (inSeg2Pt1.x < inSeg2Pt2.x) {
	                        seg2min = inSeg2Pt1;
	                        seg2minVal = inSeg2Pt1.x;
	                        seg2max = inSeg2Pt2;
	                        seg2maxVal = inSeg2Pt2.x;
	                    }
	                    else {
	                        seg2min = inSeg2Pt2;
	                        seg2minVal = inSeg2Pt2.x;
	                        seg2max = inSeg2Pt1;
	                        seg2maxVal = inSeg2Pt1.x;
	                    }
	                }
	                else {
	                    // the segments are on a vertical line
	                    if (inSeg1Pt1.y < inSeg1Pt2.y) {
	                        seg1min = inSeg1Pt1;
	                        seg1minVal = inSeg1Pt1.y;
	                        seg1max = inSeg1Pt2;
	                        seg1maxVal = inSeg1Pt2.y;
	                    }
	                    else {
	                        seg1min = inSeg1Pt2;
	                        seg1minVal = inSeg1Pt2.y;
	                        seg1max = inSeg1Pt1;
	                        seg1maxVal = inSeg1Pt1.y;
	                    }
	                    if (inSeg2Pt1.y < inSeg2Pt2.y) {
	                        seg2min = inSeg2Pt1;
	                        seg2minVal = inSeg2Pt1.y;
	                        seg2max = inSeg2Pt2;
	                        seg2maxVal = inSeg2Pt2.y;
	                    }
	                    else {
	                        seg2min = inSeg2Pt2;
	                        seg2minVal = inSeg2Pt2.y;
	                        seg2max = inSeg2Pt1;
	                        seg2maxVal = inSeg2Pt1.y;
	                    }
	                }
	                if (seg1minVal <= seg2minVal) {
	                    if (seg1maxVal < seg2minVal)
	                        return [];
	                    if (seg1maxVal === seg2minVal) {
	                        if (inExcludeAdjacentSegs)
	                            return [];
	                        return [seg2min];
	                    }
	                    if (seg1maxVal <= seg2maxVal)
	                        return [seg2min, seg1max];
	                    return [seg2min, seg2max];
	                }
	                else {
	                    if (seg1minVal > seg2maxVal)
	                        return [];
	                    if (seg1minVal === seg2maxVal) {
	                        if (inExcludeAdjacentSegs)
	                            return [];
	                        return [seg1min];
	                    }
	                    if (seg1maxVal <= seg2maxVal)
	                        return [seg1min, seg1max];
	                    return [seg1min, seg2max];
	                }
	            }
	        }
	        function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
	            // The order of legs is important
	            // translation of all points, so that Vertex is at (0,0)
	            var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
	            var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
	            var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;
	            // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
	            var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
	            var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
	            if (Math.abs(from2toAngle) > Number.EPSILON) {
	                // angle != 180 deg.
	                var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
	                // console.log("from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle);
	                if (from2toAngle > 0) {
	                    // main angle < 180 deg.
	                    return ((from2otherAngle >= 0) && (other2toAngle >= 0));
	                }
	                else {
	                    // main angle > 180 deg.
	                    return ((from2otherAngle >= 0) || (other2toAngle >= 0));
	                }
	            }
	            else {
	                // angle == 180 deg.
	                // console.log("from2to: 180 deg., from2other: " + from2otherAngle);
	                return (from2otherAngle > 0);
	            }
	        }
	        function removeHoles(contour, holes) {
	            var shape = contour.concat(); // work on this shape
	            var hole;
	            function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
	                // Check if hole point lies within angle around shape point
	                var lastShapeIdx = shape.length - 1;
	                var prevShapeIdx = inShapeIdx - 1;
	                if (prevShapeIdx < 0)
	                    prevShapeIdx = lastShapeIdx;
	                var nextShapeIdx = inShapeIdx + 1;
	                if (nextShapeIdx > lastShapeIdx)
	                    nextShapeIdx = 0;
	                var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
	                if (!insideAngle) {
	                    // console.log("Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y);
	                    return false;
	                }
	                // Check if shape point lies within angle around hole point
	                var lastHoleIdx = hole.length - 1;
	                var prevHoleIdx = inHoleIdx - 1;
	                if (prevHoleIdx < 0)
	                    prevHoleIdx = lastHoleIdx;
	                var nextHoleIdx = inHoleIdx + 1;
	                if (nextHoleIdx > lastHoleIdx)
	                    nextHoleIdx = 0;
	                insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
	                if (!insideAngle) {
	                    // console.log("Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y);
	                    return false;
	                }
	                return true;
	            }
	            function intersectsShapeEdge(inShapePt, inHolePt) {
	                // checks for intersections with shape edges
	                var sIdx, nextIdx, intersection;
	                for (sIdx = 0; sIdx < shape.length; sIdx++) {
	                    nextIdx = sIdx + 1;
	                    nextIdx %= shape.length;
	                    intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
	                    if (intersection.length > 0)
	                        return true;
	                }
	                return false;
	            }
	            var indepHoles = [];
	            function intersectsHoleEdge(inShapePt, inHolePt) {
	                // checks for intersections with hole edges
	                var ihIdx, chkHole, hIdx, nextIdx, intersection;
	                for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
	                    chkHole = holes[indepHoles[ihIdx]];
	                    for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
	                        nextIdx = hIdx + 1;
	                        nextIdx %= chkHole.length;
	                        intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
	                        if (intersection.length > 0)
	                            return true;
	                    }
	                }
	                return false;
	            }
	            var holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, failedCuts = [], tmpShape1, tmpShape2, tmpHole1, tmpHole2;
	            for (var h = 0, hl = holes.length; h < hl; h++) {
	                indepHoles.push(h);
	            }
	            var minShapeIndex = 0;
	            var counter = indepHoles.length * 2;
	            while (indepHoles.length > 0) {
	                counter--;
	                if (counter < 0) {
	                    console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
	                    break;
	                }
	                // search for shape-vertex and hole-vertex,
	                // which can be connected without intersections
	                for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
	                    shapePt = shape[shapeIndex];
	                    holeIndex = -1;
	                    // search for hole which can be reached without intersections
	                    for (var h = 0; h < indepHoles.length; h++) {
	                        holeIdx = indepHoles[h];
	                        // prevent multiple checks
	                        cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
	                        if (failedCuts[cutKey] !== undefined)
	                            continue;
	                        hole = holes[holeIdx];
	                        for (var h2 = 0; h2 < hole.length; h2++) {
	                            holePt = hole[h2];
	                            if (!isCutLineInsideAngles(shapeIndex, h2))
	                                continue;
	                            if (intersectsShapeEdge(shapePt, holePt))
	                                continue;
	                            if (intersectsHoleEdge(shapePt, holePt))
	                                continue;
	                            holeIndex = h2;
	                            indepHoles.splice(h, 1);
	                            tmpShape1 = shape.slice(0, shapeIndex + 1);
	                            tmpShape2 = shape.slice(shapeIndex);
	                            tmpHole1 = hole.slice(holeIndex);
	                            tmpHole2 = hole.slice(0, holeIndex + 1);
	                            shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
	                            minShapeIndex = shapeIndex;
	                            // Debug only, to show the selected cuts
	                            // glob_CutLines.push([ shapePt, holePt ]);
	                            break;
	                        }
	                        if (holeIndex >= 0)
	                            break; // hole-vertex found
	                        failedCuts[cutKey] = true; // remember failure
	                    }
	                    if (holeIndex >= 0)
	                        break; // hole-vertex found
	                }
	            }
	            return shape; /* shape with no holes */
	        }
	        var allPointsMap = {};
	        // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	        var allpoints = contour.concat();
	        for (var h = 0, hl = holes.length; h < hl; h++) {
	            Array.prototype.push.apply(allpoints, holes[h]);
	        }
	        //console.log("allpoints",allpoints, allpoints.length);
	        // prepare all points map
	        for (var i = 0, il = allpoints.length; i < il; i++) {
	            var key = allpoints[i].x + ":" + allpoints[i].y;
	            if (allPointsMap[key] !== undefined) {
	                console.warn("THREE.ShapeUtils: Duplicate point", key, i);
	            }
	            allPointsMap[key] = i;
	        }
	        // remove holes by cutting paths to holes and adding them to the shape
	        var shapeWithoutHoles = removeHoles(contour, holes);
	        var triangle_vertices = ShapeUtils.triangulate(shapeWithoutHoles, false); // True returns indices for points of spooled shape
	        var triangle_indices = [];
	        //console.log("triangles",triangles, triangles.length);
	        // check all face vertices against all points map
	        for (var i = 0, il = triangle_vertices.length; i < il; i++) {
	            var face_vertices = triangle_vertices[i];
	            var face_indices = triangle_indices[i] = [];
	            for (var f = 0; f < 3; f++) {
	                var key = face_vertices[f].x + ":" + face_vertices[f].y;
	                var index = allPointsMap[key];
	                if (index !== undefined) {
	                    face_indices[f] = index;
	                }
	            }
	        }
	        return triangle_indices;
	    };
	    ShapeUtils.isClockWise = function (pts) {
	        return ShapeUtils.area(pts) < 0;
	    };
	    // Bezier Curves formulas obtained from
	    // http://en.wikipedia.org/wiki/B%C3%A9zier_curve
	    // Quad Bezier Functions
	    ShapeUtils.b2 = function (t, p0, p1, p2) {
	        function b2p0(t, p) {
	            var k = 1 - t;
	            return k * k * p;
	        }
	        function b2p1(t, p) {
	            return 2 * (1 - t) * t * p;
	        }
	        function b2p2(t, p) {
	            return t * t * p;
	        }
	        //return function b2(t, p0, p1, p2) {
	        return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
	        //};
	    };
	    // Cubic Bezier Functions
	    ShapeUtils.b3 = function (t, p0, p1, p2, p3) {
	        function b3p0(t, p) {
	            var k = 1 - t;
	            return k * k * k * p;
	        }
	        function b3p1(t, p) {
	            var k = 1 - t;
	            return 3 * k * k * t * p;
	        }
	        function b3p2(t, p) {
	            var k = 1 - t;
	            return 3 * k * t * t * p;
	        }
	        function b3p3(t, p) {
	            return t * t * t * p;
	        }
	        //return function b3(t, p0, p1, p2, p3) {
	        return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
	        //};
	    };
	    return ShapeUtils;
	}());

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <Object> // containing arrays of tangents, normals, binormals
	 *
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	var ExtrudeGeometry = /** @class */ (function (_super) {
	    __extends(ExtrudeGeometry, _super);
	    function ExtrudeGeometry(shapes, options) {
	        var _this = this;
	        if (typeof (shapes) === "undefined") {
	            shapes = [];
	            return;
	        }
	        _this = _super.call(this) || this;
	        _this.type = 'ExtrudeGeometry';
	        shapes = Array.isArray(shapes) ? shapes : [shapes];
	        _this.addShapeList(shapes, options);
	        _this.computeFaceNormals();
	        return _this;
	        // can't really use automatic vertex normals
	        // as then front and back sides get smoothed too
	        // should do separate smoothing just for sides
	        //this.computeVertexNormals();
	        //console.log("took", (Date.now() - startTime));
	    }
	    ExtrudeGeometry.prototype.addShapeList = function (shapes, options) {
	        var sl = shapes.length;
	        for (var s = 0; s < sl; s++) {
	            var shape = shapes[s];
	            this.addShape(shape, options);
	        }
	    };
	    ExtrudeGeometry.prototype.addShape = function (shape, options) {
	        var amount = options.amount !== undefined ? options.amount : 100;
	        var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	        var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	        var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	        var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	        var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	        var steps = options.steps !== undefined ? options.steps : 1;
	        var extrudePath = options.extrudePath;
	        var extrudePts;
	        var extrudeByPath = false;
	        // Use default WorldUVGenerator if no UV generators are specified.
	        var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
	        var splineTube, binormal, normal, position2;
	        if (extrudePath) {
	            extrudePts = extrudePath.getSpacedPoints(steps);
	            extrudeByPath = true;
	            bevelEnabled = false; // bevels not supported for path extrusion
	            // SETUP TNB variables
	            // TODO1 - have a .isClosed in spline?
	            splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames(steps, false);
	            // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	            binormal = new Vector3();
	            normal = new Vector3();
	            position2 = new Vector3();
	        }
	        // Safeguards if bevels are not enabled
	        if (!bevelEnabled) {
	            bevelSegments = 0;
	            bevelThickness = 0;
	            bevelSize = 0;
	        }
	        // Variables initialization
	        var scope = this;
	        var shapesOffset = this.vertices.length;
	        var shapePoints = shape.extractPoints(curveSegments);
	        var vertices = shapePoints.shape;
	        var holes = shapePoints.holes;
	        var reverse = !ShapeUtils.isClockWise(vertices);
	        if (reverse) {
	            vertices = vertices.reverse();
	            // Maybe we should also check if holes are in the opposite direction, just to be safe ...
	            for (var h = 0, hl = holes.length; h < hl; h++) {
	                var ahole = holes[h];
	                if (ShapeUtils.isClockWise(ahole)) {
	                    holes[h] = ahole.reverse();
	                }
	            }
	            reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	        }
	        var faces = ShapeUtils.triangulateShape(vertices, holes);
	        /* Vertices */
	        var contour = vertices; // vertices has all points but contour has only points of circumference
	        for (var h = 0, hl = holes.length; h < hl; h++) {
	            var ahole = holes[h];
	            vertices = vertices.concat(ahole);
	        }
	        function scalePt2(pt, vec, size) {
	            if (!vec)
	                console.error("THREE.ExtrudeGeometry: vec does not exist");
	            return vec.clone().multiplyScalar(size).add(pt);
	        }
	        var vlen = vertices.length;
	        var flen = faces.length;
	        // Find directions for point movement
	        function getBevelVec(inPt, inPrev, inNext) {
	            // computes for inPt the corresponding point inPt' on a new contour
	            //   shifted by 1 unit (length of normalized vector) to the left
	            // if we walk along contour clockwise, this new contour is outside the old one
	            //
	            // inPt' is the intersection of the two lines parallel to the two
	            //  adjacent edges of inPt at a distance of 1 unit on the left side.
	            var v_trans_x, v_trans_y, shrink_by = 1; // resulting translation vector for inPt
	            // good reading for geometry algorithms (here: line-line intersection)
	            // http://geomalgorithms.com/a05-_intersect-1.html
	            var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
	            var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
	            var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
	            // check for collinear edges
	            var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
	            if (Math.abs(collinear0) > Number.EPSILON) {
	                // not collinear
	                // length of vectors for normalizing
	                var v_prev_len = Math.sqrt(v_prev_lensq);
	                var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
	                // shift adjacent points by unit vectors to the left
	                var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
	                var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
	                var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
	                var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
	                // scaling factor for v_prev to intersection point
	                var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
	                    (ptNextShift_y - ptPrevShift_y) * v_next_x) /
	                    (v_prev_x * v_next_y - v_prev_y * v_next_x);
	                // vector from inPt to intersection point
	                v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
	                v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
	                // Don't normalize!, otherwise sharp corners become ugly
	                //  but prevent crazy spikes
	                var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
	                if (v_trans_lensq <= 2) {
	                    return new Vector2(v_trans_x, v_trans_y);
	                }
	                else {
	                    shrink_by = Math.sqrt(v_trans_lensq / 2);
	                }
	            }
	            else {
	                // handle special case of collinear edges
	                var direction_eq = false; // assumes: opposite
	                if (v_prev_x > Number.EPSILON) {
	                    if (v_next_x > Number.EPSILON) {
	                        direction_eq = true;
	                    }
	                }
	                else {
	                    if (v_prev_x < -Number.EPSILON) {
	                        if (v_next_x < -Number.EPSILON) {
	                            direction_eq = true;
	                        }
	                    }
	                    else {
	                        if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
	                            direction_eq = true;
	                        }
	                    }
	                }
	                if (direction_eq) {
	                    // console.log("Warning: lines are a straight sequence");
	                    v_trans_x = -v_prev_y;
	                    v_trans_y = v_prev_x;
	                    shrink_by = Math.sqrt(v_prev_lensq);
	                }
	                else {
	                    // console.log("Warning: lines are a straight spike");
	                    v_trans_x = v_prev_x;
	                    v_trans_y = v_prev_y;
	                    shrink_by = Math.sqrt(v_prev_lensq / 2);
	                }
	            }
	            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
	        }
	        var contourMovements = [];
	        for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
	            if (j === il)
	                j = 0;
	            if (k === il)
	                k = 0;
	            //  (j)---(i)---(k)
	            // console.log('i,j,k', i, j , k)
	            contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
	        }
	        var holesMovements = [];
	        var verticesMovements = contourMovements.concat();
	        for (var h = 0, hl = holes.length; h < hl; h++) {
	            var ahole = holes[h];
	            var oneHoleMovements = [];
	            for (var i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
	                if (j === il)
	                    j = 0;
	                if (k === il)
	                    k = 0;
	                //  (j)---(i)---(k)
	                oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
	            }
	            holesMovements.push(oneHoleMovements);
	            verticesMovements = verticesMovements.concat(oneHoleMovements);
	        }
	        // Loop bevelSegments, 1 for the front, 1 for the back
	        for (var b = 0; b < bevelSegments; b++) {
	            //for (b = bevelSegments; b > 0; b --) {
	            var t = b / bevelSegments;
	            var z = bevelThickness * Math.cos(t * Math.PI / 2);
	            var bs_1 = bevelSize * Math.sin(t * Math.PI / 2);
	            // contract shape
	            for (var i = 0, il = contour.length; i < il; i++) {
	                var vert = scalePt2(contour[i], contourMovements[i], bs_1);
	                v(vert.x, vert.y, -z);
	            }
	            // expand holes
	            for (var h = 0, hl = holes.length; h < hl; h++) {
	                var ahole = holes[h];
	                var oneHoleMovements = holesMovements[h];
	                for (var i = 0, il = ahole.length; i < il; i++) {
	                    var vert = scalePt2(ahole[i], oneHoleMovements[i], bs_1);
	                    v(vert.x, vert.y, -z);
	                }
	            }
	        }
	        var bs = bevelSize;
	        // Back facing vertices
	        for (var i = 0; i < vlen; i++) {
	            var vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
	            if (!extrudeByPath) {
	                v(vert.x, vert.y, 0);
	            }
	            else {
	                // v(vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x);
	                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
	                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
	                position2.copy(extrudePts[0]).add(normal).add(binormal);
	                v(position2.x, position2.y, position2.z);
	            }
	        }
	        // Add stepped vertices...
	        // Including front facing vertices
	        for (var s = 1; s <= steps; s++) {
	            for (var i = 0; i < vlen; i++) {
	                var vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
	                if (!extrudeByPath) {
	                    v(vert.x, vert.y, amount / steps * s);
	                }
	                else {
	                    // v(vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x);
	                    normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
	                    binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
	                    position2.copy(extrudePts[s]).add(normal).add(binormal);
	                    v(position2.x, position2.y, position2.z);
	                }
	            }
	        }
	        // Add bevel segments planes
	        //for (let b = 1; b <= bevelSegments; b ++) {
	        for (var b = bevelSegments - 1; b >= 0; b--) {
	            var t = b / bevelSegments;
	            var z = bevelThickness * Math.cos(t * Math.PI / 2);
	            var bs_2 = bevelSize * Math.sin(t * Math.PI / 2);
	            // contract shape
	            for (var i = 0, il = contour.length; i < il; i++) {
	                var vert = scalePt2(contour[i], contourMovements[i], bs_2);
	                v(vert.x, vert.y, amount + z);
	            }
	            // expand holes
	            for (var h = 0, hl = holes.length; h < hl; h++) {
	                var ahole = holes[h];
	                var oneHoleMovements = holesMovements[h];
	                for (var i = 0, il = ahole.length; i < il; i++) {
	                    var vert = scalePt2(ahole[i], oneHoleMovements[i], bs_2);
	                    if (!extrudeByPath) {
	                        v(vert.x, vert.y, amount + z);
	                    }
	                    else {
	                        v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
	                    }
	                }
	            }
	        }
	        /* Faces */
	        // Top and bottom faces
	        buildLidFaces();
	        // Sides faces
	        buildSideFaces();
	        /////  Internal functions
	        function buildLidFaces() {
	            if (bevelEnabled) {
	                var layer = 0; // steps + 1
	                var offset = vlen * layer;
	                // Bottom faces
	                for (var i = 0; i < flen; i++) {
	                    var face = faces[i];
	                    f3(face[2] + offset, face[1] + offset, face[0] + offset);
	                }
	                layer = steps + bevelSegments * 2;
	                offset = vlen * layer;
	                // Top faces
	                for (var i = 0; i < flen; i++) {
	                    var face = faces[i];
	                    f3(face[0] + offset, face[1] + offset, face[2] + offset);
	                }
	            }
	            else {
	                // Bottom faces
	                for (var i = 0; i < flen; i++) {
	                    var face = faces[i];
	                    f3(face[2], face[1], face[0]);
	                }
	                // Top faces
	                for (var i = 0; i < flen; i++) {
	                    var face = faces[i];
	                    f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
	                }
	            }
	        }
	        // Create faces for the z-sides of the shape
	        function buildSideFaces() {
	            var layeroffset = 0;
	            sidewalls(contour, layeroffset);
	            layeroffset += contour.length;
	            for (var h = 0, hl = holes.length; h < hl; h++) {
	                var ahole = holes[h];
	                sidewalls(ahole, layeroffset);
	                //, true
	                layeroffset += ahole.length;
	            }
	        }
	        function sidewalls(contour, layeroffset) {
	            var i = contour.length;
	            while (--i >= 0) {
	                var j = i;
	                var k = i - 1;
	                if (k < 0)
	                    k = contour.length - 1;
	                //console.log('b', i,j, i-1, k,vertices.length);
	                var sl = steps + bevelSegments * 2;
	                for (var s = 0; s < sl; s++) {
	                    var slen1 = vlen * s;
	                    var slen2 = vlen * (s + 1);
	                    var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
	                    f4(a, b, c, d, contour, s, sl, j, k);
	                }
	            }
	        }
	        function v(x, y, z) {
	            scope.vertices.push(new Vector3(x, y, z));
	        }
	        function f3(a, b, c) {
	            a += shapesOffset;
	            b += shapesOffset;
	            c += shapesOffset;
	            scope.faces.push(new Face3(a, b, c, null, null, 0));
	            var uvs = uvgen.generateTopUV(scope, a, b, c);
	            scope.faceVertexUvs[0].push(uvs);
	        }
	        function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
	            a += shapesOffset;
	            b += shapesOffset;
	            c += shapesOffset;
	            d += shapesOffset;
	            scope.faces.push(new Face3(a, b, d, null, null, 1));
	            scope.faces.push(new Face3(b, c, d, null, null, 1));
	            var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
	            scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
	            scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);
	        }
	    };
	    ExtrudeGeometry._WorldUVGenerator = /** @class */ (function () {
	        function class_1() {
	        }
	        class_1.prototype.generateTopUV = function (geometry, indexA, indexB, indexC) {
	            var vertices = geometry.vertices;
	            var a = vertices[indexA];
	            var b = vertices[indexB];
	            var c = vertices[indexC];
	            return [
	                new Vector2(a.x, a.y),
	                new Vector2(b.x, b.y),
	                new Vector2(c.x, c.y)
	            ];
	        };
	        class_1.prototype.generateSideWallUV = function (geometry, indexA, indexB, indexC, indexD) {
	            var vertices = geometry.vertices;
	            var a = vertices[indexA];
	            var b = vertices[indexB];
	            var c = vertices[indexC];
	            var d = vertices[indexD];
	            if (Math.abs(a.y - b.y) < 0.01) {
	                return [
	                    new Vector2(a.x, 1 - a.z),
	                    new Vector2(b.x, 1 - b.z),
	                    new Vector2(c.x, 1 - c.z),
	                    new Vector2(d.x, 1 - d.z)
	                ];
	            }
	            else {
	                return [
	                    new Vector2(a.y, 1 - a.z),
	                    new Vector2(b.y, 1 - b.z),
	                    new Vector2(c.y, 1 - c.z),
	                    new Vector2(d.y, 1 - d.z)
	                ];
	            }
	        };
	        return class_1;
	    }());
	    ExtrudeGeometry.WorldUVGenerator = new ExtrudeGeometry._WorldUVGenerator();
	    return ExtrudeGeometry;
	}(Geometry));

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTangentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/
	var Curve = /** @class */ (function () {
	    function Curve() {
	    }
	    // Virtual base class method to overwrite and implement in subclasses
	    //  - t [0 .. 1]
	    Curve.prototype.getPoint = function (t) {
	        console.warn("THREE.Curve: Warning, getPoint() not implemented!");
	        return null;
	    };
	    // Get point at relative position in curve according to arc length
	    // - u [0 .. 1]
	    Curve.prototype.getPointAt = function (u) {
	        var t = this.getUtoTmapping(u);
	        return this.getPoint(t);
	    };
	    // Get sequence of points using getPoint(t)
	    Curve.prototype.getPoints = function (divisions) {
	        if (divisions === void 0) { divisions = 5; }
	        var points = [];
	        for (var d = 0; d <= divisions; d++) {
	            points.push(this.getPoint(d / divisions));
	        }
	        return points;
	    };
	    // Get sequence of points using getPointAt(u)
	    Curve.prototype.getSpacedPoints = function (divisions) {
	        if (divisions === void 0) { divisions = 5; }
	        var points = [];
	        for (var d = 0; d <= divisions; d++) {
	            points.push(this.getPointAt(d / divisions));
	        }
	        return points;
	    };
	    // Get total curve arc length
	    Curve.prototype.getLength = function () {
	        var lengths = this.getLengths();
	        return lengths[lengths.length - 1];
	    };
	    // Get list of cumulative segment lengths
	    Curve.prototype.getLengths = function (divisions) {
	        if (!divisions)
	            divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
	        if (this.cacheArcLengths
	            && (this.cacheArcLengths.length === divisions + 1)
	            && !this.needsUpdate) {
	            //console.log("cached", this.cacheArcLengths);
	            return this.cacheArcLengths;
	        }
	        this.needsUpdate = false;
	        var cache = [];
	        var current;
	        var last = this.getPoint(0);
	        var sum = 0;
	        cache.push(0);
	        for (var p = 1; p <= divisions; p++) {
	            current = this.getPoint(p / divisions);
	            sum += current.distanceTo(last);
	            cache.push(sum);
	            last = current;
	        }
	        this.cacheArcLengths = cache;
	        return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	    };
	    Curve.prototype.updateArcLengths = function () {
	        this.needsUpdate = true;
	        this.getLengths();
	    };
	    // Given u (0 .. 1), get a t to find p. This gives you points which are equidistant
	    Curve.prototype.getUtoTmapping = function (u, distance) {
	        var arcLengths = this.getLengths();
	        var i = 0;
	        var il = arcLengths.length;
	        var targetArcLength; // The targeted u distance value to get
	        if (distance) {
	            targetArcLength = distance;
	        }
	        else {
	            targetArcLength = u * arcLengths[il - 1];
	        }
	        //const time = Date.now();
	        // binary search for the index with largest value smaller than target u distance
	        var low = 0, high = il - 1, comparison;
	        while (low <= high) {
	            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	            comparison = arcLengths[i] - targetArcLength;
	            if (comparison < 0) {
	                low = i + 1;
	            }
	            else if (comparison > 0) {
	                high = i - 1;
	            }
	            else {
	                high = i;
	                break;
	                // DONE
	            }
	        }
	        i = high;
	        //console.log('b' , i, low, high, Date.now()- time);
	        if (arcLengths[i] === targetArcLength) {
	            var t_1 = i / (il - 1);
	            return t_1;
	        }
	        // we could get finer grain at lengths, or use simple interpolation between two points
	        var lengthBefore = arcLengths[i];
	        var lengthAfter = arcLengths[i + 1];
	        var segmentLength = lengthAfter - lengthBefore;
	        // determine where we are between the 'before' and 'after' points
	        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
	        // add that fractional amount to t
	        var t = (i + segmentFraction) / (il - 1);
	        return t;
	    };
	    // Returns a unit vector tangent at t
	    // In case any sub curve does not implement its tangent derivation,
	    // 2 points a small delta apart will be used to find its gradient
	    // which seems to give a reasonable approximation
	    Curve.prototype.getTangent = function (t) {
	        var delta = 0.0001;
	        var t1 = t - delta;
	        var t2 = t + delta;
	        // Capping in case of danger
	        if (t1 < 0)
	            t1 = 0;
	        if (t2 > 1)
	            t2 = 1;
	        var pt1 = this.getPoint(t1);
	        var pt2 = this.getPoint(t2);
	        var vec = pt2.clone().sub(pt1);
	        return vec.normalize();
	    };
	    Curve.prototype.getTangentAt = function (u) {
	        var t = this.getUtoTmapping(u);
	        return this.getTangent(t);
	    };
	    Curve.prototype.computeFrenetFrames = function (segments, closed) {
	        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	        var normal = new Vector3();
	        var tangents = [];
	        var normals = [];
	        var binormals = [];
	        var vec = new Vector3();
	        var mat = new Matrix4();
	        var i, u, theta;
	        // compute the tangent vectors for each segment on the curve
	        for (i = 0; i <= segments; i++) {
	            u = i / segments;
	            tangents[i] = this.getTangentAt(u);
	            tangents[i].normalize();
	        }
	        // select an initial normal vector perpendicular to the first tangent vector,
	        // and in the direction of the minimum tangent xyz component
	        normals[0] = new Vector3();
	        binormals[0] = new Vector3();
	        var min = Number.MAX_VALUE;
	        var tx = Math.abs(tangents[0].x);
	        var ty = Math.abs(tangents[0].y);
	        var tz = Math.abs(tangents[0].z);
	        if (tx <= min) {
	            min = tx;
	            normal.set(1, 0, 0);
	        }
	        if (ty <= min) {
	            min = ty;
	            normal.set(0, 1, 0);
	        }
	        if (tz <= min) {
	            normal.set(0, 0, 1);
	        }
	        vec.crossVectors(tangents[0], normal).normalize();
	        normals[0].crossVectors(tangents[0], vec);
	        binormals[0].crossVectors(tangents[0], normals[0]);
	        // compute the slowly-varying normal and binormal vectors for each segment on the curve
	        for (i = 1; i <= segments; i++) {
	            normals[i] = normals[i - 1].clone();
	            binormals[i] = binormals[i - 1].clone();
	            vec.crossVectors(tangents[i - 1], tangents[i]);
	            if (vec.length() > Number.EPSILON) {
	                vec.normalize();
	                theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors
	                normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
	            }
	            binormals[i].crossVectors(tangents[i], normals[i]);
	        }
	        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	        if (closed === true) {
	            theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
	            theta /= segments;
	            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
	                theta = -theta;
	            }
	            for (i = 1; i <= segments; i++) {
	                // twist a little...
	                normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
	                binormals[i].crossVectors(tangents[i], normals[i]);
	            }
	        }
	        return {
	            tangents: tangents,
	            normals: normals,
	            binormals: binormals
	        };
	    };
	    // TODO: Transformation for Curves?
	    /**************************************************************
	     *  3D Curves
	     **************************************************************/
	    // A Factory method for creating new curve subclasses
	    Curve.create = function (constructor, getPointFunc) {
	        constructor.prototype = Object.create(Curve.prototype);
	        constructor.prototype.constructor = constructor;
	        constructor.prototype.getPoint = getPointFunc;
	        return constructor;
	    };
	    return Curve;
	}());
	var Curve2 = /** @class */ (function (_super) {
	    __extends(Curve2, _super);
	    function Curve2() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return Curve2;
	}(Curve));
	var Curve3 = /** @class */ (function (_super) {
	    __extends(Curve3, _super);
	    function Curve3() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return Curve3;
	}(Curve));

	/**************************************************************
	 *  Line
	 **************************************************************/
	var LineCurve = /** @class */ (function (_super) {
	    __extends(LineCurve, _super);
	    function LineCurve(v1, v2) {
	        var _this = _super.call(this) || this;
	        _this.isLineCurve = true;
	        _this.v1 = v1;
	        _this.v2 = v2;
	        return _this;
	    }
	    LineCurve.prototype.getPoint = function (t) {
	        if (t === 1) {
	            return this.v2.clone();
	        }
	        var point = this.v2.clone().sub(this.v1);
	        point.multiplyScalar(t).add(this.v1);
	        return point;
	    };
	    // Line curve is linear, so we can overwrite default getPointAt
	    LineCurve.prototype.getPointAt = function (u) {
	        return this.getPoint(u);
	    };
	    LineCurve.prototype.getTangent = function (t) {
	        var tangent = this.v2.clone().sub(this.v1);
	        return tangent.normalize();
	    };
	    return LineCurve;
	}(Curve));

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	var CurveUtils = /** @class */ (function () {
	    function CurveUtils() {
	    }
	    CurveUtils.tangentQuadraticBezier = function (t, p0, p1, p2) {
	        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
	    };
	    // Puay Bing, thanks for helping with this derivative!
	    CurveUtils.tangentCubicBezier = function (t, p0, p1, p2, p3) {
	        return -3 * p0 * (1 - t) * (1 - t) +
	            3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
	            6 * t * p2 * (1 - t) - 3 * t * t * p2 +
	            3 * t * t * p3;
	    };
	    CurveUtils.tangentSpline = function (t, p0, p1, p2, p3) {
	        // To check if my formulas are correct
	        var h00 = 6 * t * t - 6 * t; // derived from 2t^3 − 3t^2 + 1
	        var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
	        var h01 = -6 * t * t + 6 * t; // − 2t3 + 3t2
	        var h11 = 3 * t * t - 2 * t; // t3 − t2
	        return h00 + h10 + h01 + h11;
	    };
	    // Catmull-Rom
	    CurveUtils.interpolate = function (p0, p1, p2, p3, t) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        var t2 = t * t;
	        var t3 = t * t2;
	        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	    };
	    return CurveUtils;
	}());

	/**************************************************************
	 *  Spline curve
	 **************************************************************/
	var SplineCurve = /** @class */ (function (_super) {
	    __extends(SplineCurve, _super);
	    function SplineCurve(points /* array of Vector2 */) {
	        if (points === void 0) { points = []; } /* array of Vector2 */
	        var _this = _super.call(this) || this;
	        _this.isSplineCurve = true;
	        _this.points = points;
	        return _this;
	    }
	    SplineCurve.prototype.getPoint = function (t) {
	        var points = this.points;
	        var point = (points.length - 1) * t;
	        var intPoint = Math.floor(point);
	        var weight = point - intPoint;
	        var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
	        var point1 = points[intPoint];
	        var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
	        var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
	        var interpolate = CurveUtils.interpolate;
	        return new Vector2(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight));
	    };
	    return SplineCurve;
	}(Curve));

	/**************************************************************
	 *  Ellipse curve
	 **************************************************************/
	var EllipseCurve = /** @class */ (function (_super) {
	    __extends(EllipseCurve, _super);
	    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
	        if (aRotation === void 0) { aRotation = 0; }
	        var _this = _super.call(this) || this;
	        _this.isEllipseCurve = true;
	        _this.aX = aX;
	        _this.aY = aY;
	        _this.xRadius = xRadius;
	        _this.yRadius = yRadius;
	        _this.aStartAngle = aStartAngle;
	        _this.aEndAngle = aEndAngle;
	        _this.aClockwise = aClockwise;
	        _this.aRotation = aRotation;
	        return _this;
	    }
	    EllipseCurve.prototype.getPoint = function (t) {
	        var twoPi = Math.PI * 2;
	        var deltaAngle = this.aEndAngle - this.aStartAngle;
	        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
	        // ensures that deltaAngle is 0 .. 2 PI
	        while (deltaAngle < 0)
	            deltaAngle += twoPi;
	        while (deltaAngle > twoPi)
	            deltaAngle -= twoPi;
	        if (deltaAngle < Number.EPSILON) {
	            if (samePoints) {
	                deltaAngle = 0;
	            }
	            else {
	                deltaAngle = twoPi;
	            }
	        }
	        if (this.aClockwise === true && !samePoints) {
	            if (deltaAngle === twoPi) {
	                deltaAngle = -twoPi;
	            }
	            else {
	                deltaAngle = deltaAngle - twoPi;
	            }
	        }
	        var angle = this.aStartAngle + t * deltaAngle;
	        var x = this.aX + this.xRadius * Math.cos(angle);
	        var y = this.aY + this.yRadius * Math.sin(angle);
	        if (this.aRotation !== 0) {
	            var cos = Math.cos(this.aRotation);
	            var sin = Math.sin(this.aRotation);
	            var tx = x - this.aX;
	            var ty = y - this.aY;
	            // Rotate the point about the center of the ellipse.
	            x = tx * cos - ty * sin + this.aX;
	            y = tx * sin + ty * cos + this.aY;
	        }
	        return new Vector2(x, y);
	    };
	    return EllipseCurve;
	}(Curve));

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/
	/**************************************************************
	 *  Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
	var CurvePath = /** @class */ (function () {
	    function CurvePath() {
	        this.curves = [];
	        this.autoClose = false; // Automatically closes the path
	    }
	    CurvePath.prototype.add = function (curve) {
	        this.curves.push(curve);
	    };
	    CurvePath.prototype.closePath = function () {
	        // Add a line curve if start and end of lines are not connected
	        var startPoint = this.curves[0].getPoint(0);
	        var endPoint = this.curves[this.curves.length - 1].getPoint(1);
	        if (!startPoint.equals(endPoint)) {
	            this.curves.push(new LineCurve(endPoint, startPoint));
	        }
	    };
	    // To get accurate point with reference to
	    // entire path distance at time t,
	    // following has to be done:
	    // 1. Length of each sub path have to be known
	    // 2. Locate and identify type of curve
	    // 3. Get t for the curve
	    // 4. Return curve.getPointAt(t')
	    CurvePath.prototype.getPoint = function (t) {
	        var d = t * this.getLength();
	        var curveLengths = this.getCurveLengths();
	        var i = 0;
	        // To think about boundaries points.
	        while (i < curveLengths.length) {
	            if (curveLengths[i] >= d) {
	                var diff = curveLengths[i] - d;
	                var curve = this.curves[i];
	                var segmentLength = curve.getLength();
	                var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
	                return curve.getPointAt(u);
	            }
	            i++;
	        }
	        return null;
	        // loop where sum != 0, sum > d , sum+1 <d
	    };
	    // We cannot use the default THREE.Curve getPoint() with getLength() because in
	    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	    // getPoint() depends on getLength
	    CurvePath.prototype.getLength = function () {
	        var lens = this.getCurveLengths();
	        return lens[lens.length - 1];
	    };
	    // cacheLengths must be recalculated.
	    CurvePath.prototype.updateArcLengths = function () {
	        this.needsUpdate = true;
	        this.cacheLengths = null;
	        this.getCurveLengths(); // !!!TODO: this.getLengths();
	    };
	    // Compute lengths and cache them
	    // We cannot overwrite getLengths() because UtoT mapping uses it.
	    CurvePath.prototype.getCurveLengths = function () {
	        // We use cache values if curves and cache array are same length
	        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
	            return this.cacheLengths;
	        }
	        // Get length of sub-curve
	        // Push sums into cached array
	        var lengths = [], sums = 0;
	        for (var i = 0, l = this.curves.length; i < l; i++) {
	            sums += this.curves[i].getLength();
	            lengths.push(sums);
	        }
	        this.cacheLengths = lengths;
	        return lengths;
	    };
	    CurvePath.prototype.getSpacedPoints = function (divisions) {
	        if (divisions === void 0) { divisions = 40; }
	        var points = [];
	        for (var i = 0; i <= divisions; i++) {
	            points.push(this.getPoint(i / divisions));
	        }
	        if (this.autoClose) {
	            points.push(points[0]);
	        }
	        return points;
	    };
	    CurvePath.prototype.getPoints = function (divisions) {
	        if (divisions === void 0) { divisions = 12; }
	        var points = [], last;
	        for (var i = 0, curves = this.curves; i < curves.length; i++) {
	            var curve = curves[i];
	            var resolution = (curve && curve instanceof EllipseCurve) ? divisions * 2
	                : (curve && curve instanceof LineCurve) ? 1
	                    : (curve && curve instanceof SplineCurve) ? divisions * curve.points.length
	                        : divisions;
	            var pts = curve.getPoints(resolution);
	            for (var j = 0; j < pts.length; j++) {
	                var point = pts[j];
	                if (last && last.equals(point))
	                    continue; // ensures no consecutive points are duplicates
	                points.push(point);
	                last = point;
	            }
	        }
	        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
	            points.push(points[0]);
	        }
	        return points;
	    };
	    /**************************************************************
	     *  Create Geometries Helpers
	     **************************************************************/
	    /// Generate geometry from path points (for Line or Points objects)
	    CurvePath.prototype.createPointsGeometry = function (divisions) {
	        var pts = this.getPoints(divisions);
	        return this.createGeometry(pts);
	    };
	    // Generate geometry from equidistant sampling along the path
	    CurvePath.prototype.createSpacedPointsGeometry = function (divisions) {
	        var pts = this.getSpacedPoints(divisions);
	        return this.createGeometry(pts);
	    };
	    CurvePath.prototype.createGeometry = function (points) {
	        var geometry = new Geometry();
	        for (var i = 0, l = points.length; i < l; i++) {
	            var point = points[i];
	            geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
	        }
	        return geometry;
	    };
	    return CurvePath;
	}());

	/**************************************************************
	 *  Cubic Bezier curve
	 **************************************************************/
	var CubicBezierCurve = /** @class */ (function (_super) {
	    __extends(CubicBezierCurve, _super);
	    function CubicBezierCurve(v0, v1, v2, v3) {
	        var _this = _super.call(this) || this;
	        _this.v0 = v0;
	        _this.v1 = v1;
	        _this.v2 = v2;
	        _this.v3 = v3;
	        return _this;
	    }
	    CubicBezierCurve.prototype.getPoint = function (t) {
	        var b3 = ShapeUtils.b3;
	        return new Vector2(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
	    };
	    CubicBezierCurve.prototype.getTangent = function (t) {
	        var tangentCubicBezier = CurveUtils.tangentCubicBezier;
	        return new Vector2(tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();
	    };
	    return CubicBezierCurve;
	}(Curve));

	/**************************************************************
	 *  Quadratic Bezier curve
	 **************************************************************/
	var QuadraticBezierCurve = /** @class */ (function (_super) {
	    __extends(QuadraticBezierCurve, _super);
	    function QuadraticBezierCurve(v0, v1, v2) {
	        var _this = _super.call(this) || this;
	        _this.v0 = v0;
	        _this.v1 = v1;
	        _this.v2 = v2;
	        return _this;
	    }
	    QuadraticBezierCurve.prototype.getPoint = function (t) {
	        var b2 = ShapeUtils.b2;
	        return new Vector2(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y));
	    };
	    QuadraticBezierCurve.prototype.getTangent = function (t) {
	        var tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;
	        return new Vector2(tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)).normalize();
	    };
	    return QuadraticBezierCurve;
	}(Curve));

	//import { Shape } from "./Shape";
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/
	var Path = /** @class */ (function (_super) {
	    __extends(Path, _super);
	    function Path(points) {
	        var _this = _super.call(this) || this;
	        _this.currentPoint = new Vector2();
	        if (points) {
	            _this.fromPoints(points);
	        }
	        return _this;
	    }
	    Path.prototype.fromPoints = function (vectors) {
	        this.moveTo(vectors[0].x, vectors[0].y);
	        for (var i = 1, l = vectors.length; i < l; i++) {
	            this.lineTo(vectors[i].x, vectors[i].y);
	        }
	    };
	    Path.prototype.moveTo = function (x, y) {
	        this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
	    };
	    Path.prototype.lineTo = function (x, y) {
	        var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
	        this.curves.push(curve);
	        this.currentPoint.set(x, y);
	    };
	    Path.prototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
	        var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
	        this.curves.push(curve);
	        this.currentPoint.set(aX, aY);
	    };
	    Path.prototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
	        var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
	        this.curves.push(curve);
	        this.currentPoint.set(aX, aY);
	    };
	    Path.prototype.splineThru = function (pts /*Array of Vector*/) {
	        var npts = [this.currentPoint.clone()].concat(pts);
	        var curve = new SplineCurve(npts);
	        this.curves.push(curve);
	        this.currentPoint.copy(pts[pts.length - 1]);
	    };
	    Path.prototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
	        var x0 = this.currentPoint.x;
	        var y0 = this.currentPoint.y;
	        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
	    };
	    Path.prototype.absarc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
	        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
	    };
	    Path.prototype.ellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
	        var x0 = this.currentPoint.x;
	        var y0 = this.currentPoint.y;
	        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
	    };
	    Path.prototype.absellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
	        var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
	        if (this.curves.length > 0) {
	            // if a previous curve is present, attempt to join
	            var firstPoint = curve.getPoint(0);
	            if (!firstPoint.equals(this.currentPoint)) {
	                this.lineTo(firstPoint.x, firstPoint.y);
	            }
	        }
	        this.curves.push(curve);
	        var lastPoint = curve.getPoint(1);
	        this.currentPoint.copy(lastPoint);
	    };
	    return Path;
	}(CurvePath));

	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *  material: <int> // material index for front and back faces
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	var ShapeGeometry = /** @class */ (function (_super) {
	    __extends(ShapeGeometry, _super);
	    function ShapeGeometry(shapes, options) {
	        var _this = _super.call(this) || this;
	        _this.type = 'ShapeGeometry';
	        if (Array.isArray(shapes)) {
	            _this.addShapeList(shapes, options);
	        }
	        else {
	            _this.addShapeList([shapes], options);
	        }
	        _this.computeFaceNormals();
	        return _this;
	    }
	    /**
	     * Add an array of shapes to THREE.ShapeGeometry.
	     */
	    ShapeGeometry.prototype.addShapeList = function (shapes, options) {
	        for (var i = 0, l = shapes.length; i < l; i++) {
	            this.addShape(shapes[i], options);
	        }
	        return this;
	    };
	    /**
	     * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	     */
	    ShapeGeometry.prototype.addShape = function (shape, options) {
	        if (options === undefined)
	            options = {};
	        var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	        var material = options.material;
	        var uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
	        //
	        var shapesOffset = this.vertices.length;
	        var shapePoints = shape.extractPoints(curveSegments);
	        var vertices = shapePoints.shape;
	        var holes = shapePoints.holes;
	        var reverse = !ShapeUtils.isClockWise(vertices);
	        if (reverse) {
	            vertices = vertices.reverse();
	            // Maybe we should also check if holes are in the opposite direction, just to be safe...
	            for (var i = 0, l = holes.length; i < l; i++) {
	                var hole = holes[i];
	                if (ShapeUtils.isClockWise(hole)) {
	                    holes[i] = hole.reverse();
	                }
	            }
	            reverse = false;
	        }
	        var faces = ShapeUtils.triangulateShape(vertices, holes);
	        // Vertices
	        for (var i = 0, l = holes.length; i < l; i++) {
	            var hole = holes[i];
	            vertices = vertices.concat(hole);
	        }
	        //
	        for (var i = 0, vlen = vertices.length; i < vlen; i++) {
	            var vert = vertices[i];
	            this.vertices.push(new Vector3(vert.x, vert.y, 0));
	        }
	        for (var i = 0, flen = faces.length; i < flen; i++) {
	            var face = faces[i];
	            var a = face[0] + shapesOffset;
	            var b = face[1] + shapesOffset;
	            var c = face[2] + shapesOffset;
	            this.faces.push(new Face3(a, b, c, null, null, material));
	            this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
	        }
	    };
	    return ShapeGeometry;
	}(Geometry));

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/
	var Shape = /** @class */ (function (_super) {
	    __extends(Shape, _super);
	    function Shape(points) {
	        var _this = _super.call(this, points) || this;
	        _this.holes = [];
	        return _this;
	    }
	    Shape.prototype.getPointsHoles = function (divisions) {
	        var holesPts = [];
	        for (var i = 0, l = this.holes.length; i < l; i++) {
	            holesPts[i] = this.holes[i].getPoints(divisions);
	        }
	        return holesPts;
	    };
	    // Get points of shape and holes (keypoints based on segments parameter)
	    Shape.prototype.extractAllPoints = function (divisions) {
	        return {
	            shape: this.getPoints(divisions),
	            holes: this.getPointsHoles(divisions)
	        };
	    };
	    Shape.prototype.extractPoints = function (divisions) {
	        return this.extractAllPoints(divisions);
	    };
	    Shape.prototype.extrude = function (options) {
	        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
	        return new ExtrudeGeometry(this, options);
	    };
	    Shape.prototype.makeGeometry = function (options) {
	        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
	        return new ShapeGeometry(this, options);
	    };
	    return Shape;
	}(Path));

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/
	// minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	var ShapePath = /** @class */ (function () {
	    function ShapePath() {
	        this.subPaths = [];
	        this.currentPath = null;
	    }
	    ShapePath.prototype.moveTo = function (x, y) {
	        this.currentPath = new Path();
	        this.subPaths.push(this.currentPath);
	        this.currentPath.moveTo(x, y);
	    };
	    ShapePath.prototype.lineTo = function (x, y) {
	        this.currentPath.lineTo(x, y);
	    };
	    ShapePath.prototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
	        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
	    };
	    ShapePath.prototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
	        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
	    };
	    ShapePath.prototype.splineThru = function (pts) {
	        this.currentPath.splineThru(pts);
	    };
	    ShapePath.prototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
	        this.currentPath.arc(aX, aY, aStartAngle, aEndAngle, aClockwise);
	    };
	    ShapePath.prototype.absarc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
	        this.currentPath.absarc(aX, aY, aStartAngle, aEndAngle, aClockwise);
	    };
	    ShapePath.prototype.ellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
	        this.currentPath.ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
	    };
	    ShapePath.prototype.absellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
	        this.currentPath.absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
	    };
	    ShapePath.prototype.toShapes = function (isCCW, noHoles) {
	        function toShapesNoHoles(inSubpaths) {
	            var shapes = [];
	            for (var i = 0, l = inSubpaths.length; i < l; i++) {
	                var tmpPath_1 = inSubpaths[i];
	                var tmpShape_1 = new Shape();
	                tmpShape_1.curves = tmpPath_1.curves;
	                shapes.push(tmpShape_1);
	            }
	            return shapes;
	        }
	        function isPointInsidePolygon(inPt, inPolygon) {
	            var polyLen = inPolygon.length;
	            // inPt on polygon contour => immediate success    or
	            // toggling of inside/outside at every single! intersection point of an edge
	            //  with the horizontal line through inPt, left of inPt
	            //  not counting lowerY endpoints of edges and whole edges on that line
	            var inside = false;
	            for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
	                var edgeLowPt = inPolygon[p];
	                var edgeHighPt = inPolygon[q];
	                var edgeDx = edgeHighPt.x - edgeLowPt.x;
	                var edgeDy = edgeHighPt.y - edgeLowPt.y;
	                if (Math.abs(edgeDy) > Number.EPSILON) {
	                    // not parallel
	                    if (edgeDy < 0) {
	                        edgeLowPt = inPolygon[q];
	                        edgeDx = -edgeDx;
	                        edgeHighPt = inPolygon[p];
	                        edgeDy = -edgeDy;
	                    }
	                    if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
	                        continue;
	                    if (inPt.y === edgeLowPt.y) {
	                        if (inPt.x === edgeLowPt.x)
	                            return true; // inPt is on contour ?
	                        // continue;        // no intersection or edgeLowPt => doesn't count !!!
	                    }
	                    else {
	                        var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
	                        if (perpEdge === 0)
	                            return true; // inPt is on contour ?
	                        if (perpEdge < 0)
	                            continue;
	                        inside = !inside; // true intersection left of inPt
	                    }
	                }
	                else {
	                    // parallel or collinear
	                    if (inPt.y !== edgeLowPt.y)
	                        continue; // parallel
	                    // edge lies on the same horizontal line as inPt
	                    if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
	                        ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
	                        return true; // inPt: Point on contour !
	                    // continue;
	                }
	            }
	            return inside;
	        }
	        var isClockWise = ShapeUtils.isClockWise;
	        var subPaths = this.subPaths;
	        if (subPaths.length === 0)
	            return [];
	        if (noHoles === true)
	            return toShapesNoHoles(subPaths);
	        var solid, tmpPath, tmpShape, shapes = [];
	        if (subPaths.length === 1) {
	            tmpPath = subPaths[0];
	            tmpShape = new Shape();
	            tmpShape.curves = tmpPath.curves;
	            shapes.push(tmpShape);
	            return shapes;
	        }
	        var holesFirst = !isClockWise(subPaths[0].getPoints());
	        holesFirst = isCCW ? !holesFirst : holesFirst;
	        // console.log("Holes first", holesFirst);
	        var betterShapeHoles = [];
	        var newShapes = [];
	        var newShapeHoles = [];
	        var mainIdx = 0;
	        var tmpPoints;
	        newShapes[mainIdx] = undefined;
	        newShapeHoles[mainIdx] = [];
	        for (var i = 0, l = subPaths.length; i < l; i++) {
	            tmpPath = subPaths[i];
	            tmpPoints = tmpPath.getPoints();
	            solid = isClockWise(tmpPoints);
	            solid = isCCW ? !solid : solid;
	            if (solid) {
	                if ((!holesFirst) && (newShapes[mainIdx]))
	                    mainIdx++;
	                newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
	                newShapes[mainIdx].s.curves = tmpPath.curves;
	                if (holesFirst)
	                    mainIdx++;
	                newShapeHoles[mainIdx] = [];
	                //console.log('cw', i);
	            }
	            else {
	                newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
	                //console.log('ccw', i);
	            }
	        }
	        // only Holes? -> probably all Shapes with wrong orientation
	        if (!newShapes[0])
	            return toShapesNoHoles(subPaths);
	        if (newShapes.length > 1) {
	            var ambiguous = false;
	            var toChange = [];
	            for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
	                betterShapeHoles[sIdx] = [];
	            }
	            for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
	                var sho = newShapeHoles[sIdx];
	                for (var hIdx = 0; hIdx < sho.length; hIdx++) {
	                    var ho = sho[hIdx];
	                    var hole_unassigned = true;
	                    for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
	                        if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
	                            if (sIdx !== s2Idx)
	                                toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
	                            if (hole_unassigned) {
	                                hole_unassigned = false;
	                                betterShapeHoles[s2Idx].push(ho);
	                            }
	                            else {
	                                ambiguous = true;
	                            }
	                        }
	                    }
	                    if (hole_unassigned) {
	                        betterShapeHoles[sIdx].push(ho);
	                    }
	                }
	            }
	            // console.log("ambiguous: ", ambiguous);
	            if (toChange.length > 0) {
	                // console.log("to change: ", toChange);
	                if (!ambiguous)
	                    newShapeHoles = betterShapeHoles;
	            }
	        }
	        var tmpHoles;
	        for (var i = 0, il = newShapes.length; i < il; i++) {
	            tmpShape = newShapes[i].s;
	            shapes.push(tmpShape);
	            tmpHoles = newShapeHoles[i];
	            for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
	                tmpShape.holes.push(tmpHoles[j].h);
	            }
	        }
	        //console.log("shape", shapes);
	        return shapes;
	    };
	    return ShapePath;
	}());

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Font = /** @class */ (function () {
	    function Font(data) {
	        this.isFont = true;
	        this.data = data;
	    }
	    Font.prototype.generateShapes = function (text, size, divisions) {
	        function createPaths(text) {
	            var chars = String(text).split('');
	            var scale = size / data.resolution;
	            var offset = 0;
	            var paths = [];
	            for (var i = 0; i < chars.length; i++) {
	                var ret = createPath(chars[i], scale, offset);
	                offset += ret.offset;
	                paths.push(ret.path);
	            }
	            return paths;
	        }
	        function createPath(c, scale, offset) {
	            var glyph = data.glyphs[c] || data.glyphs['?'];
	            if (!glyph)
	                return;
	            var path = new ShapePath();
	            var pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;
	            var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
	            if (glyph.o) {
	                var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
	                for (var i = 0, l = outline.length; i < l;) {
	                    var action = outline[i++];
	                    switch (action) {
	                        case 'm':// moveTo
	                            x = outline[i++] * scale + offset;
	                            y = outline[i++] * scale;
	                            path.moveTo(x, y);
	                            break;
	                        case 'l':// lineTo
	                            x = outline[i++] * scale + offset;
	                            y = outline[i++] * scale;
	                            path.lineTo(x, y);
	                            break;
	                        case 'q':// quadraticCurveTo
	                            cpx = outline[i++] * scale + offset;
	                            cpy = outline[i++] * scale;
	                            cpx1 = outline[i++] * scale + offset;
	                            cpy1 = outline[i++] * scale;
	                            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
	                            laste = pts[pts.length - 1];
	                            if (laste) {
	                                cpx0 = laste.x;
	                                cpy0 = laste.y;
	                                for (var i2 = 1; i2 <= divisions; i2++) {
	                                    var t = i2 / divisions;
	                                    b2(t, cpx0, cpx1, cpx);
	                                    b2(t, cpy0, cpy1, cpy);
	                                }
	                            }
	                            break;
	                        case 'b':// bezierCurveTo
	                            cpx = outline[i++] * scale + offset;
	                            cpy = outline[i++] * scale;
	                            cpx1 = outline[i++] * scale + offset;
	                            cpy1 = outline[i++] * scale;
	                            cpx2 = outline[i++] * scale + offset;
	                            cpy2 = outline[i++] * scale;
	                            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
	                            laste = pts[pts.length - 1];
	                            if (laste) {
	                                cpx0 = laste.x;
	                                cpy0 = laste.y;
	                                for (var i2 = 1; i2 <= divisions; i2++) {
	                                    var t = i2 / divisions;
	                                    b3(t, cpx0, cpx1, cpx2, cpx);
	                                    b3(t, cpy0, cpy1, cpy2, cpy);
	                                }
	                            }
	                            break;
	                    }
	                }
	            }
	            return { offset: glyph.ha * scale, path: path };
	        }
	        //
	        if (size === undefined)
	            size = 100;
	        if (divisions === undefined)
	            divisions = 4;
	        var data = this.data;
	        var paths = createPaths(text);
	        var shapes = [];
	        for (var p = 0, pl = paths.length; p < pl; p++) {
	            Array.prototype.push.apply(shapes, paths[p].toShapes());
	        }
	        return shapes;
	    };
	    return Font;
	}());

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */
	var TextGeometry = /** @class */ (function (_super) {
	    __extends(TextGeometry, _super);
	    function TextGeometry(text, parameters) {
	        if (parameters === void 0) { parameters = {}; }
	        var _this = this;
	        var font = parameters.font;
	        if ((font && font instanceof Font) === false) {
	            console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
	            /// !!!TODO: return new Geometry();
	        }
	        var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
	        // translate parameters to ExtrudeGeometry API
	        parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	        // defaults
	        if (parameters.bevelThickness === undefined)
	            parameters.bevelThickness = 10;
	        if (parameters.bevelSize === undefined)
	            parameters.bevelSize = 8;
	        if (parameters.bevelEnabled === undefined)
	            parameters.bevelEnabled = false;
	        _this = _super.call(this, shapes, parameters) || this;
	        _this.type = 'TextGeometry';
	        return _this;
	    }
	    return TextGeometry;
	}(ExtrudeGeometry));

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * based on THREE.SphereGeometry
	 */
	var SphereBufferGeometry = /** @class */ (function (_super) {
	    __extends(SphereBufferGeometry, _super);
	    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
	        var _this = _super.call(this) || this;
	        _this.type = 'SphereBufferGeometry';
	        _this.parameters = {
	            radius: radius,
	            widthSegments: widthSegments,
	            heightSegments: heightSegments,
	            phiStart: phiStart,
	            phiLength: phiLength,
	            thetaStart: thetaStart,
	            thetaLength: thetaLength
	        };
	        radius = radius || 50;
	        widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
	        heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
	        phiStart = phiStart !== undefined ? phiStart : 0;
	        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	        thetaStart = thetaStart !== undefined ? thetaStart : 0;
	        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	        var thetaEnd = thetaStart + thetaLength;
	        var vertexCount = ((widthSegments + 1) * (heightSegments + 1));
	        var positions = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
	        var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
	        var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
	        var index = 0;
	        var vertices = [], normal = new Vector3();
	        for (var y = 0; y <= heightSegments; y++) {
	            var verticesRow = [];
	            var v = y / heightSegments;
	            for (var x = 0; x <= widthSegments; x++) {
	                var u = x / widthSegments;
	                var px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
	                var py = radius * Math.cos(thetaStart + v * thetaLength);
	                var pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
	                normal.set(px, py, pz).normalize();
	                positions.setXYZ(index, px, py, pz);
	                normals.setXYZ(index, normal.x, normal.y, normal.z);
	                uvs.setXY(index, u, 1 - v);
	                verticesRow.push(index);
	                index++;
	            }
	            vertices.push(verticesRow);
	        }
	        var indices = [];
	        for (var y = 0; y < heightSegments; y++) {
	            for (var x = 0; x < widthSegments; x++) {
	                var v1 = vertices[y][x + 1];
	                var v2 = vertices[y][x];
	                var v3 = vertices[y + 1][x];
	                var v4 = vertices[y + 1][x + 1];
	                if (y !== 0 || thetaStart > 0)
	                    indices.push(v1, v2, v4);
	                if (y !== heightSegments - 1 || thetaEnd < Math.PI)
	                    indices.push(v2, v3, v4);
	            }
	        }
	        _this.setIndex((positions.count > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
	        _this.addAttribute('position', positions);
	        _this.addAttribute('normal', normals);
	        _this.addAttribute('uv', uvs);
	        _this.boundingSphere = new Sphere(new Vector3(), radius);
	        return _this;
	    }
	    return SphereBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var SphereGeometry = /** @class */ (function (_super) {
	    __extends(SphereGeometry, _super);
	    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
	        var _this = _super.call(this) || this;
	        _this.type = 'SphereGeometry';
	        _this.parameters = {
	            radius: radius,
	            widthSegments: widthSegments,
	            heightSegments: heightSegments,
	            phiStart: phiStart,
	            phiLength: phiLength,
	            thetaStart: thetaStart,
	            thetaLength: thetaLength
	        };
	        _this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
	        return _this;
	    }
	    return SphereGeometry;
	}(Geometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	var RingBufferGeometry = /** @class */ (function (_super) {
	    __extends(RingBufferGeometry, _super);
	    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
	        var _this = _super.call(this) || this;
	        _this.type = 'RingBufferGeometry';
	        _this.parameters = {
	            innerRadius: innerRadius,
	            outerRadius: outerRadius,
	            thetaSegments: thetaSegments,
	            phiSegments: phiSegments,
	            thetaStart: thetaStart,
	            thetaLength: thetaLength
	        };
	        innerRadius = innerRadius || 20;
	        outerRadius = outerRadius || 50;
	        thetaStart = thetaStart !== undefined ? thetaStart : 0;
	        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	        thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
	        phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
	        // these are used to calculate buffer length
	        var vertexCount = (thetaSegments + 1) * (phiSegments + 1);
	        var indexCount = thetaSegments * phiSegments * 2 * 3;
	        // buffers
	        var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
	        var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
	        var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
	        var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
	        // some helper variables
	        var index = 0, indexOffset = 0;
	        var radius = innerRadius;
	        var radiusStep = ((outerRadius - innerRadius) / phiSegments);
	        var vertex = new Vector3();
	        var uv = new Vector2();
	        // generate vertices, normals and uvs
	        // values are generate from the inside of the ring to the outside
	        for (var j = 0; j <= phiSegments; j++) {
	            for (var i = 0; i <= thetaSegments; i++) {
	                var segment = thetaStart + i / thetaSegments * thetaLength;
	                // vertex
	                vertex.x = radius * Math.cos(segment);
	                vertex.y = radius * Math.sin(segment);
	                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
	                // normal
	                normals.setXYZ(index, 0, 0, 1);
	                // uv
	                uv.x = (vertex.x / outerRadius + 1) / 2;
	                uv.y = (vertex.y / outerRadius + 1) / 2;
	                uvs.setXY(index, uv.x, uv.y);
	                // increase index
	                index++;
	            }
	            // increase the radius for next row of vertices
	            radius += radiusStep;
	        }
	        // generate indices
	        for (var j = 0; j < phiSegments; j++) {
	            var thetaSegmentLevel = j * (thetaSegments + 1);
	            for (var i = 0; i < thetaSegments; i++) {
	                var segment = i + thetaSegmentLevel;
	                // indices
	                var a = segment;
	                var b = segment + thetaSegments + 1;
	                var c = segment + thetaSegments + 2;
	                var d = segment + 1;
	                // face one
	                indices.setX(indexOffset, a);
	                indexOffset++;
	                indices.setX(indexOffset, b);
	                indexOffset++;
	                indices.setX(indexOffset, c);
	                indexOffset++;
	                // face two
	                indices.setX(indexOffset, a);
	                indexOffset++;
	                indices.setX(indexOffset, c);
	                indexOffset++;
	                indices.setX(indexOffset, d);
	                indexOffset++;
	            }
	        }
	        // build geometry
	        _this.setIndex(indices);
	        _this.addAttribute('position', vertices);
	        _this.addAttribute('normal', normals);
	        _this.addAttribute('uv', uvs);
	        return _this;
	    }
	    return RingBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author Kaleb Murphy
	 */
	var RingGeometry = /** @class */ (function (_super) {
	    __extends(RingGeometry, _super);
	    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
	        var _this = _super.call(this) || this;
	        _this.type = 'RingGeometry';
	        _this.parameters = {
	            innerRadius: innerRadius,
	            outerRadius: outerRadius,
	            thetaSegments: thetaSegments,
	            phiSegments: phiSegments,
	            thetaStart: thetaStart,
	            thetaLength: thetaLength
	        };
	        _this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
	        return _this;
	    }
	    return RingGeometry;
	}(Geometry));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	var PlaneGeometry = /** @class */ (function (_super) {
	    __extends(PlaneGeometry, _super);
	    function PlaneGeometry(width, height, widthSegments, heightSegments) {
	        var _this = _super.call(this) || this;
	        _this.type = 'PlaneGeometry';
	        _this.parameters = {
	            width: width,
	            height: height,
	            widthSegments: widthSegments,
	            heightSegments: heightSegments
	        };
	        _this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
	        return _this;
	    }
	    return PlaneGeometry;
	}(Geometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	// points - to create a closed torus, one must use a set of points
	//    like so: [a, b, c, d, a], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2PI) range of the lathed section
	//    2PI is a closed lathe, less than 2PI is a portion.
	var LatheBufferGeometry = /** @class */ (function (_super) {
	    __extends(LatheBufferGeometry, _super);
	    function LatheBufferGeometry(points, segments, phiStart, phiLength) {
	        var _this = _super.call(this) || this;
	        _this.type = 'LatheBufferGeometry';
	        _this.parameters = {
	            points: points,
	            segments: segments,
	            phiStart: phiStart,
	            phiLength: phiLength
	        };
	        segments = Math.floor(segments) || 12;
	        phiStart = phiStart || 0;
	        phiLength = phiLength || Math.PI * 2;
	        // clamp phiLength so it's in range of [0, 2PI]
	        phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
	        // these are used to calculate buffer length
	        var vertexCount = (segments + 1) * points.length;
	        var indexCount = segments * points.length * 2 * 3;
	        // buffers
	        var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
	        var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
	        var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
	        // helper variables
	        var index = 0, indexOffset = 0;
	        var inverseSegments = 1.0 / segments;
	        var vertex = new Vector3();
	        var uv = new Vector2();
	        // generate vertices and uvs
	        for (var i = 0; i <= segments; i++) {
	            var phi = phiStart + i * inverseSegments * phiLength;
	            var sin = Math.sin(phi);
	            var cos = Math.cos(phi);
	            for (var j = 0; j <= (points.length - 1); j++) {
	                // vertex
	                vertex.x = points[j].x * sin;
	                vertex.y = points[j].y;
	                vertex.z = points[j].x * cos;
	                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
	                // uv
	                uv.x = i / segments;
	                uv.y = j / (points.length - 1);
	                uvs.setXY(index, uv.x, uv.y);
	                // increase index
	                index++;
	            }
	        }
	        // generate indices
	        for (var i = 0; i < segments; i++) {
	            for (var j = 0; j < (points.length - 1); j++) {
	                var base = j + i * points.length;
	                // indices
	                var a = base;
	                var b = base + points.length;
	                var c = base + points.length + 1;
	                var d = base + 1;
	                // face one
	                indices.setX(indexOffset, a);
	                indexOffset++;
	                indices.setX(indexOffset, b);
	                indexOffset++;
	                indices.setX(indexOffset, d);
	                indexOffset++;
	                // face two
	                indices.setX(indexOffset, b);
	                indexOffset++;
	                indices.setX(indexOffset, c);
	                indexOffset++;
	                indices.setX(indexOffset, d);
	                indexOffset++;
	            }
	        }
	        // build geometry
	        _this.setIndex(indices);
	        _this.addAttribute('position', vertices);
	        _this.addAttribute('uv', uvs);
	        // generate normals
	        _this.computeVertexNormals();
	        // if the geometry is closed, we need to average the normals along the seam.
	        // because the corresponding vertices are identical (but still have different UVs).
	        if (phiLength === Math.PI * 2) {
	            var normals = _this.attributes.normal.array;
	            var n1 = new Vector3();
	            var n2 = new Vector3();
	            var n = new Vector3();
	            // this is the buffer offset for the last line of vertices
	            var base = segments * points.length * 3;
	            for (var i = 0, j = 0; i < points.length; i++, j += 3) {
	                // select the normal of the vertex in the first line
	                n1.x = normals[j + 0];
	                n1.y = normals[j + 1];
	                n1.z = normals[j + 2];
	                // select the normal of the vertex in the last line
	                n2.x = normals[base + j + 0];
	                n2.y = normals[base + j + 1];
	                n2.z = normals[base + j + 2];
	                // average normals
	                n.addVectors(n1, n2).normalize();
	                // assign the new values to both normals
	                normals[j + 0] = normals[base + j + 0] = n.x;
	                normals[j + 1] = normals[base + j + 1] = n.y;
	                normals[j + 2] = normals[base + j + 2] = n.z;
	            } // next row
	        }
	        return _this;
	    }
	    return LatheBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 */
	// points - to create a closed torus, one must use a set of points
	//    like so: [a, b, c, d, a], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2PI) range of the lathed section
	//    2PI is a closed lathe, less than 2PI is a portion.
	var LatheGeometry = /** @class */ (function (_super) {
	    __extends(LatheGeometry, _super);
	    function LatheGeometry(points, segments, phiStart, phiLength) {
	        var _this = _super.call(this) || this;
	        _this.type = 'LatheGeometry';
	        _this.parameters = {
	            points: points,
	            segments: segments,
	            phiStart: phiStart,
	            phiLength: phiLength
	        };
	        _this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
	        _this.mergeVertices();
	        return _this;
	    }
	    return LatheGeometry;
	}(Geometry));

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	var EdgesGeometry = /** @class */ (function (_super) {
	    __extends(EdgesGeometry, _super);
	    function EdgesGeometry(geometry, thresholdAngle) {
	        if (thresholdAngle === void 0) { thresholdAngle = 1; }
	        var _this = _super.call(this) || this;
	        var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
	        var edge = [0, 0], hash = {};
	        function sortFunction(a, b) {
	            return a - b;
	        }
	        var keys = ['a', 'b', 'c'];
	        var geometry2;
	        if ((geometry && geometry instanceof BufferGeometry)) {
	            geometry2 = new Geometry();
	            geometry2.fromBufferGeometry(geometry);
	        }
	        else if (geometry && geometry instanceof Geometry) {
	            geometry2 = geometry.clone();
	        }
	        geometry2.mergeVertices();
	        geometry2.computeFaceNormals();
	        var vertices = geometry2.vertices;
	        var faces = geometry2.faces;
	        for (var i = 0, l = faces.length; i < l; i++) {
	            var face = faces[i];
	            for (var j = 0; j < 3; j++) {
	                edge[0] = face[keys[j]];
	                edge[1] = face[keys[(j + 1) % 3]];
	                edge.sort(sortFunction);
	                var key = edge.toString();
	                if (hash[key] === undefined) {
	                    hash[key] = { vert1: edge[0], vert2: edge[1], face1: i, face2: undefined };
	                }
	                else {
	                    hash[key].face2 = i;
	                }
	            }
	        }
	        var coords = [];
	        for (var key in hash) {
	            var h = hash[key];
	            if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
	                var vertex1 = vertices[h.vert1];
	                coords.push(vertex1.x);
	                coords.push(vertex1.y);
	                coords.push(vertex1.z);
	                var vertex2 = vertices[h.vert2];
	                coords.push(vertex2.x);
	                coords.push(vertex2.y);
	                coords.push(vertex2.z);
	            }
	        }
	        _this.addAttribute('position', new BufferAttribute(new Float32Array(coords), 3));
	        return _this;
	    }
	    return EdgesGeometry;
	}(BufferGeometry));

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	var CylinderBufferGeometry = /** @class */ (function (_super) {
	    __extends(CylinderBufferGeometry, _super);
	    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
	        var _this = _super.call(this) || this;
	        _this.type = 'CylinderBufferGeometry';
	        _this.parameters = {
	            radiusTop: radiusTop,
	            radiusBottom: radiusBottom,
	            height: height,
	            radialSegments: radialSegments,
	            heightSegments: heightSegments,
	            openEnded: openEnded,
	            thetaStart: thetaStart,
	            thetaLength: thetaLength
	        };
	        var scope = _this;
	        radiusTop = radiusTop !== undefined ? radiusTop : 20;
	        radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	        height = height !== undefined ? height : 100;
	        radialSegments = Math.floor(radialSegments) || 8;
	        heightSegments = Math.floor(heightSegments) || 1;
	        openEnded = openEnded !== undefined ? openEnded : false;
	        thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
	        thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;
	        // used to calculate buffer length
	        var nbCap = 0;
	        if (openEnded === false) {
	            if (radiusTop > 0)
	                nbCap++;
	            if (radiusBottom > 0)
	                nbCap++;
	        }
	        var vertexCount = calculateVertexCount();
	        var indexCount = calculateIndexCount();
	        // buffers
	        var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
	        var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
	        var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
	        var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
	        // helper variables
	        var index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;
	        // group variables
	        var groupStart = 0;
	        // generate geometry
	        generateTorso();
	        if (openEnded === false) {
	            if (radiusTop > 0)
	                generateCap(true);
	            if (radiusBottom > 0)
	                generateCap(false);
	        }
	        // build geometry
	        _this.setIndex(indices);
	        _this.addAttribute('position', vertices);
	        _this.addAttribute('normal', normals);
	        _this.addAttribute('uv', uvs);
	        // helper functions
	        function calculateVertexCount() {
	            var count = (radialSegments + 1) * (heightSegments + 1);
	            if (openEnded === false) {
	                count += ((radialSegments + 1) * nbCap) + (radialSegments * nbCap);
	            }
	            return count;
	        }
	        function calculateIndexCount() {
	            var count = radialSegments * heightSegments * 2 * 3;
	            if (openEnded === false) {
	                count += radialSegments * nbCap * 3;
	            }
	            return count;
	        }
	        function generateTorso() {
	            var normal = new Vector3();
	            var vertex = new Vector3();
	            var groupCount = 0;
	            // this will be used to calculate the normal
	            var slope = (radiusBottom - radiusTop) / height;
	            // generate vertices, normals and uvs
	            for (var y = 0; y <= heightSegments; y++) {
	                var indexRow = [];
	                var v = y / heightSegments;
	                // calculate the radius of the current row
	                var radius = v * (radiusBottom - radiusTop) + radiusTop;
	                for (var x = 0; x <= radialSegments; x++) {
	                    var u = x / radialSegments;
	                    var theta = u * thetaLength + thetaStart;
	                    var sinTheta = Math.sin(theta);
	                    var cosTheta = Math.cos(theta);
	                    // vertex
	                    vertex.x = radius * sinTheta;
	                    vertex.y = -v * height + halfHeight;
	                    vertex.z = radius * cosTheta;
	                    vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
	                    // normal
	                    normal.set(sinTheta, slope, cosTheta).normalize();
	                    normals.setXYZ(index, normal.x, normal.y, normal.z);
	                    // uv
	                    uvs.setXY(index, u, 1 - v);
	                    // save index of vertex in respective row
	                    indexRow.push(index);
	                    // increase index
	                    index++;
	                }
	                // now save vertices of the row in our index array
	                indexArray.push(indexRow);
	            }
	            // generate indices
	            for (var x = 0; x < radialSegments; x++) {
	                for (var y = 0; y < heightSegments; y++) {
	                    // we use the index array to access the correct indices
	                    var i1 = indexArray[y][x];
	                    var i2 = indexArray[y + 1][x];
	                    var i3 = indexArray[y + 1][x + 1];
	                    var i4 = indexArray[y][x + 1];
	                    // face one
	                    indices.setX(indexOffset, i1);
	                    indexOffset++;
	                    indices.setX(indexOffset, i2);
	                    indexOffset++;
	                    indices.setX(indexOffset, i4);
	                    indexOffset++;
	                    // face two
	                    indices.setX(indexOffset, i2);
	                    indexOffset++;
	                    indices.setX(indexOffset, i3);
	                    indexOffset++;
	                    indices.setX(indexOffset, i4);
	                    indexOffset++;
	                    // update counters
	                    groupCount += 6;
	                }
	            }
	            // add a group to the geometry. this will ensure multi material support
	            scope.addGroup(groupStart, groupCount, 0);
	            // calculate new start value for groups
	            groupStart += groupCount;
	        }
	        function generateCap(top) {
	            var uv = new Vector2();
	            var vertex = new Vector3();
	            var groupCount = 0;
	            var radius = (top === true) ? radiusTop : radiusBottom;
	            var sign = (top === true) ? 1 : -1;
	            // save the index of the first center vertex
	            var centerIndexStart = index;
	            // first we generate the center vertex data of the cap.
	            // because the geometry needs one set of uvs per face,
	            // we must generate a center vertex per face/segment
	            for (var x = 1; x <= radialSegments; x++) {
	                // vertex
	                vertices.setXYZ(index, 0, halfHeight * sign, 0);
	                // normal
	                normals.setXYZ(index, 0, sign, 0);
	                // uv
	                uv.x = 0.5;
	                uv.y = 0.5;
	                uvs.setXY(index, uv.x, uv.y);
	                // increase index
	                index++;
	            }
	            // save the index of the last center vertex
	            var centerIndexEnd = index;
	            // now we generate the surrounding vertices, normals and uvs
	            for (var x = 0; x <= radialSegments; x++) {
	                var u = x / radialSegments;
	                var theta = u * thetaLength + thetaStart;
	                var cosTheta = Math.cos(theta);
	                var sinTheta = Math.sin(theta);
	                // vertex
	                vertex.x = radius * sinTheta;
	                vertex.y = halfHeight * sign;
	                vertex.z = radius * cosTheta;
	                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
	                // normal
	                normals.setXYZ(index, 0, sign, 0);
	                // uv
	                uv.x = (cosTheta * 0.5) + 0.5;
	                uv.y = (sinTheta * 0.5 * sign) + 0.5;
	                uvs.setXY(index, uv.x, uv.y);
	                // increase index
	                index++;
	            }
	            // generate indices
	            for (var x = 0; x < radialSegments; x++) {
	                var c = centerIndexStart + x;
	                var i = centerIndexEnd + x;
	                if (top === true) {
	                    // face top
	                    indices.setX(indexOffset, i);
	                    indexOffset++;
	                    indices.setX(indexOffset, i + 1);
	                    indexOffset++;
	                    indices.setX(indexOffset, c);
	                    indexOffset++;
	                }
	                else {
	                    // face bottom
	                    indices.setX(indexOffset, i + 1);
	                    indexOffset++;
	                    indices.setX(indexOffset, i);
	                    indexOffset++;
	                    indices.setX(indexOffset, c);
	                    indexOffset++;
	                }
	                // update counters
	                groupCount += 3;
	            }
	            // add a group to the geometry. this will ensure multi material support
	            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
	            // calculate new start value for groups
	            groupStart += groupCount;
	        }
	        return _this;
	    }
	    return CylinderBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var CylinderGeometry = /** @class */ (function (_super) {
	    __extends(CylinderGeometry, _super);
	    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
	        var _this = _super.call(this) || this;
	        _this.type = 'CylinderGeometry';
	        _this.parameters = {
	            radiusTop: radiusTop,
	            radiusBottom: radiusBottom,
	            height: height,
	            radialSegments: radialSegments,
	            heightSegments: heightSegments,
	            openEnded: openEnded,
	            thetaStart: thetaStart,
	            thetaLength: thetaLength
	        };
	        _this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
	        _this.mergeVertices();
	        return _this;
	    }
	    return CylinderGeometry;
	}(Geometry));

	/**
	 * @author abelnation / http://github.com/abelnation
	 */
	var ConeGeometry = /** @class */ (function (_super) {
	    __extends(ConeGeometry, _super);
	    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
	        var _this = _super.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) || this;
	        _this.type = 'ConeGeometry';
	        _this.parameters = {
	            radius: radius,
	            height: height,
	            radialSegments: radialSegments,
	            heightSegments: heightSegments,
	            openEnded: openEnded,
	            thetaStart: thetaStart,
	            thetaLength: thetaLength
	        };
	        return _this;
	    }
	    return ConeGeometry;
	}(CylinderGeometry));

	/*
	 * @author: abelnation / http://github.com/abelnation
	 */
	var ConeBufferGeometry = /** @class */ (function (_super) {
	    __extends(ConeBufferGeometry, _super);
	    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
	        var _this = _super.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) || this;
	        _this.type = 'ConeBufferGeometry';
	        _this.parameters = {
	            radius: radius,
	            height: height,
	            radialSegments: radialSegments,
	            heightSegments: heightSegments,
	            openEnded: openEnded,
	            thetaStart: thetaStart,
	            thetaLength: thetaLength
	        };
	        return _this;
	    }
	    return ConeBufferGeometry;
	}(CylinderBufferGeometry));

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	var CircleBufferGeometry = /** @class */ (function (_super) {
	    __extends(CircleBufferGeometry, _super);
	    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
	        var _this = _super.call(this) || this;
	        _this.type = 'CircleBufferGeometry';
	        _this.parameters = {
	            radius: radius,
	            segments: segments,
	            thetaStart: thetaStart,
	            thetaLength: thetaLength
	        };
	        radius = radius || 50;
	        segments = segments !== undefined ? Math.max(3, segments) : 8;
	        thetaStart = thetaStart !== undefined ? thetaStart : 0;
	        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	        var vertices = segments + 2;
	        var positions = new Float32Array(vertices * 3);
	        var normals = new Float32Array(vertices * 3);
	        var uvs = new Float32Array(vertices * 2);
	        // center data is already zero, but need to set a few extras
	        normals[2] = 1.0;
	        uvs[0] = 0.5;
	        uvs[1] = 0.5;
	        for (var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2) {
	            var segment = thetaStart + s / segments * thetaLength;
	            positions[i] = radius * Math.cos(segment);
	            positions[i + 1] = radius * Math.sin(segment);
	            normals[i + 2] = 1; // normal z
	            uvs[ii] = (positions[i] / radius + 1) / 2;
	            uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;
	        }
	        var indices = [];
	        for (var i = 1; i <= segments; i++) {
	            indices.push(i, i + 1, 0);
	        }
	        _this.setIndex(new BufferAttribute(new Uint16Array(indices), 1));
	        _this.addAttribute('position', new BufferAttribute(positions, 3));
	        _this.addAttribute('normal', new BufferAttribute(normals, 3));
	        _this.addAttribute('uv', new BufferAttribute(uvs, 2));
	        _this.boundingSphere = new Sphere(new Vector3(), radius);
	        return _this;
	    }
	    return CircleBufferGeometry;
	}(BufferGeometry));

	/**
	 * @author hughes
	 */
	var CircleGeometry = /** @class */ (function (_super) {
	    __extends(CircleGeometry, _super);
	    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
	        var _this = _super.call(this) || this;
	        _this.type = 'CircleGeometry';
	        _this.parameters = {
	            radius: radius,
	            segments: segments,
	            thetaStart: thetaStart,
	            thetaLength: thetaLength
	        };
	        _this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
	        return _this;
	    }
	    return CircleGeometry;
	}(Geometry));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */
	var BoxGeometry = /** @class */ (function (_super) {
	    __extends(BoxGeometry, _super);
	    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
	        var _this = _super.call(this) || this;
	        _this.type = 'BoxGeometry';
	        _this.parameters = {
	            width: width,
	            height: height,
	            depth: depth,
	            widthSegments: widthSegments,
	            heightSegments: heightSegments,
	            depthSegments: depthSegments
	        };
	        _this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
	        _this.mergeVertices();
	        return _this;
	    }
	    return BoxGeometry;
	}(Geometry));



	var Geometries = Object.freeze({
		WireframeGeometry: WireframeGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusBufferGeometry,
		TextGeometry: TextGeometry,
		SphereBufferGeometry: SphereBufferGeometry,
		SphereGeometry: SphereGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingBufferGeometry,
		PlaneBufferGeometry: PlaneBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		EdgesGeometry: EdgesGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CircleBufferGeometry: CircleBufferGeometry,
		CircleGeometry: CircleGeometry,
		BoxBufferGeometry: BoxBufferGeometry,
		BoxGeometry: BoxGeometry
	});

	var ShadowMaterial = /** @class */ (function (_super) {
	    __extends(ShadowMaterial, _super);
	    function ShadowMaterial() {
	        var _this = _super.call(this, {
	            uniforms: UniformsUtils.merge([
	                UniformsLib["lights"],
	                {
	                    opacity: { value: 1.0 }
	                }
	            ]),
	            vertexShader: ShaderChunk['shadow_vert'],
	            fragmentShader: ShaderChunk['shadow_frag']
	        }) || this;
	        _this.isShadowMaterial = true;
	        _this.lights = true;
	        _this.transparent = true;
	        return _this;
	    }
	    Object.defineProperty(ShadowMaterial.prototype, "opacity", {
	        get: function () { return this.uniforms.opacity.value; },
	        set: function (value) { this.uniforms.opacity.value = value; },
	        enumerable: true,
	        configurable: true
	    });
	    return ShadowMaterial;
	}(ShaderMaterial));



	var Materials = Object.freeze({
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MultiMaterial: MultiMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Cache = /** @class */ (function () {
	    function Cache() {
	    }
	    Cache.add = function (key, file) {
	        if (Cache.enabled === false)
	            return;
	        // console.log('THREE.Cache', 'Adding key:', key);
	        Cache.files[key] = file;
	    };
	    Cache.get = function (key) {
	        if (Cache.enabled === false)
	            return;
	        // console.log('THREE.Cache', 'Checking key:', key);
	        return Cache.files[key];
	    };
	    Cache.remove = function (key) {
	        delete Cache.files[key];
	    };
	    Cache.clear = function () {
	        Cache.files = {};
	    };
	    Cache.enabled = false;
	    Cache.files = {};
	    return Cache;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var LoadingManager = /** @class */ (function () {
	    function LoadingManager(onLoad, onProgress, onError) {
	        this.isLoading = false;
	        this.itemsLoaded = 0;
	        this.itemsTotal = 0;
	        this.onStart = undefined;
	        this.onLoad = onLoad;
	        this.onProgress = onProgress;
	        this.onError = onError;
	    }
	    LoadingManager.prototype.itemStart = function (url) {
	        this.itemsTotal++;
	        if (this.isLoading === false) {
	            if (this.onStart !== undefined) {
	                this.onStart(url, this.itemsLoaded, this.itemsTotal);
	            }
	        }
	        this.isLoading = true;
	    };
	    LoadingManager.prototype.itemEnd = function (url) {
	        this.itemsLoaded++;
	        if (this.onProgress !== undefined) {
	            this.onProgress(url, this.itemsLoaded, this.itemsTotal);
	        }
	        if (this.itemsLoaded === this.itemsTotal) {
	            this.isLoading = false;
	            if (this.onLoad !== undefined) {
	                this.onLoad();
	            }
	        }
	    };
	    LoadingManager.prototype.itemError = function (url) {
	        if (this.onError !== undefined) {
	            this.onError(url);
	        }
	    };
	    return LoadingManager;
	}());
	var DefaultLoadingManager = new LoadingManager();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var XHRLoader = /** @class */ (function () {
	    function XHRLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.manager = manager;
	    }
	    XHRLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        if (url === undefined)
	            url = '';
	        if (this.path !== undefined)
	            url = this.path + url;
	        var scope = this;
	        var cached = Cache.get(url);
	        if (cached !== undefined) {
	            scope.manager.itemStart(url);
	            setTimeout(function () {
	                if (onLoad)
	                    onLoad(cached);
	                scope.manager.itemEnd(url);
	            }, 0);
	            return cached;
	        }
	        var request;
	        // Check for data: URI
	        var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
	        var dataUriRegexResult = url.match(dataUriRegex);
	        // Safari can not handle Data URIs through XMLHttpRequest so process manually
	        if (dataUriRegexResult) {
	            var mimeType = dataUriRegexResult[1];
	            var isBase64 = !!dataUriRegexResult[2];
	            var data = dataUriRegexResult[3];
	            data = decodeURIComponent(data);
	            if (isBase64) {
	                data = window.atob(data);
	            }
	            try {
	                var response_1;
	                var responseType = (this.responseType || '').toLowerCase();
	                switch (responseType) {
	                    case 'arraybuffer':
	                    case 'blob':
	                        response_1 = new ArrayBuffer(data.length);
	                        var view = new Uint8Array(response_1);
	                        for (var i = 0; i < data.length; i++) {
	                            view[i] = data.charCodeAt(i);
	                        }
	                        if (responseType === 'blob') {
	                            response_1 = new Blob([response_1], { "type": mimeType });
	                        }
	                        break;
	                    case 'document':
	                        var parser = new DOMParser();
	                        response_1 = parser.parseFromString(data, mimeType);
	                        break;
	                    case 'json':
	                        response_1 = JSON.parse(data);
	                        break;
	                    default:// 'text' or other
	                        response_1 = data;
	                        break;
	                }
	                // Wait for next browser tick
	                window.setTimeout(function () {
	                    if (onLoad)
	                        onLoad(response_1);
	                    scope.manager.itemEnd(url);
	                }, 0);
	            }
	            catch (error) {
	                // Wait for next browser tick
	                window.setTimeout(function () {
	                    if (onError)
	                        onError(error);
	                    scope.manager.itemError(url);
	                }, 0);
	            }
	        }
	        else {
	            request = new XMLHttpRequest();
	            request.open('GET', url, true);
	            request.addEventListener('load', function (event) {
	                var response = request.response;
	                Cache.add(url, response);
	                if (request.status === 200) {
	                    if (onLoad)
	                        onLoad(response);
	                    scope.manager.itemEnd(url);
	                }
	                else if (request.status === 0) {
	                    // Some browsers return HTTP Status 0 when using non-http protocol
	                    // e.g. 'file://' or 'data://'. Handle as success.
	                    console.warn('THREE.XHRLoader: HTTP Status 0 received.');
	                    if (onLoad)
	                        onLoad(response);
	                    scope.manager.itemEnd(url);
	                }
	                else {
	                    if (onError)
	                        onError(event);
	                    scope.manager.itemError(url);
	                }
	            }, false);
	            if (onProgress !== undefined) {
	                request.addEventListener('progress', function (event) {
	                    onProgress(event);
	                }, false);
	            }
	            request.addEventListener('error', function (event) {
	                if (onError)
	                    onError(event);
	                scope.manager.itemError(url);
	            }, false);
	            if (this.responseType !== undefined)
	                request.responseType = this.responseType;
	            if (this.withCredentials !== undefined)
	                request.withCredentials = this.withCredentials;
	            if (request.overrideMimeType)
	                request.overrideMimeType('text/plain');
	            request.send(null);
	        }
	        scope.manager.itemStart(url);
	        return request;
	    };
	    XHRLoader.prototype.setPath = function (value) {
	        this.path = value;
	        return this;
	    };
	    XHRLoader.prototype.setResponseType = function (value) {
	        this.responseType = value;
	        return this;
	    };
	    XHRLoader.prototype.setWithCredentials = function (value) {
	        this.withCredentials = value;
	        return this;
	    };
	    return XHRLoader;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */
	var CompressedTextureLoader = /** @class */ (function () {
	    function CompressedTextureLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.manager = manager;
	        // override in sub classes
	        this._parser = null;
	    }
	    CompressedTextureLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        var scope = this;
	        var images = [];
	        var texture = new CompressedTexture();
	        texture.image = images;
	        var loader = new XHRLoader(this.manager);
	        loader.setPath(this.path);
	        loader.setResponseType('arraybuffer');
	        var loaded = 0;
	        function loadTexture(i) {
	            loader.load(url[i], function (buffer) {
	                var texDatas = scope._parser(buffer, true);
	                images[i] = {
	                    width: texDatas.width,
	                    height: texDatas.height,
	                    format: texDatas.format,
	                    mipmaps: texDatas.mipmaps
	                };
	                loaded += 1;
	                if (loaded === 6) {
	                    if (texDatas.mipmapCount === 1)
	                        texture.minFilter = exports.TextureFilter.Linear;
	                    texture.format = texDatas.format;
	                    texture.needsUpdate = true;
	                    if (onLoad)
	                        onLoad(texture);
	                }
	            }, onProgress, onError);
	        }
	        if (Array.isArray(url)) {
	            loaded = 0;
	            for (var i = 0, il = url.length; i < il; ++i) {
	                loadTexture(i);
	            }
	        }
	        else {
	            // compressed cubemap texture stored in a single DDS file
	            loader.load(url, function (buffer) {
	                var texDatas = scope._parser(buffer, true);
	                if (texDatas.isCubemap) {
	                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	                    for (var f = 0; f < faces; f++) {
	                        images[f] = { mipmaps: [] };
	                        for (var i = 0; i < texDatas.mipmapCount; i++) {
	                            images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
	                            images[f].format = texDatas.format;
	                            images[f].width = texDatas.width;
	                            images[f].height = texDatas.height;
	                        }
	                    }
	                }
	                else {
	                    texture.image.width = texDatas.width;
	                    texture.image.height = texDatas.height;
	                    texture.mipmaps = texDatas.mipmaps;
	                }
	                if (texDatas.mipmapCount === 1) {
	                    texture.minFilter = exports.TextureFilter.Linear;
	                }
	                texture.format = texDatas.format;
	                texture.needsUpdate = true;
	                if (onLoad)
	                    onLoad(texture);
	            }, onProgress, onError);
	        }
	        return texture;
	    };
	    CompressedTextureLoader.prototype.setPath = function (value) {
	        this.path = value;
	        return this;
	    };
	    return CompressedTextureLoader;
	}());

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */
	var BinaryTextureLoader = /** @class */ (function () {
	    function BinaryTextureLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.manager = manager;
	        // override in sub classes
	        this._parser = null;
	    }
	    BinaryTextureLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        var scope = this;
	        var texture = new DataTexture();
	        var loader = new XHRLoader(this.manager);
	        loader.setResponseType('arraybuffer');
	        loader.load(url, function (buffer) {
	            var texData = scope._parser(buffer);
	            if (!texData)
	                return;
	            if (undefined !== texData.image) {
	                texture.image = texData.image;
	            }
	            else if (undefined !== texData.data) {
	                texture.image.width = texData.width;
	                texture.image.height = texData.height;
	                texture.image.data = texData.data;
	            }
	            texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : exports.TextureWrapping.ClampToEdge;
	            texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : exports.TextureWrapping.ClampToEdge;
	            texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : exports.TextureFilter.Linear;
	            texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : exports.TextureFilter.LinearMipMapLinear;
	            texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
	            if (undefined !== texData.format) {
	                texture.format = texData.format;
	            }
	            if (undefined !== texData.type) {
	                texture.type = texData.type;
	            }
	            if (undefined !== texData.mipmaps) {
	                texture.mipmaps = texData.mipmaps;
	            }
	            if (1 === texData.mipmapCount) {
	                texture.minFilter = exports.TextureFilter.Linear;
	            }
	            texture.needsUpdate = true;
	            if (onLoad)
	                onLoad(texture, texData);
	        }, onProgress, onError);
	        return texture;
	    };
	    return BinaryTextureLoader;
	}());
	var DataTextureLoader = BinaryTextureLoader;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var ImageLoader = /** @class */ (function () {
	    function ImageLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.manager = manager;
	    }
	    ImageLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        var scope = this;
	        var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
	        image.onload = function (event) {
	            image.onload = null;
	            URL.revokeObjectURL(image.src);
	            if (onLoad)
	                onLoad(image);
	            scope.manager.itemEnd(url);
	        };
	        image.onerror = onError;
	        if (url.indexOf('data:') === 0) {
	            image.src = url;
	        }
	        else {
	            var loader = new XHRLoader();
	            loader.setPath(this.path);
	            loader.setResponseType('blob');
	            loader.setWithCredentials(this.withCredentials);
	            loader.load(url, function (blob) {
	                image.src = URL.createObjectURL(blob);
	            }, onProgress, onError);
	        }
	        scope.manager.itemStart(url);
	        return image;
	    };
	    ImageLoader.prototype.setCrossOrigin = function (value) {
	        this.crossOrigin = value;
	        return this;
	    };
	    ImageLoader.prototype.setWithCredentials = function (value) {
	        this.withCredentials = value;
	        return this;
	    };
	    ImageLoader.prototype.setPath = function (value) {
	        this.path = value;
	        return this;
	    };
	    return ImageLoader;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var CubeTextureLoader = /** @class */ (function () {
	    function CubeTextureLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.manager = manager;
	    }
	    CubeTextureLoader.prototype.load = function (urls, onLoad, onProgress, onError) {
	        var texture = new CubeTexture();
	        var loader = new ImageLoader(this.manager);
	        loader.setCrossOrigin(this.crossOrigin);
	        loader.setPath(this.path);
	        var loaded = 0;
	        function loadTexture(i) {
	            loader.load(urls[i], function (image) {
	                texture.images[i] = image;
	                loaded++;
	                if (loaded === 6) {
	                    texture.needsUpdate = true;
	                    if (onLoad)
	                        onLoad(texture);
	                }
	            }, undefined, onError);
	        }
	        for (var i = 0; i < urls.length; ++i) {
	            loadTexture(i);
	        }
	        return texture;
	    };
	    CubeTextureLoader.prototype.setCrossOrigin = function (value) {
	        this.crossOrigin = value;
	        return this;
	    };
	    CubeTextureLoader.prototype.setPath = function (value) {
	        this.path = value;
	        return this;
	    };
	    return CubeTextureLoader;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var TextureLoader = /** @class */ (function () {
	    function TextureLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.manager = manager;
	    }
	    TextureLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        var texture = new Texture();
	        var loader = new ImageLoader(this.manager);
	        loader.setCrossOrigin(this.crossOrigin);
	        loader.setWithCredentials(this.withCredentials);
	        loader.setPath(this.path);
	        loader.load(url, function (image) {
	            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
	            var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
	            texture.format = isJPEG ? exports.TextureFormat.RGB : exports.TextureFormat.RGBA;
	            texture.image = image;
	            texture.needsUpdate = true;
	            if (onLoad !== undefined) {
	                onLoad(texture);
	            }
	        }, onProgress, onError);
	        return texture;
	    };
	    TextureLoader.prototype.setCrossOrigin = function (value) {
	        this.crossOrigin = value;
	        return this;
	    };
	    TextureLoader.prototype.setWithCredentials = function (value) {
	        this.withCredentials = value;
	        return this;
	    };
	    TextureLoader.prototype.setPath = function (value) {
	        this.path = value;
	        return this;
	    };
	    return TextureLoader;
	}());

	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	var AnimationUtils = /** @class */ (function () {
	    function AnimationUtils() {
	    }
	    // same as Array.prototype.slice, but also works on typed arrays
	    AnimationUtils.arraySlice = function (array, from, to) {
	        if (AnimationUtils.isTypedArray(array)) {
	            return new array.constructor(array.subarray(from, to));
	        }
	        return array.slice(from, to);
	    };
	    // converts an array to a specific type
	    AnimationUtils.convertArray = function (array, type, forceClone) {
	        if (forceClone === void 0) { forceClone = false; }
	        if (!array || // let 'undefined' and 'null' pass
	            !forceClone && array.constructor === type)
	            return array;
	        if (typeof type.BYTES_PER_ELEMENT === 'number') {
	            return new type(array); // create typed array
	        }
	        return Array.prototype.slice.call(array); // create Array
	    };
	    AnimationUtils.isTypedArray = function (object) {
	        return ArrayBuffer.isView(object) &&
	            !(object instanceof DataView);
	    };
	    // returns an array by which times and values can be sorted
	    AnimationUtils.getKeyframeOrder = function (times) {
	        function compareTime(i, j) {
	            return times[i] - times[j];
	        }
	        var n = times.length;
	        var result = new Array(n);
	        for (var i = 0; i !== n; ++i)
	            result[i] = i;
	        result.sort(compareTime);
	        return result;
	    };
	    // uses the array previously returned by 'getKeyframeOrder' to sort data
	    AnimationUtils.sortedArray = function (values, stride, order) {
	        var nValues = values.length;
	        var result = new values.constructor(nValues);
	        for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
	            var srcOffset = order[i] * stride;
	            for (var j = 0; j !== stride; ++j) {
	                result[dstOffset++] = values[srcOffset + j];
	            }
	        }
	        return result;
	    };
	    // function for parsing AOS keyframe formats
	    AnimationUtils.flattenJSON = function (jsonKeys, times, values, valuePropertyName) {
	        var i = 1, key = jsonKeys[0];
	        while (key !== undefined && key[valuePropertyName] === undefined) {
	            key = jsonKeys[i++];
	        }
	        if (key === undefined)
	            return; // no data
	        var value = key[valuePropertyName];
	        if (value === undefined)
	            return; // no data
	        if (Array.isArray(value)) {
	            do {
	                value = key[valuePropertyName];
	                if (value !== undefined) {
	                    times.push(key.time);
	                    values.push.apply(values, value); // push all elements
	                }
	                key = jsonKeys[i++];
	            } while (key !== undefined);
	        }
	        else if (value.toArray !== undefined) {
	            // ...assume THREE.Math-ish
	            do {
	                value = key[valuePropertyName];
	                if (value !== undefined) {
	                    times.push(key.time);
	                    value.toArray(values, values.length);
	                }
	                key = jsonKeys[i++];
	            } while (key !== undefined);
	        }
	        else {
	            // otherwise push as-is
	            do {
	                value = key[valuePropertyName];
	                if (value !== undefined) {
	                    times.push(key.time);
	                    values.push(value);
	                }
	                key = jsonKeys[i++];
	            } while (key !== undefined);
	        }
	    };
	    return AnimationUtils;
	}());

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 *     http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */
	var Interpolant = /** @class */ (function () {
	    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
	        this.settings = null; // optional, subclass-specific settings structure
	        // Note: The indirection allows central control of many interpolants.
	        // --- Protected interface
	        this.DefaultSettings_ = {};
	        this.parameterPositions = parameterPositions;
	        this._cachedIndex = 0;
	        this.resultBuffer = resultBuffer !== undefined ?
	            resultBuffer : new sampleValues.constructor(sampleSize);
	        this.sampleValues = sampleValues;
	        this.valueSize = sampleSize;
	    }
	    Interpolant.prototype.evaluate = function (t) {
	        var pp = this.parameterPositions;
	        var i1 = this._cachedIndex;
	        var t1 = pp[i1];
	        var t0 = pp[i1 - 1];
	        validate_interval: {
	            seek: {
	                var right = void 0;
	                linear_scan: {
	                    //- See http://jsperf.com/comparison-to-undefined/3
	                    //- slower code:
	                    //-
	                    //-         if (t >= t1 || t1 === undefined) {
	                    forward_scan: if (!(t < t1)) {
	                        for (var giveUpAt = i1 + 2;;) {
	                            if (t1 === undefined) {
	                                if (t < t0)
	                                    break forward_scan;
	                                // after end
	                                i1 = pp.length;
	                                this._cachedIndex = i1;
	                                return this.afterEnd_(i1 - 1, t, t0);
	                            }
	                            if (i1 === giveUpAt)
	                                break; // this loop
	                            t0 = t1;
	                            t1 = pp[++i1];
	                            if (t < t1) {
	                                // we have arrived at the sought interval
	                                break seek;
	                            }
	                        }
	                        // prepare binary search on the right side of the index
	                        right = pp.length;
	                        break linear_scan;
	                    }
	                    //- slower code:
	                    //-          if (t < t0 || t0 === undefined) {
	                    if (!(t >= t0)) {
	                        // looping?
	                        var t1global = pp[1];
	                        if (t < t1global) {
	                            i1 = 2; // + 1, using the scan for the details
	                            t0 = t1global;
	                        }
	                        // linear reverse scan
	                        for (var giveUpAt = i1 - 2;;) {
	                            if (t0 === undefined) {
	                                // before start
	                                this._cachedIndex = 0;
	                                return this.beforeStart_(0, t, t1);
	                            }
	                            if (i1 === giveUpAt)
	                                break; // this loop
	                            t1 = t0;
	                            t0 = pp[--i1 - 1];
	                            if (t >= t0) {
	                                // we have arrived at the sought interval
	                                break seek;
	                            }
	                        }
	                        // prepare binary search on the left side of the index
	                        right = i1;
	                        i1 = 0;
	                        break linear_scan;
	                    }
	                    // the interval is valid
	                    break validate_interval;
	                } // linear scan
	                // binary search
	                while (i1 < right) {
	                    var mid = (i1 + right) >>> 1;
	                    if (t < pp[mid]) {
	                        right = mid;
	                    }
	                    else {
	                        i1 = mid + 1;
	                    }
	                }
	                t1 = pp[i1];
	                t0 = pp[i1 - 1];
	                // check boundary cases, again
	                if (t0 === undefined) {
	                    this._cachedIndex = 0;
	                    return this.beforeStart_(0, t, t1);
	                }
	                if (t1 === undefined) {
	                    i1 = pp.length;
	                    this._cachedIndex = i1;
	                    return this.afterEnd_(i1 - 1, t0, t);
	                }
	            } // seek
	            this._cachedIndex = i1;
	            this.intervalChanged_(i1, t0, t1);
	        } // validate_interval
	        return this.interpolate_(i1, t0, t, t1);
	    };
	    Interpolant.prototype.getSettings_ = function () {
	        return this.settings || this.DefaultSettings_;
	    };
	    Interpolant.prototype.copySampleValue_ = function (index, t0, t1) {
	        // copies a sample value to the result buffer
	        var result = this.resultBuffer;
	        var values = this.sampleValues;
	        var stride = this.valueSize;
	        var offset = index * stride;
	        for (var i = 0; i !== stride; ++i) {
	            result[i] = values[offset + i];
	        }
	        return result;
	    };
	    // Template methods for derived classes:
	    Interpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
	        throw new Error("call to abstract method");
	        // implementations shall return this.resultBuffer
	    };
	    Interpolant.prototype.intervalChanged_ = function (i1, t0, t1) {
	        // empty
	    };
	    Interpolant.prototype.beforeStart_ = function (i, t0, t1) {
	        return this.copySampleValue_(i, t0, t1); //(0, t, t0), returns this.resultBuffer
	    };
	    Interpolant.prototype.afterEnd_ = function (i, t0, t1) {
	        return this.copySampleValue_(i, t0, t1); //(N-1, tN-1, t), returns this.resultBuffer
	    };
	    return Interpolant;
	}());

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */
	var CubicInterpolant = /** @class */ (function (_super) {
	    __extends(CubicInterpolant, _super);
	    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
	        var _this = _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
	        _this.DefaultSettings_ = {
	            endingStart: exports.EndingMode.ZeroCurvature,
	            endingEnd: exports.EndingMode.ZeroCurvature
	        };
	        _this._weightPrev = -0;
	        _this._offsetPrev = -0;
	        _this._weightNext = -0;
	        _this._offsetNext = -0;
	        return _this;
	    }
	    CubicInterpolant.prototype.intervalChanged_ = function (i1, t0, t1) {
	        var pp = this.parameterPositions;
	        var iPrev = i1 - 2;
	        var iNext = i1 + 1;
	        var tPrev = pp[iPrev];
	        var tNext = pp[iNext];
	        if (tPrev === undefined) {
	            switch (this.getSettings_().endingStart) {
	                case exports.EndingMode.ZeroSlope:
	                    // f'(t0) = 0
	                    iPrev = i1;
	                    tPrev = 2 * t0 - t1;
	                    break;
	                case exports.EndingMode.WrapAround:
	                    // use the other end of the curve
	                    iPrev = pp.length - 2;
	                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
	                    break;
	                default:// EndingMode.ZeroCurvature
	                    // f''(t0) = 0 a.k.a. Natural Spline
	                    iPrev = i1;
	                    tPrev = t1;
	            }
	        }
	        if (tNext === undefined) {
	            switch (this.getSettings_().endingEnd) {
	                case exports.EndingMode.ZeroSlope:
	                    // f'(tN) = 0
	                    iNext = i1;
	                    tNext = 2 * t1 - t0;
	                    break;
	                case exports.EndingMode.WrapAround:
	                    // use the other end of the curve
	                    iNext = 1;
	                    tNext = t1 + pp[1] - pp[0];
	                    break;
	                default:// EndingMode.ZeroCurvature
	                    // f''(tN) = 0, a.k.a. Natural Spline
	                    iNext = i1 - 1;
	                    tNext = t0;
	            }
	        }
	        var halfDt = (t1 - t0) * 0.5;
	        var stride = this.valueSize;
	        this._weightPrev = halfDt / (t0 - tPrev);
	        this._weightNext = halfDt / (tNext - t1);
	        this._offsetPrev = iPrev * stride;
	        this._offsetNext = iNext * stride;
	    };
	    CubicInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
	        var result = this.resultBuffer;
	        var values = this.sampleValues;
	        var stride = this.valueSize;
	        var o1 = i1 * stride;
	        var o0 = o1 - stride;
	        var oP = this._offsetPrev;
	        var oN = this._offsetNext;
	        var wP = this._weightPrev;
	        var wN = this._weightNext;
	        var p = (t - t0) / (t1 - t0);
	        var pp = p * p;
	        var ppp = pp * p;
	        // evaluate polynomials
	        var sP = -wP * ppp + 2 * wP * pp - wP * p;
	        var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
	        var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
	        var sN = wN * ppp - wN * pp;
	        // combine data linearly
	        for (var i = 0; i !== stride; ++i) {
	            result[i] =
	                sP * values[oP + i] +
	                    s0 * values[o0 + i] +
	                    s1 * values[o1 + i] +
	                    sN * values[oN + i];
	        }
	        return result;
	    };
	    return CubicInterpolant;
	}(Interpolant));

	/**
	 * @author tschw
	 */
	var LinearInterpolant = /** @class */ (function (_super) {
	    __extends(LinearInterpolant, _super);
	    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
	        return _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
	    }
	    LinearInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
	        var result = this.resultBuffer;
	        var values = this.sampleValues;
	        var stride = this.valueSize;
	        var offset1 = i1 * stride;
	        var offset0 = offset1 - stride;
	        var weight1 = (t - t0) / (t1 - t0);
	        var weight0 = 1 - weight1;
	        for (var i = 0; i !== stride; ++i) {
	            result[i] =
	                values[offset0 + i] * weight0 +
	                    values[offset1 + i] * weight1;
	        }
	        return result;
	    };
	    return LinearInterpolant;
	}(Interpolant));

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */
	var DiscreteInterpolant = /** @class */ (function (_super) {
	    __extends(DiscreteInterpolant, _super);
	    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
	        return _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
	    }
	    DiscreteInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
	        return this.copySampleValue_(i1 - 1);
	    };
	    return DiscreteInterpolant;
	}(Interpolant));

	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	var KeyframeTrack = /** @class */ (function () {
	    function KeyframeTrack(name, times, values, interpolation) {
	        this.TimeBufferType = Float32Array;
	        this.ValueBufferType = Float32Array;
	        this.DefaultInterpolation = exports.InterpolateMode.Linear;
	        if (name === undefined)
	            throw new Error("track name is undefined");
	        if (times === undefined || times.length === 0) {
	            throw new Error("no keyframes in track named " + name);
	        }
	        this.name = name;
	        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
	        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
	        this.setInterpolation(interpolation || this.DefaultInterpolation);
	        this.validate();
	        this.optimize();
	    }
	    KeyframeTrack.prototype.InterpolantFactoryMethodDiscrete = function (result) {
	        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
	    };
	    KeyframeTrack.prototype.InterpolantFactoryMethodLinear = function (result) {
	        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
	    };
	    KeyframeTrack.prototype.InterpolantFactoryMethodSmooth = function (result) {
	        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
	    };
	    KeyframeTrack.prototype.setInterpolation = function (interpolation) {
	        var factoryMethod;
	        switch (interpolation) {
	            case exports.InterpolateMode.Discrete:
	                factoryMethod = this.InterpolantFactoryMethodDiscrete;
	                break;
	            case exports.InterpolateMode.Linear:
	                factoryMethod = this.InterpolantFactoryMethodLinear;
	                break;
	            case exports.InterpolateMode.Smooth:
	                factoryMethod = this.InterpolantFactoryMethodSmooth;
	                break;
	        }
	        if (factoryMethod === undefined) {
	            var message = "unsupported interpolation for " +
	                this.ValueTypeName + " keyframe track named " + this.name;
	            if (this.createInterpolant === undefined) {
	                // fall back to default, unless the default itself is messed up
	                if (interpolation !== this.DefaultInterpolation) {
	                    this.setInterpolation(this.DefaultInterpolation);
	                }
	                else {
	                    throw new Error(message); // fatal, in this case
	                }
	            }
	            console.warn(message);
	            return;
	        }
	        this.createInterpolant = factoryMethod;
	    };
	    KeyframeTrack.prototype.getInterpolation = function () {
	        switch (this.createInterpolant) {
	            case this.InterpolantFactoryMethodDiscrete:
	                return exports.InterpolateMode.Discrete;
	            case this.InterpolantFactoryMethodLinear:
	                return exports.InterpolateMode.Linear;
	            case this.InterpolantFactoryMethodSmooth:
	                return exports.InterpolateMode.Smooth;
	        }
	        throw new Error();
	    };
	    KeyframeTrack.prototype.getValueSize = function () {
	        return this.values.length / this.times.length;
	    };
	    // move all keyframes either forwards or backwards in time
	    KeyframeTrack.prototype.shift = function (timeOffset) {
	        if (timeOffset !== 0.0) {
	            var times = this.times;
	            for (var i = 0, n = times.length; i !== n; ++i) {
	                times[i] += timeOffset;
	            }
	        }
	        return this;
	    };
	    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	    KeyframeTrack.prototype.scale = function (timeScale) {
	        if (timeScale !== 1.0) {
	            var times = this.times;
	            for (var i = 0, n = times.length; i !== n; ++i) {
	                times[i] *= timeScale;
	            }
	        }
	        return this;
	    };
	    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	    KeyframeTrack.prototype.trim = function (startTime, endTime) {
	        var times = this.times;
	        var nKeys = times.length;
	        var from = 0;
	        var to = nKeys - 1;
	        while (from !== nKeys && times[from] < startTime)
	            ++from;
	        while (to !== -1 && times[to] > endTime)
	            --to;
	        ++to; // inclusive -> exclusive bound
	        if (from !== 0 || to !== nKeys) {
	            // empty tracks are forbidden, so keep at least one keyframe
	            if (from >= to)
	                to = Math.max(to, 1), from = to - 1;
	            var stride = this.getValueSize();
	            this.times = AnimationUtils.arraySlice(times, from, to);
	            this.values = AnimationUtils.
	                arraySlice(this.values, from * stride, to * stride);
	        }
	        return this;
	    };
	    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	    KeyframeTrack.prototype.validate = function () {
	        var valid = true;
	        var valueSize = this.getValueSize();
	        if (valueSize - Math.floor(valueSize) !== 0) {
	            console.error("invalid value size in track", this);
	            valid = false;
	        }
	        var times = this.times;
	        var values = this.values;
	        var nKeys = times.length;
	        if (nKeys === 0) {
	            console.error("track is empty", this);
	            valid = false;
	        }
	        var prevTime = null;
	        for (var i = 0; i !== nKeys; i++) {
	            var currTime = times[i];
	            if (typeof currTime === 'number' && isNaN(currTime)) {
	                console.error("time is not a valid number", this, i, currTime);
	                valid = false;
	                break;
	            }
	            if (prevTime !== null && prevTime > currTime) {
	                console.error("out of order keys", this, i, currTime, prevTime);
	                valid = false;
	                break;
	            }
	            prevTime = currTime;
	        }
	        if (values !== undefined) {
	            if (AnimationUtils.isTypedArray(values)) {
	                for (var i = 0, n = values.length; i !== n; ++i) {
	                    var value = values[i];
	                    if (isNaN(value)) {
	                        console.error("value is not a valid number", this, i, value);
	                        valid = false;
	                        break;
	                    }
	                }
	            }
	        }
	        return valid;
	    };
	    // removes equivalent sequential keys as common in morph target sequences
	    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	    KeyframeTrack.prototype.optimize = function () {
	        var times = this.times;
	        var values = this.values;
	        var stride = this.getValueSize();
	        var smoothInterpolation = this.getInterpolation() === exports.InterpolateMode.Smooth;
	        var writeIndex = 1;
	        var lastIndex = times.length - 1;
	        for (var i = 1; i < lastIndex; ++i) {
	            var keep = false;
	            var time = times[i];
	            var timeNext = times[i + 1];
	            // remove adjacent keyframes scheduled at the same time
	            if (time !== timeNext && (i !== 1 || time !== time[0])) {
	                if (!smoothInterpolation) {
	                    // remove unnecessary keyframes same as their neighbors
	                    var offset = i * stride;
	                    var offsetP = offset - stride;
	                    var offsetN = offset + stride;
	                    for (var j = 0; j !== stride; ++j) {
	                        var value = values[offset + j];
	                        if (value !== values[offsetP + j] ||
	                            value !== values[offsetN + j]) {
	                            keep = true;
	                            break;
	                        }
	                    }
	                }
	                else
	                    keep = true;
	            }
	            // in-place compaction
	            if (keep) {
	                if (i !== writeIndex) {
	                    times[writeIndex] = times[i];
	                    var readOffset = i * stride;
	                    var writeOffset = writeIndex * stride;
	                    for (var j = 0; j !== stride; ++j)
	                        values[writeOffset + j] = values[readOffset + j];
	                }
	                ++writeIndex;
	            }
	        }
	        // flush last keyframe (compaction looks ahead)
	        if (lastIndex > 0) {
	            times[writeIndex] = times[lastIndex];
	            for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j)
	                values[writeOffset + j] = values[readOffset + j];
	            ++writeIndex;
	        }
	        if (writeIndex !== times.length) {
	            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
	            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
	        }
	        return this;
	    };
	    return KeyframeTrack;
	}());

	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	var NewStringKeyframeTrack = /** @class */ (function (_super) {
	    __extends(NewStringKeyframeTrack, _super);
	    function NewStringKeyframeTrack(name, times, values, interpolation) {
	        var _this = _super.call(this, name, times, values, interpolation) || this;
	        _this.ValueTypeName = 'string';
	        _this.ValueBufferType = Array;
	        _this.DefaultInterpolation = exports.InterpolateMode.Discrete;
	        return _this;
	    }
	    return NewStringKeyframeTrack;
	}(KeyframeTrack));

	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	var NewBooleanKeyframeTrack = /** @class */ (function (_super) {
	    __extends(NewBooleanKeyframeTrack, _super);
	    function NewBooleanKeyframeTrack(name, times, values, interpolation) {
	        var _this = _super.call(this, name, times, values, interpolation) || this;
	        _this.ValueTypeName = 'color';
	        _this.ValueBufferType = Array;
	        _this.DefaultInterpolation = exports.InterpolateMode.Discrete;
	        return _this;
	    }
	    return NewBooleanKeyframeTrack;
	}(KeyframeTrack));

	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */
	var QuaternionLinearInterpolant = /** @class */ (function (_super) {
	    __extends(QuaternionLinearInterpolant, _super);
	    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
	        return _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
	    }
	    QuaternionLinearInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
	        var result = this.resultBuffer;
	        var values = this.sampleValues;
	        var stride = this.valueSize;
	        var offset = i1 * stride;
	        var alpha = (t - t0) / (t1 - t0);
	        for (var end = offset + stride; offset !== end; offset += 4) {
	            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
	        }
	        return result;
	    };
	    return QuaternionLinearInterpolant;
	}(Interpolant));

	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	var NewQuaternionKeyframeTrack = /** @class */ (function (_super) {
	    __extends(NewQuaternionKeyframeTrack, _super);
	    function NewQuaternionKeyframeTrack(name, times, values, interpolation) {
	        var _this = _super.call(this, name, times, values, interpolation) || this;
	        _this.ValueTypeName = 'quaternion';
	        // ValueBufferType is inherited
	        _this.DefaultInterpolation = exports.InterpolateMode.Linear;
	        return _this;
	    }
	    NewQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodLinear = function (result) {
	        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
	    };
	    return NewQuaternionKeyframeTrack;
	}(KeyframeTrack));

	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	var NewColorKeyframeTrack = /** @class */ (function (_super) {
	    __extends(NewColorKeyframeTrack, _super);
	    function NewColorKeyframeTrack(name, times, values, interpolation) {
	        var _this = _super.call(this, name, times, values, interpolation) || this;
	        _this.ValueTypeName = 'color';
	        return _this;
	    }
	    return NewColorKeyframeTrack;
	}(KeyframeTrack));

	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	var NewVectorKeyframeTrack = /** @class */ (function (_super) {
	    __extends(NewVectorKeyframeTrack, _super);
	    function NewVectorKeyframeTrack(name, times, values, interpolation) {
	        var _this = _super.call(this, name, times, values, interpolation) || this;
	        _this.ValueTypeName = 'vector';
	        return _this;
	    }
	    return NewVectorKeyframeTrack;
	}(KeyframeTrack));

	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	var NewNumberKeyframeTrack = /** @class */ (function (_super) {
	    __extends(NewNumberKeyframeTrack, _super);
	    function NewNumberKeyframeTrack(name, times, values, interpolation) {
	        var _this = _super.call(this, name, times, values, interpolation) || this;
	        _this.ValueTypeName = 'number';
	        return _this;
	    }
	    return NewNumberKeyframeTrack;
	}(KeyframeTrack));

	var KeyframeTrackUtils = /** @class */ (function () {
	    function KeyframeTrackUtils() {
	    }
	    // Static methods:
	    // Serialization (in static context, because of constructor invocation
	    // and automatic invocation of .toJSON):
	    KeyframeTrackUtils.parse = function (json) {
	        if (json.type === undefined) {
	            throw new Error("track type undefined, can not parse");
	        }
	        var trackType = KeyframeTrackUtils._getTrackTypeForValueTypeName(json.type);
	        if (json.times === undefined) {
	            var times = [], values = [];
	            AnimationUtils.flattenJSON(json.keys, times, values, 'value');
	            json.times = times;
	            json.values = values;
	        }
	        // derived classes can define a static parse method
	        if (trackType.parse !== undefined) {
	            return trackType.parse(json);
	        }
	        else {
	            // by default, we asssume a constructor compatible with the base
	            return new trackType(json.name, json.times, json.values, json.interpolation);
	        }
	    };
	    KeyframeTrackUtils.toJSON = function (track) {
	        var trackType = track.constructor;
	        var json;
	        // derived classes can define a static toJSON method
	        if (trackType.toJSON !== undefined) {
	            json = trackType.toJSON(track);
	        }
	        else {
	            // by default, we assume the data can be serialized as-is
	            json = {
	                'name': track.name,
	                'times': AnimationUtils.convertArray(track.times, Array),
	                'values': AnimationUtils.convertArray(track.values, Array)
	            };
	            var interpolation = track.getInterpolation();
	            if (interpolation !== track.DefaultInterpolation) {
	                json.interpolation = interpolation;
	            }
	        }
	        json.type = track.ValueTypeName; // mandatory
	        return json;
	    };
	    KeyframeTrackUtils._getTrackTypeForValueTypeName = function (typeName) {
	        switch (typeName.toLowerCase()) {
	            case "scalar":
	            case "double":
	            case "float":
	            case "number":
	            case "integer":
	                return NewNumberKeyframeTrack;
	            case "vector":
	            case "vector2":
	            case "vector3":
	            case "vector4":
	                return NewVectorKeyframeTrack;
	            case "color":
	                return NewColorKeyframeTrack;
	            case "quaternion":
	                return NewQuaternionKeyframeTrack;
	            case "bool":
	            case "boolean":
	                return NewBooleanKeyframeTrack;
	            case "string":
	                return NewStringKeyframeTrack;
	        }
	        throw new Error("Unsupported typeName: " + typeName);
	    };
	    return KeyframeTrackUtils;
	}());

	///import { KeyframeTrack } from "./KeyframeTrack";
	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	var AnimationClip = /** @class */ (function () {
	    function AnimationClip(name, duration, tracks) {
	        this.name = name;
	        this.tracks = tracks;
	        this.duration = (duration !== undefined) ? duration : -1;
	        this.uuid = _Math.generateUUID();
	        // this means it should figure out its duration by scanning the tracks
	        if (this.duration < 0) {
	            this.resetDuration();
	        }
	        this.optimize();
	    }
	    AnimationClip.prototype.resetDuration = function () {
	        var tracks = this.tracks;
	        var duration = 0;
	        for (var i = 0, n = tracks.length; i !== n; ++i) {
	            var track = this.tracks[i];
	            duration = Math.max(duration, track.times[track.times.length - 1]);
	        }
	        this.duration = duration;
	    };
	    AnimationClip.prototype.trim = function () {
	        for (var i = 0; i < this.tracks.length; i++) {
	            this.tracks[i].trim(0, this.duration);
	        }
	        return this;
	    };
	    AnimationClip.prototype.optimize = function () {
	        for (var i = 0; i < this.tracks.length; i++) {
	            this.tracks[i].optimize();
	        }
	        return this;
	    };
	    // Static methods:
	    AnimationClip.parse = function (json) {
	        var tracks = [], jsonTracks = json.tracks, frameTime = 1.0 / (json.fps || 1.0);
	        for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
	            tracks.push(KeyframeTrackUtils.parse(jsonTracks[i]).scale(frameTime));
	        }
	        return new AnimationClip(json.name, json.duration, tracks);
	    };
	    AnimationClip.toJSON = function (clip) {
	        var tracks = [];
	        var clipTracks = clip.tracks;
	        var json = {
	            'name': clip.name,
	            'duration': clip.duration,
	            'tracks': tracks
	        };
	        for (var i = 0, n = clipTracks.length; i !== n; ++i) {
	            tracks.push(KeyframeTrackUtils.toJSON(clipTracks[i]));
	        }
	        return json;
	    };
	    AnimationClip.CreateFromMorphTargetSequence = function (name, morphTargetSequence, fps, noLoop) {
	        var numMorphTargets = morphTargetSequence.length;
	        var tracks = [];
	        for (var i = 0; i < numMorphTargets; i++) {
	            var times = [];
	            var values = [];
	            times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
	            values.push(0, 1, 0);
	            var order = AnimationUtils.getKeyframeOrder(times);
	            times = AnimationUtils.sortedArray(times, 1, order);
	            values = AnimationUtils.sortedArray(values, 1, order);
	            // if there is a key at the first frame, duplicate it as the
	            // last frame as well for perfect loop.
	            if (!noLoop && times[0] === 0) {
	                times.push(numMorphTargets);
	                values.push(values[0]);
	            }
	            tracks.push(new NewNumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
	        }
	        return new AnimationClip(name, -1, tracks);
	    };
	    AnimationClip.findByName = function (objectOrClipArray, name) {
	        var clipArray = objectOrClipArray;
	        if (!Array.isArray(objectOrClipArray)) {
	            var o = objectOrClipArray;
	            clipArray = o.geometry && o.geometry.animations || o.animations;
	        }
	        for (var i = 0; i < clipArray.length; i++) {
	            if (clipArray[i].name === name) {
	                return clipArray[i];
	            }
	        }
	        return null;
	    };
	    AnimationClip.CreateClipsFromMorphTargetSequences = function (morphTargets, fps, noLoop) {
	        var animationToMorphTargets = {};
	        // tested with https://regex101.com/ on trick sequences
	        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
	        var pattern = /^([\w-]*?)([\d]+)$/;
	        // sort morph target names into animation groups based
	        // patterns like Walk_001, Walk_002, Run_001, Run_002
	        for (var i = 0, il = morphTargets.length; i < il; i++) {
	            var morphTarget = morphTargets[i];
	            var parts = morphTarget.name.match(pattern);
	            if (parts && parts.length > 1) {
	                var name = parts[1];
	                var animationMorphTargets = animationToMorphTargets[name];
	                if (!animationMorphTargets) {
	                    animationToMorphTargets[name] = animationMorphTargets = [];
	                }
	                animationMorphTargets.push(morphTarget);
	            }
	        }
	        var clips = [];
	        for (var name in animationToMorphTargets) {
	            clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
	        }
	        return clips;
	    };
	    // parse the animation.hierarchy format
	    AnimationClip.parseAnimation = function (animation, bones) {
	        if (!animation) {
	            console.error("  no animation in JSONLoader data");
	            return null;
	        }
	        function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {
	            // only return track if there are actually keys.
	            if (animationKeys.length !== 0) {
	                var times = [];
	                var values = [];
	                AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
	                // empty keys are filtered out, so check again
	                if (times.length !== 0) {
	                    destTracks.push(new trackType(trackName, times, values));
	                }
	            }
	        }
	        var tracks = [];
	        var clipName = animation.name || 'default';
	        // automatic length determination in AnimationClip.
	        var duration = animation.length || -1;
	        var fps = animation.fps || 30;
	        var hierarchyTracks = animation.hierarchy || [];
	        for (var h = 0; h < hierarchyTracks.length; h++) {
	            var animationKeys = hierarchyTracks[h].keys;
	            // skip empty tracks
	            if (!animationKeys || animationKeys.length === 0)
	                continue;
	            // process morph targets in a way exactly compatible
	            // with AnimationHandler.init(animation)
	            if (animationKeys[0].morphTargets) {
	                // figure out all morph targets used in this track
	                var morphTargetNames = {};
	                var k = void 0;
	                for (k = 0; k < animationKeys.length; k++) {
	                    if (animationKeys[k].morphTargets) {
	                        for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
	                            morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
	                        }
	                    }
	                }
	                // create a track for each morph target with all zero
	                // morphTargetInfluences except for the keys in which
	                // the morphTarget is named.
	                for (var morphTargetName in morphTargetNames) {
	                    var times = [];
	                    var values = [];
	                    for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
	                        var animationKey = animationKeys[k];
	                        times.push(animationKey.time);
	                        values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
	                    }
	                    tracks.push(new NewNumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
	                }
	                duration = morphTargetNames.length * (fps || 1.0);
	            }
	            else {
	                // ...assume skeletal animation
	                var boneName = '.bones[' + bones[h].name + ']';
	                addNonemptyTrack(NewVectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
	                addNonemptyTrack(NewQuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
	                addNonemptyTrack(NewVectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
	            }
	        }
	        if (tracks.length === 0) {
	            return null;
	        }
	        var clip = new AnimationClip(clipName, duration, tracks);
	        return clip;
	    };
	    return AnimationClip;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var MaterialLoader = /** @class */ (function () {
	    function MaterialLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.textures = new Map();
	        this.manager = manager;
	    }
	    MaterialLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        var scope = this;
	        var loader = new XHRLoader(scope.manager);
	        loader.load(url, function (text) {
	            onLoad(scope.parse(JSON.parse(text)));
	        }, onProgress, onError);
	    };
	    MaterialLoader.prototype.setTextures = function (value) {
	        this.textures = value;
	    };
	    MaterialLoader.prototype.parse = function (json) {
	        var textures = this.textures;
	        function getTexture(name) {
	            if (textures[name] === undefined) {
	                console.warn('THREE.MaterialLoader: Undefined texture', name);
	            }
	            return textures[name];
	        }
	        var material = new Materials[json.type]();
	        if (json.uuid !== undefined)
	            material.uuid = json.uuid;
	        if (json.name !== undefined)
	            material.name = json.name;
	        if (json.color !== undefined)
	            material.color.setHex(json.color);
	        if (json.roughness !== undefined)
	            material.roughness = json.roughness;
	        if (json.metalness !== undefined)
	            material.metalness = json.metalness;
	        if (json.emissive !== undefined)
	            material.emissive.setHex(json.emissive);
	        if (json.specular !== undefined)
	            material.specular.setHex(json.specular);
	        if (json.shininess !== undefined)
	            material.shininess = json.shininess;
	        if (json.uniforms !== undefined)
	            material.uniforms = json.uniforms;
	        if (json.vertexShader !== undefined)
	            material.vertexShader = json.vertexShader;
	        if (json.fragmentShader !== undefined)
	            material.fragmentShader = json.fragmentShader;
	        if (json.vertexColors !== undefined)
	            material.vertexColors = json.vertexColors;
	        if (json.fog !== undefined)
	            material.fog = json.fog;
	        if (json.shading !== undefined)
	            material.shading = json.shading;
	        if (json.blending !== undefined)
	            material.blending = json.blending;
	        if (json.side !== undefined)
	            material.side = json.side;
	        if (json.opacity !== undefined)
	            material.opacity = json.opacity;
	        if (json.transparent !== undefined)
	            material.transparent = json.transparent;
	        if (json.alphaTest !== undefined)
	            material.alphaTest = json.alphaTest;
	        if (json.depthTest !== undefined)
	            material.depthTest = json.depthTest;
	        if (json.depthWrite !== undefined)
	            material.depthWrite = json.depthWrite;
	        if (json.colorWrite !== undefined)
	            material.colorWrite = json.colorWrite;
	        if (json.wireframe !== undefined)
	            material.wireframe = json.wireframe;
	        if (json.wireframeLinewidth !== undefined)
	            material.wireframeLinewidth = json.wireframeLinewidth;
	        if (json.wireframeLinecap !== undefined)
	            material.wireframeLinecap = json.wireframeLinecap;
	        if (json.wireframeLinejoin !== undefined)
	            material.wireframeLinejoin = json.wireframeLinejoin;
	        if (json.skinning !== undefined)
	            material.skinning = json.skinning;
	        if (json.morphTargets !== undefined)
	            material.morphTargets = json.morphTargets;
	        // for PointsMaterial
	        if (json.size !== undefined)
	            material.size = json.size;
	        if (json.sizeAttenuation !== undefined)
	            material.sizeAttenuation = json.sizeAttenuation;
	        // maps
	        if (json.map !== undefined)
	            material.map = getTexture(json.map);
	        if (json.alphaMap !== undefined) {
	            material.alphaMap = getTexture(json.alphaMap);
	            material.transparent = true;
	        }
	        if (json.bumpMap !== undefined)
	            material.bumpMap = getTexture(json.bumpMap);
	        if (json.bumpScale !== undefined)
	            material.bumpScale = json.bumpScale;
	        if (json.normalMap !== undefined)
	            material.normalMap = getTexture(json.normalMap);
	        if (json.normalScale !== undefined) {
	            var normalScale = json.normalScale;
	            if (Array.isArray(normalScale) === false) {
	                // Blender exporter used to export a scalar. See #7459
	                normalScale = [normalScale, normalScale];
	            }
	            material.normalScale = new Vector2().fromArray(normalScale);
	        }
	        if (json.displacementMap !== undefined)
	            material.displacementMap = getTexture(json.displacementMap);
	        if (json.displacementScale !== undefined)
	            material.displacementScale = json.displacementScale;
	        if (json.displacementBias !== undefined)
	            material.displacementBias = json.displacementBias;
	        if (json.roughnessMap !== undefined)
	            material.roughnessMap = getTexture(json.roughnessMap);
	        if (json.metalnessMap !== undefined)
	            material.metalnessMap = getTexture(json.metalnessMap);
	        if (json.emissiveMap !== undefined)
	            material.emissiveMap = getTexture(json.emissiveMap);
	        if (json.emissiveIntensity !== undefined)
	            material.emissiveIntensity = json.emissiveIntensity;
	        if (json.specularMap !== undefined)
	            material.specularMap = getTexture(json.specularMap);
	        if (json.envMap !== undefined)
	            material.envMap = getTexture(json.envMap);
	        if (json.reflectivity !== undefined)
	            material.reflectivity = json.reflectivity;
	        if (json.lightMap !== undefined)
	            material.lightMap = getTexture(json.lightMap);
	        if (json.lightMapIntensity !== undefined)
	            material.lightMapIntensity = json.lightMapIntensity;
	        if (json.aoMap !== undefined)
	            material.aoMap = getTexture(json.aoMap);
	        if (json.aoMapIntensity !== undefined)
	            material.aoMapIntensity = json.aoMapIntensity;
	        // MultiMaterial
	        if (json.materials !== undefined) {
	            for (var i = 0, l = json.materials.length; i < l; i++) {
	                material.materials.push(this.parse(json.materials[i]));
	            }
	        }
	        return material;
	    };
	    return MaterialLoader;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var BufferGeometryLoader = /** @class */ (function () {
	    function BufferGeometryLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.manager = manager;
	    }
	    BufferGeometryLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        var scope = this;
	        var loader = new XHRLoader(scope.manager);
	        loader.load(url, function (text) {
	            onLoad(scope.parse(JSON.parse(text)));
	        }, onProgress, onError);
	    };
	    BufferGeometryLoader.prototype.parse = function (json) {
	        var geometry = new BufferGeometry();
	        var index = json.data.index;
	        var TYPED_ARRAYS = {
	            'Int8Array': Int8Array,
	            'Uint8Array': Uint8Array,
	            'Uint8ClampedArray': Uint8ClampedArray,
	            'Int16Array': Int16Array,
	            'Uint16Array': Uint16Array,
	            'Int32Array': Int32Array,
	            'Uint32Array': Uint32Array,
	            'Float32Array': Float32Array,
	            'Float64Array': Float64Array
	        };
	        if (index !== undefined) {
	            var typedArray = new TYPED_ARRAYS[index.type](index.array);
	            geometry.setIndex(new BufferAttribute(typedArray, 1));
	        }
	        var attributes = json.data.attributes;
	        for (var key in attributes) {
	            var attribute = attributes[key];
	            var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
	            geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
	        }
	        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	        if (groups !== undefined) {
	            for (var i = 0, n = groups.length; i !== n; ++i) {
	                var group = groups[i];
	                geometry.addGroup(group.start, group.count, group.materialIndex);
	            }
	        }
	        var boundingSphere = json.data.boundingSphere;
	        if (boundingSphere !== undefined) {
	            var center = new Vector3();
	            if (boundingSphere.center !== undefined) {
	                center.fromArray(boundingSphere.center);
	            }
	            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
	        }
	        return geometry;
	    };
	    return BufferGeometryLoader;
	}());

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	var Loader = /** @class */ (function () {
	    function Loader() {
	        this.onLoadStart = function () { };
	        this.onLoadProgress = function () { };
	        this.onLoadComplete = function () { };
	    }
	    Loader.prototype.extractUrlBase = function (url) {
	        var parts = url.split('/');
	        if (parts.length === 1)
	            return './';
	        parts.pop();
	        return parts.join('/') + '/';
	    };
	    Loader.prototype.initMaterials = function (materials, texturePath, crossOrigin) {
	        var array = [];
	        for (var i = 0; i < materials.length; ++i) {
	            array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
	        }
	        return array;
	    };
	    Loader.prototype.createMaterial = function (m, texturePath, crossOrigin) {
	        var color = new Color(), textureLoader = new TextureLoader(), materialLoader = new MaterialLoader();
	        //return function createMaterial(m, texturePath, crossOrigin) {
	        // convert from old material format
	        var textures = new Map();
	        function loadTexture(path, repeat, offset, wrap, anisotropy) {
	            var fullPath = texturePath + path;
	            var loader = Loader.Handlers.get(fullPath);
	            var texture;
	            if (loader !== null) {
	                texture = loader.load(fullPath);
	            }
	            else {
	                textureLoader.setCrossOrigin(crossOrigin);
	                texture = textureLoader.load(fullPath);
	            }
	            if (repeat !== undefined) {
	                texture.repeat.fromArray(repeat);
	                if (repeat[0] !== 1)
	                    texture.wrapS = exports.TextureWrapping.Repeat;
	                if (repeat[1] !== 1)
	                    texture.wrapT = exports.TextureWrapping.Repeat;
	            }
	            if (offset !== undefined) {
	                texture.offset.fromArray(offset);
	            }
	            if (wrap !== undefined) {
	                if (wrap[0] === 'repeat')
	                    texture.wrapS = exports.TextureWrapping.Repeat;
	                if (wrap[0] === 'mirror')
	                    texture.wrapS = exports.TextureWrapping.MirroredRepeat;
	                if (wrap[1] === 'repeat')
	                    texture.wrapT = exports.TextureWrapping.Repeat;
	                if (wrap[1] === 'mirror')
	                    texture.wrapT = exports.TextureWrapping.MirroredRepeat;
	            }
	            if (anisotropy !== undefined) {
	                texture.anisotropy = anisotropy;
	            }
	            var uuid = _Math.generateUUID();
	            textures[uuid] = texture;
	            return uuid;
	        }
	        //
	        var json = {
	            uuid: _Math.generateUUID(),
	            type: 'MeshLambertMaterial'
	        };
	        for (var name in m) {
	            var value = m[name];
	            switch (name) {
	                case 'DbgColor':
	                case 'DbgIndex':
	                case 'opticalDensity':
	                case 'illumination':
	                    break;
	                case 'DbgName':
	                    json.name = value;
	                    break;
	                case 'blending':
	                    json.blending = exports.BlendingMode[value];
	                    break;
	                case 'colorAmbient':
	                case 'mapAmbient':
	                    console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
	                    break;
	                case 'colorDiffuse':
	                    json.color = color.fromArray(value).getHex();
	                    break;
	                case 'colorSpecular':
	                    json.specular = color.fromArray(value).getHex();
	                    break;
	                case 'colorEmissive':
	                    json.emissive = color.fromArray(value).getHex();
	                    break;
	                case 'specularCoef':
	                    json.shininess = value;
	                    break;
	                case 'shading':
	                    if (value.toLowerCase() === 'basic')
	                        json.type = 'MeshBasicMaterial';
	                    if (value.toLowerCase() === 'phong')
	                        json.type = 'MeshPhongMaterial';
	                    if (value.toLowerCase() === 'standard')
	                        json.type = 'MeshStandardMaterial';
	                    break;
	                case 'mapDiffuse':
	                    json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
	                    break;
	                case 'mapDiffuseRepeat':
	                case 'mapDiffuseOffset':
	                case 'mapDiffuseWrap':
	                case 'mapDiffuseAnisotropy':
	                    break;
	                case 'mapEmissive':
	                    json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
	                    break;
	                case 'mapEmissiveRepeat':
	                case 'mapEmissiveOffset':
	                case 'mapEmissiveWrap':
	                case 'mapEmissiveAnisotropy':
	                    break;
	                case 'mapLight':
	                    json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
	                    break;
	                case 'mapLightRepeat':
	                case 'mapLightOffset':
	                case 'mapLightWrap':
	                case 'mapLightAnisotropy':
	                    break;
	                case 'mapAO':
	                    json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
	                    break;
	                case 'mapAORepeat':
	                case 'mapAOOffset':
	                case 'mapAOWrap':
	                case 'mapAOAnisotropy':
	                    break;
	                case 'mapBump':
	                    json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
	                    break;
	                case 'mapBumpScale':
	                    json.bumpScale = value;
	                    break;
	                case 'mapBumpRepeat':
	                case 'mapBumpOffset':
	                case 'mapBumpWrap':
	                case 'mapBumpAnisotropy':
	                    break;
	                case 'mapNormal':
	                    json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
	                    break;
	                case 'mapNormalFactor':
	                    json.normalScale = [value, value];
	                    break;
	                case 'mapNormalRepeat':
	                case 'mapNormalOffset':
	                case 'mapNormalWrap':
	                case 'mapNormalAnisotropy':
	                    break;
	                case 'mapSpecular':
	                    json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
	                    break;
	                case 'mapSpecularRepeat':
	                case 'mapSpecularOffset':
	                case 'mapSpecularWrap':
	                case 'mapSpecularAnisotropy':
	                    break;
	                case 'mapMetalness':
	                    json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
	                    break;
	                case 'mapMetalnessRepeat':
	                case 'mapMetalnessOffset':
	                case 'mapMetalnessWrap':
	                case 'mapMetalnessAnisotropy':
	                    break;
	                case 'mapRoughness':
	                    json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
	                    break;
	                case 'mapRoughnessRepeat':
	                case 'mapRoughnessOffset':
	                case 'mapRoughnessWrap':
	                case 'mapRoughnessAnisotropy':
	                    break;
	                case 'mapAlpha':
	                    json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
	                    break;
	                case 'mapAlphaRepeat':
	                case 'mapAlphaOffset':
	                case 'mapAlphaWrap':
	                case 'mapAlphaAnisotropy':
	                    break;
	                case 'flipSided':
	                    json.side = exports.SideMode.Back;
	                    break;
	                case 'doubleSided':
	                    json.side = exports.SideMode.Double;
	                    break;
	                case 'transparency':
	                    console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
	                    json.opacity = value;
	                    break;
	                case 'depthTest':
	                case 'depthWrite':
	                case 'colorWrite':
	                case 'opacity':
	                case 'reflectivity':
	                case 'transparent':
	                case 'visible':
	                case 'wireframe':
	                    json[name] = value;
	                    break;
	                case 'vertexColors':
	                    if (value === true)
	                        json.vertexColors = exports.ColorsMode.Vertex;
	                    if (value === 'face')
	                        json.vertexColors = exports.ColorsMode.Face;
	                    break;
	                default:
	                    console.error('THREE.Loader.createMaterial: Unsupported', name, value);
	                    break;
	            }
	        }
	        if (json.type === 'MeshBasicMaterial')
	            delete json.emissive;
	        if (json.type !== 'MeshPhongMaterial')
	            delete json.specular;
	        if (json.opacity < 1)
	            json.transparent = true;
	        materialLoader.setTextures(textures);
	        return materialLoader.parse(json);
	        //};
	    };
	    Loader.Handlers = (_a = /** @class */ (function () {
	            function class_1() {
	            }
	            class_1.add = function (regex, loader) {
	                this.handlers.push(regex, loader);
	            };
	            class_1.get = function (file) {
	                var handlers = this.handlers;
	                for (var i = 0, l = handlers.length; i < l; i += 2) {
	                    var regex = handlers[i];
	                    var loader = handlers[i + 1];
	                    if (regex.test(file)) {
	                        return loader;
	                    }
	                }
	                return null;
	            };
	            return class_1;
	        }()), _a.handlers = [], _a);
	    return Loader;
	    var _a;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var JSONLoader = /** @class */ (function () {
	    function JSONLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.withCredentials = false;
	        //if (typeof manager === 'boolean') {
	        //  console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
	        //  manager = undefined;
	        //}
	        this.manager = manager;
	    }
	    JSONLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        var scope = this;
	        var texturePath = this.texturePath && (typeof this.texturePath === "string") ? this.texturePath : Loader.prototype.extractUrlBase(url);
	        var loader = new XHRLoader(this.manager);
	        loader.setWithCredentials(this.withCredentials);
	        loader.load(url, function (text) {
	            var json = JSON.parse(text);
	            var metadata = json.metadata;
	            if (metadata !== undefined) {
	                var type = metadata.type;
	                if (type !== undefined) {
	                    if (type.toLowerCase() === 'object') {
	                        console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
	                        return;
	                    }
	                    if (type.toLowerCase() === 'scene') {
	                        console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
	                        return;
	                    }
	                }
	            }
	            var object = scope.parse(json, texturePath);
	            onLoad(object.geometry, object.materials);
	        }, onProgress, onError);
	    };
	    JSONLoader.prototype.setTexturePath = function (value) {
	        this.texturePath = value;
	    };
	    JSONLoader.prototype.parse = function (json, texturePath) {
	        var geometry = new Geometry();
	        var scale = (json.scale !== undefined) ? 1.0 / json.scale : 1.0;
	        parseModel(scale);
	        parseSkin();
	        parseMorphing(scale);
	        parseAnimations();
	        geometry.computeFaceNormals();
	        geometry.computeBoundingSphere();
	        function parseModel(scale) {
	            function isBitSet(value, position) {
	                return value & (1 << position);
	            }
	            var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
	            if (json.uvs !== undefined) {
	                // disregard empty arrays
	                for (i = 0; i < json.uvs.length; i++) {
	                    if (json.uvs[i].length)
	                        nUvLayers++;
	                }
	                for (i = 0; i < nUvLayers; i++) {
	                    geometry.faceVertexUvs[i] = [];
	                }
	            }
	            offset = 0;
	            zLength = vertices.length;
	            while (offset < zLength) {
	                vertex = new Vector3();
	                vertex.x = vertices[offset++] * scale;
	                vertex.y = vertices[offset++] * scale;
	                vertex.z = vertices[offset++] * scale;
	                geometry.vertices.push(vertex);
	            }
	            offset = 0;
	            zLength = faces.length;
	            while (offset < zLength) {
	                type = faces[offset++];
	                isQuad = isBitSet(type, 0);
	                hasMaterial = isBitSet(type, 1);
	                hasFaceVertexUv = isBitSet(type, 3);
	                hasFaceNormal = isBitSet(type, 4);
	                hasFaceVertexNormal = isBitSet(type, 5);
	                hasFaceColor = isBitSet(type, 6);
	                hasFaceVertexColor = isBitSet(type, 7);
	                // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	                if (isQuad) {
	                    faceA = new Face3();
	                    faceA.a = faces[offset];
	                    faceA.b = faces[offset + 1];
	                    faceA.c = faces[offset + 3];
	                    faceB = new Face3();
	                    faceB.a = faces[offset + 1];
	                    faceB.b = faces[offset + 2];
	                    faceB.c = faces[offset + 3];
	                    offset += 4;
	                    if (hasMaterial) {
	                        materialIndex = faces[offset++];
	                        faceA.materialIndex = materialIndex;
	                        faceB.materialIndex = materialIndex;
	                    }
	                    // to get face <=> uv index correspondence
	                    fi = geometry.faces.length;
	                    if (hasFaceVertexUv) {
	                        for (i = 0; i < nUvLayers; i++) {
	                            uvLayer = json.uvs[i];
	                            geometry.faceVertexUvs[i][fi] = [];
	                            geometry.faceVertexUvs[i][fi + 1] = [];
	                            for (j = 0; j < 4; j++) {
	                                uvIndex = faces[offset++];
	                                u = uvLayer[uvIndex * 2];
	                                v = uvLayer[uvIndex * 2 + 1];
	                                uv = new Vector2(u, v);
	                                if (j !== 2)
	                                    geometry.faceVertexUvs[i][fi].push(uv);
	                                if (j !== 0)
	                                    geometry.faceVertexUvs[i][fi + 1].push(uv);
	                            }
	                        }
	                    }
	                    if (hasFaceNormal) {
	                        normalIndex = faces[offset++] * 3;
	                        faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
	                        faceB.normal.copy(faceA.normal);
	                    }
	                    if (hasFaceVertexNormal) {
	                        for (i = 0; i < 4; i++) {
	                            normalIndex = faces[offset++] * 3;
	                            normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
	                            if (i !== 2)
	                                faceA.vertexNormals.push(normal);
	                            if (i !== 0)
	                                faceB.vertexNormals.push(normal);
	                        }
	                    }
	                    if (hasFaceColor) {
	                        colorIndex = faces[offset++];
	                        hex = colors[colorIndex];
	                        faceA.color.setHex(hex);
	                        faceB.color.setHex(hex);
	                    }
	                    if (hasFaceVertexColor) {
	                        for (i = 0; i < 4; i++) {
	                            colorIndex = faces[offset++];
	                            hex = colors[colorIndex];
	                            if (i !== 2)
	                                faceA.vertexColors.push(new Color(hex));
	                            if (i !== 0)
	                                faceB.vertexColors.push(new Color(hex));
	                        }
	                    }
	                    geometry.faces.push(faceA);
	                    geometry.faces.push(faceB);
	                }
	                else {
	                    face = new Face3();
	                    face.a = faces[offset++];
	                    face.b = faces[offset++];
	                    face.c = faces[offset++];
	                    if (hasMaterial) {
	                        materialIndex = faces[offset++];
	                        face.materialIndex = materialIndex;
	                    }
	                    // to get face <=> uv index correspondence
	                    fi = geometry.faces.length;
	                    if (hasFaceVertexUv) {
	                        for (i = 0; i < nUvLayers; i++) {
	                            uvLayer = json.uvs[i];
	                            geometry.faceVertexUvs[i][fi] = [];
	                            for (j = 0; j < 3; j++) {
	                                uvIndex = faces[offset++];
	                                u = uvLayer[uvIndex * 2];
	                                v = uvLayer[uvIndex * 2 + 1];
	                                uv = new Vector2(u, v);
	                                geometry.faceVertexUvs[i][fi].push(uv);
	                            }
	                        }
	                    }
	                    if (hasFaceNormal) {
	                        normalIndex = faces[offset++] * 3;
	                        face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
	                    }
	                    if (hasFaceVertexNormal) {
	                        for (i = 0; i < 3; i++) {
	                            normalIndex = faces[offset++] * 3;
	                            normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
	                            face.vertexNormals.push(normal);
	                        }
	                    }
	                    if (hasFaceColor) {
	                        colorIndex = faces[offset++];
	                        face.color.setHex(colors[colorIndex]);
	                    }
	                    if (hasFaceVertexColor) {
	                        for (i = 0; i < 3; i++) {
	                            colorIndex = faces[offset++];
	                            face.vertexColors.push(new Color(colors[colorIndex]));
	                        }
	                    }
	                    geometry.faces.push(face);
	                }
	            }
	        }
	        function parseSkin() {
	            var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
	            if (json.skinWeights) {
	                for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
	                    var x = json.skinWeights[i];
	                    var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
	                    var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
	                    var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
	                    geometry.skinWeights.push(new Vector4(x, y, z, w));
	                }
	            }
	            if (json.skinIndices) {
	                for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
	                    var a = json.skinIndices[i];
	                    var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
	                    var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
	                    var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
	                    geometry.skinIndices.push(new Vector4(a, b, c, d));
	                }
	            }
	            geometry.bones = json.bones;
	            if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
	                console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
	                    geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
	            }
	        }
	        function parseMorphing(scale) {
	            if (json.morphTargets !== undefined) {
	                for (var i = 0, l = json.morphTargets.length; i < l; i++) {
	                    geometry.morphTargets[i] = {};
	                    geometry.morphTargets[i].name = json.morphTargets[i].name;
	                    geometry.morphTargets[i].vertices = [];
	                    var dstVertices = geometry.morphTargets[i].vertices;
	                    var srcVertices = json.morphTargets[i].vertices;
	                    for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
	                        var vertex = new Vector3();
	                        vertex.x = srcVertices[v] * scale;
	                        vertex.y = srcVertices[v + 1] * scale;
	                        vertex.z = srcVertices[v + 2] * scale;
	                        dstVertices.push(vertex);
	                    }
	                }
	            }
	            if (json.morphColors !== undefined && json.morphColors.length > 0) {
	                console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
	                var faces = geometry.faces;
	                var morphColors = json.morphColors[0].colors;
	                for (var i = 0, l = faces.length; i < l; i++) {
	                    faces[i].color.fromArray(morphColors, i * 3);
	                }
	            }
	        }
	        function parseAnimations() {
	            var outputAnimations = [];
	            // parse old style Bone/Hierarchy animations
	            var animations = [];
	            if (json.animation !== undefined) {
	                animations.push(json.animation);
	            }
	            if (json.animations !== undefined) {
	                if (json.animations.length) {
	                    animations = animations.concat(json.animations);
	                }
	                else {
	                    animations.push(json.animations);
	                }
	            }
	            for (var i = 0; i < animations.length; i++) {
	                var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
	                if (clip)
	                    outputAnimations.push(clip);
	            }
	            // parse implicit morph animations
	            if (geometry.morphTargets) {
	                // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
	                var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
	                outputAnimations = outputAnimations.concat(morphAnimationClips);
	            }
	            if (outputAnimations.length > 0)
	                geometry.animations = outputAnimations;
	        }
	        if (json.materials === undefined || json.materials.length === 0) {
	            return { geometry: geometry };
	        }
	        else {
	            var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
	            return { geometry: geometry, materials: materials };
	        }
	    };
	    return JSONLoader;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var ObjectLoader = /** @class */ (function () {
	    function ObjectLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.texturePath = '';
	        this.manager = manager;
	    }
	    ObjectLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        if (this.texturePath === '') {
	            this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
	        }
	        var scope = this;
	        var loader = new XHRLoader(scope.manager);
	        loader.load(url, function (text) {
	            scope.parse(JSON.parse(text), onLoad);
	        }, onProgress, onError);
	    };
	    ObjectLoader.prototype.setTexturePath = function (value) {
	        this.texturePath = value;
	    };
	    ObjectLoader.prototype.setCrossOrigin = function (value) {
	        this.crossOrigin = value;
	    };
	    ObjectLoader.prototype.parse = function (json, onLoad) {
	        var geometries = this.parseGeometries(json.geometries);
	        var images = this.parseImages(json.images, function () {
	            if (onLoad !== undefined)
	                onLoad(object);
	        });
	        var textures = this.parseTextures(json.textures, images);
	        var materials = this.parseMaterials(json.materials, textures);
	        var object = this.parseObject(json.object, geometries, materials);
	        if (json.animations) {
	            object.animations = this.parseAnimations(json.animations);
	        }
	        if (json.images === undefined || json.images.length === 0) {
	            if (onLoad !== undefined)
	                onLoad(object);
	        }
	        return object;
	    };
	    ObjectLoader.prototype.parseGeometries = function (json) {
	        var geometries = new Map();
	        if (json !== undefined) {
	            var geometryLoader = new JSONLoader();
	            var bufferGeometryLoader = new BufferGeometryLoader();
	            for (var i = 0, l = json.length; i < l; i++) {
	                var geometry = void 0;
	                var data = json[i];
	                switch (data.type) {
	                    case 'PlaneGeometry':
	                    case 'PlaneBufferGeometry':
	                        geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
	                        break;
	                    case 'BoxGeometry':
	                    case 'BoxBufferGeometry':
	                    case 'CubeGeometry':// backwards compatible
	                        geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
	                        break;
	                    case 'CircleGeometry':
	                    case 'CircleBufferGeometry':
	                        geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
	                        break;
	                    case 'CylinderGeometry':
	                    case 'CylinderBufferGeometry':
	                        geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
	                        break;
	                    case 'ConeGeometry':
	                    case 'ConeBufferGeometry':
	                        geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
	                        break;
	                    case 'SphereGeometry':
	                    case 'SphereBufferGeometry':
	                        geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
	                        break;
	                    case 'DodecahedronGeometry':
	                    case 'IcosahedronGeometry':
	                    case 'OctahedronGeometry':
	                    case 'TetrahedronGeometry':
	                        geometry = new Geometries[data.type](data.radius, data.detail);
	                        break;
	                    case 'RingGeometry':
	                    case 'RingBufferGeometry':
	                        geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
	                        break;
	                    case 'TorusGeometry':
	                    case 'TorusBufferGeometry':
	                        geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
	                        break;
	                    case 'TorusKnotGeometry':
	                    case 'TorusKnotBufferGeometry':
	                        geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
	                        break;
	                    case 'LatheGeometry':
	                    case 'LatheBufferGeometry':
	                        geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
	                        break;
	                    case 'BufferGeometry':
	                        geometry = bufferGeometryLoader.parse(data);
	                        break;
	                    case 'Geometry':
	                        geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
	                        break;
	                    default:
	                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
	                        continue;
	                }
	                geometry.uuid = data.uuid;
	                if (data.name !== undefined)
	                    geometry.name = data.name;
	                geometries[data.uuid] = geometry;
	            }
	        }
	        return geometries;
	    };
	    ObjectLoader.prototype.parseMaterials = function (json, textures) {
	        var materials = new Map();
	        if (json !== undefined) {
	            var loader = new MaterialLoader();
	            loader.setTextures(textures);
	            for (var i = 0, l = json.length; i < l; i++) {
	                var material = loader.parse(json[i]);
	                materials[material.uuid] = material;
	            }
	        }
	        return materials;
	    };
	    ObjectLoader.prototype.parseAnimations = function (json) {
	        var animations = [];
	        for (var i = 0; i < json.length; i++) {
	            var clip = AnimationClip.parse(json[i]);
	            animations.push(clip);
	        }
	        return animations;
	    };
	    ObjectLoader.prototype.parseImages = function (json, onLoad) {
	        var scope = this;
	        var images = new Map();
	        var loader;
	        function loadImage(url) {
	            scope.manager.itemStart(url);
	            return loader.load(url, function () {
	                scope.manager.itemEnd(url);
	            }, undefined, function () {
	                scope.manager.itemError(url);
	            });
	        }
	        if (json !== undefined && json.length > 0) {
	            var manager = new LoadingManager(onLoad);
	            loader = new ImageLoader(manager);
	            loader.setCrossOrigin(this.crossOrigin);
	            for (var i = 0, l = json.length; i < l; i++) {
	                var image = json[i];
	                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
	                images[image.uuid] = loadImage(path);
	            }
	        }
	        return images;
	    };
	    ObjectLoader.prototype.parseTextures = function (json, images) {
	        function parseConstant(value, type) {
	            if (typeof (value) === 'number')
	                return value;
	            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
	            return type[value];
	        }
	        var textures = new Map();
	        if (json !== undefined) {
	            for (var i = 0, l = json.length; i < l; i++) {
	                var data = json[i];
	                if (data.image === undefined) {
	                    console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
	                }
	                if (images[data.image] === undefined) {
	                    console.warn('THREE.ObjectLoader: Undefined image', data.image);
	                }
	                var texture = new Texture(images[data.image]);
	                texture.needsUpdate = true;
	                texture.uuid = data.uuid;
	                if (data.name !== undefined)
	                    texture.name = data.name;
	                if (data.mapping !== undefined)
	                    texture.mapping = parseConstant(data.mapping, exports.TextureMapping);
	                if (data.offset !== undefined)
	                    texture.offset.fromArray(data.offset);
	                if (data.repeat !== undefined)
	                    texture.repeat.fromArray(data.repeat);
	                if (data.wrap !== undefined) {
	                    texture.wrapS = parseConstant(data.wrap[0], exports.TextureWrapping);
	                    texture.wrapT = parseConstant(data.wrap[1], exports.TextureWrapping);
	                }
	                if (data.minFilter !== undefined)
	                    texture.minFilter = parseConstant(data.minFilter, exports.TextureFilter);
	                if (data.magFilter !== undefined)
	                    texture.magFilter = parseConstant(data.magFilter, exports.TextureFilter);
	                if (data.anisotropy !== undefined)
	                    texture.anisotropy = data.anisotropy;
	                if (data.flipY !== undefined)
	                    texture.flipY = data.flipY;
	                textures[data.uuid] = texture;
	            }
	        }
	        return textures;
	    };
	    ObjectLoader.prototype.parseObject = function (data, geometries, materials) {
	        var matrix = new Matrix4();
	        //return function parseObject(data, geometries, materials) {
	        var object;
	        function getGeometry(name) {
	            if (geometries[name] === undefined) {
	                console.warn('THREE.ObjectLoader: Undefined geometry', name);
	            }
	            return geometries[name];
	        }
	        function getMaterial(name) {
	            if (name === undefined)
	                return undefined;
	            if (materials[name] === undefined) {
	                console.warn('THREE.ObjectLoader: Undefined material', name);
	            }
	            return materials[name];
	        }
	        switch (data.type) {
	            case 'Scene':
	                object = new Scene();
	                if (data.background !== undefined) {
	                    if (Number.isInteger(data.background)) {
	                        object.background = new Color(data.background);
	                    }
	                }
	                if (data.fog !== undefined) {
	                    if (data.fog.type === 'Fog') {
	                        object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
	                    }
	                    else if (data.fog.type === 'FogExp2') {
	                        object.fog = new FogExp2(data.fog.color, data.fog.density);
	                    }
	                }
	                break;
	            case 'PerspectiveCamera':
	                object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
	                if (data.focus !== undefined)
	                    object.focus = data.focus;
	                if (data.zoom !== undefined)
	                    object.zoom = data.zoom;
	                if (data.filmGauge !== undefined)
	                    object.filmGauge = data.filmGauge;
	                if (data.filmOffset !== undefined)
	                    object.filmOffset = data.filmOffset;
	                if (data.view !== undefined)
	                    object.view = Object.assign({}, data.view);
	                break;
	            case 'OrthographicCamera':
	                object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
	                break;
	            case 'AmbientLight':
	                object = new AmbientLight(data.color, data.intensity);
	                break;
	            case 'DirectionalLight':
	                object = new DirectionalLight(data.color, data.intensity);
	                break;
	            case 'PointLight':
	                object = new PointLight(data.color, data.intensity, data.distance, data.decay);
	                break;
	            case 'SpotLight':
	                object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
	                break;
	            case 'HemisphereLight':
	                object = new HemisphereLight(data.color, data.groundColor, data.intensity);
	                break;
	            case 'Mesh':
	                var geometry = getGeometry(data.geometry);
	                var material = getMaterial(data.material);
	                if (geometry.bones && geometry.bones.length > 0) {
	                    object = new SkinnedMesh(geometry, material);
	                }
	                else {
	                    object = new Mesh(geometry, material);
	                }
	                break;
	            case 'LOD':
	                object = new LOD();
	                break;
	            case 'Line':
	                object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
	                break;
	            case 'LineSegments':
	                object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
	                break;
	            case 'PointCloud':
	            case 'Points':
	                object = new Points(getGeometry(data.geometry), getMaterial(data.material));
	                break;
	            case 'Sprite':
	                object = new Sprite(getMaterial(data.material));
	                break;
	            case 'Group':
	                object = new Group();
	                break;
	            default:
	                object = new Object3D();
	        }
	        object.uuid = data.uuid;
	        if (data.name !== undefined)
	            object.name = data.name;
	        if (data.matrix !== undefined) {
	            matrix.fromArray(data.matrix);
	            matrix.decompose(object.position, object.quaternion, object.scale);
	        }
	        else {
	            if (data.position !== undefined)
	                object.position.fromArray(data.position);
	            if (data.rotation !== undefined)
	                object.rotation.fromArray(data.rotation);
	            if (data.quaternion !== undefined)
	                object.quaternion.fromArray(data.quaternion);
	            if (data.scale !== undefined)
	                object.scale.fromArray(data.scale);
	        }
	        if (data.castShadow !== undefined)
	            object.castShadow = data.castShadow;
	        if (data.receiveShadow !== undefined)
	            object.receiveShadow = data.receiveShadow;
	        if (data.shadow) {
	            if (data.shadow.bias !== undefined)
	                object.shadow.bias = data.shadow.bias;
	            if (data.shadow.radius !== undefined)
	                object.shadow.radius = data.shadow.radius;
	            if (data.shadow.mapSize !== undefined)
	                object.shadow.mapSize.fromArray(data.shadow.mapSize);
	            if (data.shadow.camera !== undefined)
	                object.shadow.camera = this.parseObject(data.shadow.camera);
	        }
	        if (data.visible !== undefined)
	            object.visible = data.visible;
	        if (data.userData !== undefined)
	            object.userData = data.userData;
	        if (data.children !== undefined) {
	            for (var child in data.children) {
	                object.add(this.parseObject(data.children[child], geometries, materials));
	            }
	        }
	        if (data.type === 'LOD') {
	            var levels = data.levels;
	            for (var l = 0; l < levels.length; l++) {
	                var level = levels[l];
	                var child = object.getObjectByProperty('uuid', level.object);
	                if (child !== undefined) {
	                    object.addLevel(child, level.distance);
	                }
	            }
	        }
	        return object;
	        //};
	    };
	    return ObjectLoader;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var FontLoader = /** @class */ (function () {
	    function FontLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.manager = manager;
	    }
	    FontLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        var scope = this;
	        var loader = new XHRLoader(this.manager);
	        loader.load(url, function (text) {
	            var json;
	            try {
	                json = JSON.parse(text);
	            }
	            catch (e) {
	                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
	                json = JSON.parse(text.substring(65, text.length - 2));
	            }
	            var font = scope.parse(json);
	            if (onLoad)
	                onLoad(font);
	        }, onProgress, onError);
	    };
	    FontLoader.prototype.parse = function (json) {
	        return new Font(json);
	    };
	    return FontLoader;
	}());

	var context;
	function getAudioContext() {
	    if (context === undefined) {
	        // !!!TODO: context = new (window.AudioContext || window.webkitAudioContext)();
	        context = new AudioContext();
	    }
	    return context;
	}

	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */
	var AudioLoader = /** @class */ (function () {
	    function AudioLoader(manager) {
	        if (manager === void 0) { manager = DefaultLoadingManager; }
	        this.manager = manager;
	    }
	    AudioLoader.prototype.load = function (url, onLoad, onProgress, onError) {
	        var loader = new XHRLoader(this.manager);
	        loader.setResponseType('arraybuffer');
	        loader.load(url, function (buffer) {
	            var context = getAudioContext();
	            context.decodeAudioData(buffer, function (audioBuffer) {
	                onLoad(audioBuffer);
	            });
	        }, onProgress, onError);
	    };
	    return AudioLoader;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var StereoCamera = /** @class */ (function () {
	    function StereoCamera() {
	        this.type = 'StereoCamera';
	        this.aspect = 1;
	        this.eyeSep = 0.064;
	        this.cameraL = new PerspectiveCamera();
	        this.cameraL.layers.enable(1);
	        this.cameraL.matrixAutoUpdate = false;
	        this.cameraR = new PerspectiveCamera();
	        this.cameraR.layers.enable(2);
	        this.cameraR.matrixAutoUpdate = false;
	    }
	    StereoCamera.prototype.update = function (camera) {
	        var instance, focus, fov, aspect, near, far, zoom;
	        var eyeRight = new Matrix4();
	        var eyeLeft = new Matrix4();
	        //return function update(camera) {
	        var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
	            aspect !== camera.aspect * this.aspect || near !== camera.near ||
	            far !== camera.far || zoom !== camera.zoom;
	        if (needsUpdate) {
	            instance = this;
	            focus = camera.focus;
	            fov = camera.fov;
	            aspect = camera.aspect * this.aspect;
	            near = camera.near;
	            far = camera.far;
	            zoom = camera.zoom;
	            // Off-axis stereoscopic effect based on
	            // http://paulbourke.net/stereographics/stereorender/
	            var projectionMatrix = camera.projectionMatrix.clone();
	            var eyeSep = this.eyeSep / 2;
	            var eyeSepOnProjection = eyeSep * near / focus;
	            var ymax = (near * Math.tan(_Math.DEG2RAD * fov * 0.5)) / zoom;
	            var xmin = void 0, xmax = void 0;
	            // translate xOffset
	            eyeLeft.elements[12] = -eyeSep;
	            eyeRight.elements[12] = eyeSep;
	            // for left eye
	            xmin = -ymax * aspect + eyeSepOnProjection;
	            xmax = ymax * aspect + eyeSepOnProjection;
	            projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
	            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
	            this.cameraL.projectionMatrix.copy(projectionMatrix);
	            // for right eye
	            xmin = -ymax * aspect - eyeSepOnProjection;
	            xmax = ymax * aspect - eyeSepOnProjection;
	            projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
	            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
	            this.cameraR.projectionMatrix.copy(projectionMatrix);
	        }
	        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
	        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
	        //};
	    };
	    return StereoCamera;
	}());

	/**
	 * Camera for rendering cube maps
	 *  - renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */
	var CubeCamera = /** @class */ (function (_super) {
	    __extends(CubeCamera, _super);
	    function CubeCamera(near, far, cubeResolution) {
	        var _this = _super.call(this) || this;
	        _this.type = 'CubeCamera';
	        var fov = 90, aspect = 1;
	        _this.cameraPX = new PerspectiveCamera(fov, aspect, near, far);
	        _this.cameraPX.up.set(0, -1, 0);
	        _this.cameraPX.lookAt(new Vector3(1, 0, 0));
	        _this.add(_this.cameraPX);
	        _this.cameraNX = new PerspectiveCamera(fov, aspect, near, far);
	        _this.cameraNX.up.set(0, -1, 0);
	        _this.cameraNX.lookAt(new Vector3(-1, 0, 0));
	        _this.add(_this.cameraNX);
	        _this.cameraPY = new PerspectiveCamera(fov, aspect, near, far);
	        _this.cameraPY.up.set(0, 0, 1);
	        _this.cameraPY.lookAt(new Vector3(0, 1, 0));
	        _this.add(_this.cameraPY);
	        _this.cameraNY = new PerspectiveCamera(fov, aspect, near, far);
	        _this.cameraNY.up.set(0, 0, -1);
	        _this.cameraNY.lookAt(new Vector3(0, -1, 0));
	        _this.add(_this.cameraNY);
	        _this.cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
	        _this.cameraPZ.up.set(0, -1, 0);
	        _this.cameraPZ.lookAt(new Vector3(0, 0, 1));
	        _this.add(_this.cameraPZ);
	        _this.cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
	        _this.cameraNZ.up.set(0, -1, 0);
	        _this.cameraNZ.lookAt(new Vector3(0, 0, -1));
	        _this.add(_this.cameraNZ);
	        var options = { format: exports.TextureFormat.RGB, magFilter: exports.TextureFilter.Linear, minFilter: exports.TextureFilter.Linear };
	        _this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
	        return _this;
	    }
	    CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
	        if (this.parent === null)
	            this.updateMatrixWorld();
	        var renderTarget = this.renderTarget;
	        var generateMipmaps = renderTarget.texture.generateMipmaps;
	        renderTarget.texture.generateMipmaps = false;
	        renderTarget.activeCubeFace = 0;
	        renderer.render(scene, this.cameraPX, renderTarget);
	        renderTarget.activeCubeFace = 1;
	        renderer.render(scene, this.cameraNX, renderTarget);
	        renderTarget.activeCubeFace = 2;
	        renderer.render(scene, this.cameraPY, renderTarget);
	        renderTarget.activeCubeFace = 3;
	        renderer.render(scene, this.cameraNY, renderTarget);
	        renderTarget.activeCubeFace = 4;
	        renderer.render(scene, this.cameraPZ, renderTarget);
	        renderTarget.texture.generateMipmaps = generateMipmaps;
	        renderTarget.activeCubeFace = 5;
	        renderer.render(scene, this.cameraNZ, renderTarget);
	        renderer.setRenderTarget(null);
	    };
	    return CubeCamera;
	}(Object3D));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var AudioListener = /** @class */ (function (_super) {
	    __extends(AudioListener, _super);
	    function AudioListener() {
	        var _this = _super.call(this) || this;
	        _this.type = 'AudioListener';
	        _this.context = getAudioContext();
	        _this.gain = _this.context.createGain();
	        _this.gain.connect(_this.context.destination);
	        _this.filter = null;
	        return _this;
	    }
	    AudioListener.prototype.getInput = function () {
	        return this.gain;
	    };
	    AudioListener.prototype.removeFilter = function () {
	        if (this.filter !== null) {
	            this.gain.disconnect(this.filter);
	            this.filter.disconnect(this.context.destination);
	            this.gain.connect(this.context.destination);
	            this.filter = null;
	        }
	    };
	    AudioListener.prototype.getFilter = function () {
	        return this.filter;
	    };
	    AudioListener.prototype.setFilter = function (value) {
	        if (this.filter !== null) {
	            this.gain.disconnect(this.filter);
	            this.filter.disconnect(this.context.destination);
	        }
	        else {
	            this.gain.disconnect(this.context.destination);
	        }
	        this.filter = value;
	        this.gain.connect(this.filter);
	        this.filter.connect(this.context.destination);
	    };
	    AudioListener.prototype.getMasterVolume = function () {
	        return this.gain.gain.value;
	    };
	    AudioListener.prototype.setMasterVolume = function (value) {
	        this.gain.gain.value = value;
	    };
	    AudioListener.prototype.updateMatrixWorld = function (force) {
	        var position = new Vector3();
	        var quaternion = new Quaternion();
	        var scale = new Vector3();
	        var orientation = new Vector3();
	        //return function updateMatrixWorld(force) {
	        _super.prototype.updateMatrixWorld.call(this, force);
	        var listener = this.context.listener;
	        var up = this.up;
	        this.matrixWorld.decompose(position, quaternion, scale);
	        orientation.set(0, 0, -1).applyQuaternion(quaternion);
	        listener.setPosition(position.x, position.y, position.z);
	        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
	        //};
	    };
	    return AudioListener;
	}(Object3D));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */
	var Audio = /** @class */ (function (_super) {
	    __extends(Audio, _super);
	    function Audio(listener) {
	        var _this = _super.call(this) || this;
	        _this.autoplay = false;
	        _this.startTime = 0;
	        _this.playbackRate = 1;
	        _this.isPlaying = false;
	        _this.hasPlaybackControl = true;
	        _this.sourceType = 'empty';
	        _this.filters = [];
	        _this.type = 'Audio';
	        _this.context = listener.context;
	        _this.source = _this.context.createBufferSource();
	        _this.source.onended = _this.onEnded.bind(_this);
	        _this.gain = _this.context.createGain();
	        _this.gain.connect(listener.getInput());
	        return _this;
	    }
	    Audio.prototype.getOutput = function () {
	        return this.gain;
	    };
	    Audio.prototype.setNodeSource = function (audioNode) {
	        this.hasPlaybackControl = false;
	        this.sourceType = 'audioNode';
	        this.source = audioNode;
	        this.connect();
	        return this;
	    };
	    Audio.prototype.setBuffer = function (audioBuffer) {
	        this.source.buffer = audioBuffer;
	        this.sourceType = 'buffer';
	        if (this.autoplay)
	            this.play();
	        return this;
	    };
	    Audio.prototype.play = function () {
	        if (this.isPlaying === true) {
	            console.warn('THREE.Audio: Audio is already playing.');
	            return this;
	        }
	        if (this.hasPlaybackControl === false) {
	            console.warn('THREE.Audio: this Audio has no playback control.');
	            return this;
	        }
	        var source = this.context.createBufferSource();
	        source.buffer = this.source.buffer;
	        source.loop = this.source.loop;
	        source.onended = this.source.onended;
	        source.start(0, this.startTime);
	        source.playbackRate.value = this.playbackRate;
	        this.isPlaying = true;
	        this.source = source;
	        return this.connect();
	    };
	    Audio.prototype.pause = function () {
	        if (this.hasPlaybackControl === false) {
	            console.warn('THREE.Audio: this Audio has no playback control.');
	            return this;
	        }
	        this.source.stop();
	        this.startTime = this.context.currentTime;
	        this.isPlaying = false;
	        return this;
	    };
	    Audio.prototype.stop = function () {
	        if (this.hasPlaybackControl === false) {
	            console.warn('THREE.Audio: this Audio has no playback control.');
	            return this;
	        }
	        this.source.stop();
	        this.startTime = 0;
	        this.isPlaying = false;
	        return this;
	    };
	    Audio.prototype.connect = function () {
	        if (this.filters.length > 0) {
	            this.source.connect(this.filters[0]);
	            for (var i = 1, l = this.filters.length; i < l; i++) {
	                this.filters[i - 1].connect(this.filters[i]);
	            }
	            this.filters[this.filters.length - 1].connect(this.getOutput());
	        }
	        else {
	            this.source.connect(this.getOutput());
	        }
	        return this;
	    };
	    Audio.prototype.disconnect = function () {
	        if (this.filters.length > 0) {
	            this.source.disconnect(this.filters[0]);
	            for (var i = 1, l = this.filters.length; i < l; i++) {
	                this.filters[i - 1].disconnect(this.filters[i]);
	            }
	            this.filters[this.filters.length - 1].disconnect(this.getOutput());
	        }
	        else {
	            this.source.disconnect(this.getOutput());
	        }
	        return this;
	    };
	    Audio.prototype.getFilters = function () {
	        return this.filters;
	    };
	    Audio.prototype.setFilters = function (value) {
	        if (value === void 0) { value = []; }
	        if (this.isPlaying === true) {
	            this.disconnect();
	            this.filters = value;
	            this.connect();
	        }
	        else {
	            this.filters = value;
	        }
	        return this;
	    };
	    Audio.prototype.getFilter = function () {
	        return this.getFilters()[0];
	    };
	    Audio.prototype.setFilter = function (filter) {
	        return this.setFilters(filter ? [filter] : []);
	    };
	    Audio.prototype.setPlaybackRate = function (value) {
	        if (this.hasPlaybackControl === false) {
	            console.warn('THREE.Audio: this Audio has no playback control.');
	            return this;
	        }
	        this.playbackRate = value;
	        if (this.isPlaying === true) {
	            this.source.playbackRate.value = this.playbackRate;
	        }
	        return this;
	    };
	    Audio.prototype.getPlaybackRate = function () {
	        return this.playbackRate;
	    };
	    Audio.prototype.onEnded = function () {
	        this.isPlaying = false;
	    };
	    Audio.prototype.getLoop = function () {
	        if (this.hasPlaybackControl === false) {
	            console.warn('THREE.Audio: this Audio has no playback control.');
	            return false;
	        }
	        return this.source.loop;
	    };
	    Audio.prototype.setLoop = function (value) {
	        if (this.hasPlaybackControl === false) {
	            console.warn('THREE.Audio: this Audio has no playback control.');
	            return;
	        }
	        this.source.loop = value;
	    };
	    Audio.prototype.getVolume = function () {
	        return this.gain.gain.value;
	    };
	    Audio.prototype.setVolume = function (value) {
	        this.gain.gain.value = value;
	        return this;
	    };
	    Audio.prototype.load = function (file) {
	        console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");
	        var scope = this;
	        var audioLoader = new AudioLoader();
	        audioLoader.load(file, function (buffer) {
	            scope.setBuffer(buffer);
	        });
	        return this;
	    };
	    return Audio;
	}(Object3D));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var PositionalAudio = /** @class */ (function (_super) {
	    __extends(PositionalAudio, _super);
	    function PositionalAudio(listener) {
	        var _this = _super.call(this, listener) || this;
	        _this.panner = _this.context.createPanner();
	        _this.panner.connect(_this.gain);
	        return _this;
	    }
	    PositionalAudio.prototype.getOutput = function () {
	        return this.panner;
	    };
	    PositionalAudio.prototype.getRefDistance = function () {
	        return this.panner.refDistance;
	    };
	    PositionalAudio.prototype.setRefDistance = function (value) {
	        this.panner.refDistance = value;
	    };
	    PositionalAudio.prototype.getRolloffFactor = function () {
	        return this.panner.rolloffFactor;
	    };
	    PositionalAudio.prototype.setRolloffFactor = function (value) {
	        this.panner.rolloffFactor = value;
	    };
	    PositionalAudio.prototype.getDistanceModel = function () {
	        return this.panner.distanceModel;
	    };
	    PositionalAudio.prototype.setDistanceModel = function (value) {
	        this.panner.distanceModel = value;
	    };
	    PositionalAudio.prototype.getMaxDistance = function () {
	        return this.panner.maxDistance;
	    };
	    PositionalAudio.prototype.setMaxDistance = function (value) {
	        this.panner.maxDistance = value;
	    };
	    PositionalAudio.prototype.updateMatrixWorld = function (force) {
	        var position = new Vector3();
	        //return function updateMatrixWorld(force) {
	        _super.prototype.updateMatrixWorld.call(this, force);
	        position.setFromMatrixPosition(this.matrixWorld);
	        this.panner.setPosition(position.x, position.y, position.z);
	        //};
	    };
	    return PositionalAudio;
	}(Audio));

	var AudioAnalyser = /** @class */ (function () {
	    function AudioAnalyser(audio, fftSize) {
	        if (fftSize === void 0) { fftSize = 2048; }
	        this.analyser = audio.context.createAnalyser();
	        this.analyser.fftSize = fftSize;
	        this.data = new Uint8Array(this.analyser.frequencyBinCount);
	        audio.getOutput().connect(this.analyser);
	    }
	    AudioAnalyser.prototype.getFrequencyData = function () {
	        this.analyser.getByteFrequencyData(this.data);
	        return this.data;
	    };
	    AudioAnalyser.prototype.getAverageFrequency = function () {
	        var value = 0;
	        var data = this.getFrequencyData();
	        for (var i = 0; i < data.length; i++) {
	            value += data[i];
	        }
	        return value / data.length;
	    };
	    AudioAnalyser.prototype.getData = function (file) {
	        console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
	        return this.getFrequencyData();
	    };
	    return AudioAnalyser;
	}());

	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	var PropertyMixer = /** @class */ (function () {
	    function PropertyMixer(binding, typeName, valueSize) {
	        this.binding = binding;
	        this.valueSize = valueSize;
	        var bufferType = Float64Array, mixFunction;
	        switch (typeName) {
	            case 'quaternion':
	                mixFunction = this._slerp;
	                break;
	            case 'string':
	            case 'bool':
	                bufferType = Array, mixFunction = this._select;
	                break;
	            default: mixFunction = this._lerp;
	        }
	        this.buffer = new bufferType(valueSize * 4);
	        // layout: [ incoming | accu0 | accu1 | orig ]
	        //
	        // interpolators can use .buffer as their .result
	        // the data then goes to 'incoming'
	        //
	        // 'accu0' and 'accu1' are used frame-interleaved for
	        // the cumulative result and are compared to detect
	        // changes
	        //
	        // 'orig' stores the original state of the property
	        this._mixBufferRegion = mixFunction;
	        this.cumulativeWeight = 0;
	        this.useCount = 0;
	        this.referenceCount = 0;
	    }
	    // accumulate data in the 'incoming' region into 'accu<i>'
	    PropertyMixer.prototype.accumulate = function (accuIndex, weight) {
	        // note: happily accumulating nothing when weight = 0, the caller knows
	        // the weight and shouldn't have made the call in the first place
	        var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
	        var currentWeight = this.cumulativeWeight;
	        if (currentWeight === 0) {
	            // accuN := incoming * weight
	            for (var i = 0; i !== stride; ++i) {
	                buffer[offset + i] = buffer[i];
	            }
	            currentWeight = weight;
	        }
	        else {
	            // accuN := accuN + incoming * weight
	            currentWeight += weight;
	            var mix = weight / currentWeight;
	            this._mixBufferRegion(buffer, offset, 0, mix, stride);
	        }
	        this.cumulativeWeight = currentWeight;
	    };
	    // apply the state of 'accu<i>' to the binding when accus differ
	    PropertyMixer.prototype.apply = function (accuIndex) {
	        var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
	        this.cumulativeWeight = 0;
	        if (weight < 1) {
	            // accuN := accuN + original * (1 - cumulativeWeight)
	            var originalValueOffset = stride * 3;
	            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
	        }
	        for (var i = stride, e = stride + stride; i !== e; ++i) {
	            if (buffer[i] !== buffer[i + stride]) {
	                // value has changed -> update scene graph
	                binding.setValue(buffer, offset);
	                break;
	            }
	        }
	    };
	    // remember the state of the bound property and copy it to both accus
	    PropertyMixer.prototype.saveOriginalState = function () {
	        var binding = this.binding;
	        var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
	        binding.getValue(buffer, originalValueOffset);
	        // accu[0..1] := orig -- initially detect changes against the original
	        for (var i = stride, e = originalValueOffset; i !== e; ++i) {
	            buffer[i] = buffer[originalValueOffset + (i % stride)];
	        }
	        this.cumulativeWeight = 0;
	    };
	    // apply the state previously taken via 'saveOriginalState' to the binding
	    PropertyMixer.prototype.restoreOriginalState = function () {
	        var originalValueOffset = this.valueSize * 3;
	        this.binding.setValue(this.buffer, originalValueOffset);
	    };
	    // mix functions
	    PropertyMixer.prototype._select = function (buffer, dstOffset, srcOffset, t, stride) {
	        if (t >= 0.5) {
	            for (var i = 0; i !== stride; ++i) {
	                buffer[dstOffset + i] = buffer[srcOffset + i];
	            }
	        }
	    };
	    PropertyMixer.prototype._slerp = function (buffer, dstOffset, srcOffset, t, stride) {
	        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
	    };
	    PropertyMixer.prototype._lerp = function (buffer, dstOffset, srcOffset, t, stride) {
	        var s = 1 - t;
	        for (var i = 0; i !== stride; ++i) {
	            var j = dstOffset + i;
	            buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
	        }
	    };
	    return PropertyMixer;
	}());

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *   -  Add objects you would otherwise pass as 'root' to the
	 *     constructor or the .clipAction method of AnimationMixer.
	 *
	 *   -  Instead pass this object as 'root'.
	 *
	 *   -  You can also add and remove objects later when the mixer
	 *     is running.
	 *
	 * Note:
	 *
	 *    Objects of this class appear as one object to the mixer,
	 *    so cache control of the individual objects must be done
	 *    on the group.
	 *
	 * Limitation:
	 *
	 *   -   The animated properties must be compatible among the
	 *     all objects in the group.
	 *
	 *  -  A single property can either be controlled through a
	 *    target group or directly, but not both.
	 *
	 * @author tschw
	 */
	var AnimationObjectGroup = /** @class */ (function () {
	    function AnimationObjectGroup(var_args) {
	        this.uuid = _Math.generateUUID();
	        // cached objects followed by the active ones
	        this._objects = Array.prototype.slice.call(arguments);
	        this.nCachedObjects_ = 0; // threshold
	        // note: read by PropertyBinding.Composite
	        var indices = {};
	        this._indicesByUUID = indices; // for bookkeeping
	        for (var i = 0, n = arguments.length; i !== n; ++i) {
	            indices[arguments[i].uuid] = i;
	        }
	        this._paths = []; // inside: string
	        this._parsedPaths = []; // inside: { we don't care, here }
	        this._bindings = []; // inside: Array< PropertyBinding >
	        this._bindingsIndicesByPath = {}; // inside: indices in these arrays
	        var scope = this;
	        this.stats = {
	            objects: {
	                get total() { return scope._objects.length; },
	                get inUse() { return scope._objects.length - scope.nCachedObjects_; }
	            },
	            get bindingsPerObject() { return scope._bindings.length; }
	        };
	    }
	    AnimationObjectGroup.prototype.add = function (var_args) {
	        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject;
	        for (var i = 0, n = arguments.length; i !== n; ++i) {
	            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
	            if (index === undefined) {
	                // unknown object -> add it to the ACTIVE region
	                index = nObjects++;
	                indicesByUUID[uuid] = index;
	                objects.push(object);
	                // accounting is done, now do the same for all bindings
	                for (var j = 0, m = nBindings; j !== m; ++j) {
	                    bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
	                }
	            }
	            else if (index < nCachedObjects) {
	                knownObject = objects[index];
	                // move existing object to the ACTIVE region
	                var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
	                indicesByUUID[lastCachedObject.uuid] = index;
	                objects[index] = lastCachedObject;
	                indicesByUUID[uuid] = firstActiveIndex;
	                objects[firstActiveIndex] = object;
	                // accounting is done, now do the same for all bindings
	                for (var j = 0, m = nBindings; j !== m; ++j) {
	                    var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
	                    bindingsForPath[index] = lastCached;
	                    if (binding === undefined) {
	                        // since we do not bother to create new bindings
	                        // for objects that are cached, the binding may
	                        // or may not exist
	                        binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
	                    }
	                    bindingsForPath[firstActiveIndex] = binding;
	                }
	            }
	            else if (objects[index] !== knownObject) {
	                console.error("Different objects with the same UUID " +
	                    "detected. Clean the caches or recreate your " +
	                    "infrastructure when reloading scenes...");
	            } // else the object is already where we want it to be
	        } // for arguments
	        this.nCachedObjects_ = nCachedObjects;
	    };
	    AnimationObjectGroup.prototype.remove = function (var_args) {
	        var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
	        for (var i = 0, n = arguments.length; i !== n; ++i) {
	            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
	            if (index !== undefined && index >= nCachedObjects) {
	                // move existing object into the CACHED region
	                var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
	                indicesByUUID[firstActiveObject.uuid] = index;
	                objects[index] = firstActiveObject;
	                indicesByUUID[uuid] = lastCachedIndex;
	                objects[lastCachedIndex] = object;
	                // accounting is done, now do the same for all bindings
	                for (var j = 0, m = nBindings; j !== m; ++j) {
	                    var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
	                    bindingsForPath[index] = firstActive;
	                    bindingsForPath[lastCachedIndex] = binding;
	                }
	            }
	        } // for arguments
	        this.nCachedObjects_ = nCachedObjects;
	    };
	    // remove & forget
	    AnimationObjectGroup.prototype.uncache = function (var_args) {
	        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
	        for (var i = 0, n = arguments.length; i !== n; ++i) {
	            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
	            if (index !== undefined) {
	                delete indicesByUUID[uuid];
	                if (index < nCachedObjects) {
	                    // object is cached, shrink the CACHED region
	                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
	                    // last cached object takes this object's place
	                    indicesByUUID[lastCachedObject.uuid] = index;
	                    objects[index] = lastCachedObject;
	                    // last object goes to the activated slot and pop
	                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
	                    objects[firstActiveIndex] = lastObject;
	                    objects.pop();
	                    // accounting is done, now do the same for all bindings
	                    for (var j = 0, m = nBindings; j !== m; ++j) {
	                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
	                        bindingsForPath[index] = lastCached;
	                        bindingsForPath[firstActiveIndex] = last;
	                        bindingsForPath.pop();
	                    }
	                }
	                else {
	                    // object is active, just swap with the last and pop
	                    var lastIndex = --nObjects, lastObject = objects[lastIndex];
	                    indicesByUUID[lastObject.uuid] = index;
	                    objects[index] = lastObject;
	                    objects.pop();
	                    // accounting is done, now do the same for all bindings
	                    for (var j = 0, m = nBindings; j !== m; ++j) {
	                        var bindingsForPath = bindings[j];
	                        bindingsForPath[index] = bindingsForPath[lastIndex];
	                        bindingsForPath.pop();
	                    }
	                } // cached or active
	            } // if object is known
	        } // for arguments
	        this.nCachedObjects_ = nCachedObjects;
	    };
	    // Internal interface used by befriended PropertyBinding.Composite:
	    AnimationObjectGroup.prototype.subscribe_ = function (path, parsedPath) {
	        // returns an array of bindings for the given path that is changed
	        // according to the contained objects in the group
	        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
	        if (index !== undefined)
	            return bindings[index];
	        var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
	        index = bindings.length;
	        indicesByPath[path] = index;
	        paths.push(path);
	        parsedPaths.push(parsedPath);
	        bindings.push(bindingsForPath);
	        for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
	            var object = objects[i];
	            bindingsForPath[i] =
	                new PropertyBinding(object, path, parsedPath);
	        }
	        return bindingsForPath;
	    };
	    AnimationObjectGroup.prototype.unsubscribe_ = function (path) {
	        // tells the group to forget about a property path and no longer
	        // update the array previously obtained with 'subscribe_'
	        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
	        if (index !== undefined) {
	            var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
	            indicesByPath[lastBindingsPath] = index;
	            bindings[index] = lastBindings;
	            bindings.pop();
	            parsedPaths[index] = parsedPaths[lastBindingsIndex];
	            parsedPaths.pop();
	            paths[index] = paths[lastBindingsIndex];
	            paths.pop();
	        }
	    };
	    AnimationObjectGroup.isAnimationObjectGroup = true;
	    return AnimationObjectGroup;
	}());

	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	var PropertyBinding = /** @class */ (function () {
	    function PropertyBinding(rootNode, path, parsedPath) {
	        // initial state of these methods that calls 'bind'
	        this.getValue = this._getValue_unbound;
	        this.setValue = this._setValue_unbound;
	        this.BindingType = {
	            Direct: 0,
	            EntireArray: 1,
	            ArrayElement: 2,
	            HasFromToArray: 3
	        };
	        this.Versioning = {
	            None: 0,
	            NeedsUpdate: 1,
	            MatrixWorldNeedsUpdate: 2
	        };
	        this.GetterByBindingType = [
	            this.getValue_direct,
	            this.getValue_array,
	            this.getValue_arrayElement,
	            this.getValue_toArray
	        ];
	        this.SetterByBindingTypeAndVersioning = [
	            [
	                // Direct
	                this.setValue_direct,
	                this.setValue_direct_setNeedsUpdate,
	                this.setValue_direct_setMatrixWorldNeedsUpdate
	            ], [
	                // EntireArray
	                this.setValue_array,
	                this.setValue_array_setNeedsUpdate,
	                this.setValue_array_setMatrixWorldNeedsUpdate
	            ], [
	                // ArrayElement
	                this.setValue_arrayElement,
	                this.setValue_arrayElement_setNeedsUpdate,
	                this.setValue_arrayElement_setMatrixWorldNeedsUpdate
	            ], [
	                // HasToFromArray
	                this.setValue_fromArray,
	                this.setValue_fromArray_setNeedsUpdate,
	                this.setValue_fromArray_setMatrixWorldNeedsUpdate
	            ]
	        ];
	        this.path = path;
	        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
	        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
	        this.rootNode = rootNode;
	    }
	    PropertyBinding.prototype._getValue_unbound = function (targetArray, offset) {
	        this.bind();
	        this.getValue(targetArray, offset);
	        // Note: This class uses a State pattern on a per-method basis:
	        // 'bind' sets 'this.getValue' / 'setValue' and shadows the
	        // prototype version of these methods with one that represents
	        // the bound state. When the property is not found, the methods
	        // become no-ops.
	    };
	    PropertyBinding.prototype._setValue_unbound = function (sourceArray, offset) {
	        this.bind();
	        this.setValue(sourceArray, offset);
	    };
	    // create getter / setter pair for a property in the scene graph
	    PropertyBinding.prototype.bind = function () {
	        var targetObject = this.node;
	        var parsedPath = this.parsedPath;
	        var objectName = parsedPath.objectName;
	        var propertyName = parsedPath.propertyName;
	        var propertyIndex = parsedPath.propertyIndex;
	        if (!targetObject) {
	            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
	            this.node = targetObject;
	        }
	        // set fail state so we can just 'return' on error
	        this.getValue = this._getValue_unavailable;
	        this.setValue = this._setValue_unavailable;
	        // ensure there is a value node
	        if (!targetObject) {
	            console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
	            return;
	        }
	        if (objectName) {
	            var objectIndex = parsedPath.objectIndex;
	            // special cases were we need to reach deeper into the hierarchy to get the face materials....
	            switch (objectName) {
	                case 'materials':
	                    if (!targetObject.material) {
	                        console.error('  can not bind to material as node does not have a material', this);
	                        return;
	                    }
	                    if (!targetObject.material.materials) {
	                        console.error('  can not bind to material.materials as node.material does not have a materials array', this);
	                        return;
	                    }
	                    targetObject = targetObject.material.materials;
	                    break;
	                case 'bones':
	                    if (!targetObject.skeleton) {
	                        console.error('  can not bind to bones as node does not have a skeleton', this);
	                        return;
	                    }
	                    // potential future optimization: skip this if propertyIndex is already an integer
	                    // and convert the integer string to a true integer.
	                    targetObject = targetObject.skeleton.bones;
	                    // support resolving morphTarget names into indices.
	                    for (var i = 0; i < targetObject.length; i++) {
	                        if (targetObject[i].name === objectIndex) {
	                            objectIndex = i;
	                            break;
	                        }
	                    }
	                    break;
	                default:
	                    if (targetObject[objectName] === undefined) {
	                        console.error('  can not bind to objectName of node, undefined', this);
	                        return;
	                    }
	                    targetObject = targetObject[objectName];
	            }
	            if (objectIndex !== undefined) {
	                if (targetObject[objectIndex] === undefined) {
	                    console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
	                    return;
	                }
	                targetObject = targetObject[objectIndex];
	            }
	        }
	        // resolve property
	        var nodeProperty = targetObject[propertyName];
	        if (nodeProperty === undefined) {
	            var nodeName = parsedPath.nodeName;
	            console.error("  trying to update property for track: " + nodeName +
	                '.' + propertyName + " but it wasn't found.", targetObject);
	            return;
	        }
	        // determine versioning scheme
	        var versioning = this.Versioning.None;
	        if (targetObject.needsUpdate !== undefined) {
	            versioning = this.Versioning.NeedsUpdate;
	            this.targetObject = targetObject;
	        }
	        else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
	            versioning = this.Versioning.MatrixWorldNeedsUpdate;
	            this.targetObject = targetObject;
	        }
	        // determine how the property gets bound
	        var bindingType = this.BindingType.Direct;
	        if (propertyIndex !== undefined) {
	            // access a sub element of the property array (only primitives are supported right now)
	            if (propertyName === "morphTargetInfluences") {
	                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	                // support resolving morphTarget names into indices.
	                if (!targetObject.geometry) {
	                    console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry', this);
	                    return;
	                }
	                if (!targetObject.geometry.morphTargets) {
	                    console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this);
	                    return;
	                }
	                for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
	                    if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
	                        propertyIndex = i;
	                        break;
	                    }
	                }
	            }
	            bindingType = this.BindingType.ArrayElement;
	            this.resolvedProperty = nodeProperty;
	            this.propertyIndex = propertyIndex;
	        }
	        else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
	            // must use copy for Object3D.Euler/Quaternion
	            bindingType = this.BindingType.HasFromToArray;
	            this.resolvedProperty = nodeProperty;
	        }
	        else if (nodeProperty.length !== undefined) {
	            bindingType = this.BindingType.EntireArray;
	            this.resolvedProperty = nodeProperty;
	        }
	        else {
	            this.propertyName = propertyName;
	        }
	        // select getter / setter
	        this.getValue = this.GetterByBindingType[bindingType];
	        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
	    };
	    PropertyBinding.prototype.unbind = function () {
	        this.node = null;
	        // back to the prototype version of getValue / setValue
	        // note: avoiding to mutate the shape of 'this' via 'delete'
	        this.getValue = this._getValue_unbound;
	        this.setValue = this._setValue_unbound;
	    };
	    // these are used to "bind" a nonexistent property
	    PropertyBinding.prototype._getValue_unavailable = function (targetArray, offset) { };
	    PropertyBinding.prototype._setValue_unavailable = function (targetArray, offset) { };
	    PropertyBinding.prototype.getValue_direct = function (buffer, offset) {
	        buffer[offset] = this.node[this.propertyName];
	    };
	    PropertyBinding.prototype.getValue_array = function (buffer, offset) {
	        var source = this.resolvedProperty;
	        for (var i = 0, n = source.length; i !== n; ++i) {
	            buffer[offset++] = source[i];
	        }
	    };
	    PropertyBinding.prototype.getValue_arrayElement = function (buffer, offset) {
	        buffer[offset] = this.resolvedProperty[this.propertyIndex];
	    };
	    PropertyBinding.prototype.getValue_toArray = function (buffer, offset) {
	        this.resolvedProperty.toArray(buffer, offset);
	    };
	    // Direct
	    PropertyBinding.prototype.setValue_direct = function (buffer, offset) {
	        this.node[this.propertyName] = buffer[offset];
	    };
	    PropertyBinding.prototype.setValue_direct_setNeedsUpdate = function (buffer, offset) {
	        this.node[this.propertyName] = buffer[offset];
	        this.targetObject.needsUpdate = true;
	    };
	    PropertyBinding.prototype.setValue_direct_setMatrixWorldNeedsUpdate = function (buffer, offset) {
	        this.node[this.propertyName] = buffer[offset];
	        this.targetObject.matrixWorldNeedsUpdate = true;
	    };
	    // EntireArray
	    PropertyBinding.prototype.setValue_array = function (buffer, offset) {
	        var dest = this.resolvedProperty;
	        for (var i = 0, n = dest.length; i !== n; ++i) {
	            dest[i] = buffer[offset++];
	        }
	    };
	    PropertyBinding.prototype.setValue_array_setNeedsUpdate = function (buffer, offset) {
	        var dest = this.resolvedProperty;
	        for (var i = 0, n = dest.length; i !== n; ++i) {
	            dest[i] = buffer[offset++];
	        }
	        this.targetObject.needsUpdate = true;
	    };
	    PropertyBinding.prototype.setValue_array_setMatrixWorldNeedsUpdate = function (buffer, offset) {
	        var dest = this.resolvedProperty;
	        for (var i = 0, n = dest.length; i !== n; ++i) {
	            dest[i] = buffer[offset++];
	        }
	        this.targetObject.matrixWorldNeedsUpdate = true;
	    };
	    // ArrayElement
	    PropertyBinding.prototype.setValue_arrayElement = function (buffer, offset) {
	        this.resolvedProperty[this.propertyIndex] = buffer[offset];
	    };
	    PropertyBinding.prototype.setValue_arrayElement_setNeedsUpdate = function (buffer, offset) {
	        this.resolvedProperty[this.propertyIndex] = buffer[offset];
	        this.targetObject.needsUpdate = true;
	    };
	    PropertyBinding.prototype.setValue_arrayElement_setMatrixWorldNeedsUpdate = function (buffer, offset) {
	        this.resolvedProperty[this.propertyIndex] = buffer[offset];
	        this.targetObject.matrixWorldNeedsUpdate = true;
	    };
	    // HasToFromArray
	    PropertyBinding.prototype.setValue_fromArray = function (buffer, offset) {
	        this.resolvedProperty.fromArray(buffer, offset);
	    };
	    PropertyBinding.prototype.setValue_fromArray_setNeedsUpdate = function (buffer, offset) {
	        this.resolvedProperty.fromArray(buffer, offset);
	        this.targetObject.needsUpdate = true;
	    };
	    PropertyBinding.prototype.setValue_fromArray_setMatrixWorldNeedsUpdate = function (buffer, offset) {
	        this.resolvedProperty.fromArray(buffer, offset);
	        this.targetObject.matrixWorldNeedsUpdate = true;
	    };
	    PropertyBinding.create = function (root, path, parsedPath) {
	        if (!((root && root instanceof AnimationObjectGroup))) {
	            return new PropertyBinding(root, path, parsedPath);
	        }
	        else {
	            return new PropertyBinding.Composite(root, path, parsedPath);
	        }
	    };
	    PropertyBinding.parseTrackName = function (trackName) {
	        // matches strings in the form of:
	        //    nodeName.property
	        //    nodeName.property[accessor]
	        //    nodeName.material.property[accessor]
	        //    uuid.property[accessor]
	        //    uuid.objectName[objectIndex].propertyName[propertyIndex]
	        //    parentName/nodeName.property
	        //    parentName/parentName/nodeName.property[index]
	        //    .bone[Armature.DEF_cog].position
	        //    scene:helium_balloon_model:helium_balloon_model.position
	        // created and tested via https://regex101.com/#javascript
	        var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
	        var matches = re.exec(trackName);
	        if (!matches) {
	            throw new Error("cannot parse trackName at all: " + trackName);
	        }
	        var results = {
	            // directoryName: matches[ 1 ], // (tschw) currently unused
	            nodeName: matches[2],
	            objectName: matches[3],
	            objectIndex: matches[4],
	            propertyName: matches[5],
	            propertyIndex: matches[6] // allowed to be null, specifies that the whole property is set.
	        };
	        if (results.propertyName === null || results.propertyName.length === 0) {
	            throw new Error("can not parse propertyName from trackName: " + trackName);
	        }
	        return results;
	    };
	    PropertyBinding.findNode = function (root, nodeName) {
	        if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
	            return root;
	        }
	        // search into skeleton bones.
	        if (root.skeleton) {
	            var searchSkeleton = function (skeleton) {
	                for (var i = 0; i < skeleton.bones.length; i++) {
	                    var bone_1 = skeleton.bones[i];
	                    if (bone_1.name === nodeName) {
	                        return bone_1;
	                    }
	                }
	                return null;
	            };
	            var bone = searchSkeleton(root.skeleton);
	            if (bone) {
	                return bone;
	            }
	        }
	        // search into node subtree.
	        if (root.children) {
	            var searchNodeSubtree_1 = function (children) {
	                for (var i = 0; i < children.length; i++) {
	                    var childNode = children[i];
	                    if (childNode.name === nodeName || childNode.uuid === nodeName) {
	                        return childNode;
	                    }
	                    var result = searchNodeSubtree_1(childNode.children);
	                    if (result)
	                        return result;
	                }
	                return null;
	            };
	            var subTreeNode = searchNodeSubtree_1(root.children);
	            if (subTreeNode) {
	                return subTreeNode;
	            }
	        }
	        return null;
	    };
	    PropertyBinding.Composite = /** @class */ (function () {
	        function class_1(targetGroup, path, optionalParsedPath) {
	            var parsedPath = optionalParsedPath ||
	                PropertyBinding.parseTrackName(path);
	            this._targetGroup = targetGroup;
	            this._bindings = targetGroup.subscribe_(path, parsedPath);
	        }
	        class_1.prototype.getValue = function (array, offset) {
	            this.bind(); // bind all binding
	            var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
	            // and only call .getValue on the first
	            if (binding !== undefined)
	                binding.getValue(array, offset);
	        };
	        class_1.prototype.setValue = function (array, offset) {
	            var bindings = this._bindings;
	            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
	                bindings[i].setValue(array, offset);
	            }
	        };
	        class_1.prototype.bind = function () {
	            var bindings = this._bindings;
	            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
	                bindings[i].bind();
	            }
	        };
	        class_1.prototype.unbind = function () {
	            var bindings = this._bindings;
	            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
	                bindings[i].unbind();
	            }
	        };
	        return class_1;
	    }());
	    return PropertyBinding;
	}());

	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */
	var AnimationAction = /** @class */ (function () {
	    function AnimationAction(mixer, clip, localRoot) {
	        this._mixer = mixer;
	        this._clip = clip;
	        this._localRoot = localRoot || null;
	        var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
	        var interpolantSettings = {
	            endingStart: exports.EndingMode.ZeroCurvature,
	            endingEnd: exports.EndingMode.ZeroCurvature
	        };
	        for (var i = 0; i !== nTracks; ++i) {
	            var interpolant = tracks[i].createInterpolant(null);
	            interpolants[i] = interpolant;
	            interpolant.settings = interpolantSettings;
	        }
	        this._interpolantSettings = interpolantSettings;
	        this._interpolants = interpolants; // bound by the mixer
	        // inside: PropertyMixer (managed by the mixer)
	        this._propertyBindings = new Array(nTracks);
	        this._cacheIndex = null; // for the memory manager
	        this._byClipCacheIndex = null; // for the memory manager
	        this._timeScaleInterpolant = null;
	        this._weightInterpolant = null;
	        this.loop = exports.LoopMode.Repeat;
	        this._loopCount = -1;
	        // global mixer time when the action is to be started
	        // it's set back to 'null' upon start of the action
	        this._startTime = null;
	        // scaled local time of the action
	        // gets clamped or wrapped to 0..clip.duration according to loop
	        this.time = 0;
	        this.timeScale = 1;
	        this._effectiveTimeScale = 1;
	        this.weight = 1;
	        this._effectiveWeight = 1;
	        this.repetitions = Infinity; // no. of repetitions when looping
	        this.paused = false; // false -> zero effective time scale
	        this.enabled = true; // true -> zero effective weight
	        this.clampWhenFinished = false; // keep feeding the last frame?
	        this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
	        this.zeroSlopeAtEnd = true; // clips for start, loop and end
	    }
	    // State & Scheduling
	    AnimationAction.prototype.play = function () {
	        this._mixer._activateAction(this);
	        return this;
	    };
	    AnimationAction.prototype.stop = function () {
	        this._mixer._deactivateAction(this);
	        return this.reset();
	    };
	    AnimationAction.prototype.reset = function () {
	        this.paused = false;
	        this.enabled = true;
	        this.time = 0; // restart clip
	        this._loopCount = -1; // forget previous loops
	        this._startTime = null; // forget scheduling
	        return this.stopFading().stopWarping();
	    };
	    AnimationAction.prototype.isRunning = function () {
	        return this.enabled && !this.paused && this.timeScale !== 0 &&
	            this._startTime === null && this._mixer._isActiveAction(this);
	    };
	    // return true when play has been called
	    AnimationAction.prototype.isScheduled = function () {
	        return this._mixer._isActiveAction(this);
	    };
	    AnimationAction.prototype.startAt = function (time) {
	        this._startTime = time;
	        return this;
	    };
	    AnimationAction.prototype.setLoop = function (mode, repetitions) {
	        this.loop = mode;
	        this.repetitions = repetitions;
	        return this;
	    };
	    // Weight
	    // set the weight stopping any scheduled fading
	    // although .enabled = false yields an effective weight of zero, this
	    // method does *not* change .enabled, because it would be confusing
	    AnimationAction.prototype.setEffectiveWeight = function (weight) {
	        this.weight = weight;
	        // note: same logic as when updated at runtime
	        this._effectiveWeight = this.enabled ? weight : 0;
	        return this.stopFading();
	    };
	    // return the weight considering fading and .enabled
	    AnimationAction.prototype.getEffectiveWeight = function () {
	        return this._effectiveWeight;
	    };
	    AnimationAction.prototype.fadeIn = function (duration) {
	        return this._scheduleFading(duration, 0, 1);
	    };
	    AnimationAction.prototype.fadeOut = function (duration) {
	        return this._scheduleFading(duration, 1, 0);
	    };
	    AnimationAction.prototype.crossFadeFrom = function (fadeOutAction, duration, warp) {
	        fadeOutAction.fadeOut(duration);
	        this.fadeIn(duration);
	        if (warp) {
	            var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
	            fadeOutAction.warp(1.0, startEndRatio, duration);
	            this.warp(endStartRatio, 1.0, duration);
	        }
	        return this;
	    };
	    AnimationAction.prototype.crossFadeTo = function (fadeInAction, duration, warp) {
	        return fadeInAction.crossFadeFrom(this, duration, warp);
	    };
	    AnimationAction.prototype.stopFading = function () {
	        var weightInterpolant = this._weightInterpolant;
	        if (weightInterpolant !== null) {
	            this._weightInterpolant = null;
	            this._mixer._takeBackControlInterpolant(weightInterpolant);
	        }
	        return this;
	    };
	    // Time Scale Control
	    // set the weight stopping any scheduled warping
	    // although .paused = true yields an effective time scale of zero, this
	    // method does *not* change .paused, because it would be confusing
	    AnimationAction.prototype.setEffectiveTimeScale = function (timeScale) {
	        this.timeScale = timeScale;
	        this._effectiveTimeScale = this.paused ? 0 : timeScale;
	        return this.stopWarping();
	    };
	    // return the time scale considering warping and .paused
	    AnimationAction.prototype.getEffectiveTimeScale = function () {
	        return this._effectiveTimeScale;
	    };
	    AnimationAction.prototype.setDuration = function (duration) {
	        this.timeScale = this._clip.duration / duration;
	        return this.stopWarping();
	    };
	    AnimationAction.prototype.syncWith = function (action) {
	        this.time = action.time;
	        this.timeScale = action.timeScale;
	        return this.stopWarping();
	    };
	    AnimationAction.prototype.halt = function (duration) {
	        return this.warp(this._effectiveTimeScale, 0, duration);
	    };
	    AnimationAction.prototype.warp = function (startTimeScale, endTimeScale, duration) {
	        var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
	        if (interpolant === null) {
	            interpolant = mixer._lendControlInterpolant(), this._timeScaleInterpolant = interpolant;
	        }
	        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
	        times[0] = now;
	        times[1] = now + duration;
	        values[0] = startTimeScale / timeScale;
	        values[1] = endTimeScale / timeScale;
	        return this;
	    };
	    AnimationAction.prototype.stopWarping = function () {
	        var timeScaleInterpolant = this._timeScaleInterpolant;
	        if (timeScaleInterpolant !== null) {
	            this._timeScaleInterpolant = null;
	            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
	        }
	        return this;
	    };
	    // Object Accessors
	    AnimationAction.prototype.getMixer = function () {
	        return this._mixer;
	    };
	    AnimationAction.prototype.getClip = function () {
	        return this._clip;
	    };
	    AnimationAction.prototype.getRoot = function () {
	        return this._localRoot || this._mixer._root;
	    };
	    // Interna
	    AnimationAction.prototype._update = function (time, deltaTime, timeDirection, accuIndex) {
	        // called by the mixer
	        var startTime = this._startTime;
	        if (startTime !== null) {
	            // check for scheduled start of action
	            var timeRunning = (time - startTime) * timeDirection;
	            if (timeRunning < 0 || timeDirection === 0) {
	                return; // yet to come / don't decide when delta = 0
	            }
	            // start
	            this._startTime = null; // unschedule
	            deltaTime = timeDirection * timeRunning;
	        }
	        // apply time scale and advance time
	        deltaTime *= this._updateTimeScale(time);
	        var clipTime = this._updateTime(deltaTime);
	        // note: _updateTime may disable the action resulting in
	        // an effective weight of 0
	        var weight = this._updateWeight(time);
	        if (weight > 0) {
	            var interpolants = this._interpolants;
	            var propertyMixers = this._propertyBindings;
	            for (var j = 0, m = interpolants.length; j !== m; ++j) {
	                interpolants[j].evaluate(clipTime);
	                propertyMixers[j].accumulate(accuIndex, weight);
	            }
	        }
	    };
	    AnimationAction.prototype._updateWeight = function (time) {
	        var weight = 0;
	        if (this.enabled) {
	            weight = this.weight;
	            var interpolant = this._weightInterpolant;
	            if (interpolant !== null) {
	                var interpolantValue = interpolant.evaluate(time)[0];
	                weight *= interpolantValue;
	                if (time > interpolant.parameterPositions[1]) {
	                    this.stopFading();
	                    if (interpolantValue === 0) {
	                        // faded out, disable
	                        this.enabled = false;
	                    }
	                }
	            }
	        }
	        this._effectiveWeight = weight;
	        return weight;
	    };
	    AnimationAction.prototype._updateTimeScale = function (time) {
	        var timeScale = 0;
	        if (!this.paused) {
	            timeScale = this.timeScale;
	            var interpolant = this._timeScaleInterpolant;
	            if (interpolant !== null) {
	                var interpolantValue = interpolant.evaluate(time)[0];
	                timeScale *= interpolantValue;
	                if (time > interpolant.parameterPositions[1]) {
	                    this.stopWarping();
	                    if (timeScale === 0) {
	                        // motion has halted, pause
	                        this.paused = true;
	                    }
	                    else {
	                        // warp done - apply final time scale
	                        this.timeScale = timeScale;
	                    }
	                }
	            }
	        }
	        this._effectiveTimeScale = timeScale;
	        return timeScale;
	    };
	    AnimationAction.prototype._updateTime = function (deltaTime) {
	        var time = this.time + deltaTime;
	        if (deltaTime === 0)
	            return time;
	        var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
	        if (loop === exports.LoopMode.Once) {
	            if (loopCount === -1) {
	                // just started
	                this.loopCount = 0;
	                this._setEndings(true, true, false);
	            }
	            handle_stop: {
	                if (time >= duration) {
	                    time = duration;
	                }
	                else if (time < 0) {
	                    time = 0;
	                }
	                else
	                    break handle_stop;
	                if (this.clampWhenFinished)
	                    this.paused = true;
	                else
	                    this.enabled = false;
	                this._mixer.dispatchEvent({
	                    type: 'finished', action: this,
	                    direction: deltaTime < 0 ? -1 : 1
	                });
	            }
	        }
	        else {
	            var pingPong = (loop === exports.LoopMode.PingPong);
	            if (loopCount === -1) {
	                // just started
	                if (deltaTime >= 0) {
	                    loopCount = 0;
	                    this._setEndings(true, this.repetitions === 0, pingPong);
	                }
	                else {
	                    // when looping in reverse direction, the initial
	                    // transition through zero counts as a repetition,
	                    // so leave loopCount at -1
	                    this._setEndings(this.repetitions === 0, true, pingPong);
	                }
	            }
	            if (time >= duration || time < 0) {
	                // wrap around
	                var loopDelta = Math.floor(time / duration); // signed
	                time -= duration * loopDelta;
	                loopCount += Math.abs(loopDelta);
	                var pending = this.repetitions - loopCount;
	                if (pending < 0) {
	                    // have to stop (switch state, clamp time, fire event)
	                    if (this.clampWhenFinished)
	                        this.paused = true;
	                    else
	                        this.enabled = false;
	                    time = deltaTime > 0 ? duration : 0;
	                    this._mixer.dispatchEvent({
	                        type: 'finished', action: this,
	                        direction: deltaTime > 0 ? 1 : -1
	                    });
	                }
	                else {
	                    // keep running
	                    if (pending === 0) {
	                        // entering the last round
	                        var atStart = deltaTime < 0;
	                        this._setEndings(atStart, !atStart, pingPong);
	                    }
	                    else {
	                        this._setEndings(false, false, pingPong);
	                    }
	                    this._loopCount = loopCount;
	                    this._mixer.dispatchEvent({
	                        type: 'loop', action: this, loopDelta: loopDelta
	                    });
	                }
	            }
	            if (pingPong && (loopCount & 1) === 1) {
	                // invert time for the "pong round"
	                this.time = time;
	                return duration - time;
	            }
	        }
	        this.time = time;
	        return time;
	    };
	    AnimationAction.prototype._setEndings = function (atStart, atEnd, pingPong) {
	        var settings = this._interpolantSettings;
	        if (pingPong) {
	            settings.endingStart = exports.EndingMode.ZeroSlope;
	            settings.endingEnd = exports.EndingMode.ZeroSlope;
	        }
	        else {
	            // assuming for LoopMode.Once atStart == atEnd == true
	            if (atStart) {
	                settings.endingStart = this.zeroSlopeAtStart ?
	                    exports.EndingMode.ZeroSlope : exports.EndingMode.ZeroCurvature;
	            }
	            else {
	                settings.endingStart = exports.EndingMode.WrapAround;
	            }
	            if (atEnd) {
	                settings.endingEnd = this.zeroSlopeAtEnd ?
	                    exports.EndingMode.ZeroSlope : exports.EndingMode.ZeroCurvature;
	            }
	            else {
	                settings.endingEnd = exports.EndingMode.WrapAround;
	            }
	        }
	    };
	    AnimationAction.prototype._scheduleFading = function (duration, weightNow, weightThen) {
	        var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
	        if (interpolant === null) {
	            interpolant = mixer._lendControlInterpolant(), this._weightInterpolant = interpolant;
	        }
	        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
	        times[0] = now;
	        values[0] = weightNow;
	        times[1] = now + duration;
	        values[1] = weightThen;
	        return this;
	    };
	    return AnimationAction;
	}());

	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	var AnimationMixer = /** @class */ (function (_super) {
	    __extends(AnimationMixer, _super);
	    function AnimationMixer(root) {
	        var _this = _super.call(this) || this;
	        _this._controlInterpolantsResultBuffer = new Float32Array(1);
	        _this._root = root;
	        _this._initMemoryManager();
	        _this._accuIndex = 0;
	        _this.time = 0;
	        _this.timeScale = 1.0;
	        return _this;
	    }
	    // return an action for a clip optionally using a custom root target
	    // object (this method allocates a lot of dynamic memory in case a
	    // previously unknown clip/root combination is specified)
	    AnimationMixer.prototype.clipAction = function (clip, optionalRoot) {
	        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?
	            AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
	        if (actionsForClip !== undefined) {
	            var existingAction = actionsForClip.actionByRoot[rootUuid];
	            if (existingAction !== undefined) {
	                return existingAction;
	            }
	            // we know the clip, so we don't have to parse all
	            // the bindings again but can just copy
	            prototypeAction = actionsForClip.knownActions[0];
	            // also, take the clip from the prototype action
	            if (clipObject === null)
	                clipObject = prototypeAction._clip;
	        }
	        // clip must be known when specified via string
	        if (clipObject === null)
	            return null;
	        // allocate all resources required to run it
	        var newAction = new AnimationAction(this, clipObject, optionalRoot);
	        this._bindAction(newAction, prototypeAction);
	        // and make the action known to the memory manager
	        this._addInactiveAction(newAction, clipUuid, rootUuid);
	        return newAction;
	    };
	    // get an existing action
	    AnimationMixer.prototype.existingAction = function (clip, optionalRoot) {
	        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?
	            AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
	        if (actionsForClip !== undefined) {
	            return actionsForClip.actionByRoot[rootUuid] || null;
	        }
	        return null;
	    };
	    // deactivates all previously scheduled actions
	    AnimationMixer.prototype.stopAllAction = function () {
	        var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
	        this._nActiveActions = 0;
	        this._nActiveBindings = 0;
	        for (var i = 0; i !== nActions; ++i) {
	            actions[i].reset();
	        }
	        for (var i = 0; i !== nBindings; ++i) {
	            bindings[i].useCount = 0;
	        }
	        return this;
	    };
	    // advance the time and update apply the animation
	    AnimationMixer.prototype.update = function (deltaTime) {
	        deltaTime *= this.timeScale;
	        var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
	        // run active actions
	        for (var i = 0; i !== nActions; ++i) {
	            var action = actions[i];
	            if (action.enabled) {
	                action._update(time, deltaTime, timeDirection, accuIndex);
	            }
	        }
	        // update scene graph
	        var bindings = this._bindings, nBindings = this._nActiveBindings;
	        for (var i = 0; i !== nBindings; ++i) {
	            bindings[i].apply(accuIndex);
	        }
	        return this;
	    };
	    // return this mixer's root target object
	    AnimationMixer.prototype.getRoot = function () {
	        return this._root;
	    };
	    // free all resources specific to a particular clip
	    AnimationMixer.prototype.uncacheClip = function (clip) {
	        var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
	        if (actionsForClip !== undefined) {
	            // note: just calling _removeInactiveAction would mess up the
	            // iteration state and also require updating the state we can
	            // just throw away
	            var actionsToRemove = actionsForClip.knownActions;
	            for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
	                var action = actionsToRemove[i];
	                this._deactivateAction(action);
	                var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
	                action._cacheIndex = null;
	                action._byClipCacheIndex = null;
	                lastInactiveAction._cacheIndex = cacheIndex;
	                actions[cacheIndex] = lastInactiveAction;
	                actions.pop();
	                this._removeInactiveBindingsForAction(action);
	            }
	            delete actionsByClip[clipUuid];
	        }
	    };
	    // free all resources specific to a particular root target object
	    AnimationMixer.prototype.uncacheRoot = function (root) {
	        var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
	        for (var clipUuid in actionsByClip) {
	            var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
	            if (action !== undefined) {
	                this._deactivateAction(action);
	                this._removeInactiveAction(action);
	            }
	        }
	        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
	        if (bindingByName !== undefined) {
	            for (var trackName in bindingByName) {
	                var binding = bindingByName[trackName];
	                binding.restoreOriginalState();
	                this._removeInactiveBinding(binding);
	            }
	        }
	    };
	    // remove a targeted clip from the cache
	    AnimationMixer.prototype.uncacheAction = function (clip, optionalRoot) {
	        var action = this.existingAction(clip, optionalRoot);
	        if (action !== null) {
	            this._deactivateAction(action);
	            this._removeInactiveAction(action);
	        }
	    };
	    // Implementation details:
	    AnimationMixer.prototype._bindAction = function (action, prototypeAction) {
	        var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
	        if (bindingsByName === undefined) {
	            bindingsByName = {};
	            bindingsByRoot[rootUuid] = bindingsByName;
	        }
	        for (var i = 0; i !== nTracks; ++i) {
	            var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
	            if (binding !== undefined) {
	                bindings[i] = binding;
	            }
	            else {
	                binding = bindings[i];
	                if (binding !== undefined) {
	                    // existing binding, make sure the cache knows
	                    if (binding._cacheIndex === null) {
	                        ++binding.referenceCount;
	                        this._addInactiveBinding(binding, rootUuid, trackName);
	                    }
	                    continue;
	                }
	                var path = prototypeAction && prototypeAction.
	                    _propertyBindings[i].binding.parsedPath;
	                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
	                ++binding.referenceCount;
	                this._addInactiveBinding(binding, rootUuid, trackName);
	                bindings[i] = binding;
	            }
	            interpolants[i].resultBuffer = binding.buffer;
	        }
	    };
	    AnimationMixer.prototype._activateAction = function (action) {
	        if (!this._isActiveAction(action)) {
	            if (action._cacheIndex === null) {
	                // this action has been forgotten by the cache, but the user
	                // appears to be still using it -> rebind
	                var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
	                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
	                this._addInactiveAction(action, clipUuid, rootUuid);
	            }
	            var bindings = action._propertyBindings;
	            // increment reference counts / sort out state
	            for (var i = 0, n = bindings.length; i !== n; ++i) {
	                var binding = bindings[i];
	                if (binding.useCount++ === 0) {
	                    this._lendBinding(binding);
	                    binding.saveOriginalState();
	                }
	            }
	            this._lendAction(action);
	        }
	    };
	    AnimationMixer.prototype._deactivateAction = function (action) {
	        if (this._isActiveAction(action)) {
	            var bindings = action._propertyBindings;
	            // decrement reference counts / sort out state
	            for (var i = 0, n = bindings.length; i !== n; ++i) {
	                var binding = bindings[i];
	                if (--binding.useCount === 0) {
	                    binding.restoreOriginalState();
	                    this._takeBackBinding(binding);
	                }
	            }
	            this._takeBackAction(action);
	        }
	    };
	    // Memory manager
	    AnimationMixer.prototype._initMemoryManager = function () {
	        this._actions = []; // 'nActiveActions' followed by inactive ones
	        this._nActiveActions = 0;
	        this._actionsByClip = {};
	        // inside:
	        // {
	        //     knownActions: Array< AnimationAction >  - used as prototypes
	        //     actionByRoot: AnimationAction      - lookup
	        // }
	        this._bindings = []; // 'nActiveBindings' followed by inactive ones
	        this._nActiveBindings = 0;
	        this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
	        this._controlInterpolants = []; // same game as above
	        this._nActiveControlInterpolants = 0;
	        var scope = this;
	        this.stats = {
	            actions: {
	                get total() { return scope._actions.length; },
	                get inUse() { return scope._nActiveActions; }
	            },
	            bindings: {
	                get total() { return scope._bindings.length; },
	                get inUse() { return scope._nActiveBindings; }
	            },
	            controlInterpolants: {
	                get total() { return scope._controlInterpolants.length; },
	                get inUse() { return scope._nActiveControlInterpolants; }
	            }
	        };
	    };
	    // Memory management for AnimationAction objects
	    AnimationMixer.prototype._isActiveAction = function (action) {
	        var index = action._cacheIndex;
	        return index !== null && index < this._nActiveActions;
	    };
	    AnimationMixer.prototype._addInactiveAction = function (action, clipUuid, rootUuid) {
	        var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
	        if (actionsForClip === undefined) {
	            actionsForClip = {
	                knownActions: [action],
	                actionByRoot: {}
	            };
	            action._byClipCacheIndex = 0;
	            actionsByClip[clipUuid] = actionsForClip;
	        }
	        else {
	            var knownActions = actionsForClip.knownActions;
	            action._byClipCacheIndex = knownActions.length;
	            knownActions.push(action);
	        }
	        action._cacheIndex = actions.length;
	        actions.push(action);
	        actionsForClip.actionByRoot[rootUuid] = action;
	    };
	    AnimationMixer.prototype._removeInactiveAction = function (action) {
	        var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
	        lastInactiveAction._cacheIndex = cacheIndex;
	        actions[cacheIndex] = lastInactiveAction;
	        actions.pop();
	        action._cacheIndex = null;
	        var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
	        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
	        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
	        knownActionsForClip.pop();
	        action._byClipCacheIndex = null;
	        var actionByRoot = actionsForClip.actionByRoot, rootUuid = (actions._localRoot || this._root).uuid;
	        delete actionByRoot[rootUuid];
	        if (knownActionsForClip.length === 0) {
	            delete actionsByClip[clipUuid];
	        }
	        this._removeInactiveBindingsForAction(action);
	    };
	    AnimationMixer.prototype._removeInactiveBindingsForAction = function (action) {
	        var bindings = action._propertyBindings;
	        for (var i = 0, n = bindings.length; i !== n; ++i) {
	            var binding = bindings[i];
	            if (--binding.referenceCount === 0) {
	                this._removeInactiveBinding(binding);
	            }
	        }
	    };
	    AnimationMixer.prototype._lendAction = function (action) {
	        // [ active actions |  inactive actions  ]
	        // [  active actions >| inactive actions ]
	        //                 s        a
	        //                  <-swap->
	        //                 a        s
	        var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
	        action._cacheIndex = lastActiveIndex;
	        actions[lastActiveIndex] = action;
	        firstInactiveAction._cacheIndex = prevIndex;
	        actions[prevIndex] = firstInactiveAction;
	    };
	    AnimationMixer.prototype._takeBackAction = function (action) {
	        // [  active actions  | inactive actions ]
	        // [ active actions |< inactive actions  ]
	        //        a        s
	        //         <-swap->
	        //        s        a
	        var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
	        action._cacheIndex = firstInactiveIndex;
	        actions[firstInactiveIndex] = action;
	        lastActiveAction._cacheIndex = prevIndex;
	        actions[prevIndex] = lastActiveAction;
	    };
	    // Memory management for PropertyMixer objects
	    AnimationMixer.prototype._addInactiveBinding = function (binding, rootUuid, trackName) {
	        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
	        if (bindingByName === undefined) {
	            bindingByName = {};
	            bindingsByRoot[rootUuid] = bindingByName;
	        }
	        bindingByName[trackName] = binding;
	        binding._cacheIndex = bindings.length;
	        bindings.push(binding);
	    };
	    AnimationMixer.prototype._removeInactiveBinding = function (binding) {
	        var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
	        lastInactiveBinding._cacheIndex = cacheIndex;
	        bindings[cacheIndex] = lastInactiveBinding;
	        bindings.pop();
	        delete bindingByName[trackName];
	        remove_empty_map: {
	            for (var _ in bindingByName)
	                break remove_empty_map;
	            delete bindingsByRoot[rootUuid];
	        }
	    };
	    AnimationMixer.prototype._lendBinding = function (binding) {
	        var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
	        binding._cacheIndex = lastActiveIndex;
	        bindings[lastActiveIndex] = binding;
	        firstInactiveBinding._cacheIndex = prevIndex;
	        bindings[prevIndex] = firstInactiveBinding;
	    };
	    AnimationMixer.prototype._takeBackBinding = function (binding) {
	        var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
	        binding._cacheIndex = firstInactiveIndex;
	        bindings[firstInactiveIndex] = binding;
	        lastActiveBinding._cacheIndex = prevIndex;
	        bindings[prevIndex] = lastActiveBinding;
	    };
	    // Memory management of Interpolants for weight and time scale
	    AnimationMixer.prototype._lendControlInterpolant = function () {
	        var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
	        if (interpolant === undefined) {
	            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
	            interpolant.__cacheIndex = lastActiveIndex;
	            interpolants[lastActiveIndex] = interpolant;
	        }
	        return interpolant;
	    };
	    AnimationMixer.prototype._takeBackControlInterpolant = function (interpolant) {
	        var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
	        interpolant.__cacheIndex = firstInactiveIndex;
	        interpolants[firstInactiveIndex] = interpolant;
	        lastActiveInterpolant.__cacheIndex = prevIndex;
	        interpolants[prevIndex] = lastActiveInterpolant;
	    };
	    return AnimationMixer;
	}(EventDispatcher));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Uniform = /** @class */ (function () {
	    function Uniform(value) {
	        if (typeof value === 'string') {
	            console.warn('THREE.Uniform: Type parameter is no longer needed.');
	            value = arguments[1];
	        }
	        this.value = value;
	    }
	    Object.defineProperty(Uniform.prototype, "dynamic", {
	        set: function (value) {
	            console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Uniform.prototype.onUpdate = function (callback) {
	        console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
	        return this;
	    };
	    return Uniform;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */
	var Intersect = /** @class */ (function () {
	    function Intersect() {
	    }
	    return Intersect;
	}());
	var Raycaster = /** @class */ (function () {
	    function Raycaster(origin, direction, near, far) {
	        this.linePrecision = 1;
	        this.ray = new Ray(origin, direction);
	        // direction is assumed to be normalized (for accurate distance calculations)
	        this.near = near || 0;
	        this.far = far || Infinity;
	        this.params = {
	            Mesh: {},
	            Line: {},
	            LOD: {},
	            Points: { threshold: 1 },
	            Sprite: {}
	        };
	        //Object.defineProperties(this.params, {
	        //  PointCloud: {
	        //    get: function () {
	        //      console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
	        //      return this.Points;
	        //    }
	        //  }
	        //});
	    }
	    Raycaster.prototype.set = function (origin, direction) {
	        // direction is assumed to be normalized (for accurate distance calculations)
	        this.ray.set(origin, direction);
	    };
	    Raycaster.prototype.setFromCamera = function (coords, camera) {
	        if ((camera && camera instanceof PerspectiveCamera)) {
	            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
	            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
	        }
	        else if ((camera && camera instanceof OrthographicCamera)) {
	            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
	            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
	        }
	        else {
	            console.error('THREE.Raycaster: Unsupported camera type.');
	        }
	    };
	    Raycaster.prototype.intersectObject = function (object, recursive) {
	        var intersects = [];
	        intersectObject(object, this, intersects, recursive);
	        intersects.sort(ascSort);
	        return intersects;
	    };
	    Raycaster.prototype.intersectObjects = function (objects, recursive) {
	        var intersects = [];
	        if (Array.isArray(objects) === false) {
	            console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
	            return intersects;
	        }
	        for (var i = 0, l = objects.length; i < l; i++) {
	            intersectObject(objects[i], this, intersects, recursive);
	        }
	        intersects.sort(ascSort);
	        return intersects;
	    };
	    return Raycaster;
	}());
	function ascSort(a, b) {
	    return a.distance - b.distance;
	}
	function intersectObject(object, raycaster, intersects, recursive) {
	    if (object.visible === false)
	        return;
	    object.raycast(raycaster, intersects);
	    if (recursive === true) {
	        var children = object.children;
	        for (var i = 0, l = children.length; i < l; i++) {
	            intersectObject(children[i], raycaster, intersects, true);
	        }
	    }
	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	var Clock = /** @class */ (function () {
	    function Clock(autoStart) {
	        if (autoStart === void 0) { autoStart = true; }
	        this.startTime = 0;
	        this.oldTime = 0;
	        this.elapsedTime = 0;
	        this.running = false;
	        this.autoStart = autoStart;
	    }
	    Clock.prototype.start = function () {
	        this.startTime = (performance || Date).now();
	        this.oldTime = this.startTime;
	        this.elapsedTime = 0;
	        this.running = true;
	    };
	    Clock.prototype.stop = function () {
	        this.getElapsedTime();
	        this.running = false;
	    };
	    Clock.prototype.getElapsedTime = function () {
	        this.getDelta();
	        return this.elapsedTime;
	    };
	    Clock.prototype.getDelta = function () {
	        var diff = 0;
	        if (this.autoStart && !this.running) {
	            this.start();
	        }
	        if (this.running) {
	            var newTime = (performance || Date).now();
	            diff = (newTime - this.oldTime) / 1000;
	            this.oldTime = newTime;
	            this.elapsedTime += diff;
	        }
	        return diff;
	    };
	    return Clock;
	}());

	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	var Spline = /** @class */ (function () {
	    function Spline(points) {
	        this.points = points;
	    }
	    Spline.prototype.initFromArray = function (a) {
	        this.points = [];
	        for (var i = 0; i < a.length; i++) {
	            this.points[i] = { x: a[i][0], y: a[i][1], z: a[i][2] };
	        }
	    };
	    Spline.prototype.getPoint = function (k) {
	        var c = [], v3 = { x: 0, y: 0, z: 0 };
	        var point, intPoint, weight, w2, w3, pa, pb, pc, pd;
	        point = (this.points.length - 1) * k;
	        intPoint = Math.floor(point);
	        weight = point - intPoint;
	        c[0] = intPoint === 0 ? intPoint : intPoint - 1;
	        c[1] = intPoint;
	        c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
	        c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
	        pa = this.points[c[0]];
	        pb = this.points[c[1]];
	        pc = this.points[c[2]];
	        pd = this.points[c[3]];
	        w2 = weight * weight;
	        w3 = weight * w2;
	        v3.x = Spline.interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
	        v3.y = Spline.interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
	        v3.z = Spline.interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
	        return v3;
	    };
	    Spline.prototype.getControlPointsArray = function () {
	        var l = this.points.length, coords = [];
	        for (var i = 0; i < l; i++) {
	            var p = this.points[i];
	            coords[i] = [p.x, p.y, p.z];
	        }
	        return coords;
	    };
	    // approximate length by summing linear segments
	    Spline.prototype.getLength = function (nSubDivisions) {
	        if (nSubDivisions === void 0) { nSubDivisions = 100; }
	        var oldIntPoint = 0;
	        var oldPosition = new Vector3();
	        var tmpVec = new Vector3();
	        var chunkLengths = [];
	        var totalLength = 0;
	        // first point has 0 length
	        chunkLengths[0] = 0;
	        var nSamples = this.points.length * nSubDivisions;
	        oldPosition.copy(this.points[0]);
	        for (var i = 1; i < nSamples; i++) {
	            var index = i / nSamples;
	            var position = this.getPoint(index);
	            tmpVec.copy(position);
	            totalLength += tmpVec.distanceTo(oldPosition);
	            oldPosition.copy(position);
	            var point = (this.points.length - 1) * index;
	            var intPoint = Math.floor(point);
	            if (intPoint !== oldIntPoint) {
	                chunkLengths[intPoint] = totalLength;
	                oldIntPoint = intPoint;
	            }
	        }
	        // last point ends with total length
	        chunkLengths[chunkLengths.length] = totalLength;
	        return { chunks: chunkLengths, total: totalLength };
	    };
	    Spline.prototype.reparametrizeByArcLength = function (samplingCoef) {
	        var newpoints = [];
	        var tmpVec = new Vector3();
	        var sl = this.getLength();
	        newpoints.push(tmpVec.copy(this.points[0]).clone());
	        for (var i = 1; i < this.points.length; i++) {
	            //tmpVec.copy(this.points[i - 1]);
	            //linearDistance = tmpVec.distanceTo(this.points[i]);
	            var realDistance = sl.chunks[i] - sl.chunks[i - 1];
	            var sampling = Math.ceil(samplingCoef * realDistance / sl.total);
	            var indexCurrent = (i - 1) / (this.points.length - 1);
	            var indexNext = i / (this.points.length - 1);
	            for (var j = 1; j < sampling - 1; j++) {
	                var index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
	                var position = this.getPoint(index);
	                newpoints.push(tmpVec.copy(position).clone());
	            }
	            newpoints.push(tmpVec.copy(this.points[i]).clone());
	        }
	        this.points = newpoints;
	    };
	    // Catmull-Rom
	    Spline.interpolate = function (p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	    };
	    return Spline;
	}());

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The poles (phi) are at the positive and negative y axis.
	 * The equator starts at positive z.
	 */
	var Spherical = /** @class */ (function () {
	    function Spherical(radius, phi, theta) {
	        if (radius === void 0) { radius = 1.0; }
	        if (phi === void 0) { phi = 0; }
	        if (theta === void 0) { theta = 0; }
	        this.radius = radius;
	        this.phi = phi; // up / down towards top and bottom pole
	        this.theta = theta; // around the equator of the sphere
	    }
	    Spherical.prototype.set = function (radius, phi, theta) {
	        this.radius = radius;
	        this.phi = phi;
	        this.theta = theta;
	        return this;
	    };
	    Spherical.prototype.clone = function () {
	        return new this.constructor().copy(this);
	    };
	    Spherical.prototype.copy = function (other) {
	        this.radius = other.radius;
	        this.phi = other.phi;
	        this.theta = other.theta;
	        return this;
	    };
	    // restrict phi to be betwee EPS and PI-EPS
	    Spherical.prototype.makeSafe = function () {
	        var EPS = 0.000001;
	        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
	        return this;
	    };
	    Spherical.prototype.setFromVector3 = function (vec3) {
	        this.radius = vec3.length();
	        if (this.radius === 0) {
	            this.theta = 0;
	            this.phi = 0;
	        }
	        else {
	            this.theta = Math.atan2(vec3.x, vec3.z); // equator angle around y-up axis
	            this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1)); // polar angle
	        }
	        return this;
	    };
	    return Spherical;
	}());

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	var MorphBlendMesh = /** @class */ (function (_super) {
	    __extends(MorphBlendMesh, _super);
	    function MorphBlendMesh(geometry, material) {
	        var _this = _super.call(this, geometry, material) || this;
	        _this.animationsMap = {};
	        _this.animationsList = [];
	        // prepare default animation
	        // (all frames played together in 1 second)
	        var numFrames = _this.geometry.morphTargets.length;
	        var name = "__default";
	        var startFrame = 0;
	        var endFrame = numFrames - 1;
	        var fps = numFrames / 1;
	        _this.createAnimation(name, startFrame, endFrame, fps);
	        _this.setAnimationWeight(name, 1);
	        return _this;
	    }
	    MorphBlendMesh.prototype.createAnimation = function (name, start, end, fps) {
	        var animation = {
	            start: start,
	            end: end,
	            length: end - start + 1,
	            fps: fps,
	            duration: (end - start) / fps,
	            lastFrame: 0,
	            currentFrame: 0,
	            active: false,
	            time: 0,
	            direction: 1,
	            weight: 1,
	            directionBackwards: false,
	            mirroredLoop: false
	        };
	        this.animationsMap[name] = animation;
	        this.animationsList.push(animation);
	    };
	    MorphBlendMesh.prototype.autoCreateAnimations = function (fps) {
	        var pattern = /([a-z]+)_?(\d+)/i;
	        var firstAnimation, frameRanges = {};
	        var geometry = this.geometry;
	        for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
	            var morph = geometry.morphTargets[i];
	            var chunks = morph.name.match(pattern);
	            if (chunks && chunks.length > 1) {
	                var name = chunks[1];
	                if (!frameRanges[name])
	                    frameRanges[name] = { start: Infinity, end: -Infinity };
	                var range = frameRanges[name];
	                if (i < range.start)
	                    range.start = i;
	                if (i > range.end)
	                    range.end = i;
	                if (!firstAnimation)
	                    firstAnimation = name;
	            }
	        }
	        for (var name in frameRanges) {
	            var range = frameRanges[name];
	            this.createAnimation(name, range.start, range.end, fps);
	        }
	        this.firstAnimation = firstAnimation;
	    };
	    MorphBlendMesh.prototype.setAnimationDirectionForward = function (name) {
	        var animation = this.animationsMap[name];
	        if (animation) {
	            animation.direction = 1;
	            animation.directionBackwards = false;
	        }
	    };
	    MorphBlendMesh.prototype.setAnimationDirectionBackward = function (name) {
	        var animation = this.animationsMap[name];
	        if (animation) {
	            animation.direction = -1;
	            animation.directionBackwards = true;
	        }
	    };
	    MorphBlendMesh.prototype.setAnimationFPS = function (name, fps) {
	        var animation = this.animationsMap[name];
	        if (animation) {
	            animation.fps = fps;
	            animation.duration = (animation.end - animation.start) / animation.fps;
	        }
	    };
	    MorphBlendMesh.prototype.setAnimationDuration = function (name, duration) {
	        var animation = this.animationsMap[name];
	        if (animation) {
	            animation.duration = duration;
	            animation.fps = (animation.end - animation.start) / animation.duration;
	        }
	    };
	    MorphBlendMesh.prototype.setAnimationWeight = function (name, weight) {
	        var animation = this.animationsMap[name];
	        if (animation) {
	            animation.weight = weight;
	        }
	    };
	    MorphBlendMesh.prototype.setAnimationTime = function (name, time) {
	        var animation = this.animationsMap[name];
	        if (animation) {
	            animation.time = time;
	        }
	    };
	    MorphBlendMesh.prototype.getAnimationTime = function (name) {
	        var time = 0;
	        var animation = this.animationsMap[name];
	        if (animation) {
	            time = animation.time;
	        }
	        return time;
	    };
	    MorphBlendMesh.prototype.getAnimationDuration = function (name) {
	        var duration = -1;
	        var animation = this.animationsMap[name];
	        if (animation) {
	            duration = animation.duration;
	        }
	        return duration;
	    };
	    MorphBlendMesh.prototype.playAnimation = function (name) {
	        var animation = this.animationsMap[name];
	        if (animation) {
	            animation.time = 0;
	            animation.active = true;
	        }
	        else {
	            console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
	        }
	    };
	    MorphBlendMesh.prototype.stopAnimation = function (name) {
	        var animation = this.animationsMap[name];
	        if (animation) {
	            animation.active = false;
	        }
	    };
	    MorphBlendMesh.prototype.update = function (delta) {
	        for (var i = 0, il = this.animationsList.length; i < il; i++) {
	            var animation = this.animationsList[i];
	            if (!animation.active)
	                continue;
	            var frameTime = animation.duration / animation.length;
	            animation.time += animation.direction * delta;
	            if (animation.mirroredLoop) {
	                if (animation.time > animation.duration || animation.time < 0) {
	                    animation.direction *= -1;
	                    if (animation.time > animation.duration) {
	                        animation.time = animation.duration;
	                        animation.directionBackwards = true;
	                    }
	                    if (animation.time < 0) {
	                        animation.time = 0;
	                        animation.directionBackwards = false;
	                    }
	                }
	            }
	            else {
	                animation.time = animation.time % animation.duration;
	                if (animation.time < 0)
	                    animation.time += animation.duration;
	            }
	            var keyframe = animation.start + _Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
	            var weight = animation.weight;
	            if (keyframe !== animation.currentFrame) {
	                this.morphTargetInfluences[animation.lastFrame] = 0;
	                this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
	                this.morphTargetInfluences[keyframe] = 0;
	                animation.lastFrame = animation.currentFrame;
	                animation.currentFrame = keyframe;
	            }
	            var mix = (animation.time % frameTime) / frameTime;
	            if (animation.directionBackwards)
	                mix = 1 - mix;
	            if (animation.currentFrame !== animation.lastFrame) {
	                this.morphTargetInfluences[animation.currentFrame] = mix * weight;
	                this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
	            }
	            else {
	                this.morphTargetInfluences[animation.currentFrame] = weight;
	            }
	        }
	    };
	    return MorphBlendMesh;
	}(Mesh));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	var VertexNormalsHelper = /** @class */ (function (_super) {
	    __extends(VertexNormalsHelper, _super);
	    function VertexNormalsHelper(object, size, color, linewidth) {
	        if (size === void 0) { size = 1; }
	        if (color === void 0) { color = 0xff0000; }
	        if (linewidth === void 0) { linewidth = 1; }
	        var _this = this;
	        ///this.object = object;
	        ///this.size = size;
	        //
	        var nNormals = 0;
	        var objGeometry = object.geometry;
	        if ((objGeometry && objGeometry instanceof Geometry)) {
	            nNormals = objGeometry.faces.length * 3;
	        }
	        else if ((objGeometry && objGeometry instanceof BufferGeometry)) {
	            nNormals = objGeometry.attributes.normal.count;
	        }
	        //
	        var geometry = new BufferGeometry();
	        var positions = Float32Attribute(nNormals * 2 * 3, 3);
	        geometry.addAttribute('position', positions);
	        _this = _super.call(this, geometry, new LineBasicMaterial({ color: color, linewidth: linewidth })) || this;
	        //
	        _this.object = object;
	        _this.size = size;
	        _this.matrixAutoUpdate = false;
	        _this.update();
	        return _this;
	    }
	    VertexNormalsHelper.prototype.update = function () {
	        var v1 = new Vector3();
	        var v2 = new Vector3();
	        var normalMatrix = new Matrix3();
	        //return function update() {
	        var keys = ['a', 'b', 'c'];
	        this.object.updateMatrixWorld(true);
	        normalMatrix.getNormalMatrix(this.object.matrixWorld);
	        var matrixWorld = this.object.matrixWorld;
	        var position = this.geometry.attributes.position;
	        //
	        var objGeometry = this.object.geometry;
	        if ((objGeometry && objGeometry instanceof Geometry)) {
	            var vertices = objGeometry.vertices;
	            var faces = objGeometry.faces;
	            var idx = 0;
	            for (var i = 0, l = faces.length; i < l; i++) {
	                var face = faces[i];
	                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
	                    var vertex = vertices[face[keys[j]]];
	                    var normal = face.vertexNormals[j];
	                    v1.copy(vertex).applyMatrix4(matrixWorld);
	                    v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
	                    position.setXYZ(idx, v1.x, v1.y, v1.z);
	                    idx = idx + 1;
	                    position.setXYZ(idx, v2.x, v2.y, v2.z);
	                    idx = idx + 1;
	                }
	            }
	        }
	        else if ((objGeometry && objGeometry instanceof BufferGeometry)) {
	            var objPos = objGeometry.attributes.position;
	            var objNorm = objGeometry.attributes.normal;
	            var idx = 0;
	            // for simplicity, ignore index and drawcalls, and render every normal
	            for (var j = 0, jl = objPos.count; j < jl; j++) {
	                v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
	                v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
	                v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
	                position.setXYZ(idx, v1.x, v1.y, v1.z);
	                idx = idx + 1;
	                position.setXYZ(idx, v2.x, v2.y, v2.z);
	                idx = idx + 1;
	            }
	        }
	        position.needsUpdate = true;
	        return this;
	        //};
	    };
	    return VertexNormalsHelper;
	}(LineSegments));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	var SpotLightHelper = /** @class */ (function (_super) {
	    __extends(SpotLightHelper, _super);
	    function SpotLightHelper(light) {
	        var _this = _super.call(this) || this;
	        _this.light = light;
	        _this.light.updateMatrixWorld();
	        _this.matrix = light.matrixWorld;
	        _this.matrixAutoUpdate = false;
	        var geometry = new BufferGeometry();
	        var positions = [
	            0, 0, 0, 0, 0, 1,
	            0, 0, 0, 1, 0, 1,
	            0, 0, 0, -1, 0, 1,
	            0, 0, 0, 0, 1, 1,
	            0, 0, 0, 0, -1, 1
	        ];
	        for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
	            var p1 = (i / l) * Math.PI * 2;
	            var p2 = (j / l) * Math.PI * 2;
	            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
	        }
	        geometry.addAttribute('position', Float32Attribute(positions, 3));
	        var material = new LineBasicMaterial({ fog: false });
	        _this.cone = new LineSegments(geometry, material);
	        _this.add(_this.cone);
	        _this.update();
	        return _this;
	    }
	    SpotLightHelper.prototype.dispose = function () {
	        this.cone.geometry.dispose();
	        this.cone.material.dispose();
	    };
	    SpotLightHelper.prototype.update = function () {
	        var vector = new Vector3();
	        var vector2 = new Vector3();
	        //return function update() {
	        var coneLength = this.light.distance ? this.light.distance : 1000;
	        var coneWidth = coneLength * Math.tan(this.light.angle);
	        this.cone.scale.set(coneWidth, coneWidth, coneLength);
	        vector.setFromMatrixPosition(this.light.matrixWorld);
	        vector2.setFromMatrixPosition(this.light.target.matrixWorld);
	        this.cone.lookAt(vector2.sub(vector));
	        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
	        //};
	    };
	    return SpotLightHelper;
	}(Object3D));

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */
	var SkeletonHelper = /** @class */ (function (_super) {
	    __extends(SkeletonHelper, _super);
	    function SkeletonHelper(object) {
	        var _this = this;
	        var bones = SkeletonHelper.getBoneList(object);
	        var geometry = new Geometry();
	        for (var i = 0; i < bones.length; i++) {
	            var bone = bones[i];
	            if ((bone.parent && bone.parent instanceof Bone)) {
	                geometry.vertices.push(new Vector3());
	                geometry.vertices.push(new Vector3());
	                geometry.colors.push(new Color(0, 0, 1));
	                geometry.colors.push(new Color(0, 1, 0));
	            }
	        }
	        geometry.dynamic = true;
	        var material = new LineBasicMaterial({ vertexColors: exports.ColorsMode.Vertex, depthTest: false, depthWrite: false, transparent: true });
	        _this = _super.call(this, geometry, material) || this;
	        _this.bones = bones;
	        _this.root = object;
	        _this.matrix = object.matrixWorld;
	        _this.matrixAutoUpdate = false;
	        _this.update();
	        return _this;
	    }
	    SkeletonHelper.getBoneList = function (object) {
	        var boneList = [];
	        if ((object && object instanceof Bone)) {
	            boneList.push(object);
	        }
	        for (var i = 0; i < object.children.length; i++) {
	            boneList.push.apply(boneList, SkeletonHelper.getBoneList(object.children[i]));
	        }
	        return boneList;
	    };
	    SkeletonHelper.prototype.getBonesList = function (object) {
	        return SkeletonHelper.getBoneList(object);
	    };
	    SkeletonHelper.prototype.update = function () {
	        var geometry = this.geometry;
	        if (geometry instanceof Geometry) {
	            var matrixWorldInv = new Matrix4().getInverse(this.root.matrixWorld);
	            var boneMatrix = new Matrix4();
	            var j = 0;
	            for (var i = 0; i < this.bones.length; i++) {
	                var bone = this.bones[i];
	                if ((bone.parent && bone.parent instanceof Bone)) {
	                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
	                    geometry.vertices[j].setFromMatrixPosition(boneMatrix);
	                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
	                    geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
	                    j += 2;
	                }
	            }
	            geometry.verticesNeedUpdate = true;
	            geometry.computeBoundingSphere();
	        }
	    };
	    return SkeletonHelper;
	}(LineSegments));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	var PointLightHelper = /** @class */ (function (_super) {
	    __extends(PointLightHelper, _super);
	    function PointLightHelper(light, sphereSize) {
	        var _this = this;
	        light.updateMatrixWorld();
	        var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
	        var material = new MeshBasicMaterial({ wireframe: true, fog: false });
	        material.color.copy(light.color).multiplyScalar(light.intensity);
	        _this = _super.call(this, geometry, material) || this;
	        _this.light = light;
	        _this.matrix = _this.light.matrixWorld;
	        _this.matrixAutoUpdate = false;
	        return _this;
	        /*
	        let distanceGeometry = new THREE.IcosahedronGeometry(1, 2);
	        let distanceMaterial = new THREE.MeshBasicMaterial({ color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true });
	        this.lightSphere = new THREE.Mesh(bulbGeometry, bulbMaterial);
	        this.lightDistance = new THREE.Mesh(distanceGeometry, distanceMaterial);
	        let d = light.distance;
	        if (d === 0.0) {
	          this.lightDistance.visible = false;
	        } else {
	          this.lightDistance.scale.set(d, d, d);
	        }
	        this.add(this.lightDistance);
	        */
	    }
	    PointLightHelper.prototype.dispose = function () {
	        this.geometry.dispose();
	        this.material.dispose();
	    };
	    PointLightHelper.prototype.update = function () {
	        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
	        /*
	        let d = this.light.distance;
	        if (d === 0.0) {
	          this.lightDistance.visible = false;
	        } else {
	          this.lightDistance.visible = true;
	          this.lightDistance.scale.set(d, d, d);
	        }
	        */
	    };
	    return PointLightHelper;
	}(Mesh));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	var HemisphereLightHelper = /** @class */ (function (_super) {
	    __extends(HemisphereLightHelper, _super);
	    function HemisphereLightHelper(light, sphereSize) {
	        var _this = _super.call(this) || this;
	        _this.light = light;
	        _this.light.updateMatrixWorld();
	        _this.matrix = light.matrixWorld;
	        _this.matrixAutoUpdate = false;
	        _this.colors = [new Color(), new Color()];
	        var geometry = new SphereGeometry(sphereSize, 4, 2);
	        geometry.rotateX(-Math.PI / 2);
	        for (var i = 0, il = 8; i < il; i++) {
	            geometry.faces[i].color = _this.colors[i < 4 ? 0 : 1];
	        }
	        var material = new MeshBasicMaterial({ vertexColors: exports.ColorsMode.Face, wireframe: true });
	        _this.lightSphere = new Mesh(geometry, material);
	        _this.add(_this.lightSphere);
	        _this.update();
	        return _this;
	    }
	    HemisphereLightHelper.prototype.dispose = function () {
	        this.lightSphere.geometry.dispose();
	        this.lightSphere.material.dispose();
	    };
	    HemisphereLightHelper.prototype.update = function () {
	        var vector = new Vector3();
	        //return function update() {
	        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
	        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
	        this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
	        this.lightSphere.geometry.colorsNeedUpdate = true;
	        //};
	    };
	    return HemisphereLightHelper;
	}(Object3D));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var GridHelper = /** @class */ (function (_super) {
	    __extends(GridHelper, _super);
	    function GridHelper(size, divisions, color1, color2) {
	        if (divisions === void 0) { divisions = 1; }
	        if (color1 === void 0) { color1 = 0x444444; }
	        if (color2 === void 0) { color2 = 0x888888; }
	        var _this = this;
	        var _color1 = new Color(color1);
	        var _color2 = new Color(color2);
	        var center = divisions / 2;
	        var step = (size * 2) / divisions;
	        var vertices = [], colors = [];
	        for (var i = 0, j = 0, k = -size; i <= divisions; i++, k += step) {
	            vertices.push(-size, 0, k, size, 0, k);
	            vertices.push(k, 0, -size, k, 0, size);
	            var color = i === center ? _color1 : _color2;
	            color.toArray(colors, j);
	            j += 3;
	            color.toArray(colors, j);
	            j += 3;
	            color.toArray(colors, j);
	            j += 3;
	            color.toArray(colors, j);
	            j += 3;
	        }
	        var geometry = new BufferGeometry();
	        geometry.addAttribute('position', Float32Attribute(vertices, 3));
	        geometry.addAttribute('color', Float32Attribute(colors, 3));
	        var material = new LineBasicMaterial({ vertexColors: exports.ColorsMode.Vertex });
	        _this = _super.call(this, geometry, material) || this;
	        return _this;
	    }
	    GridHelper.prototype.setColors = function () {
	        console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
	    };
	    return GridHelper;
	}(LineSegments));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	var FaceNormalsHelper = /** @class */ (function (_super) {
	    __extends(FaceNormalsHelper, _super);
	    function FaceNormalsHelper(object, size, color, linewidth) {
	        if (size === void 0) { size = 1; }
	        if (color === void 0) { color = 0xffff00; }
	        if (linewidth === void 0) { linewidth = 1; }
	        var _this = this;
	        // FaceNormalsHelper only supports THREE.Geometry
	        ///this.object = object;
	        ///this.size = (size !== undefined) ? size : 1;
	        //
	        var nNormals = 0;
	        var objGeometry = object.geometry;
	        if ((objGeometry && objGeometry instanceof Geometry)) {
	            nNormals = objGeometry.faces.length;
	        }
	        else {
	            console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
	        }
	        //
	        var geometry = new BufferGeometry();
	        var positions = Float32Attribute(nNormals * 2 * 3, 3);
	        geometry.addAttribute('position', positions);
	        _this = _super.call(this, geometry, new LineBasicMaterial({ color: color, linewidth: linewidth })) || this;
	        //
	        _this.object = object;
	        _this.size = size;
	        _this.matrixAutoUpdate = false;
	        _this.update();
	        return _this;
	    }
	    FaceNormalsHelper.prototype.update = function () {
	        var v1 = new Vector3();
	        var v2 = new Vector3();
	        var normalMatrix = new Matrix3();
	        //return function update() {
	        this.object.updateMatrixWorld(true);
	        normalMatrix.getNormalMatrix(this.object.matrixWorld);
	        var matrixWorld = this.object.matrixWorld;
	        var position = this.geometry.attributes.position;
	        //
	        var objGeometry = this.object.geometry;
	        var vertices = objGeometry.vertices;
	        var faces = objGeometry.faces;
	        var idx = 0;
	        for (var i = 0, l = faces.length; i < l; i++) {
	            var face = faces[i];
	            var normal = face.normal;
	            v1.copy(vertices[face.a])
	                .add(vertices[face.b])
	                .add(vertices[face.c])
	                .divideScalar(3)
	                .applyMatrix4(matrixWorld);
	            v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
	            position.setXYZ(idx, v1.x, v1.y, v1.z);
	            idx = idx + 1;
	            position.setXYZ(idx, v2.x, v2.y, v2.z);
	            idx = idx + 1;
	        }
	        position.needsUpdate = true;
	        return this;
	        //};
	    };
	    return FaceNormalsHelper;
	}(LineSegments));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	var DirectionalLightHelper = /** @class */ (function (_super) {
	    __extends(DirectionalLightHelper, _super);
	    function DirectionalLightHelper(light, size) {
	        if (size === void 0) { size = 1; }
	        var _this = _super.call(this) || this;
	        _this.light = light;
	        _this.light.updateMatrixWorld();
	        _this.matrix = light.matrixWorld;
	        _this.matrixAutoUpdate = false;
	        var geometry = new BufferGeometry();
	        geometry.addAttribute('position', Float32Attribute([
	            -size, size, 0,
	            size, size, 0,
	            size, -size, 0,
	            -size, -size, 0,
	            -size, size, 0
	        ], 3));
	        var material = new LineBasicMaterial({ fog: false });
	        _this.add(new Line(geometry, material));
	        geometry = new BufferGeometry();
	        geometry.addAttribute('position', Float32Attribute([0, 0, 0, 0, 0, 1], 3));
	        _this.add(new Line(geometry, material));
	        _this.update();
	        return _this;
	    }
	    DirectionalLightHelper.prototype.dispose = function () {
	        var lightPlane = this.children[0];
	        var targetLine = this.children[1];
	        lightPlane.geometry.dispose();
	        lightPlane.material.dispose();
	        targetLine.geometry.dispose();
	        targetLine.material.dispose();
	    };
	    DirectionalLightHelper.prototype.update = function () {
	        var v1 = new Vector3();
	        var v2 = new Vector3();
	        var v3 = new Vector3();
	        //return function update() {
	        v1.setFromMatrixPosition(this.light.matrixWorld);
	        v2.setFromMatrixPosition(this.light.target.matrixWorld);
	        v3.subVectors(v2, v1);
	        var lightPlane = this.children[0];
	        var targetLine = this.children[1];
	        lightPlane.lookAt(v3);
	        lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
	        targetLine.lookAt(v3);
	        targetLine.scale.z = v3.length();
	        //};
	    };
	    return DirectionalLightHelper;
	}(Object3D));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *  - shows frustum, line of sight and up of the camera
	 *  - suitable for fast updates
	 *   - based on frustum visualization in lightgl.js shadowmap example
	 *    http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */
	var CameraHelper = /** @class */ (function (_super) {
	    __extends(CameraHelper, _super);
	    function CameraHelper(camera) {
	        var _this = this;
	        var geometry = new Geometry();
	        var material = new LineBasicMaterial({ color: 0xffffff, vertexColors: exports.ColorsMode.Face });
	        var pointMap = {};
	        // colors
	        var hexFrustum = 0xffaa00;
	        var hexCone = 0xff0000;
	        var hexUp = 0x00aaff;
	        var hexTarget = 0xffffff;
	        var hexCross = 0x333333;
	        // near
	        addLine("n1", "n2", hexFrustum);
	        addLine("n2", "n4", hexFrustum);
	        addLine("n4", "n3", hexFrustum);
	        addLine("n3", "n1", hexFrustum);
	        // far
	        addLine("f1", "f2", hexFrustum);
	        addLine("f2", "f4", hexFrustum);
	        addLine("f4", "f3", hexFrustum);
	        addLine("f3", "f1", hexFrustum);
	        // sides
	        addLine("n1", "f1", hexFrustum);
	        addLine("n2", "f2", hexFrustum);
	        addLine("n3", "f3", hexFrustum);
	        addLine("n4", "f4", hexFrustum);
	        // cone
	        addLine("p", "n1", hexCone);
	        addLine("p", "n2", hexCone);
	        addLine("p", "n3", hexCone);
	        addLine("p", "n4", hexCone);
	        // up
	        addLine("u1", "u2", hexUp);
	        addLine("u2", "u3", hexUp);
	        addLine("u3", "u1", hexUp);
	        // target
	        addLine("c", "t", hexTarget);
	        addLine("p", "c", hexCross);
	        // cross
	        addLine("cn1", "cn2", hexCross);
	        addLine("cn3", "cn4", hexCross);
	        addLine("cf1", "cf2", hexCross);
	        addLine("cf3", "cf4", hexCross);
	        function addLine(a, b, hex) {
	            addPoint(a, hex);
	            addPoint(b, hex);
	        }
	        function addPoint(id, hex) {
	            geometry.vertices.push(new Vector3());
	            geometry.colors.push(new Color(hex));
	            if (pointMap[id] === undefined) {
	                pointMap[id] = [];
	            }
	            pointMap[id].push(geometry.vertices.length - 1);
	        }
	        _this = _super.call(this, geometry, material) || this;
	        _this.camera = camera;
	        _this.camera.updateProjectionMatrix();
	        _this.matrix = camera.matrixWorld;
	        _this.matrixAutoUpdate = false;
	        _this.pointMap = pointMap;
	        _this.update();
	        return _this;
	    }
	    CameraHelper.prototype.update = function () {
	        var geometry, pointMap;
	        var vector = new Vector3();
	        var camera = new Camera();
	        function setPoint(point, x, y, z) {
	            vector.set(x, y, z).unproject(camera);
	            var points = pointMap[point];
	            if (points !== undefined) {
	                for (var i = 0, il = points.length; i < il; i++) {
	                    geometry.vertices[points[i]].copy(vector);
	                }
	            }
	        }
	        //return function update() {
	        geometry = this.geometry;
	        pointMap = this.pointMap;
	        var w = 1, h = 1;
	        // we need just camera projection matrix
	        // world matrix must be identity
	        camera.projectionMatrix.copy(this.camera.projectionMatrix);
	        // center / target
	        setPoint("c", 0, 0, -1);
	        setPoint("t", 0, 0, 1);
	        // near
	        setPoint("n1", -w, -h, -1);
	        setPoint("n2", w, -h, -1);
	        setPoint("n3", -w, h, -1);
	        setPoint("n4", w, h, -1);
	        // far
	        setPoint("f1", -w, -h, 1);
	        setPoint("f2", w, -h, 1);
	        setPoint("f3", -w, h, 1);
	        setPoint("f4", w, h, 1);
	        // up
	        setPoint("u1", w * 0.7, h * 1.1, -1);
	        setPoint("u2", -w * 0.7, h * 1.1, -1);
	        setPoint("u3", 0, h * 2, -1);
	        // cross
	        setPoint("cf1", -w, 0, 1);
	        setPoint("cf2", w, 0, 1);
	        setPoint("cf3", 0, -h, 1);
	        setPoint("cf4", 0, h, 1);
	        setPoint("cn1", -w, 0, -1);
	        setPoint("cn2", w, 0, -1);
	        setPoint("cn3", 0, -h, -1);
	        setPoint("cn4", 0, h, -1);
	        geometry.verticesNeedUpdate = true;
	        //};
	    };
	    return CameraHelper;
	}(LineSegments));

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	// a helper to show the world-axis-aligned bounding box for an object
	var BoundingBoxHelper = /** @class */ (function (_super) {
	    __extends(BoundingBoxHelper, _super);
	    function BoundingBoxHelper(object, color) {
	        if (color === void 0) { color = 0x888888; }
	        var _this = _super.call(this, new BoxGeometry(1, 1, 1), new MeshBasicMaterial({ color: color, wireframe: true })) || this;
	        _this.object = object;
	        _this.box = new Box3();
	        return _this;
	    }
	    BoundingBoxHelper.prototype.update = function () {
	        this.box.setFromObject(this.object);
	        this.box.getSize(this.scale);
	        this.box.getCenter(this.position);
	    };
	    return BoundingBoxHelper;
	}(Mesh));

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var BoxHelper = /** @class */ (function (_super) {
	    __extends(BoxHelper, _super);
	    function BoxHelper(object, color) {
	        if (color === void 0) { color = 0xffff00; }
	        var _this = this;
	        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
	        var positions = new Float32Array(8 * 3);
	        var geometry = new BufferGeometry();
	        geometry.setIndex(new BufferAttribute(indices, 1));
	        geometry.addAttribute('position', new BufferAttribute(positions, 3));
	        _this = _super.call(this, geometry, new LineBasicMaterial({ color: color })) || this;
	        if (object !== undefined) {
	            _this.update(object);
	        }
	        return _this;
	    }
	    BoxHelper.prototype.update = function (object) {
	        var box = new Box3();
	        //return function update(object) {
	        if ((object && object instanceof Box3)) {
	            box.copy(object);
	        }
	        else {
	            box.setFromObject(object);
	        }
	        if (box.isEmpty())
	            return;
	        var min = box.min;
	        var max = box.max;
	        /*
	          5____4
	        1/___0/|
	        | 6__|_7
	        2/___3/
	        0: max.x, max.y, max.z
	        1: min.x, max.y, max.z
	        2: min.x, min.y, max.z
	        3: max.x, min.y, max.z
	        4: max.x, max.y, min.z
	        5: min.x, max.y, min.z
	        6: min.x, min.y, min.z
	        7: max.x, min.y, min.z
	        */
	        var position = this.geometry.attributes.position;
	        var array = position.array;
	        array[0] = max.x;
	        array[1] = max.y;
	        array[2] = max.z;
	        array[3] = min.x;
	        array[4] = max.y;
	        array[5] = max.z;
	        array[6] = min.x;
	        array[7] = min.y;
	        array[8] = max.z;
	        array[9] = max.x;
	        array[10] = min.y;
	        array[11] = max.z;
	        array[12] = max.x;
	        array[13] = max.y;
	        array[14] = min.z;
	        array[15] = min.x;
	        array[16] = max.y;
	        array[17] = min.z;
	        array[18] = min.x;
	        array[19] = min.y;
	        array[20] = min.z;
	        array[21] = max.x;
	        array[22] = min.y;
	        array[23] = min.z;
	        position.needsUpdate = true;
	        this.geometry.computeBoundingSphere();
	        //};
	    };
	    return BoxHelper;
	}(LineSegments));

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */
	var lineGeometry = new BufferGeometry();
	lineGeometry.addAttribute('position', Float32Attribute([0, 0, 0, 0, 1, 0], 3));
	var coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
	coneGeometry.translate(0, -0.5, 0);
	var ArrowHelper = /** @class */ (function (_super) {
	    __extends(ArrowHelper, _super);
	    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
	        var _this = 
	        // dir is assumed to be normalized
	        _super.call(this) || this;
	        if (color === undefined)
	            color = 0xffff00;
	        if (length === undefined)
	            length = 1;
	        if (headLength === undefined)
	            headLength = 0.2 * length;
	        if (headWidth === undefined)
	            headWidth = 0.2 * headLength;
	        _this.position.copy(origin);
	        _this.line = new Line(lineGeometry, new LineBasicMaterial({ color: color }));
	        _this.line.matrixAutoUpdate = false;
	        _this.add(_this.line);
	        _this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({ color: color }));
	        _this.cone.matrixAutoUpdate = false;
	        _this.add(_this.cone);
	        _this.setDirection(dir);
	        _this.setLength(length, headLength, headWidth);
	        return _this;
	    }
	    ArrowHelper.prototype.setDirection = function (dir) {
	        var axis = new Vector3();
	        //return function setDirection(dir) {
	        // dir is assumed to be normalized
	        if (dir.y > 0.99999) {
	            this.quaternion.set(0, 0, 0, 1);
	        }
	        else if (dir.y < -0.99999) {
	            this.quaternion.set(1, 0, 0, 0);
	        }
	        else {
	            axis.set(dir.z, 0, -dir.x).normalize();
	            var radians = Math.acos(dir.y);
	            this.quaternion.setFromAxisAngle(axis, radians);
	        }
	        //};
	    };
	    ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
	        if (headLength === undefined)
	            headLength = 0.2 * length;
	        if (headWidth === undefined)
	            headWidth = 0.2 * headLength;
	        this.line.scale.set(1, Math.max(0, length - headLength), 1);
	        this.line.updateMatrix();
	        this.cone.scale.set(headWidth, headLength, headWidth);
	        this.cone.position.y = length;
	        this.cone.updateMatrix();
	    };
	    ArrowHelper.prototype.setColor = function (color) {
	        this.line.material.color.copy(color);
	        this.cone.material.color.copy(color);
	    };
	    return ArrowHelper;
	}(Object3D));

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */
	var AxisHelper = /** @class */ (function (_super) {
	    __extends(AxisHelper, _super);
	    function AxisHelper(size) {
	        if (size === void 0) { size = 1; }
	        var _this = this;
	        var vertices = new Float32Array([
	            0, 0, 0, size, 0, 0,
	            0, 0, 0, 0, size, 0,
	            0, 0, 0, 0, 0, size
	        ]);
	        var colors = new Float32Array([
	            1, 0, 0, 1, 0.6, 0,
	            0, 1, 0, 0.6, 1, 0,
	            0, 0, 1, 0, 0.6, 1
	        ]);
	        var geometry = new BufferGeometry();
	        geometry.addAttribute('position', new BufferAttribute(vertices, 3));
	        geometry.addAttribute('color', new BufferAttribute(colors, 3));
	        var material = new LineBasicMaterial({ vertexColors: exports.ColorsMode.Vertex });
	        _this = _super.call(this, geometry, material) || this;
	        return _this;
	    }
	    return AxisHelper;
	}(LineSegments));

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */
	var CatmullRomCurve3 = /** @class */ (function (_super) {
	    __extends(CatmullRomCurve3, _super);
	    function CatmullRomCurve3(p) {
	        if (p === void 0) { p = []; }
	        var _this = _super.call(this) || this;
	        _this.closed = false;
	        _this.tension = 0.5;
	        _this.points = p;
	        _this.closed = false;
	        return _this;
	    }
	    CatmullRomCurve3.prototype.getPoint = function (t) {
	        var tmp = new Vector3();
	        var px = new CubicPoly();
	        var py = new CubicPoly();
	        var pz = new CubicPoly();
	        var points = this.points;
	        var l = points.length;
	        if (l < 2)
	            console.log('duh, you need at least 2 points');
	        var point = (l - (this.closed ? 0 : 1)) * t;
	        var intPoint = Math.floor(point);
	        var weight = point - intPoint;
	        if (this.closed) {
	            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
	        }
	        else if (weight === 0 && intPoint === l - 1) {
	            intPoint = l - 2;
	            weight = 1;
	        }
	        var p0, p1, p2, p3; // 4 points
	        if (this.closed || intPoint > 0) {
	            p0 = points[(intPoint - 1) % l];
	        }
	        else {
	            // extrapolate first point
	            tmp.subVectors(points[0], points[1]).add(points[0]);
	            p0 = tmp;
	        }
	        p1 = points[intPoint % l];
	        p2 = points[(intPoint + 1) % l];
	        if (this.closed || intPoint + 2 < l) {
	            p3 = points[(intPoint + 2) % l];
	        }
	        else {
	            // extrapolate last point
	            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
	            p3 = tmp;
	        }
	        if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {
	            // init Centripetal / Chordal Catmull-Rom
	            var pow = this.type === 'chordal' ? 0.5 : 0.25;
	            var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
	            var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
	            var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
	            // safety check for repeated points
	            if (dt1 < 1e-4)
	                dt1 = 1.0;
	            if (dt0 < 1e-4)
	                dt0 = dt1;
	            if (dt2 < 1e-4)
	                dt2 = dt1;
	            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
	            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
	            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
	        }
	        else if (this.type === 'catmullrom') {
	            var tension = this.tension;
	            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
	            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
	            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
	        }
	        var v = new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
	        return v;
	    };
	    return CatmullRomCurve3;
	}(Curve));
	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM
	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/
	var CubicPoly = /** @class */ (function () {
	    function CubicPoly() {
	    }
	    /*
	     * Compute coefficients for a cubic polynomial
	     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	     * such that
	     *   p(0) = x0, p(1) = x1
	     *  and
	     *   p'(0) = t0, p'(1) = t1.
	     */
	    CubicPoly.prototype.init = function (x0, x1, t0, t1) {
	        this.c0 = x0;
	        this.c1 = t0;
	        this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
	        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
	    };
	    CubicPoly.prototype.initNonuniformCatmullRom = function (x0, x1, x2, x3, dt0, dt1, dt2) {
	        // compute tangents when parameterized in [t1,t2]
	        var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
	        var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
	        // rescale tangents for parametrization in [0,1]
	        t1 *= dt1;
	        t2 *= dt1;
	        // initCubicPoly
	        this.init(x1, x2, t1, t2);
	    };
	    // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
	    CubicPoly.prototype.initCatmullRom = function (x0, x1, x2, x3, tension) {
	        this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
	    };
	    CubicPoly.prototype.calc = function (t) {
	        var t2 = t * t;
	        var t3 = t2 * t;
	        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
	    };
	    return CubicPoly;
	}());

	/**************************************************************
	 *  Closed Spline 3D curve
	 **************************************************************/
	var ClosedSplineCurve3 = /** @class */ (function (_super) {
	    __extends(ClosedSplineCurve3, _super);
	    function ClosedSplineCurve3(points) {
	        var _this = this;
	        console.warn('THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.');
	        _this = _super.call(this, points) || this;
	        _this.type = 'catmullrom';
	        _this.closed = true;
	        return _this;
	    }
	    return ClosedSplineCurve3;
	}(CatmullRomCurve3));

	/**************************************************************
	 *  Spline 3D curve
	 **************************************************************/
	var SplineCurve3 = /** @class */ (function (_super) {
	    __extends(SplineCurve3, _super);
	    function SplineCurve3(points /* array of Vector3 */) {
	        if (points === void 0) { points = []; } /* array of Vector3 */
	        var _this = _super.call(this) || this;
	        console.warn('THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3');
	        _this.points = points;
	        return _this;
	    }
	    SplineCurve3.prototype.getPoint = function (t) {
	        var points = this.points;
	        var point = (points.length - 1) * t;
	        var intPoint = Math.floor(point);
	        var weight = point - intPoint;
	        var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
	        var point1 = points[intPoint];
	        var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
	        var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
	        var interpolate = CurveUtils.interpolate;
	        return new Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));
	    };
	    return SplineCurve3;
	}(Curve));

	/**************************************************************
	 *  Cubic Bezier 3D curve
	 **************************************************************/
	var CubicBezierCurve3 = /** @class */ (function (_super) {
	    __extends(CubicBezierCurve3, _super);
	    function CubicBezierCurve3(v0, v1, v2, v3) {
	        var _this = _super.call(this) || this;
	        _this.v0 = v0;
	        _this.v1 = v1;
	        _this.v2 = v2;
	        _this.v3 = v3;
	        return _this;
	    }
	    CubicBezierCurve3.prototype.getPoint = function (t) {
	        var b3 = ShapeUtils.b3;
	        return new Vector3(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
	    };
	    return CubicBezierCurve3;
	}(Curve));

	/**************************************************************
	 *  Quadratic Bezier 3D curve
	 **************************************************************/
	var QuadraticBezierCurve3 = /** @class */ (function (_super) {
	    __extends(QuadraticBezierCurve3, _super);
	    function QuadraticBezierCurve3(v0, v1, v2) {
	        var _this = _super.call(this) || this;
	        _this.v0 = v0;
	        _this.v1 = v1;
	        _this.v2 = v2;
	        return _this;
	    }
	    QuadraticBezierCurve3.prototype.getPoint = function (t) {
	        var b2 = ShapeUtils.b2;
	        return new Vector3(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y), b2(t, this.v0.z, this.v1.z, this.v2.z));
	    };
	    return QuadraticBezierCurve3;
	}(Curve));

	/**************************************************************
	 *  Line3D
	 **************************************************************/
	var LineCurve3 = /** @class */ (function (_super) {
	    __extends(LineCurve3, _super);
	    function LineCurve3(v1, v2) {
	        var _this = _super.call(this) || this;
	        _this.v1 = v1;
	        _this.v2 = v2;
	        return _this;
	    }
	    LineCurve3.prototype.getPoint = function (t) {
	        if (t === 1) {
	            return this.v2.clone();
	        }
	        var vector = new Vector3();
	        vector.subVectors(this.v2, this.v1); // diff
	        vector.multiplyScalar(t);
	        vector.add(this.v1);
	        return vector;
	    };
	    return LineCurve3;
	}(Curve));

	/**************************************************************
	 *  Arc curve
	 **************************************************************/
	var ArcCurve = /** @class */ (function (_super) {
	    __extends(ArcCurve, _super);
	    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
	        return _super.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise) || this;
	    }
	    return ArcCurve;
	}(EllipseCurve));

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	var SceneUtils = /** @class */ (function () {
	    function SceneUtils() {
	    }
	    SceneUtils.createMultiMaterialObject = function (geometry, materials) {
	        var group = new Group();
	        for (var i = 0, l = materials.length; i < l; i++) {
	            group.add(new Mesh(geometry, materials[i]));
	        }
	        return group;
	    };
	    SceneUtils.detach = function (child, parent, scene) {
	        child.applyMatrix(parent.matrixWorld);
	        parent.remove(child);
	        scene.add(child);
	    };
	    SceneUtils.attach = function (child, scene, parent) {
	        var matrixWorldInverse = new Matrix4();
	        matrixWorldInverse.getInverse(parent.matrixWorld);
	        child.applyMatrix(matrixWorldInverse);
	        scene.remove(child);
	        parent.add(child);
	    };
	    return SceneUtils;
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	var Face4 = /** @class */ (function (_super) {
	    __extends(Face4, _super);
	    function Face4(a, b, c, d, normal, color, materialIndex) {
	        var _this = this;
	        console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
	        _this = _super.call(this, a, b, c, normal, color, materialIndex) || this;
	        return _this;
	    }
	    return Face4;
	}(Face3));
	var LineStrip = 0;
	var LinePieces = 1;
	var PointCloud = /** @class */ (function (_super) {
	    __extends(PointCloud, _super);
	    function PointCloud(geometry, material) {
	        var _this = this;
	        console.warn("THREE.PointCloud has been renamed to THREE.Points.");
	        _this = _super.call(this, geometry, material) || this;
	        return _this;
	    }
	    return PointCloud;
	}(Points));
	var ParticleSystem = /** @class */ (function (_super) {
	    __extends(ParticleSystem, _super);
	    function ParticleSystem(geometry, material) {
	        var _this = this;
	        console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
	        _this = _super.call(this, geometry, material) || this;
	        return _this;
	    }
	    return ParticleSystem;
	}(Points));
	var PointCloudMaterial = /** @class */ (function (_super) {
	    __extends(PointCloudMaterial, _super);
	    function PointCloudMaterial(parameters) {
	        var _this = this;
	        console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
	        _this = _super.call(this, parameters) || this;
	        return _this;
	    }
	    return PointCloudMaterial;
	}(PointsMaterial));
	var ParticleBasicMaterial = /** @class */ (function (_super) {
	    __extends(ParticleBasicMaterial, _super);
	    function ParticleBasicMaterial(parameters) {
	        var _this = this;
	        console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
	        _this = _super.call(this, parameters) || this;
	        return _this;
	    }
	    return ParticleBasicMaterial;
	}(PointsMaterial));
	var ParticleSystemMaterial = /** @class */ (function (_super) {
	    __extends(ParticleSystemMaterial, _super);
	    function ParticleSystemMaterial(parameters) {
	        var _this = this;
	        console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
	        _this = _super.call(this, parameters) || this;
	        return _this;
	    }
	    return ParticleSystemMaterial;
	}(PointsMaterial));
	var Vertex = /** @class */ (function (_super) {
	    __extends(Vertex, _super);
	    function Vertex(x, y, z) {
	        var _this = this;
	        console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
	        _this = _super.call(this, x, y, z) || this;
	        return _this;
	    }
	    return Vertex;
	}(Vector3));
	//
	var EdgesHelper = /** @class */ (function (_super) {
	    __extends(EdgesHelper, _super);
	    function EdgesHelper(object, hex) {
	        if (hex === void 0) { hex = 0xffffff; }
	        var _this = this;
	        console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
	        _this = _super.call(this, new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex })) || this;
	        return _this;
	    }
	    return EdgesHelper;
	}(LineSegments));
	var WireframeHelper = /** @class */ (function (_super) {
	    __extends(WireframeHelper, _super);
	    function WireframeHelper(object, hex) {
	        if (hex === void 0) { hex = 0xffffff; }
	        var _this = this;
	        console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
	        _this = _super.call(this, new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex })) || this;
	        return _this;
	    }
	    return WireframeHelper;
	}(LineSegments));
	//
	var GeometryUtils = /** @class */ (function () {
	    function GeometryUtils() {
	    }
	    GeometryUtils.merge = function (geometry1, geometry2, materialIndexOffset) {
	        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge(geometry2, matrix, materialIndexOffset) instead.");
	        var matrix;
	        if (geometry2 instanceof Mesh) {
	            geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	            matrix = geometry2.matrix;
	            geometry2 = geometry2.geometry;
	        }
	        geometry1.merge(geometry2, matrix, materialIndexOffset);
	    };
	    GeometryUtils.center = function (geometry) {
	        console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
	        return geometry.center();
	    };
	    return GeometryUtils;
	}());
	var ImageUtils = /** @class */ (function () {
	    function ImageUtils() {
	    }
	    ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
	        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
	        var loader = new TextureLoader();
	        loader.setCrossOrigin(this.crossOrigin);
	        var texture = loader.load(url, onLoad, undefined, onError);
	        if (mapping)
	            texture.mapping = mapping;
	        return texture;
	    };
	    ImageUtils.prototype.loadTextureCube = function (urls, mapping, onLoad, onError) {
	        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
	        var loader = new CubeTextureLoader();
	        loader.setCrossOrigin(ImageUtils.crossOrigin);
	        var texture = loader.load(urls, onLoad, undefined, onError);
	        if (mapping)
	            texture.mapping = mapping;
	        return texture;
	    };
	    ImageUtils.prototype.loadCompressedTexture = function () {
	        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
	    };
	    ImageUtils.prototype.loadCompressedTextureCube = function () {
	        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
	    };
	    return ImageUtils;
	}());
	//
	var Projector = /** @class */ (function () {
	    function Projector() {
	        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.ts.");
	    }
	    Projector.prototype.projectVector = function (vector, camera) {
	        console.warn("THREE.Projector: .projectVector() is now vector.project().");
	        vector.project(camera);
	    };
	    Projector.prototype.unprojectVector = function (vector, camera) {
	        console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
	        vector.unproject(camera);
	    };
	    Projector.prototype.pickingRay = function (vector, camera) {
	        console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
	    };
	    return Projector;
	}());
	//
	var CanvasRenderer = /** @class */ (function () {
	    function CanvasRenderer() {
	        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.ts");
	        this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
	    }
	    CanvasRenderer.prototype.clear = function () { };
	    CanvasRenderer.prototype.render = function () { };
	    CanvasRenderer.prototype.setClearColor = function () { };
	    CanvasRenderer.prototype.setSize = function () { };
	    return CanvasRenderer;
	}());

	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderer = WebGLRenderer;
	exports.ShaderLib = ShaderLib;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.FogExp2 = FogExp2;
	exports.Fog = Fog;
	exports.Scene = Scene;
	exports.LensFlare = LensFlare;
	exports.Sprite = Sprite;
	exports.LOD = LOD;
	exports.SkinnedMesh = SkinnedMesh;
	exports.Skeleton = Skeleton;
	exports.Bone = Bone;
	exports.Mesh = Mesh;
	exports.LineSegments = LineSegments;
	exports.Line = Line;
	exports.Points = Points;
	exports.Group = Group;
	exports.VideoTexture = VideoTexture;
	exports.DataTexture = DataTexture;
	exports.CompressedTexture = CompressedTexture;
	exports.CubeTexture = CubeTexture;
	exports.CanvasTexture = CanvasTexture;
	exports.DepthTexture = DepthTexture;
	exports.TextureIdCount = TextureIdCount;
	exports.Texture = Texture;
	exports.MaterialIdCount = MaterialIdCount;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.DataTextureLoader = DataTextureLoader;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.TextureLoader = TextureLoader;
	exports.ObjectLoader = ObjectLoader;
	exports.MaterialLoader = MaterialLoader;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.LoadingManager = LoadingManager;
	exports.JSONLoader = JSONLoader;
	exports.ImageLoader = ImageLoader;
	exports.FontLoader = FontLoader;
	exports.XHRLoader = XHRLoader;
	exports.Loader = Loader;
	exports.Cache = Cache;
	exports.AudioLoader = AudioLoader;
	exports.SpotLightShadow = SpotLightShadow;
	exports.SpotLight = SpotLight;
	exports.PointLight = PointLight;
	exports.HemisphereLight = HemisphereLight;
	exports.DirectionalLightShadow = DirectionalLightShadow;
	exports.DirectionalLight = DirectionalLight;
	exports.AmbientLight = AmbientLight;
	exports.LightShadow = LightShadow;
	exports.Light = Light;
	exports.StereoCamera = StereoCamera;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.OrthographicCamera = OrthographicCamera;
	exports.CubeCamera = CubeCamera;
	exports.Camera = Camera;
	exports.AudioListener = AudioListener;
	exports.PositionalAudio = PositionalAudio;
	exports.getAudioContext = getAudioContext;
	exports.AudioAnalyser = AudioAnalyser;
	exports.Audio = Audio;
	exports.VectorKeyframeTrack = NewVectorKeyframeTrack;
	exports.StringKeyframeTrack = NewStringKeyframeTrack;
	exports.QuaternionKeyframeTrack = NewQuaternionKeyframeTrack;
	exports.NumberKeyframeTrack = NewNumberKeyframeTrack;
	exports.ColorKeyframeTrack = NewColorKeyframeTrack;
	exports.BooleanKeyframeTrack = NewBooleanKeyframeTrack;
	exports.PropertyMixer = PropertyMixer;
	exports.PropertyBinding = PropertyBinding;
	exports.KeyframeTrack = KeyframeTrack;
	exports.AnimationUtils = AnimationUtils;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationClip = AnimationClip;
	exports.Uniform = Uniform;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.BufferGeometry = BufferGeometry;
	exports.GeometryIdCount = GeometryIdCount;
	exports.Geometry = Geometry;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.Float64Attribute = Float64Attribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Int16Attribute = Int16Attribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Int8Attribute = Int8Attribute;
	exports.BufferAttribute = BufferAttribute;
	exports.Face3 = Face3;
	exports.Object3DIdCount = Object3DIdCount;
	exports.Object3D = Object3D;
	exports.Raycaster = Raycaster;
	exports.Intersect = Intersect;
	exports.Layers = Layers;
	exports.EventDispatcher = EventDispatcher;
	exports.Clock = Clock;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.LinearInterpolant = LinearInterpolant;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.CubicInterpolant = CubicInterpolant;
	exports.Interpolant = Interpolant;
	exports.Triangle = Triangle;
	exports.Spline = Spline;
	exports.Math = _Math;
	exports.Spherical = Spherical;
	exports.Plane = Plane;
	exports.Frustum = Frustum;
	exports.Sphere = Sphere;
	exports.Ray = Ray;
	exports.Matrix4 = Matrix4;
	exports.Matrix3 = Matrix3;
	exports.Box3 = Box3;
	exports.Box2 = Box2;
	exports.Line3 = Line3;
	exports.Euler = Euler;
	exports.Vector4 = Vector4;
	exports.Vector3 = Vector3;
	exports.Vector2 = Vector2;
	exports.Quaternion = Quaternion;
	exports.ColorKeywords = ColorKeywords;
	exports.Color = Color;
	exports.MorphBlendMesh = MorphBlendMesh;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.VertexNormalsHelper = VertexNormalsHelper;
	exports.SpotLightHelper = SpotLightHelper;
	exports.SkeletonHelper = SkeletonHelper;
	exports.PointLightHelper = PointLightHelper;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.GridHelper = GridHelper;
	exports.FaceNormalsHelper = FaceNormalsHelper;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.CameraHelper = CameraHelper;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.BoxHelper = BoxHelper;
	exports.ArrowHelper = ArrowHelper;
	exports.AxisHelper = AxisHelper;
	exports.ClosedSplineCurve3 = ClosedSplineCurve3;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.SplineCurve3 = SplineCurve3;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.LineCurve3 = LineCurve3;
	exports.ArcCurve = ArcCurve;
	exports.EllipseCurve = EllipseCurve;
	exports.SplineCurve = SplineCurve;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.LineCurve = LineCurve;
	exports.Shape = Shape;
	exports.Path = Path;
	exports.ShapePath = ShapePath;
	exports.Font = Font;
	exports.CurvePath = CurvePath;
	exports.Curve = Curve;
	exports.ShapeUtils = ShapeUtils;
	exports.SceneUtils = SceneUtils;
	exports.CurveUtils = CurveUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.ParametricBufferGeometry = ParametricBufferGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.TubeBufferGeometry = TubeBufferGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusBufferGeometry = TorusBufferGeometry;
	exports.TextGeometry = TextGeometry;
	exports.SphereBufferGeometry = SphereBufferGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.RingGeometry = RingGeometry;
	exports.RingBufferGeometry = RingBufferGeometry;
	exports.PlaneBufferGeometry = PlaneBufferGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.LatheBufferGeometry = LatheBufferGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.EdgesGeometry = EdgesGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.ConeBufferGeometry = ConeBufferGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.CylinderBufferGeometry = CylinderBufferGeometry;
	exports.CircleBufferGeometry = CircleBufferGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.BoxBufferGeometry = BoxBufferGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.ShadowMaterial = ShadowMaterial;
	exports.SpriteMaterial = SpriteMaterial;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.ShaderMaterial = ShaderMaterial;
	exports.PointsMaterial = PointsMaterial;
	exports.MultiMaterial = MultiMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.Material = Material;
	exports.REVISION = REVISION;
	exports.CullFaceNone = CullFaceNone;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
	exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
	exports.BasicShadowMap = BasicShadowMap;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.FrontSide = FrontSide;
	exports.BackSide = BackSide;
	exports.DoubleSide = DoubleSide;
	exports.FlatShading = FlatShading;
	exports.SmoothShading = SmoothShading;
	exports.NoColors = NoColors;
	exports.FaceColors = FaceColors;
	exports.VertexColors = VertexColors;
	exports.NoBlending = NoBlending;
	exports.NormalBlending = NormalBlending;
	exports.AdditiveBlending = AdditiveBlending;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.MultiplyBlending = MultiplyBlending;
	exports.CustomBlending = CustomBlending;
	exports.AddEquation = AddEquation;
	exports.SubtractEquation = SubtractEquation;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.MinEquation = MinEquation;
	exports.MaxEquation = MaxEquation;
	exports.ZeroFactor = ZeroFactor;
	exports.OneFactor = OneFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.NeverDepth = NeverDepth;
	exports.AlwaysDepth = AlwaysDepth;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.EqualDepth = EqualDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterDepth = GreaterDepth;
	exports.NotEqualDepth = NotEqualDepth;
	exports.MultiplyOperation = MultiplyOperation;
	exports.MixOperation = MixOperation;
	exports.AddOperation = AddOperation;
	exports.NoToneMapping = NoToneMapping;
	exports.LinearToneMapping = LinearToneMapping;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
	exports.CineonToneMapping = CineonToneMapping;
	exports.UVMapping = UVMapping;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.SphericalReflectionMapping = SphericalReflectionMapping;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.LinearFilter = LinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.UnsignedByteType = UnsignedByteType;
	exports.ByteType = ByteType;
	exports.ShortType = ShortType;
	exports.UnsignedShortType = UnsignedShortType;
	exports.IntType = IntType;
	exports.UnsignedIntType = UnsignedIntType;
	exports.FloatType = FloatType;
	exports.HalfFloatType = HalfFloatType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.AlphaFormat = AlphaFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBAFormat = RGBAFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.RGBEFormat = RGBEFormat;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.LoopOnce = LoopOnce;
	exports.LoopRepeat = LoopRepeat;
	exports.LoopPingPong = LoopPingPong;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.LinearEncoding = LinearEncoding;
	exports.sRGBEncoding = sRGBEncoding;
	exports.GammaEncoding = GammaEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBDEncoding = RGBDEncoding;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.CubeGeometry = BoxGeometry;
	exports.LineStrip = LineStrip;
	exports.LinePieces = LinePieces;
	exports.MeshFaceMaterial = MultiMaterial;
	exports.Particle = Sprite;
	exports.Face4 = Face4;
	exports.PointCloud = PointCloud;
	exports.ParticleSystem = ParticleSystem;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Vertex = Vertex;
	exports.EdgesHelper = EdgesHelper;
	exports.WireframeHelper = WireframeHelper;
	exports.GeometryUtils = GeometryUtils;
	exports.ImageUtils = ImageUtils;
	exports.Projector = Projector;
	exports.CanvasRenderer = CanvasRenderer;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=three.js.map
