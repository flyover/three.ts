function __extends(d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// Polyfills
if (Number.EPSILON === undefined) {
    ///Number.EPSILON = Math.pow(2, - 52);
    Object.defineProperty(Number, 'EPSILON', { value: Math.pow(2, -52) });
}
//
if (Math.sign === undefined) {
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
    Math.sign = function (x) {
        return (x < 0) ? -1 : (x > 0) ? 1 : +x;
    };
}
if (Function.prototype.name === undefined) {
    // Missing in IE9-11.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
    Object.defineProperty(Function.prototype, 'name', {
        get: function () {
            return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
        }
    });
}
if (Object.assign === undefined) {
    // Missing in IE.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    (function () {
        Object.assign = function (target /*: any*/) {
            'use strict';
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }
            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    for (var nextKey in source) {
                        if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    })();
}

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
var EventDispatcher = (function () {
    function EventDispatcher() {
    }
    EventDispatcher.prototype.addEventListener = function (type, listener) {
        if (this._listeners === undefined)
            this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === undefined) {
            listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
        }
    };
    EventDispatcher.prototype.hasEventListener = function (type, listener) {
        if (this._listeners === undefined)
            return false;
        var listeners = this._listeners;
        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
            return true;
        }
        return false;
    };
    EventDispatcher.prototype.removeEventListener = function (type, listener) {
        if (this._listeners === undefined)
            return;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            var index = listenerArray.indexOf(listener);
            if (index !== -1) {
                listenerArray.splice(index, 1);
            }
        }
    };
    EventDispatcher.prototype.dispatchEvent = function (event) {
        if (this._listeners === undefined)
            return;
        var listeners = this._listeners;
        var listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            var array = [];
            var length = listenerArray.length;
            for (var i = 0; i < length; i++) {
                array[i] = listenerArray[i];
            }
            for (var i = 0; i < length; i++) {
                array[i].call(this, event);
            }
        }
    };
    EventDispatcher.prototype.apply = function (target) {
        console.warn("THREE.EventDispatcher: .apply is deprecated, " +
            "just inherit or Object.assign the prototype to mix-in.");
        Object.assign(target, this);
    };
    return EventDispatcher;
}());

var REVISION = "82";
//
var MOUSE;
(function (MOUSE) {
    MOUSE[MOUSE["LEFT"] = 0] = "LEFT";
    MOUSE[MOUSE["MIDDLE"] = 1] = "MIDDLE";
    MOUSE[MOUSE["RIGHT"] = 2] = "RIGHT";
})(MOUSE || (MOUSE = {}));
//
var CullFace;
(function (CullFace) {
    CullFace[CullFace["None"] = 0] = "None";
    CullFace[CullFace["Back"] = 1] = "Back";
    CullFace[CullFace["Front"] = 2] = "Front";
    CullFace[CullFace["FrontBack"] = 3] = "FrontBack";
})(CullFace || (CullFace = {}));
var CullFaceNone = CullFace.None;
var CullFaceBack = CullFace.Back;
var CullFaceFront = CullFace.Front;
var CullFaceFrontBack = CullFace.FrontBack;
//
var FrontFaceDirection;
(function (FrontFaceDirection) {
    FrontFaceDirection[FrontFaceDirection["CW"] = 0] = "CW";
    FrontFaceDirection[FrontFaceDirection["CCW"] = 1] = "CCW";
})(FrontFaceDirection || (FrontFaceDirection = {}));
var FrontFaceDirectionCW = FrontFaceDirection.CW;
var FrontFaceDirectionCCW = FrontFaceDirection.CCW;
//
var ShadowMap;
(function (ShadowMap) {
    ShadowMap[ShadowMap["Basic"] = 0] = "Basic";
    ShadowMap[ShadowMap["PCF"] = 1] = "PCF";
    ShadowMap[ShadowMap["PCFSoft"] = 2] = "PCFSoft";
})(ShadowMap || (ShadowMap = {}));
var BasicShadowMap = ShadowMap.Basic;
var PCFShadowMap = ShadowMap.PCF;
var PCFSoftShadowMap = ShadowMap.PCFSoft;
//
var SideMode;
(function (SideMode) {
    SideMode[SideMode["Front"] = 0] = "Front";
    SideMode[SideMode["Back"] = 1] = "Back";
    SideMode[SideMode["Double"] = 2] = "Double";
})(SideMode || (SideMode = {}));
var FrontSide = SideMode.Front;
var BackSide = SideMode.Back;
var DoubleSide = SideMode.Double;
//
var ShadingMode;
(function (ShadingMode) {
    ShadingMode[ShadingMode["Flat"] = 1] = "Flat";
    ShadingMode[ShadingMode["Smooth"] = 2] = "Smooth";
})(ShadingMode || (ShadingMode = {}));
var FlatShading = ShadingMode.Flat;
var SmoothShading = ShadingMode.Smooth;
//
var ColorsMode;
(function (ColorsMode) {
    ColorsMode[ColorsMode["None"] = 0] = "None";
    ColorsMode[ColorsMode["Face"] = 1] = "Face";
    ColorsMode[ColorsMode["Vertex"] = 2] = "Vertex";
})(ColorsMode || (ColorsMode = {}));
var NoColors = ColorsMode.None;
var FaceColors = ColorsMode.Face;
var VertexColors = ColorsMode.Vertex;
//
var BlendingMode;
(function (BlendingMode) {
    BlendingMode[BlendingMode["None"] = 0] = "None";
    BlendingMode[BlendingMode["Normal"] = 1] = "Normal";
    BlendingMode[BlendingMode["Additive"] = 2] = "Additive";
    BlendingMode[BlendingMode["Subtractive"] = 3] = "Subtractive";
    BlendingMode[BlendingMode["Multiply"] = 4] = "Multiply";
    BlendingMode[BlendingMode["Custom"] = 5] = "Custom";
})(BlendingMode || (BlendingMode = {}));
var NoBlending = BlendingMode.None;
var NormalBlending = BlendingMode.Normal;
var AdditiveBlending = BlendingMode.Additive;
var SubtractiveBlending = BlendingMode.Subtractive;
var MultiplyBlending = BlendingMode.Multiply;
var CustomBlending = BlendingMode.Custom;
//
var BlendingEquation;
(function (BlendingEquation) {
    BlendingEquation[BlendingEquation["Add"] = 100] = "Add";
    BlendingEquation[BlendingEquation["Subtract"] = 101] = "Subtract";
    BlendingEquation[BlendingEquation["ReverseSubtract"] = 102] = "ReverseSubtract";
    BlendingEquation[BlendingEquation["Min"] = 103] = "Min";
    BlendingEquation[BlendingEquation["Max"] = 104] = "Max";
})(BlendingEquation || (BlendingEquation = {}));
var AddEquation = BlendingEquation.Add;
var SubtractEquation = BlendingEquation.Subtract;
var ReverseSubtractEquation = BlendingEquation.ReverseSubtract;
var MinEquation = BlendingEquation.Min;
var MaxEquation = BlendingEquation.Max;
//
var BlendingFactor;
(function (BlendingFactor) {
    BlendingFactor[BlendingFactor["Zero"] = 200] = "Zero";
    BlendingFactor[BlendingFactor["One"] = 201] = "One";
    BlendingFactor[BlendingFactor["SrcColor"] = 202] = "SrcColor";
    BlendingFactor[BlendingFactor["OneMinusSrcColor"] = 203] = "OneMinusSrcColor";
    BlendingFactor[BlendingFactor["SrcAlpha"] = 204] = "SrcAlpha";
    BlendingFactor[BlendingFactor["OneMinusSrcAlpha"] = 205] = "OneMinusSrcAlpha";
    BlendingFactor[BlendingFactor["DstAlpha"] = 206] = "DstAlpha";
    BlendingFactor[BlendingFactor["OneMinusDstAlpha"] = 207] = "OneMinusDstAlpha";
    BlendingFactor[BlendingFactor["DstColor"] = 208] = "DstColor";
    BlendingFactor[BlendingFactor["OneMinusDstColor"] = 209] = "OneMinusDstColor";
    BlendingFactor[BlendingFactor["SrcAlphaSaturate"] = 210] = "SrcAlphaSaturate";
})(BlendingFactor || (BlendingFactor = {}));
var ZeroFactor = BlendingFactor.Zero;
var OneFactor = BlendingFactor.One;
var SrcColorFactor = BlendingFactor.SrcColor;
var OneMinusSrcColorFactor = BlendingFactor.OneMinusSrcColor;
var SrcAlphaFactor = BlendingFactor.SrcAlpha;
var OneMinusSrcAlphaFactor = BlendingFactor.OneMinusSrcAlpha;
var DstAlphaFactor = BlendingFactor.DstAlpha;
var OneMinusDstAlphaFactor = BlendingFactor.OneMinusDstAlpha;
var DstColorFactor = BlendingFactor.DstColor;
var OneMinusDstColorFactor = BlendingFactor.OneMinusDstColor;
var SrcAlphaSaturateFactor = BlendingFactor.SrcAlphaSaturate;
//
var DepthFunction;
(function (DepthFunction) {
    DepthFunction[DepthFunction["Never"] = 0] = "Never";
    DepthFunction[DepthFunction["Always"] = 1] = "Always";
    DepthFunction[DepthFunction["Less"] = 2] = "Less";
    DepthFunction[DepthFunction["LessEqual"] = 3] = "LessEqual";
    DepthFunction[DepthFunction["Equal"] = 4] = "Equal";
    DepthFunction[DepthFunction["GreaterEqual"] = 5] = "GreaterEqual";
    DepthFunction[DepthFunction["Greater"] = 6] = "Greater";
    DepthFunction[DepthFunction["NotEqual"] = 7] = "NotEqual";
})(DepthFunction || (DepthFunction = {}));
var NeverDepth = DepthFunction.Never;
var AlwaysDepth = DepthFunction.Always;
var LessDepth = DepthFunction.Less;
var LessEqualDepth = DepthFunction.LessEqual;
var EqualDepth = DepthFunction.Equal;
var GreaterEqualDepth = DepthFunction.GreaterEqual;
var GreaterDepth = DepthFunction.Greater;
var NotEqualDepth = DepthFunction.NotEqual;
//
var BlendingOperation;
(function (BlendingOperation) {
    BlendingOperation[BlendingOperation["Multiply"] = 0] = "Multiply";
    BlendingOperation[BlendingOperation["Mix"] = 1] = "Mix";
    BlendingOperation[BlendingOperation["Add"] = 2] = "Add";
})(BlendingOperation || (BlendingOperation = {}));
var MultiplyOperation = BlendingOperation.Multiply;
var MixOperation = BlendingOperation.Mix;
var AddOperation = BlendingOperation.Add;
//
var ToneMapping;
(function (ToneMapping) {
    ToneMapping[ToneMapping["None"] = 0] = "None";
    ToneMapping[ToneMapping["Linear"] = 1] = "Linear";
    ToneMapping[ToneMapping["Reinhard"] = 2] = "Reinhard";
    ToneMapping[ToneMapping["Uncharted2"] = 3] = "Uncharted2";
    ToneMapping[ToneMapping["Cineon"] = 4] = "Cineon";
})(ToneMapping || (ToneMapping = {}));
var NoToneMapping = ToneMapping.None;
var LinearToneMapping = ToneMapping.Linear;
var ReinhardToneMapping = ToneMapping.Reinhard;
var Uncharted2ToneMapping = ToneMapping.Uncharted2;
var CineonToneMapping = ToneMapping.Cineon;
//
var TextureMapping;
(function (TextureMapping) {
    TextureMapping[TextureMapping["UV"] = 300] = "UV";
    TextureMapping[TextureMapping["CubeReflection"] = 301] = "CubeReflection";
    TextureMapping[TextureMapping["CubeRefraction"] = 302] = "CubeRefraction";
    TextureMapping[TextureMapping["EquirectangularReflection"] = 303] = "EquirectangularReflection";
    TextureMapping[TextureMapping["EquirectangularRefraction"] = 304] = "EquirectangularRefraction";
    TextureMapping[TextureMapping["SphericalReflection"] = 305] = "SphericalReflection";
    TextureMapping[TextureMapping["CubeUVReflection"] = 306] = "CubeUVReflection";
    TextureMapping[TextureMapping["CubeUVRefraction"] = 307] = "CubeUVRefraction";
})(TextureMapping || (TextureMapping = {}));
var UVMapping = TextureMapping.UV;
var CubeReflectionMapping = TextureMapping.CubeReflection;
var CubeRefractionMapping = TextureMapping.CubeRefraction;
var EquirectangularReflectionMapping = TextureMapping.EquirectangularReflection;
var EquirectangularRefractionMapping = TextureMapping.EquirectangularRefraction;
var SphericalReflectionMapping = TextureMapping.SphericalReflection;
var CubeUVReflectionMapping = TextureMapping.CubeUVReflection;
var CubeUVRefractionMapping = TextureMapping.CubeUVRefraction;
//
var TextureWrapping;
(function (TextureWrapping) {
    TextureWrapping[TextureWrapping["Repeat"] = 1000] = "Repeat";
    TextureWrapping[TextureWrapping["ClampToEdge"] = 1001] = "ClampToEdge";
    TextureWrapping[TextureWrapping["MirroredRepeat"] = 1002] = "MirroredRepeat";
})(TextureWrapping || (TextureWrapping = {}));
var RepeatWrapping = TextureWrapping.Repeat;
var ClampToEdgeWrapping = TextureWrapping.ClampToEdge;
var MirroredRepeatWrapping = TextureWrapping.MirroredRepeat;
//
var TextureFilter;
(function (TextureFilter) {
    TextureFilter[TextureFilter["Nearest"] = 1003] = "Nearest";
    TextureFilter[TextureFilter["NearestMipMapNearest"] = 1004] = "NearestMipMapNearest";
    TextureFilter[TextureFilter["NearestMipMapLinear"] = 1005] = "NearestMipMapLinear";
    TextureFilter[TextureFilter["Linear"] = 1006] = "Linear";
    TextureFilter[TextureFilter["LinearMipMapNearest"] = 1007] = "LinearMipMapNearest";
    TextureFilter[TextureFilter["LinearMipMapLinear"] = 1008] = "LinearMipMapLinear";
})(TextureFilter || (TextureFilter = {}));
var NearestFilter = TextureFilter.Nearest;
var NearestMipMapNearestFilter = TextureFilter.NearestMipMapNearest;
var NearestMipMapLinearFilter = TextureFilter.NearestMipMapLinear;
var LinearFilter = TextureFilter.Linear;
var LinearMipMapNearestFilter = TextureFilter.LinearMipMapNearest;
var LinearMipMapLinearFilter = TextureFilter.LinearMipMapLinear;
//
var TextureType;
(function (TextureType) {
    TextureType[TextureType["UnsignedByte"] = 1009] = "UnsignedByte";
    TextureType[TextureType["Byte"] = 1010] = "Byte";
    TextureType[TextureType["Short"] = 1011] = "Short";
    TextureType[TextureType["UnsignedShort"] = 1012] = "UnsignedShort";
    TextureType[TextureType["Int"] = 1013] = "Int";
    TextureType[TextureType["UnsignedInt"] = 1014] = "UnsignedInt";
    TextureType[TextureType["Float"] = 1015] = "Float";
    TextureType[TextureType["HalfFloat"] = 1016] = "HalfFloat";
    TextureType[TextureType["UnsignedShort4444"] = 1017] = "UnsignedShort4444";
    TextureType[TextureType["UnsignedShort5551"] = 1018] = "UnsignedShort5551";
    TextureType[TextureType["UnsignedShort565"] = 1019] = "UnsignedShort565";
    TextureType[TextureType["UnsignedInt248"] = 1020] = "UnsignedInt248";
})(TextureType || (TextureType = {}));
var UnsignedByteType = TextureType.UnsignedByte;
var ByteType = TextureType.Byte;
var ShortType = TextureType.Short;
var UnsignedShortType = TextureType.UnsignedShort;
var IntType = TextureType.Int;
var UnsignedIntType = TextureType.UnsignedInt;
var FloatType = TextureType.Float;
var HalfFloatType = TextureType.HalfFloat;
var UnsignedShort4444Type = TextureType.UnsignedShort4444;
var UnsignedShort5551Type = TextureType.UnsignedShort5551;
var UnsignedShort565Type = TextureType.UnsignedShort565;
var UnsignedInt248Type = TextureType.UnsignedInt248;
//
var TextureFormat;
(function (TextureFormat) {
    TextureFormat[TextureFormat["Alpha"] = 1021] = "Alpha";
    TextureFormat[TextureFormat["RGB"] = 1022] = "RGB";
    TextureFormat[TextureFormat["RGBA"] = 1023] = "RGBA";
    TextureFormat[TextureFormat["Luminance"] = 1024] = "Luminance";
    TextureFormat[TextureFormat["LuminanceAlpha"] = 1025] = "LuminanceAlpha";
    TextureFormat[TextureFormat["RGBE"] = 1023] = "RGBE";
    TextureFormat[TextureFormat["Depth"] = 1026] = "Depth";
    TextureFormat[TextureFormat["DepthStencil"] = 1027] = "DepthStencil";
    TextureFormat[TextureFormat["RGB_S3TC_DXT1"] = 2001] = "RGB_S3TC_DXT1";
    TextureFormat[TextureFormat["RGBA_S3TC_DXT1"] = 2002] = "RGBA_S3TC_DXT1";
    TextureFormat[TextureFormat["RGBA_S3TC_DXT3"] = 2003] = "RGBA_S3TC_DXT3";
    TextureFormat[TextureFormat["RGBA_S3TC_DXT5"] = 2004] = "RGBA_S3TC_DXT5";
    TextureFormat[TextureFormat["RGB_PVRTC_4BPPV1"] = 2100] = "RGB_PVRTC_4BPPV1";
    TextureFormat[TextureFormat["RGB_PVRTC_2BPPV1"] = 2101] = "RGB_PVRTC_2BPPV1";
    TextureFormat[TextureFormat["RGBA_PVRTC_4BPPV1"] = 2102] = "RGBA_PVRTC_4BPPV1";
    TextureFormat[TextureFormat["RGBA_PVRTC_2BPPV1"] = 2103] = "RGBA_PVRTC_2BPPV1";
    TextureFormat[TextureFormat["RGB_ETC1"] = 2151] = "RGB_ETC1";
})(TextureFormat || (TextureFormat = {}));
var AlphaFormat = TextureFormat.Alpha;
var RGBFormat = TextureFormat.RGB;
var RGBAFormat = TextureFormat.RGBA;
var LuminanceFormat = TextureFormat.Luminance;
var LuminanceAlphaFormat = TextureFormat.LuminanceAlpha;
var RGBEFormat = TextureFormat.RGBE;
var DepthFormat = TextureFormat.Depth;
var DepthStencilFormat = TextureFormat.DepthStencil;
var RGB_S3TC_DXT1_Format = TextureFormat.RGB_S3TC_DXT1;
var RGBA_S3TC_DXT1_Format = TextureFormat.RGBA_S3TC_DXT1;
var RGBA_S3TC_DXT3_Format = TextureFormat.RGBA_S3TC_DXT3;
var RGBA_S3TC_DXT5_Format = TextureFormat.RGBA_S3TC_DXT5;
var RGB_PVRTC_4BPPV1_Format = TextureFormat.RGB_PVRTC_4BPPV1;
var RGB_PVRTC_2BPPV1_Format = TextureFormat.RGB_PVRTC_2BPPV1;
var RGBA_PVRTC_4BPPV1_Format = TextureFormat.RGBA_PVRTC_4BPPV1;
var RGBA_PVRTC_2BPPV1_Format = TextureFormat.RGBA_PVRTC_2BPPV1;
var RGB_ETC1_Format = TextureFormat.RGB_ETC1;
//
var LoopMode;
(function (LoopMode) {
    LoopMode[LoopMode["Once"] = 2200] = "Once";
    LoopMode[LoopMode["Repeat"] = 2201] = "Repeat";
    LoopMode[LoopMode["PingPong"] = 2202] = "PingPong";
})(LoopMode || (LoopMode = {}));
var LoopOnce = LoopMode.Once;
var LoopRepeat = LoopMode.Repeat;
var LoopPingPong = LoopMode.PingPong;
//
var InterpolateMode;
(function (InterpolateMode) {
    InterpolateMode[InterpolateMode["Discrete"] = 2300] = "Discrete";
    InterpolateMode[InterpolateMode["Linear"] = 2301] = "Linear";
    InterpolateMode[InterpolateMode["Smooth"] = 2302] = "Smooth";
})(InterpolateMode || (InterpolateMode = {}));
var InterpolateDiscrete = InterpolateMode.Discrete;
var InterpolateLinear = InterpolateMode.Linear;
var InterpolateSmooth = InterpolateMode.Smooth;
//
var EndingMode;
(function (EndingMode) {
    EndingMode[EndingMode["ZeroCurvature"] = 2400] = "ZeroCurvature";
    EndingMode[EndingMode["ZeroSlope"] = 2401] = "ZeroSlope";
    EndingMode[EndingMode["WrapAround"] = 2402] = "WrapAround";
})(EndingMode || (EndingMode = {}));
var ZeroCurvatureEnding = EndingMode.ZeroCurvature;
var ZeroSlopeEnding = EndingMode.ZeroSlope;
var WrapAroundEnding = EndingMode.WrapAround;
//
var DrawMode;
(function (DrawMode) {
    DrawMode[DrawMode["Triangles"] = 0] = "Triangles";
    DrawMode[DrawMode["TriangleStrip"] = 1] = "TriangleStrip";
    DrawMode[DrawMode["TriangleFan"] = 2] = "TriangleFan";
})(DrawMode || (DrawMode = {}));
var TrianglesDrawMode = DrawMode.Triangles;
var TriangleStripDrawMode = DrawMode.TriangleStrip;
var TriangleFanDrawMode = DrawMode.TriangleFan;
//
var TextureEncoding;
(function (TextureEncoding) {
    TextureEncoding[TextureEncoding["Linear"] = 3000] = "Linear";
    TextureEncoding[TextureEncoding["sRGB"] = 3001] = "sRGB";
    TextureEncoding[TextureEncoding["Gamma"] = 3007] = "Gamma";
    TextureEncoding[TextureEncoding["RGBE"] = 3002] = "RGBE";
    TextureEncoding[TextureEncoding["LogLuv"] = 3003] = "LogLuv";
    TextureEncoding[TextureEncoding["RGBM7"] = 3004] = "RGBM7";
    TextureEncoding[TextureEncoding["RGBM16"] = 3005] = "RGBM16";
    TextureEncoding[TextureEncoding["RGBD"] = 3006] = "RGBD";
})(TextureEncoding || (TextureEncoding = {}));
var LinearEncoding = TextureEncoding.Linear;
var sRGBEncoding = TextureEncoding.sRGB;
var GammaEncoding = TextureEncoding.Gamma;
var RGBEEncoding = TextureEncoding.RGBE;
var LogLuvEncoding = TextureEncoding.LogLuv;
var RGBM7Encoding = TextureEncoding.RGBM7;
var RGBM16Encoding = TextureEncoding.RGBM16;
var RGBDEncoding = TextureEncoding.RGBD;
//
var DepthPacking;
(function (DepthPacking) {
    DepthPacking[DepthPacking["Basic"] = 3200] = "Basic";
    DepthPacking[DepthPacking["RGBA"] = 3201] = "RGBA";
})(DepthPacking || (DepthPacking = {}));
var BasicDepthPacking = DepthPacking.Basic;
var RGBADepthPacking = DepthPacking.RGBA;

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */
var _Math = (function () {
    function _Math() {
    }
    _Math.generateUUID = function () {
        var chars = _Math.generateUUID_chars;
        var uuid = _Math.generateUUID_uuid;
        for (var i = 0; i < 36; i++) {
            if (i === 8 || i === 13 || i === 18 || i === 23) {
                uuid[i] = '-';
            }
            else if (i === 14) {
                uuid[i] = '4';
            }
            else {
                var rnd = _Math.generateUUID_rnd;
                if (rnd <= 0x02)
                    rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
                var r = rnd & 0xf;
                _Math.generateUUID_rnd = rnd >> 4;
                uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];
            }
        }
        return uuid.join('');
    };
    _Math.clamp = function (value, min, max) {
        return Math.max(min, Math.min(max, value));
    };
    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation
    _Math.euclideanModulo = function (n, m) {
        return ((n % m) + m) % m;
    };
    // Linear mapping from range <a1, a2> to range <b1, b2>
    _Math.mapLinear = function (x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    };
    // https://en.wikipedia.org/wiki/Linear_interpolation
    _Math.lerp = function (x, y, t) {
        return (1 - t) * x + t * y;
    };
    // http://en.wikipedia.org/wiki/Smoothstep
    _Math.smoothstep = function (x, min, max) {
        if (x <= min)
            return 0;
        if (x >= max)
            return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
    };
    _Math.smootherstep = function (x, min, max) {
        if (x <= min)
            return 0;
        if (x >= max)
            return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
    };
    _Math.random16 = function () {
        console.warn('THREE.Math.random16() has been deprecated. Use Math.random() instead.');
        return Math.random();
    };
    // Random integer from <low, high> interval
    _Math.randInt = function (low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
    };
    // Random float from <low, high> interval
    _Math.randFloat = function (low, high) {
        return low + Math.random() * (high - low);
    };
    // Random float from <-range/2, range/2> interval
    _Math.randFloatSpread = function (range) {
        return range * (0.5 - Math.random());
    };
    _Math.degToRad = function (degrees) {
        return degrees * _Math.DEG2RAD;
    };
    _Math.radToDeg = function (radians) {
        return radians * _Math.RAD2DEG;
    };
    _Math.isPowerOfTwo = function (value) {
        return (value & (value - 1)) === 0 && value !== 0;
    };
    _Math.nearestPowerOfTwo = function (value) {
        return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
    };
    _Math.nextPowerOfTwo = function (value) {
        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;
        return value;
    };
    _Math.DEG2RAD = Math.PI / 180;
    _Math.RAD2DEG = 180 / Math.PI;
    _Math.generateUUID_chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
    _Math.generateUUID_uuid = new Array(36);
    _Math.generateUUID_rnd = 0;
    return _Math;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */
var Vector2 = (function () {
    function Vector2(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        this.isVector2 = true;
        this.x = x;
        this.y = y;
    }
    Object.defineProperty(Vector2.prototype, "width", {
        get: function () { return this.x; },
        set: function (value) { this.x = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector2.prototype, "height", {
        get: function () { return this.y; },
        set: function (value) { this.y = value; },
        enumerable: true,
        configurable: true
    });
    Vector2.prototype.set = function (x, y) {
        this.x = x;
        this.y = y;
        return this;
    };
    Vector2.prototype.setScalar = function (scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    };
    Vector2.prototype.setX = function (x) {
        this.x = x;
        return this;
    };
    Vector2.prototype.setY = function (y) {
        this.y = y;
        return this;
    };
    Vector2.prototype.setComponent = function (index, value) {
        switch (index) {
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default: throw new Error('index is out of range: ' + index);
        }
        return this;
    };
    Vector2.prototype.getComponent = function (index) {
        switch (index) {
            case 0: return this.x;
            case 1: return this.y;
            default: throw new Error('index is out of range: ' + index);
        }
    };
    Vector2.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Vector2.prototype.copy = function (v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    };
    Vector2.prototype.add = function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors(a, b) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    };
    Vector2.prototype.addScalar = function (s) {
        this.x += s;
        this.y += s;
        return this;
    };
    Vector2.prototype.addVectors = function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    };
    Vector2.prototype.addScaledVector = function (v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    };
    Vector2.prototype.sub = function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors(a, b) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    };
    Vector2.prototype.subScalar = function (s) {
        this.x -= s;
        this.y -= s;
        return this;
    };
    Vector2.prototype.subVectors = function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    };
    Vector2.prototype.multiply = function (v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    };
    Vector2.prototype.multiplyScalar = function (scalar) {
        if (isFinite(scalar)) {
            this.x *= scalar;
            this.y *= scalar;
        }
        else {
            this.x = 0;
            this.y = 0;
        }
        return this;
    };
    Vector2.prototype.divide = function (v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    };
    Vector2.prototype.divideScalar = function (scalar) {
        return this.multiplyScalar(1 / scalar);
    };
    Vector2.prototype.min = function (v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    };
    Vector2.prototype.max = function (v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    };
    Vector2.prototype.clamp = function (min, max) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    };
    Vector2.prototype.clampScalar = function (minVal, maxVal) {
        var min = Vector2.clampScalar_min.set(minVal, minVal);
        var max = Vector2.clampScalar_max.set(maxVal, maxVal);
        return this.clamp(min, max);
    };
    Vector2.prototype.clampLength = function (min, max) {
        var length = this.length();
        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
    };
    Vector2.prototype.floor = function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    };
    Vector2.prototype.ceil = function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    };
    Vector2.prototype.round = function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    };
    Vector2.prototype.roundToZero = function () {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    };
    Vector2.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    };
    Vector2.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y;
    };
    Vector2.prototype.lengthSq = function () {
        return this.x * this.x + this.y * this.y;
    };
    Vector2.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    Vector2.prototype.lengthManhattan = function () {
        return Math.abs(this.x) + Math.abs(this.y);
    };
    Vector2.prototype.normalize = function () {
        return this.divideScalar(this.length());
    };
    Vector2.prototype.angle = function () {
        // computes the angle in radians with respect to the positive x-axis
        var angle = Math.atan2(this.y, this.x);
        if (angle < 0)
            angle += 2 * Math.PI;
        return angle;
    };
    Vector2.prototype.distanceTo = function (v) {
        return Math.sqrt(this.distanceToSquared(v));
    };
    Vector2.prototype.distanceToSquared = function (v) {
        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    };
    Vector2.prototype.distanceToManhattan = function (v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    };
    Vector2.prototype.setLength = function (length) {
        return this.multiplyScalar(length / this.length());
    };
    Vector2.prototype.lerp = function (v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    };
    Vector2.prototype.lerpVectors = function (v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    };
    Vector2.prototype.equals = function (v) {
        return ((v.x === this.x) && (v.y === this.y));
    };
    Vector2.prototype.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    };
    Vector2.prototype.toArray = function (array, offset) {
        if (array === void 0) { array = []; }
        if (offset === void 0) { offset = 0; }
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    };
    Vector2.prototype.fromAttribute = function (attribute, index, offset) {
        if (offset === void 0) { offset = 0; }
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        return this;
    };
    Vector2.prototype.rotateAround = function (center, angle) {
        var c = Math.cos(angle), s = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    };
    Vector2.clampScalar_min = new Vector2();
    Vector2.clampScalar_max = new Vector2();
    return Vector2;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */
var Texture = (function (_super) {
    __extends(Texture, _super);
    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        if (image === void 0) { image = Texture.DEFAULT_IMAGE; }
        if (mapping === void 0) { mapping = Texture.DEFAULT_MAPPING; }
        if (wrapS === void 0) { wrapS = TextureWrapping.ClampToEdge; }
        if (wrapT === void 0) { wrapT = TextureWrapping.ClampToEdge; }
        if (magFilter === void 0) { magFilter = TextureFilter.Linear; }
        if (minFilter === void 0) { minFilter = TextureFilter.LinearMipMapLinear; }
        if (format === void 0) { format = TextureFormat.RGBA; }
        if (type === void 0) { type = TextureType.UnsignedByte; }
        if (anisotropy === void 0) { anisotropy = 1; }
        if (encoding === void 0) { encoding = TextureEncoding.Linear; }
        _super.call(this);
        this.id = TextureIdCount();
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.sourceFile = '';
        this.mipmaps = [];
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
        this.version = 0;
        this.onUpdate = null;
        this.isTexture = true;
        this.image = image;
        this.mapping = mapping;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.anisotropy = anisotropy;
        this.format = format;
        this.type = type;
        this.encoding = encoding;
    }
    Object.defineProperty(Texture.prototype, "needsUpdate", {
        set: function (value) {
            if (value === true)
                this.version++;
        },
        enumerable: true,
        configurable: true
    });
    Texture.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Texture.prototype.copy = function (source) {
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
    };
    Texture.prototype.toJSON = function (meta) {
        if (meta.textures[this.uuid] !== undefined) {
            return meta.textures[this.uuid];
        }
        function getDataURL(image) {
            var canvas;
            if (image instanceof HTMLCanvasElement) {
                canvas = image;
            }
            else {
                canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = image.width;
                canvas.height = image.height;
                canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
            }
            if (canvas.width > 2048 || canvas.height > 2048) {
                return canvas.toDataURL('image/jpeg', 0.6);
            }
            else {
                return canvas.toDataURL('image/png');
            }
        }
        var output = {
            metadata: {
                version: 4.4,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            wrap: [this.wrapS, this.wrapT],
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY
        };
        if (this.image !== undefined) {
            // TODO: Move to THREE.Image
            var image = this.image;
            if (image.uuid === undefined) {
                image.uuid = _Math.generateUUID(); // UGH
            }
            if (meta.images[image.uuid] === undefined) {
                meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: getDataURL(image)
                };
            }
            output.image = image.uuid;
        }
        meta.textures[this.uuid] = output;
        return output;
    };
    Texture.prototype.dispose = function () {
        this.dispatchEvent({ type: 'dispose' });
    };
    Texture.prototype.transformUv = function (uv) {
        if (this.mapping !== TextureMapping.UV)
            return;
        uv.multiply(this.repeat);
        uv.add(this.offset);
        if (uv.x < 0 || uv.x > 1) {
            switch (this.wrapS) {
                case TextureWrapping.Repeat:
                    uv.x = uv.x - Math.floor(uv.x);
                    break;
                case TextureWrapping.ClampToEdge:
                    uv.x = uv.x < 0 ? 0 : 1;
                    break;
                case TextureWrapping.MirroredRepeat:
                    if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                        uv.x = Math.ceil(uv.x) - uv.x;
                    }
                    else {
                        uv.x = uv.x - Math.floor(uv.x);
                    }
                    break;
            }
        }
        if (uv.y < 0 || uv.y > 1) {
            switch (this.wrapT) {
                case TextureWrapping.Repeat:
                    uv.y = uv.y - Math.floor(uv.y);
                    break;
                case TextureWrapping.ClampToEdge:
                    uv.y = uv.y < 0 ? 0 : 1;
                    break;
                case TextureWrapping.MirroredRepeat:
                    if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                        uv.y = Math.ceil(uv.y) - uv.y;
                    }
                    else {
                        uv.y = uv.y - Math.floor(uv.y);
                    }
                    break;
            }
        }
        if (this.flipY) {
            uv.y = 1 - uv.y;
        }
    };
    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = TextureMapping.UV;
    return Texture;
}(EventDispatcher));
var count = 0;
function TextureIdCount() { return count++; }

var Vector4 = (function () {
    function Vector4(x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 1; }
        this.isVector4 = true;
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    Vector4.prototype.set = function (x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    };
    Vector4.prototype.setScalar = function (scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    };
    Vector4.prototype.setX = function (x) {
        this.x = x;
        return this;
    };
    Vector4.prototype.setY = function (y) {
        this.y = y;
        return this;
    };
    Vector4.prototype.setZ = function (z) {
        this.z = z;
        return this;
    };
    Vector4.prototype.setW = function (w) {
        this.w = w;
        return this;
    };
    Vector4.prototype.setComponent = function (index, value) {
        switch (index) {
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default: throw new Error('index is out of range: ' + index);
        }
        return this;
    };
    Vector4.prototype.getComponent = function (index) {
        switch (index) {
            case 0: return this.x;
            case 1: return this.y;
            case 2: return this.z;
            case 3: return this.w;
            default: throw new Error('index is out of range: ' + index);
        }
    };
    Vector4.prototype.clone = function () {
        return new this.constructor(this.x, this.y, this.z, this.w);
    };
    Vector4.prototype.copy = function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w;
        return this;
    };
    Vector4.prototype.add = function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors(a, b) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    };
    Vector4.prototype.addScalar = function (s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    };
    Vector4.prototype.addVectors = function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    };
    Vector4.prototype.addScaledVector = function (v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    };
    Vector4.prototype.sub = function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors(a, b) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    };
    Vector4.prototype.subScalar = function (s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    };
    Vector4.prototype.subVectors = function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    };
    Vector4.prototype.multiplyScalar = function (scalar) {
        if (isFinite(scalar)) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
        }
        else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 0;
        }
        return this;
    };
    Vector4.prototype.applyMatrix4 = function (m) {
        var x = this.x, y = this.y, z = this.z, w = this.w;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
    };
    Vector4.prototype.divideScalar = function (scalar) {
        return this.multiplyScalar(1 / scalar);
    };
    Vector4.prototype.setAxisAngleFromQuaternion = function (q) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
        // q is assumed to be normalized
        this.w = 2 * Math.acos(q.w);
        var s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        }
        else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    };
    Vector4.prototype.setAxisAngleFromRotationMatrix = function (m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var angle, x, y, z; // variables for result
        var epsilon = 0.01, // margin to allow for rounding errors
        epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
        te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if ((Math.abs(m12 - m21) < epsilon) &&
            (Math.abs(m13 - m31) < epsilon) &&
            (Math.abs(m23 - m32) < epsilon)) {
            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms
            if ((Math.abs(m12 + m21) < epsilon2) &&
                (Math.abs(m13 + m31) < epsilon2) &&
                (Math.abs(m23 + m32) < epsilon2) &&
                (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
                // this singularity is identity matrix so angle = 0
                this.set(1, 0, 0, 0);
                return this; // zero angle, arbitrary axis
            }
            // otherwise this singularity is angle = 180
            angle = Math.PI;
            var xx = (m11 + 1) / 2;
            var yy = (m22 + 1) / 2;
            var zz = (m33 + 1) / 2;
            var xy = (m12 + m21) / 4;
            var xz = (m13 + m31) / 4;
            var yz = (m23 + m32) / 4;
            if ((xx > yy) && (xx > zz)) {
                // m11 is the largest diagonal term
                if (xx < epsilon) {
                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;
                }
                else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                }
            }
            else if (yy > zz) {
                // m22 is the largest diagonal term
                if (yy < epsilon) {
                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;
                }
                else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                }
            }
            else {
                // m33 is the largest diagonal term so base result on this
                if (zz < epsilon) {
                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;
                }
                else {
                    z = Math.sqrt(zz);
                    x = xz / z;
                    y = yz / z;
                }
            }
            this.set(x, y, z, angle);
            return this; // return 180 deg rotation
        }
        // as we have reached here there are no singularities so we can handle normally
        var s = Math.sqrt((m32 - m23) * (m32 - m23) +
            (m13 - m31) * (m13 - m31) +
            (m21 - m12) * (m21 - m12)); // used to normalize
        if (Math.abs(s) < 0.001)
            s = 1;
        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    };
    Vector4.prototype.min = function (v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    };
    Vector4.prototype.max = function (v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    };
    Vector4.prototype.clamp = function (min, max) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    };
    Vector4.prototype.clampScalar = function (minVal, maxVal) {
        var min = Vector4._clampScalar_min, max = Vector4._clampScalar_max;
        min.set(minVal, minVal, minVal, minVal);
        max.set(maxVal, maxVal, maxVal, maxVal);
        return this.clamp(min, max);
    };
    Vector4.prototype.floor = function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    };
    Vector4.prototype.ceil = function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    };
    Vector4.prototype.round = function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    };
    Vector4.prototype.roundToZero = function () {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    };
    Vector4.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    };
    Vector4.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    };
    Vector4.prototype.lengthSq = function () {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };
    Vector4.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    };
    Vector4.prototype.lengthManhattan = function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    };
    Vector4.prototype.normalize = function () {
        return this.divideScalar(this.length());
    };
    Vector4.prototype.setLength = function (length) {
        return this.multiplyScalar(length / this.length());
    };
    Vector4.prototype.lerp = function (v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    };
    Vector4.prototype.lerpVectors = function (v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    };
    Vector4.prototype.equals = function (v) {
        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
    };
    Vector4.prototype.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    };
    Vector4.prototype.toArray = function (array, offset) {
        if (array === void 0) { array = []; }
        if (offset === void 0) { offset = 0; }
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    };
    Vector4.prototype.fromAttribute = function (attribute, index, offset) {
        if (offset === void 0) { offset = 0; }
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        this.w = attribute.array[index + 3];
        return this;
    };
    Vector4._clampScalar_min = new Vector4();
    Vector4._clampScalar_max = new Vector4();
    return Vector4;
}());

var WebGLRenderTarget = (function (_super) {
    __extends(WebGLRenderTarget, _super);
    /*
     In options, we can specify:
     * Texture parameters for an auto-generated target texture
     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
    */
    function WebGLRenderTarget(width, height, options) {
        _super.call(this);
        this.isWebGLRenderTarget = true;
        this.uuid = _Math.generateUUID();
        this.width = width;
        this.height = height;
        this.scissor = new Vector4(0, 0, width, height);
        this.scissorTest = false;
        this.viewport = new Vector4(0, 0, width, height);
        options = options || {};
        if (options.minFilter === undefined)
            options.minFilter = TextureFilter.Linear;
        this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
        this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    }
    WebGLRenderTarget.prototype.setSize = function (width, height) {
        if (this.width !== width || this.height !== height) {
            this.width = width;
            this.height = height;
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
    };
    WebGLRenderTarget.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    WebGLRenderTarget.prototype.copy = function (source) {
        this.width = source.width;
        this.height = source.height;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
    };
    WebGLRenderTarget.prototype.dispose = function () {
        this.dispatchEvent({ type: 'dispose' });
    };
    Object.defineProperty(WebGLRenderTarget.prototype, "wrapS", {
        get: function () {
            console.warn("THREE.WebGLRenderTarget .wrapS is now .texture.wrapS.");
            return this.texture.wrapS;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderTarget .wrapS is now .texture.wrapS.");
            this.texture.wrapS = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderTarget.prototype, "wrapT", {
        get: function () {
            console.warn("THREE.WebGLRenderTarget .wrapT is now .texture.wrapT.");
            return this.texture.wrapT;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderTarget .wrapT is now .texture.wrapT.");
            this.texture.wrapT = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderTarget.prototype, "magFilter", {
        get: function () {
            console.warn("THREE.WebGLRenderTarget .magFilter is now .texture.magFilter.");
            return this.texture.magFilter;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderTarget .magFilter is now .texture.magFilter.");
            this.texture.magFilter = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderTarget.prototype, "minFilter", {
        get: function () {
            console.warn("THREE.WebGLRenderTarget .minFilter is now .texture.minFilter.");
            return this.texture.minFilter;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderTarget .minFilter is now .texture.minFilter.");
            this.texture.minFilter = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderTarget.prototype, "anisotropy", {
        get: function () {
            console.warn("THREE.WebGLRenderTarget .anisotropy is now .texture.anisotropy.");
            return this.texture.anisotropy;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderTarget .anisotropy is now .texture.anisotropy.");
            this.texture.anisotropy = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderTarget.prototype, "offset", {
        get: function () {
            console.warn("THREE.WebGLRenderTarget .offset is now .texture.offset.");
            return this.texture.offset;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderTarget .offset is now .texture.offset.");
            this.texture.offset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderTarget.prototype, "repeat", {
        get: function () {
            console.warn("THREE.WebGLRenderTarget .repeat is now .texture.repeat.");
            return this.texture.repeat;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderTarget .repeat is now .texture.repeat.");
            this.texture.repeat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderTarget.prototype, "format", {
        get: function () {
            console.warn("THREE.WebGLRenderTarget .format is now .texture.format.");
            return this.texture.format;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderTarget .format is now .texture.format.");
            this.texture.format = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderTarget.prototype, "type", {
        get: function () {
            console.warn("THREE.WebGLRenderTarget .type is now .texture.type.");
            return this.texture.type;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderTarget .type is now .texture.type.");
            this.texture.type = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderTarget.prototype, "generateMipmaps", {
        get: function () {
            console.warn("THREE.WebGLRenderTarget .generateMipmaps is now .texture.generateMipmaps.");
            return this.texture.generateMipmaps;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderTarget .generateMipmaps is now .texture.generateMipmaps.");
            this.texture.generateMipmaps = value;
        },
        enumerable: true,
        configurable: true
    });
    return WebGLRenderTarget;
}(EventDispatcher));

var WebGLRenderTargetCube = (function (_super) {
    __extends(WebGLRenderTargetCube, _super);
    function WebGLRenderTargetCube(width, height, options) {
        _super.call(this, width, height, options);
        this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
        this.activeMipMapLevel = 0;
        this.isWebGLRenderTargetCube = true;
    }
    return WebGLRenderTargetCube;
}(WebGLRenderTarget));

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */
var Quaternion = (function () {
    function Quaternion(x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 1; }
        this.onChangeCallback = function () { };
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
    }
    Object.defineProperty(Quaternion.prototype, "x", {
        get: function () { return this._x; },
        set: function (value) { this._x = value; this.onChangeCallback(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Quaternion.prototype, "y", {
        get: function () { return this._y; },
        set: function (value) { this._y = value; this.onChangeCallback(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Quaternion.prototype, "z", {
        get: function () { return this._z; },
        set: function (value) { this._z = value; this.onChangeCallback(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Quaternion.prototype, "w", {
        get: function () { return this._w; },
        set: function (value) { this._w = value; this.onChangeCallback(); },
        enumerable: true,
        configurable: true
    });
    Quaternion.prototype.set = function (x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this.onChangeCallback();
        return this;
    };
    Quaternion.prototype.clone = function () {
        return new this.constructor(this._x, this._y, this._z, this._w);
    };
    Quaternion.prototype.copy = function (quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this.onChangeCallback();
        return this;
    };
    Quaternion.prototype.setFromEuler = function (euler, update) {
        if (update === void 0) { update = true; }
        // http://www.mathworks.com/matlabcentral/fileexchange/
        //   20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //  content/SpinCalc.m
        var c1 = Math.cos(euler._x / 2);
        var c2 = Math.cos(euler._y / 2);
        var c3 = Math.cos(euler._z / 2);
        var s1 = Math.sin(euler._x / 2);
        var s2 = Math.sin(euler._y / 2);
        var s3 = Math.sin(euler._z / 2);
        var order = euler.order;
        if (order === 'XYZ') {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        }
        else if (order === 'YXZ') {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        else if (order === 'ZXY') {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        }
        else if (order === 'ZYX') {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        else if (order === 'YZX') {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        }
        else if (order === 'XZY') {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        if (update !== false)
            this.onChangeCallback();
        return this;
    };
    Quaternion.prototype.setFromAxisAngle = function (axis, angle) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
        // assumes axis is normalized
        var halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this.onChangeCallback();
        return this;
    };
    Quaternion.prototype.setFromRotationMatrix = function (m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        var s;
        if (trace > 0) {
            s = 0.5 / Math.sqrt(trace + 1.0);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        }
        else if (m11 > m22 && m11 > m33) {
            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
        }
        else if (m22 > m33) {
            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
        }
        else {
            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
        }
        this.onChangeCallback();
        return this;
    };
    Quaternion.prototype.setFromUnitVectors = function (vFrom, vTo) {
        // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
        // assumes direction vectors vFrom and vTo are normalized
        var v1 = Quaternion._setFromUnitVectors_v1 = (Quaternion._setFromUnitVectors_v1 || new Vector3());
        var EPS = 0.000001;
        var r = vFrom.dot(vTo) + 1;
        if (r < EPS) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                v1.set(-vFrom.y, vFrom.x, 0);
            }
            else {
                v1.set(0, -vFrom.z, vFrom.y);
            }
        }
        else {
            v1.crossVectors(vFrom, vTo);
        }
        this._x = v1.x;
        this._y = v1.y;
        this._z = v1.z;
        this._w = r;
        return this.normalize();
    };
    Quaternion.prototype.inverse = function () {
        return this.conjugate().normalize();
    };
    Quaternion.prototype.conjugate = function () {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this.onChangeCallback();
        return this;
    };
    Quaternion.prototype.dot = function (v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    };
    Quaternion.prototype.lengthSq = function () {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    };
    Quaternion.prototype.length = function () {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    };
    Quaternion.prototype.normalize = function () {
        var l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        }
        else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this.onChangeCallback();
        return this;
    };
    Quaternion.prototype.multiply = function (q, p) {
        if (p !== undefined) {
            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions(a, b) instead.');
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    };
    Quaternion.prototype.premultiply = function (q) {
        return this.multiplyQuaternions(q, this);
    };
    Quaternion.prototype.multiplyQuaternions = function (a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this.onChangeCallback();
        return this;
    };
    Quaternion.prototype.slerp = function (qb, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(qb);
        var x = this._x, y = this._y, z = this._z, w = this._w;
        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        }
        else {
            this.copy(qb);
        }
        if (cosHalfTheta >= 1.0) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
        }
        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
        if (Math.abs(sinHalfTheta) < 0.001) {
            this._w = 0.5 * (w + this._w);
            this._x = 0.5 * (x + this._x);
            this._y = 0.5 * (y + this._y);
            this._z = 0.5 * (z + this._z);
            return this;
        }
        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = (w * ratioA + this._w * ratioB);
        this._x = (x * ratioA + this._x * ratioB);
        this._y = (y * ratioA + this._y * ratioB);
        this._z = (z * ratioA + this._z * ratioB);
        this.onChangeCallback();
        return this;
    };
    Quaternion.prototype.equals = function (quaternion) {
        return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
    };
    Quaternion.prototype.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this.onChangeCallback();
        return this;
    };
    Quaternion.prototype.toArray = function (array, offset) {
        if (array === void 0) { array = []; }
        if (offset === void 0) { offset = 0; }
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    };
    Quaternion.prototype.onChange = function (callback) {
        this.onChangeCallback = callback;
        return this;
    };
    Quaternion.slerp = function (qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t);
    };
    Quaternion.slerpFlat = function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        var x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = (cos >= 0 ? 1 : -1), sqrSin = 1 - cos * cos;
            // Skip the Slerp for tiny steps to avoid numeric problems:
            if (sqrSin > Number.EPSILON) {
                var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin;
                t = Math.sin(t * len) / sin;
            }
            var tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            // Normalize in case we just did a lerp:
            if (s === 1 - t) {
                var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    };
    Quaternion.prototype.multiplyVector3 = function (vector) {
        console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion(quaternion) instead.");
        return vector.applyQuaternion(this);
    };
    return Quaternion;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */
var Vector3 = (function () {
    function Vector3(x, y, z) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        this.isVector3 = true;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    Vector3.prototype.set = function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    };
    Vector3.prototype.setScalar = function (scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    };
    Vector3.prototype.setX = function (x) {
        this.x = x;
        return this;
    };
    Vector3.prototype.setY = function (y) {
        this.y = y;
        return this;
    };
    Vector3.prototype.setZ = function (z) {
        this.z = z;
        return this;
    };
    Vector3.prototype.setComponent = function (index, value) {
        switch (index) {
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default: throw new Error('index is out of range: ' + index);
        }
        return this;
    };
    Vector3.prototype.getComponent = function (index) {
        switch (index) {
            case 0: return this.x;
            case 1: return this.y;
            case 2: return this.z;
            default: throw new Error('index is out of range: ' + index);
        }
    };
    Vector3.prototype.clone = function () {
        return new this.constructor(this.x, this.y, this.z);
    };
    Vector3.prototype.copy = function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    };
    Vector3.prototype.add = function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors(a, b) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    };
    Vector3.prototype.addScalar = function (s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    };
    Vector3.prototype.addVectors = function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    };
    Vector3.prototype.addScaledVector = function (v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    };
    Vector3.prototype.sub = function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors(a, b) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    };
    Vector3.prototype.subScalar = function (s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    };
    Vector3.prototype.subVectors = function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    };
    Vector3.prototype.multiply = function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors(a, b) instead.');
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    };
    Vector3.prototype.multiplyScalar = function (scalar) {
        if (isFinite(scalar)) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
        }
        else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }
        return this;
    };
    Vector3.prototype.multiplyVectors = function (a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    };
    Vector3.prototype.applyEuler = function (euler) {
        var quaternion = Vector3._applyEuler_quaternion;
        return this.applyQuaternion(quaternion.setFromEuler(euler));
    };
    Vector3.prototype.applyAxisAngle = function (axis, angle) {
        var quaternion = Vector3._applyAxisAngle_quaternion;
        return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
    };
    Vector3.prototype.applyMatrix3 = function (m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
    };
    Vector3.prototype.applyMatrix4 = function (m) {
        // input: THREE.Matrix4 affine matrix
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return this;
    };
    Vector3.prototype.applyProjection = function (m) {
        // input: THREE.Matrix4 projection matrix
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]); // perspective divide
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
        return this;
    };
    Vector3.prototype.applyQuaternion = function (q) {
        var x = this.x, y = this.y, z = this.z;
        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        // calculate quat * vector
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        // calculate result * inverse quat
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    };
    Vector3.prototype.project = function (camera) {
        var matrix = Vector3._project_matrix = (Vector3._project_matrix || new Matrix4());
        matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
        return this.applyProjection(matrix);
    };
    Vector3.prototype.unproject = function (camera) {
        var matrix = Vector3._unproject_matrix = (Vector3._unproject_matrix || new Matrix4());
        matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
        return this.applyProjection(matrix);
    };
    Vector3.prototype.transformDirection = function (m) {
        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
    };
    Vector3.prototype.divide = function (v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    };
    Vector3.prototype.divideScalar = function (scalar) {
        return this.multiplyScalar(1 / scalar);
    };
    Vector3.prototype.min = function (v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    };
    Vector3.prototype.max = function (v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    };
    Vector3.prototype.clamp = function (min, max) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    };
    Vector3.prototype.clampScalar = function (minVal, maxVal) {
        var min = Vector3._clampScalar_min, max = Vector3._clampScalar_max;
        min.set(minVal, minVal, minVal);
        max.set(maxVal, maxVal, maxVal);
        return this.clamp(min, max);
    };
    Vector3.prototype.clampLength = function (min, max) {
        var length = this.length();
        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
    };
    Vector3.prototype.floor = function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    };
    Vector3.prototype.ceil = function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    };
    Vector3.prototype.round = function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    };
    Vector3.prototype.roundToZero = function () {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    };
    Vector3.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    };
    Vector3.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    };
    Vector3.prototype.lengthSq = function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    };
    Vector3.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };
    Vector3.prototype.lengthManhattan = function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    };
    Vector3.prototype.normalize = function () {
        return this.divideScalar(this.length());
    };
    Vector3.prototype.setLength = function (length) {
        return this.multiplyScalar(length / this.length());
    };
    Vector3.prototype.lerp = function (v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    };
    Vector3.prototype.lerpVectors = function (v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    };
    Vector3.prototype.cross = function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors(a, b) instead.');
            return this.crossVectors(v, w);
        }
        var x = this.x, y = this.y, z = this.z;
        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;
        return this;
    };
    Vector3.prototype.crossVectors = function (a, b) {
        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    };
    Vector3.prototype.projectOnVector = function (vector) {
        var scalar = vector.dot(this) / vector.lengthSq();
        return this.copy(vector).multiplyScalar(scalar);
    };
    Vector3.prototype.projectOnPlane = function (planeNormal) {
        var v1 = Vector3._projectOnPlane_v1;
        v1.copy(this).projectOnVector(planeNormal);
        return this.sub(v1);
    };
    Vector3.prototype.reflect = function (normal) {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        var v1 = Vector3._reflect_v1;
        return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
    };
    Vector3.prototype.angleTo = function (v) {
        var theta = this.dot(v) / (Math.sqrt(this.lengthSq() * v.lengthSq()));
        // clamp, to handle numerical problems
        return Math.acos(_Math.clamp(theta, -1, 1));
    };
    Vector3.prototype.distanceTo = function (v) {
        return Math.sqrt(this.distanceToSquared(v));
    };
    Vector3.prototype.distanceToSquared = function (v) {
        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    };
    Vector3.prototype.distanceToManhattan = function (v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    };
    Vector3.prototype.setFromSpherical = function (s) {
        var sinPhiRadius = Math.sin(s.phi) * s.radius;
        this.x = sinPhiRadius * Math.sin(s.theta);
        this.y = Math.cos(s.phi) * s.radius;
        this.z = sinPhiRadius * Math.cos(s.theta);
        return this;
    };
    Vector3.prototype.setFromMatrixPosition = function (m) {
        return this.setFromMatrixColumn(m, 3);
    };
    Vector3.prototype.setFromMatrixScale = function (m) {
        var sx = this.setFromMatrixColumn(m, 0).length();
        var sy = this.setFromMatrixColumn(m, 1).length();
        var sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    };
    Vector3.prototype.setFromMatrixColumn = function (m, index) {
        //if (typeof m === 'number') {
        //  console.warn('THREE.Vector3: setFromMatrixColumn now expects (matrix, index).');
        //  const temp = m;
        //  m = index;
        //  index = temp;
        //}
        return this.fromArray(m.elements, index * 4);
    };
    Vector3.prototype.equals = function (v) {
        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
    };
    Vector3.prototype.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    };
    Vector3.prototype.toArray = function (array, offset) {
        if (array === void 0) { array = []; }
        if (offset === void 0) { offset = 0; }
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    };
    Vector3.prototype.fromAttribute = function (attribute, index, offset) {
        if (offset === void 0) { offset = 0; }
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        return this;
    };
    Vector3.prototype.setEulerFromRotationMatrix = function () {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    };
    Vector3.prototype.setEulerFromQuaternion = function () {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    };
    Vector3.prototype.getPositionFromMatrix = function (m) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m);
    };
    Vector3.prototype.getScaleFromMatrix = function (m) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m);
    };
    Vector3.prototype.getColumnFromMatrix = function (index, matrix) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(matrix, index);
    };
    Vector3._applyEuler_quaternion = new Quaternion();
    Vector3._applyAxisAngle_quaternion = new Quaternion();
    Vector3._clampScalar_min = new Vector3();
    Vector3._clampScalar_max = new Vector3();
    Vector3._projectOnPlane_v1 = new Vector3();
    Vector3._reflect_v1 = new Vector3();
    return Vector3;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */
var Euler = (function () {
    function Euler(x, y, z, order) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (order === void 0) { order = Euler.DefaultOrder; }
        this._order = Euler.DefaultOrder;
        this.onChangeCallback = function () { };
        this.isEuler = true;
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
    }
    Object.defineProperty(Euler.prototype, "x", {
        get: function () {
            return this._x;
        },
        set: function (value) {
            this._x = value;
            this.onChangeCallback();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Euler.prototype, "y", {
        get: function () {
            return this._y;
        },
        set: function (value) {
            this._y = value;
            this.onChangeCallback();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Euler.prototype, "z", {
        get: function () {
            return this._z;
        },
        set: function (value) {
            this._z = value;
            this.onChangeCallback();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Euler.prototype, "order", {
        get: function () {
            return this._order;
        },
        set: function (value) {
            this._order = value;
            this.onChangeCallback();
        },
        enumerable: true,
        configurable: true
    });
    Euler.prototype.set = function (x, y, z, order) {
        if (order === void 0) { order = this._order; }
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
        this.onChangeCallback();
        return this;
    };
    Euler.prototype.clone = function () {
        return new this.constructor(this._x, this._y, this._z, this._order);
    };
    Euler.prototype.copy = function (euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this.onChangeCallback();
        return this;
    };
    Euler.prototype.setFromRotationMatrix = function (m, order, update) {
        if (order === void 0) { order = this._order; }
        if (update === void 0) { update = true; }
        var clamp = _Math.clamp;
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var te = m.elements;
        var m11 = te[0], m12 = te[4], m13 = te[8];
        var m21 = te[1], m22 = te[5], m23 = te[9];
        var m31 = te[2], m32 = te[6], m33 = te[10];
        if (order === 'XYZ') {
            this._y = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < 0.99999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
            }
            else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
            }
        }
        else if (order === 'YXZ') {
            this._x = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < 0.99999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
            }
            else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
            }
        }
        else if (order === 'ZXY') {
            this._x = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < 0.99999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
            }
            else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
            }
        }
        else if (order === 'ZYX') {
            this._y = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < 0.99999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
            }
            else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
            }
        }
        else if (order === 'YZX') {
            this._z = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < 0.99999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
            }
            else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
            }
        }
        else if (order === 'XZY') {
            this._z = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < 0.99999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
            }
            else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
            }
        }
        else {
            console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
        }
        this._order = order;
        if (update !== false)
            this.onChangeCallback();
        return this;
    };
    Euler.prototype.setFromQuaternion = function (q, order, update) {
        if (update === void 0) { update = false; }
        var matrix = Euler._setFromQuaternion_matrix || (Euler._setFromQuaternion_matrix = new Matrix4());
        matrix.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(matrix, order, update);
    };
    Euler.prototype.setFromVector3 = function (v, order) {
        if (order === void 0) { order = this._order; }
        return this.set(v.x, v.y, v.z, order);
    };
    Euler.prototype.reorder = function (newOrder) {
        // WARNING: this discards revolution information -bhouston
        var q = Euler._reorder_q || (Euler._reorder_q = new Quaternion());
        q.setFromEuler(this);
        return this.setFromQuaternion(q, newOrder);
    };
    Euler.prototype.equals = function (euler) {
        return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
    };
    Euler.prototype.fromArray = function (array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined)
            this._order = array[3];
        this.onChangeCallback();
        return this;
    };
    Euler.prototype.toArray = function (array, offset) {
        if (array === void 0) { array = []; }
        if (offset === void 0) { offset = 0; }
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    };
    Euler.prototype.toVector3 = function (result) {
        if (result === void 0) { result = new Vector3(); }
        return result.set(this._x, this._y, this._z);
    };
    Euler.prototype.onChange = function (callback) {
        this.onChangeCallback = callback;
        return this;
    };
    Euler.DefaultOrder = 'XYZ';
    Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
    return Euler;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */
var Matrix4 = (function () {
    function Matrix4() {
        this.isMatrix4 = true;
        this.elements = new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
        if (arguments.length > 0) {
            console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
        }
    }
    Matrix4.prototype.set = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    };
    Matrix4.prototype.identity = function () {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    };
    Matrix4.prototype.clone = function () {
        return new this.constructor().fromArray(this.elements);
    };
    Matrix4.prototype.copy = function (m) {
        this.elements.set(m.elements);
        return this;
    };
    Matrix4.prototype.copyPosition = function (m) {
        var te = this.elements;
        var me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    };
    Matrix4.prototype.extractBasis = function (xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    };
    Matrix4.prototype.makeBasis = function (xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    };
    Matrix4.prototype.extractRotation = function (m) {
        var v1 = Matrix4._extractRotation_v1;
        var te = this.elements;
        var me = m.elements;
        var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
        var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
        var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        return this;
    };
    Matrix4.prototype.makeRotationFromEuler = function (euler) {
        if ((euler && euler instanceof Euler) === false) {
            console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var te = this.elements;
        var x = euler.x, y = euler.y, z = euler.z;
        var a = Math.cos(x), b = Math.sin(x);
        var c = Math.cos(y), d = Math.sin(y);
        var e = Math.cos(z), f = Math.sin(z);
        if (euler.order === 'XYZ') {
            var ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
        }
        else if (euler.order === 'YXZ') {
            var ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
        }
        else if (euler.order === 'ZXY') {
            var ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
        }
        else if (euler.order === 'ZYX') {
            var ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
        }
        else if (euler.order === 'YZX') {
            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        }
        else if (euler.order === 'XZY') {
            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
        }
        // last column
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        // bottom row
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    };
    Matrix4.prototype.makeRotationFromQuaternion = function (q) {
        var te = this.elements;
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;
        te[0] = 1 - (yy + zz);
        te[4] = xy - wz;
        te[8] = xz + wy;
        te[1] = xy + wz;
        te[5] = 1 - (xx + zz);
        te[9] = yz - wx;
        te[2] = xz - wy;
        te[6] = yz + wx;
        te[10] = 1 - (xx + yy);
        // last column
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        // bottom row
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    };
    Matrix4.prototype.lookAt = function (eye, target, up) {
        var x = Matrix4._lookAt_x;
        var y = Matrix4._lookAt_y;
        var z = Matrix4._lookAt_z;
        var te = this.elements;
        z.subVectors(eye, target).normalize();
        if (z.lengthSq() === 0) {
            z.z = 1;
        }
        x.crossVectors(up, z).normalize();
        if (x.lengthSq() === 0) {
            z.z += 0.0001;
            x.crossVectors(up, z).normalize();
        }
        y.crossVectors(z, x);
        te[0] = x.x;
        te[4] = y.x;
        te[8] = z.x;
        te[1] = x.y;
        te[5] = y.y;
        te[9] = z.y;
        te[2] = x.z;
        te[6] = y.z;
        te[10] = z.z;
        return this;
    };
    Matrix4.prototype.multiply = function (m, n) {
        if (n !== undefined) {
            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices(a, b) instead.');
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    };
    Matrix4.prototype.premultiply = function (m) {
        return this.multiplyMatrices(m, this);
    };
    Matrix4.prototype.multiplyMatrices = function (a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    };
    Matrix4.prototype.multiplyToArray = function (a, b, r) {
        var te = this.elements;
        this.multiplyMatrices(a, b);
        r[0] = te[0];
        r[1] = te[1];
        r[2] = te[2];
        r[3] = te[3];
        r[4] = te[4];
        r[5] = te[5];
        r[6] = te[6];
        r[7] = te[7];
        r[8] = te[8];
        r[9] = te[9];
        r[10] = te[10];
        r[11] = te[11];
        r[12] = te[12];
        r[13] = te[13];
        r[14] = te[14];
        r[15] = te[15];
        return this;
    };
    Matrix4.prototype.multiplyScalar = function (s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    };
    Matrix4.prototype.applyToVector3Array = function (array, offset, length) {
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = array.length; }
        var v1 = Matrix4._applyToVector3Array_v1;
        for (var i = 0, j = offset; i < length; i += 3, j += 3) {
            v1.fromArray(array, j);
            v1.applyMatrix4(this);
            v1.toArray(array, j);
        }
        return array;
    };
    Matrix4.prototype.applyToBuffer = function (buffer, offset, length) {
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = buffer.length / buffer.itemSize; }
        var v1 = Matrix4._applyToBuffer_v1;
        for (var i = 0, j = offset; i < length; i++, j++) {
            v1.x = buffer.getX(j);
            v1.y = buffer.getY(j);
            v1.z = buffer.getZ(j);
            v1.applyMatrix4(this);
            buffer.setXYZ(j, v1.x, v1.y, v1.z);
        }
        return buffer;
    };
    Matrix4.prototype.determinant = function () {
        var te = this.elements;
        var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        //TODO: make this more efficient
        //(based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm)
        return (n41 * (+n14 * n23 * n32
            - n13 * n24 * n32
            - n14 * n22 * n33
            + n12 * n24 * n33
            + n13 * n22 * n34
            - n12 * n23 * n34) +
            n42 * (+n11 * n23 * n34
                - n11 * n24 * n33
                + n14 * n21 * n33
                - n13 * n21 * n34
                + n13 * n24 * n31
                - n14 * n23 * n31) +
            n43 * (+n11 * n24 * n32
                - n11 * n22 * n34
                - n14 * n21 * n32
                + n12 * n21 * n34
                + n14 * n22 * n31
                - n12 * n24 * n31) +
            n44 * (-n13 * n22 * n31
                - n11 * n23 * n32
                + n11 * n22 * n33
                + n13 * n21 * n32
                - n12 * n21 * n33
                + n12 * n23 * n31));
    };
    Matrix4.prototype.transpose = function () {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
    };
    Matrix4.prototype.flattenToArrayOffset = function (array, offset) {
        if (array === void 0) { array = []; }
        if (offset === void 0) { offset = 0; }
        console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated " +
            "- just use .toArray instead.");
        return this.toArray(array, offset);
    };
    Matrix4.prototype.getPosition = function () {
        var v1 = Matrix4._getPosition_v1;
        console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition(matrix) instead.');
        return v1.setFromMatrixColumn(this, 3);
    };
    Matrix4.prototype.setPosition = function (v) {
        var te = this.elements;
        te[12] = v.x;
        te[13] = v.y;
        te[14] = v.z;
        return this;
    };
    Matrix4.prototype.getInverse = function (m, throwOnDegenerate) {
        if (throwOnDegenerate === void 0) { throwOnDegenerate = false; }
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) {
            var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
            if (throwOnDegenerate === true) {
                throw new Error(msg);
            }
            else {
                console.warn(msg);
            }
            return this.identity();
        }
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    };
    Matrix4.prototype.scale = function (v) {
        var te = this.elements;
        var x = v.x, y = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
    };
    Matrix4.prototype.getMaxScaleOnAxis = function () {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    };
    Matrix4.prototype.makeTranslation = function (x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    };
    Matrix4.prototype.makeRotationX = function (theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
    };
    Matrix4.prototype.makeRotationY = function (theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
    };
    Matrix4.prototype.makeRotationZ = function (theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    };
    Matrix4.prototype.makeRotationAxis = function (axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x, y = axis.y, z = axis.z;
        var tx = t * x, ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
    };
    Matrix4.prototype.makeScale = function (x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    };
    Matrix4.prototype.compose = function (position, quaternion, scale) {
        this.makeRotationFromQuaternion(quaternion);
        this.scale(scale);
        this.setPosition(position);
        return this;
    };
    Matrix4.prototype.decompose = function (position, quaternion, scale) {
        var vector = Matrix4._decompose_vector, matrix = Matrix4._decompose_matrix;
        var te = this.elements;
        var sx = vector.set(te[0], te[1], te[2]).length();
        var sy = vector.set(te[4], te[5], te[6]).length();
        var sz = vector.set(te[8], te[9], te[10]).length();
        // if determine is negative, we need to invert one scale
        var det = this.determinant();
        if (det < 0) {
            sx = -sx;
        }
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        // scale the rotation part
        matrix.elements.set(this.elements); // at this point matrix is incomplete so we can't use .copy()
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        matrix.elements[0] *= invSX;
        matrix.elements[1] *= invSX;
        matrix.elements[2] *= invSX;
        matrix.elements[4] *= invSY;
        matrix.elements[5] *= invSY;
        matrix.elements[6] *= invSY;
        matrix.elements[8] *= invSZ;
        matrix.elements[9] *= invSZ;
        matrix.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(matrix);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    };
    Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    };
    Matrix4.prototype.makePerspective = function (fov, aspect, near, far) {
        var ymax = near * Math.tan(_Math.DEG2RAD * fov * 0.5);
        var ymin = -ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;
        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
    };
    Matrix4.prototype.makeOrthographic = function (left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = 1.0 / (right - left);
        var h = 1.0 / (top - bottom);
        var p = 1.0 / (far - near);
        var x = (right + left) * w;
        var y = (top + bottom) * h;
        var z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    };
    Matrix4.prototype.equals = function (matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i = 0; i < 16; i++) {
            if (te[i] !== me[i])
                return false;
        }
        return true;
    };
    Matrix4.prototype.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        for (var i = 0; i < 16; i++) {
            this.elements[i] = array[i + offset];
        }
        return this;
    };
    Matrix4.prototype.toArray = function (array, offset) {
        if (array === void 0) { array = []; }
        if (offset === void 0) { offset = 0; }
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    };
    Matrix4.prototype.extractPosition = function (m) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m);
    };
    Matrix4.prototype.setRotationFromQuaternion = function (q) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q);
    };
    Matrix4.prototype.multiplyVector3 = function (vector) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4(matrix) or vector.applyProjection(matrix) instead.");
        return vector.applyProjection(this);
    };
    Matrix4.prototype.multiplyVector4 = function (vector) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4(matrix) instead.");
        return vector.applyMatrix4(this);
    };
    Matrix4.prototype.multiplyVector3Array = function (a) {
        console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array(array) instead.");
        return this.applyToVector3Array(a);
    };
    Matrix4.prototype.rotateAxis = function (v) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection(matrix) instead.");
        v.transformDirection(this);
    };
    Matrix4.prototype.crossVector = function (vector) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4(matrix) instead.");
        return vector.applyMatrix4(this);
    };
    Matrix4.prototype.translate = function (v) {
        console.error("THREE.Matrix4: .translate() has been removed.");
    };
    Matrix4.prototype.rotateX = function (angle) {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
    };
    Matrix4.prototype.rotateY = function (angle) {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
    };
    Matrix4.prototype.rotateZ = function (angle) {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
    };
    Matrix4.prototype.rotateByAxis = function (axis, angle) {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    };
    Matrix4._extractRotation_v1 = new Vector3();
    Matrix4._lookAt_x = new Vector3();
    Matrix4._lookAt_y = new Vector3();
    Matrix4._lookAt_z = new Vector3();
    Matrix4._applyToVector3Array_v1 = new Vector3();
    Matrix4._applyToBuffer_v1 = new Vector3();
    Matrix4._getPosition_v1 = new Vector3();
    Matrix4._decompose_vector = new Vector3();
    Matrix4._decompose_matrix = new Matrix4();
    return Matrix4;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var CubeTexture = (function (_super) {
    __extends(CubeTexture, _super);
    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        if (images === void 0) { images = []; }
        if (mapping === void 0) { mapping = TextureMapping.CubeReflection; }
        _super.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.isCubeTexture = true;
        this.flipY = false;
    }
    Object.defineProperty(CubeTexture.prototype, "images", {
        get: function () { return this.image; },
        set: function (value) { this.image = value; },
        enumerable: true,
        configurable: true
    });
    return CubeTexture;
}(Texture));

var emptyTexture = new Texture();
var emptyCubeTexture = new CubeTexture();
// --- Base for inner nodes (including the root) ---
var UniformContainer = (function () {
    function UniformContainer() {
        this.seq = [];
        this.map = [];
    }
    return UniformContainer;
}());
// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
var arrayCacheF32 = [];
var arrayCacheI32 = [];
// Flattening for arrays of vectors and matrices
function flatten(array, nBlocks, blockSize) {
    var firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
        return array;
    // unoptimized: ! isNaN(firstElem)
    // see http://jacksondunstan.com/articles/983
    var n = nBlocks * blockSize;
    var r = arrayCacheF32[n];
    if (r === undefined) {
        r = new Float32Array(n);
        arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for (var i = 1, offset = 0; i !== nBlocks; ++i) {
            offset += blockSize;
            array[i].toArray(r, offset);
        }
    }
    return r;
}
// Texture unit allocation
function allocTexUnits(renderer, n) {
    var r = arrayCacheI32[n];
    if (r === undefined) {
        r = new Int32Array(n);
        arrayCacheI32[n] = r;
    }
    for (var i = 0; i !== n; ++i)
        r[i] = renderer.allocTextureUnit();
    return r;
}
// --- Uniform Classes ---
var SingleUniform = (function () {
    function SingleUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.setValue = this.getSingularSetter(activeInfo.type);
        // this.path = activeInfo.name; // DEBUG
    }
    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.
    // Single scalar
    SingleUniform.prototype.setValue1f = function (gl, v) { gl.uniform1f(this.addr, v); };
    SingleUniform.prototype.setValue1i = function (gl, v) { gl.uniform1i(this.addr, v); };
    // Single float vector (from flat array or THREE.VectorN)
    SingleUniform.prototype.setValue2fv = function (gl, v) {
        if (v.x === undefined)
            gl.uniform2fv(this.addr, v);
        else
            gl.uniform2f(this.addr, v.x, v.y);
    };
    SingleUniform.prototype.setValue3fv = function (gl, v) {
        if (v.x !== undefined)
            gl.uniform3f(this.addr, v.x, v.y, v.z);
        else if (v.r !== undefined)
            gl.uniform3f(this.addr, v.r, v.g, v.b);
        else
            gl.uniform3fv(this.addr, v);
    };
    SingleUniform.prototype.setValue4fv = function (gl, v) {
        if (v.x === undefined)
            gl.uniform4fv(this.addr, v);
        else
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
    };
    // Single matrix (from flat array or MatrixN)
    SingleUniform.prototype.setValue2fm = function (gl, v) {
        gl.uniformMatrix2fv(this.addr, false, v.elements || v);
    };
    SingleUniform.prototype.setValue3fm = function (gl, v) {
        gl.uniformMatrix3fv(this.addr, false, v.elements || v);
    };
    SingleUniform.prototype.setValue4fm = function (gl, v) {
        gl.uniformMatrix4fv(this.addr, false, v.elements || v);
    };
    // Single texture (2D / Cube)
    SingleUniform.prototype.setValueT1 = function (gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit);
        renderer.setTexture2D(v || emptyTexture, unit);
    };
    SingleUniform.prototype.setValueT6 = function (gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit);
        renderer.setTextureCube(v || emptyCubeTexture, unit);
    };
    // Integer / Boolean vectors or arrays thereof (always flat arrays)
    SingleUniform.prototype.setValue2iv = function (gl, v) { gl.uniform2iv(this.addr, v); };
    SingleUniform.prototype.setValue3iv = function (gl, v) { gl.uniform3iv(this.addr, v); };
    SingleUniform.prototype.setValue4iv = function (gl, v) { gl.uniform4iv(this.addr, v); };
    // Helper to pick the right setter for the singular case
    SingleUniform.prototype.getSingularSetter = function (type) {
        switch (type) {
            case 0x1406: return this.setValue1f; // FLOAT
            case 0x8b50: return this.setValue2fv; // _VEC2
            case 0x8b51: return this.setValue3fv; // _VEC3
            case 0x8b52: return this.setValue4fv; // _VEC4
            case 0x8b5a: return this.setValue2fm; // _MAT2
            case 0x8b5b: return this.setValue3fm; // _MAT3
            case 0x8b5c: return this.setValue4fm; // _MAT4
            case 0x8b5e: return this.setValueT1; // SAMPLER_2D
            case 0x8b60: return this.setValueT6; // SAMPLER_CUBE
            case 0x1404:
            case 0x8b56: return this.setValue1i; // INT, BOOL
            case 0x8b53:
            case 0x8b57: return this.setValue2iv; // _VEC2
            case 0x8b54:
            case 0x8b58: return this.setValue3iv; // _VEC3
            case 0x8b55:
            case 0x8b59: return this.setValue4iv; // _VEC4
        }
    };
    return SingleUniform;
}());
var PureArrayUniform = (function () {
    function PureArrayUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.size = activeInfo.size;
        this.setValue = this.getPureArraySetter(activeInfo.type);
        // this.path = activeInfo.name; // DEBUG
    }
    // Array of scalars
    PureArrayUniform.prototype.setValue1fv = function (gl, v) { gl.uniform1fv(this.addr, v); };
    PureArrayUniform.prototype.setValue1iv = function (gl, v) { gl.uniform1iv(this.addr, v); };
    // Array of vectors (flat or from THREE classes)
    PureArrayUniform.prototype.setValueV2a = function (gl, v) {
        gl.uniform2fv(this.addr, flatten(v, this.size, 2));
    };
    PureArrayUniform.prototype.setValueV3a = function (gl, v) {
        gl.uniform3fv(this.addr, flatten(v, this.size, 3));
    };
    PureArrayUniform.prototype.setValueV4a = function (gl, v) {
        gl.uniform4fv(this.addr, flatten(v, this.size, 4));
    };
    // Array of matrices (flat or from THREE clases)
    PureArrayUniform.prototype.setValueM2a = function (gl, v) {
        gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));
    };
    PureArrayUniform.prototype.setValueM3a = function (gl, v) {
        gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));
    };
    PureArrayUniform.prototype.setValueM4a = function (gl, v) {
        gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));
    };
    // Array of textures (2D / Cube)
    PureArrayUniform.prototype.setValueT1a = function (gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) {
            renderer.setTexture2D(v[i] || emptyTexture, units[i]);
        }
    };
    PureArrayUniform.prototype.setValueT6a = function (gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) {
            renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
        }
    };
    // Integer / Boolean vectors or arrays thereof (always flat arrays)
    PureArrayUniform.prototype.setValue2iv = function (gl, v) { gl.uniform2iv(this.addr, v); };
    PureArrayUniform.prototype.setValue3iv = function (gl, v) { gl.uniform3iv(this.addr, v); };
    PureArrayUniform.prototype.setValue4iv = function (gl, v) { gl.uniform4iv(this.addr, v); };
    // Helper to pick the right setter for a pure (bottom-level) array
    PureArrayUniform.prototype.getPureArraySetter = function (type) {
        switch (type) {
            case 0x1406: return this.setValue1fv; // FLOAT
            case 0x8b50: return this.setValueV2a; // _VEC2
            case 0x8b51: return this.setValueV3a; // _VEC3
            case 0x8b52: return this.setValueV4a; // _VEC4
            case 0x8b5a: return this.setValueM2a; // _MAT2
            case 0x8b5b: return this.setValueM3a; // _MAT3
            case 0x8b5c: return this.setValueM4a; // _MAT4
            case 0x8b5e: return this.setValueT1a; // SAMPLER_2D
            case 0x8b60: return this.setValueT6a; // SAMPLER_CUBE
            case 0x1404:
            case 0x8b56: return this.setValue1iv; // INT, BOOL
            case 0x8b53:
            case 0x8b57: return this.setValue2iv; // _VEC2
            case 0x8b54:
            case 0x8b58: return this.setValue3iv; // _VEC3
            case 0x8b55:
            case 0x8b59: return this.setValue4iv; // _VEC4
        }
    };
    return PureArrayUniform;
}());
var StructuredUniform = (function (_super) {
    __extends(StructuredUniform, _super);
    function StructuredUniform(id) {
        _super.call(this); // mix-in
        this.id = id;
    }
    StructuredUniform.prototype.setValue = function (gl, value) {
        // Note: Don't need an extra 'renderer' parameter, since samplers
        // are not allowed in structured uniforms.
        var seq = this.seq;
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            u.setValue(gl, value[u.id]);
        }
    };
    return StructuredUniform;
}(UniformContainer));
// --- Top-level ---
// Parser - builds up the property tree from the path strings
var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
// extracts
//   - the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
    var path = activeInfo.name;
    var pathLength = path.length;
    // reset RegExp object, because of the early exit of a previous run
    RePathPart.lastIndex = 0;
    for (;;) {
        var match = RePathPart.exec(path);
        var matchEnd = RePathPart.lastIndex;
        var id = match[1];
        var idIsIndex = match[2] === ']';
        var subscript = match[3];
        //if (idIsIndex) id = id | 0; // convert to integer
        if (idIsIndex)
            id = parseInt(id, 10).toString(); // convert to integer
        if (subscript === undefined ||
            subscript === '[' && matchEnd + 2 === pathLength) {
            // bare name or "pure" bottom-level array "[0]" suffix
            addUniform(container, subscript === undefined ?
                new SingleUniform(id, activeInfo, addr) :
                new PureArrayUniform(id, activeInfo, addr));
            break;
        }
        else {
            // step into inner node / create it in case it doesn't exist
            var map = container.map;
            var next = map[id];
            if (next === undefined) {
                next = new StructuredUniform(id);
                addUniform(container, next);
            }
            container = next;
        }
    }
}
// Root Container
var WebGLUniforms = (function (_super) {
    __extends(WebGLUniforms, _super);
    function WebGLUniforms(gl, program, renderer) {
        _super.call(this);
        this.renderer = renderer;
        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i !== n; ++i) {
            var info = gl.getActiveUniform(program, i), path = info.name, addr = gl.getUniformLocation(program, path);
            parseUniform(info, addr, this);
        }
    }
    WebGLUniforms.prototype.setValue = function (gl, name, value) {
        var u = this.map[name];
        if (u !== undefined)
            u.setValue(gl, value, this.renderer);
    };
    WebGLUniforms.prototype.set = function (gl, object, name) {
        var u = this.map[name];
        if (u !== undefined)
            u.setValue(gl, object[name], this.renderer);
    };
    WebGLUniforms.prototype.setOptional = function (gl, object, name) {
        var v = object[name];
        if (v !== undefined)
            this.setValue(gl, name, v);
    };
    // Static interface
    WebGLUniforms.upload = function (gl, seq, values, renderer) {
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i], v = values[u.id];
            if (v.needsUpdate !== false) {
                // note: always updating when .needsUpdate is undefined
                u.setValue(gl, v.value, renderer);
            }
        }
    };
    WebGLUniforms.seqWithValue = function (seq, values) {
        var r = [];
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            if (u.id in values)
                r.push(u);
        }
        return r;
    };
    return WebGLUniforms;
}(UniformContainer));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var Color = (function () {
    function Color(r, g, b) {
        this.r = 1;
        this.g = 1;
        this.b = 1;
        this.isColor = true;
        //if (g === undefined && b === undefined) {
        //  // r is THREE.Color, hex or string
        //  this.set(r);
        //}
        //this.setRGB(r, g, b);
        if (r instanceof Color) {
            this.copy(r);
        }
        else if (typeof (r) === 'string') {
            this.setStyle(r);
        }
        else if (typeof (r) === 'number') {
            if (typeof (g) === 'number' && typeof (b) === 'number') {
                this.setRGB(r, g, b);
            }
            else {
                this.setHex(r);
            }
        }
    }
    Color.prototype.set = function (value) {
        if (value && value instanceof Color) {
            this.copy(value);
        }
        else if (typeof (value) === 'number') {
            this.setHex(value);
        }
        else if (typeof (value) === 'string') {
            this.setStyle(value);
        }
        return this;
    };
    Color.prototype.setScalar = function (scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
    };
    Color.prototype.setHex = function (hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    };
    Color.prototype.setRGB = function (r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    };
    Color.prototype.setHSL = function (h, s, l) {
        function hue2rgb(p, q, t) {
            if (t < 0)
                t += 1;
            if (t > 1)
                t -= 1;
            if (t < 1 / 6)
                return p + (q - p) * 6 * t;
            if (t < 1 / 2)
                return q;
            if (t < 2 / 3)
                return p + (q - p) * 6 * (2 / 3 - t);
            return p;
        }
        // h,s,l ranges are in 0.0 - 1.0
        h = _Math.euclideanModulo(h, 1);
        s = _Math.clamp(s, 0, 1);
        l = _Math.clamp(l, 0, 1);
        if (s === 0) {
            this.r = this.g = this.b = l;
        }
        else {
            var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
            var q = (2 * l) - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
    };
    Color.prototype.setStyle = function (style) {
        function handleAlpha(alpha) {
            if (alpha === undefined)
                return;
            if (parseFloat(alpha) < 1) {
                console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
            }
        }
        var m;
        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
            // rgb / hsl
            var color = void 0;
            var name = m[1];
            var components = m[2];
            switch (name) {
                case 'rgb':
                case 'rgba':
                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // rgb(255,0,0) rgba(255,0,0,0.5)
                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                        handleAlpha(color[5]);
                        return this;
                    }
                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                        handleAlpha(color[5]);
                        return this;
                    }
                    break;
                case 'hsl':
                case 'hsla':
                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                        var h = parseFloat(color[1]) / 360;
                        var s = parseInt(color[2], 10) / 100;
                        var l = parseInt(color[3], 10) / 100;
                        handleAlpha(color[5]);
                        return this.setHSL(h, s, l);
                    }
                    break;
            }
        }
        else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
            // hex color
            var hex = m[1];
            var size = hex.length;
            if (size === 3) {
                // #ff0
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                return this;
            }
            else if (size === 6) {
                // #ff0000
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                return this;
            }
        }
        if (style && style.length > 0) {
            // color keywords
            var hex = ColorKeywords[style];
            if (hex !== undefined) {
                // red
                this.setHex(hex);
            }
            else {
                // unknown color
                console.warn('THREE.Color: Unknown color ' + style);
            }
        }
        return this;
    };
    Color.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Color.prototype.copy = function (color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    };
    Color.prototype.copyGammaToLinear = function (color, gammaFactor) {
        if (gammaFactor === void 0) { gammaFactor = 2.0; }
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
    };
    Color.prototype.copyLinearToGamma = function (color, gammaFactor) {
        if (gammaFactor === void 0) { gammaFactor = 2.0; }
        var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
    };
    Color.prototype.convertGammaToLinear = function () {
        var r = this.r, g = this.g, b = this.b;
        this.r = r * r;
        this.g = g * g;
        this.b = b * b;
        return this;
    };
    Color.prototype.convertLinearToGamma = function () {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this;
    };
    Color.prototype.getHex = function () {
        return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
    };
    Color.prototype.getHexString = function () {
        return ('000000' + this.getHex().toString(16)).slice(-6);
    };
    Color.prototype.getHSL = function (hsl) {
        if (hsl === void 0) { hsl = { h: 0, s: 0, l: 0 }; }
        // h,s,l ranges are in 0.0 - 1.0
        var r = this.r, g = this.g, b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue, saturation;
        var lightness = (min + max) / 2.0;
        if (min === max) {
            hue = 0;
            saturation = 0;
        }
        else {
            var delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch (max) {
                case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                case g:
                    hue = (b - r) / delta + 2;
                    break;
                case b:
                    hue = (r - g) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;
        return hsl;
    };
    Color.prototype.getStyle = function () {
        return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
    };
    Color.prototype.offsetHSL = function (h, s, l) {
        var hsl = this.getHSL();
        hsl.h += h;
        hsl.s += s;
        hsl.l += l;
        this.setHSL(hsl.h, hsl.s, hsl.l);
        return this;
    };
    Color.prototype.add = function (color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
    };
    Color.prototype.addColors = function (color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    };
    Color.prototype.addScalar = function (s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    };
    Color.prototype.sub = function (color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
    };
    Color.prototype.multiply = function (color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
    };
    Color.prototype.multiplyScalar = function (s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    };
    Color.prototype.lerp = function (color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
    };
    Color.prototype.equals = function (c) {
        return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
    };
    Color.prototype.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    };
    Color.prototype.toArray = function (array, offset) {
        if (array === void 0) { array = []; }
        if (offset === void 0) { offset = 0; }
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    };
    Color.prototype.toJSON = function (meta) {
        return this.getHex();
    };
    return Color;
}());
var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */
var Matrix3 = (function () {
    function Matrix3() {
        this.elements = new Float32Array([
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        ]);
        this.isMatrix3 = true;
        if (arguments.length > 0) {
            console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
        }
    }
    Matrix3.prototype.set = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    };
    Matrix3.prototype.identity = function () {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    };
    Matrix3.prototype.clone = function () {
        return new this.constructor().fromArray(this.elements);
    };
    Matrix3.prototype.copy = function (m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
        return this;
    };
    Matrix3.prototype.setFromMatrix4 = function (m) {
        var me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    };
    Matrix3.prototype.applyToVector3Array = function (array, offset, length) {
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = array.length; }
        var v1 = Matrix3.applyToVector3Array_v1;
        for (var i = 0, j = offset; i < length; i += 3, j += 3) {
            v1.fromArray(array, j);
            v1.applyMatrix3(this);
            v1.toArray(array, j);
        }
        return array;
    };
    Matrix3.prototype.applyToBuffer = function (buffer, offset, length) {
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = buffer.length / buffer.itemSize; }
        var v1 = Matrix3.applyToBuffer_v1;
        for (var i = 0, j = offset; i < length; i++, j++) {
            v1.x = buffer.getX(j);
            v1.y = buffer.getY(j);
            v1.z = buffer.getZ(j);
            v1.applyMatrix3(this);
            buffer.setXYZ(j, v1.x, v1.y, v1.z);
        }
        return buffer;
    };
    Matrix3.prototype.multiplyScalar = function (s) {
        var te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    };
    Matrix3.prototype.determinant = function () {
        var te = this.elements;
        var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    };
    Matrix3.prototype.getInverse = function (matrix, throwOnDegenerate) {
        if (matrix === void 0) { matrix = new Matrix3(); }
        if (throwOnDegenerate === void 0) { throwOnDegenerate = false; }
        var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) {
            var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
            if (throwOnDegenerate === true) {
                throw new Error(msg);
            }
            else {
                console.warn(msg);
            }
            return this.identity();
        }
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    };
    Matrix3.prototype.transpose = function () {
        var tmp;
        var m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
    };
    Matrix3.prototype.flattenToArrayOffset = function (array, offset) {
        if (array === void 0) { array = []; }
        console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated " +
            "- just use .toArray instead.");
        return this.toArray(array, offset);
    };
    Matrix3.prototype.getNormalMatrix = function (matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
    };
    Matrix3.prototype.transposeIntoArray = function (r) {
        var m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    };
    Matrix3.prototype.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        for (var i = 0; i < 9; i++) {
            this.elements[i] = array[i + offset];
        }
        return this;
    };
    Matrix3.prototype.toArray = function (array, offset) {
        if (array === void 0) { array = []; }
        if (offset === void 0) { offset = 0; }
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    };
    Matrix3.prototype.multiplyVector3 = function (vector) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3(matrix) instead.");
        return vector.applyMatrix3(this);
    };
    Matrix3.prototype.multiplyVector3Array = function (a) {
        console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array(array) instead.");
        return this.applyToVector3Array(a);
    };
    Matrix3.applyToVector3Array_v1 = new Vector3();
    Matrix3.applyToBuffer_v1 = new Vector3();
    return Matrix3;
}());

var UniformsUtils = (function () {
    function UniformsUtils() {
    }
    UniformsUtils.merge = function (uniforms) {
        var merged = {};
        for (var u = 0; u < uniforms.length; u++) {
            var tmp = UniformsUtils.clone(uniforms[u]);
            for (var p in tmp) {
                merged[p] = tmp[p];
            }
        }
        return merged;
    };
    UniformsUtils.clone = function (uniforms_src) {
        var uniforms_dst = {};
        for (var u in uniforms_src) {
            uniforms_dst[u] = {};
            for (var p in uniforms_src[u]) {
                var parameter_src = uniforms_src[u][p];
                if (parameter_src && (parameter_src instanceof Color ||
                    parameter_src instanceof Matrix3 || parameter_src instanceof Matrix4 ||
                    parameter_src instanceof Vector2 || parameter_src instanceof Vector3 || parameter_src instanceof Vector4 ||
                    parameter_src instanceof Texture)) {
                    uniforms_dst[u][p] = parameter_src.clone();
                }
                else if (Array.isArray(parameter_src)) {
                    uniforms_dst[u][p] = parameter_src.slice();
                }
                else {
                    uniforms_dst[u][p] = parameter_src;
                }
            }
        }
        return uniforms_dst;
    };
    return UniformsUtils;
}());

var alphamap_fragment = [
    "#ifdef USE_ALPHAMAP",
    "",
    "	diffuseColor.a *= texture2D( alphaMap, vUv ).g;",
    "",
    "#endif",
    "",
].join('\n');

var alphamap_pars_fragment = [
    "#ifdef USE_ALPHAMAP",
    "",
    "	uniform sampler2D alphaMap;",
    "",
    "#endif",
    "",
].join('\n');

var alphatest_fragment = [
    "#ifdef ALPHATEST",
    "",
    "	if ( diffuseColor.a < ALPHATEST ) discard;",
    "",
    "#endif",
    "",
].join('\n');

var aomap_fragment = [
    "#ifdef USE_AOMAP",
    "",
    "	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;",
    "",
    "	reflectedLight.indirectDiffuse *= ambientOcclusion;",
    "",
    "	#if defined( USE_ENVMAP ) && defined( PHYSICAL )",
    "",
    "		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
    "",
    "		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var aomap_pars_fragment = [
    "#ifdef USE_AOMAP",
    "",
    "	uniform sampler2D aoMap;",
    "	uniform float aoMapIntensity;",
    "",
    "#endif",
].join('\n');

var begin_vertex = [
    "",
    "vec3 transformed = vec3( position );",
    "",
].join('\n');

var beginnormal_vertex = [
    "",
    "vec3 objectNormal = vec3( normal );",
    "",
].join('\n');

var bsdfs = [
    "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {",
    "",
    "	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );",
    "",
    "}",
    "",
    "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {",
    "",
    "		if( decayExponent > 0.0 ) {",
    "",
    "#if defined ( PHYSICALLY_CORRECT_LIGHTS )",
    "",
    "			// based upon Frostbite 3 Moving to Physically-based Rendering",
    "			// page 32, equation 26: E[window1]",
    "			// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf",
    "			// this is intended to be used on spot and point lights who are represented as luminous intensity",
    "			// but who must be converted to luminous irradiance for surface lighting calculation",
    "			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );",
    "			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );",
    "			return distanceFalloff * maxDistanceCutoffFactor;",
    "",
    "#else",
    "",
    "			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );",
    "",
    "#endif",
    "",
    "		}",
    "",
    "		return 1.0;",
    "}",
    "",
    "vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {",
    "",
    "	return RECIPROCAL_PI * diffuseColor;",
    "",
    "} // validated",
    "",
    "",
    "vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {",
    "",
    "	// Original approximation by Christophe Schlick '94",
    "	//;float fresnel = pow( 1.0 - dotLH, 5.0 );",
    "",
    "	// Optimized variant (presented by Epic at SIGGRAPH '13)",
    "	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );",
    "",
    "	return ( 1.0 - specularColor ) * fresnel + specularColor;",
    "",
    "} // validated",
    "",
    "",
    "// Microfacet Models for Refraction through Rough Surfaces - equation (34)",
    "// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html",
    "// alpha is \"roughness squared\" in Disneys reparameterization",
    "float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {",
    "",
    "	// geometry term = G(l)G(v) / 4(nl)(nv)",
    "",
    "	float a2 = pow2( alpha );",
    "",
    "	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );",
    "	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );",
    "",
    "	return 1.0 / ( gl * gv );",
    "",
    "} // validated",
    "",
    "// from page 12, listing 2 of http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf",
    "float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {",
    "",
    "	float a2 = pow2( alpha );",
    "",
    "	// dotNL and dotNV are explicitly swapped. This is not a mistake.",
    "	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );",
    "	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );",
    "",
    "	return 0.5 / max( gv + gl, EPSILON );",
    "}",
    "",
    "",
    "",
    "// Microfacet Models for Refraction through Rough Surfaces - equation (33)",
    "// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html",
    "// alpha is \"roughness squared\" in Disneys reparameterization",
    "float D_GGX( const in float alpha, const in float dotNH ) {",
    "",
    "	float a2 = pow2( alpha );",
    "",
    "	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1",
    "",
    "	return RECIPROCAL_PI * a2 / pow2( denom );",
    "",
    "}",
    "",
    "",
    "// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility",
    "vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {",
    "",
    "	float alpha = pow2( roughness ); // UE4's roughness",
    "",
    "	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );",
    "",
    "	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );",
    "	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
    "	float dotNH = saturate( dot( geometry.normal, halfDir ) );",
    "	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );",
    "",
    "	vec3 F = F_Schlick( specularColor, dotLH );",
    "",
    "	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );",
    "",
    "	float D = D_GGX( alpha, dotNH );",
    "",
    "	return F * ( G * D );",
    "",
    "} // validated",
    "",
    "",
    "// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile",
    "vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {",
    "",
    "	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
    "",
    "	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );",
    "",
    "	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );",
    "",
    "	vec4 r = roughness * c0 + c1;",
    "",
    "	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;",
    "",
    "	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;",
    "",
    "	return specularColor * AB.x + AB.y;",
    "",
    "} // validated",
    "",
    "",
    "float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {",
    "",
    "	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)",
    "	return 0.25;",
    "",
    "}",
    "",
    "float D_BlinnPhong( const in float shininess, const in float dotNH ) {",
    "",
    "	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );",
    "",
    "}",
    "",
    "vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {",
    "",
    "	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );",
    "",
    "	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );",
    "	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
    "	float dotNH = saturate( dot( geometry.normal, halfDir ) );",
    "	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );",
    "",
    "	vec3 F = F_Schlick( specularColor, dotLH );",
    "",
    "	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );",
    "",
    "	float D = D_BlinnPhong( shininess, dotNH );",
    "",
    "	return F * ( G * D );",
    "",
    "} // validated",
    "",
    "// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html",
    "float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {",
    "	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );",
    "}",
    "",
    "float BlinnExponentToGGXRoughness( const in float blinnExponent ) {",
    "	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );",
    "}",
    "",
].join('\n');

var bumpmap_pars_fragment = [
    "#ifdef USE_BUMPMAP",
    "",
    "	uniform sampler2D bumpMap;",
    "	uniform float bumpScale;",
    "",
    "	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen",
    "	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html",
    "",
    "	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)",
    "",
    "	vec2 dHdxy_fwd() {",
    "",
    "		vec2 dSTdx = dFdx( vUv );",
    "		vec2 dSTdy = dFdy( vUv );",
    "",
    "		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
    "		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
    "		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",
    "",
    "		return vec2( dBx, dBy );",
    "",
    "	}",
    "",
    "	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",
    "",
    "		vec3 vSigmaX = dFdx( surf_pos );",
    "		vec3 vSigmaY = dFdy( surf_pos );",
    "		vec3 vN = surf_norm;		// normalized",
    "",
    "		vec3 R1 = cross( vSigmaY, vN );",
    "		vec3 R2 = cross( vN, vSigmaX );",
    "",
    "		float fDet = dot( vSigmaX, R1 );",
    "",
    "		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
    "		return normalize( abs( fDet ) * surf_norm - vGrad );",
    "",
    "	}",
    "",
    "#endif",
    "",
].join('\n');

var clipping_planes_fragment = [
    "#if NUM_CLIPPING_PLANES > 0",
    "",
    "	for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {",
    "",
    "		vec4 plane = clippingPlanes[ i ];",
    "		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;",
    "",
    "	}",
    "",
    "#endif",
    "",
].join('\n');

var clipping_planes_pars_fragment = [
    "#if NUM_CLIPPING_PLANES > 0",
    "",
    "	#if ! defined( PHYSICAL ) && ! defined( PHONG )",
    "		varying vec3 vViewPosition;",
    "	#endif",
    "",
    "	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];",
    "",
    "#endif",
    "",
].join('\n');

var clipping_planes_pars_vertex = [
    "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )",
    "	varying vec3 vViewPosition;",
    "#endif",
    "",
].join('\n');

var clipping_planes_vertex = [
    "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )",
    "	vViewPosition = - mvPosition.xyz;",
    "#endif",
    "",
    "",
].join('\n');

var color_fragment = [
    "#ifdef USE_COLOR",
    "",
    "	diffuseColor.rgb *= vColor;",
    "",
    "#endif",
].join('\n');

var color_pars_fragment = [
    "#ifdef USE_COLOR",
    "",
    "	varying vec3 vColor;",
    "",
    "#endif",
    "",
].join('\n');

var color_pars_vertex = [
    "#ifdef USE_COLOR",
    "",
    "	varying vec3 vColor;",
    "",
    "#endif",
].join('\n');

var color_vertex = [
    "#ifdef USE_COLOR",
    "",
    "	vColor.xyz = color.xyz;",
    "",
    "#endif",
].join('\n');

var common = [
    "#define PI 3.14159265359",
    "#define PI2 6.28318530718",
    "#define RECIPROCAL_PI 0.31830988618",
    "#define RECIPROCAL_PI2 0.15915494",
    "#define LOG2 1.442695",
    "#define EPSILON 1e-6",
    "",
    "#define saturate(a) clamp( a, 0.0, 1.0 )",
    "#define whiteCompliment(a) ( 1.0 - saturate( a ) )",
    "",
    "float pow2( const in float x ) { return x*x; }",
    "float pow3( const in float x ) { return x*x*x; }",
    "float pow4( const in float x ) { float x2 = x*x; return x2*x2; }",
    "float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }",
    "// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.",
    "// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/",
    "highp float rand( const in vec2 uv ) {",
    "	const highp float a = 12.9898, b = 78.233, c = 43758.5453;",
    "	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );",
    "	return fract(sin(sn) * c);",
    "}",
    "",
    "struct IncidentLight {",
    "	vec3 color;",
    "	vec3 direction;",
    "	bool visible;",
    "};",
    "",
    "struct ReflectedLight {",
    "	vec3 directDiffuse;",
    "	vec3 directSpecular;",
    "	vec3 indirectDiffuse;",
    "	vec3 indirectSpecular;",
    "};",
    "",
    "struct GeometricContext {",
    "	vec3 position;",
    "	vec3 normal;",
    "	vec3 viewDir;",
    "};",
    "",
    "",
    "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
    "",
    "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
    "",
    "}",
    "",
    "// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations",
    "vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {",
    "",
    "	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );",
    "",
    "}",
    "",
    "vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {",
    "",
    "	float distance = dot( planeNormal, point - pointOnPlane );",
    "",
    "	return - distance * planeNormal + point;",
    "",
    "}",
    "",
    "float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {",
    "",
    "	return sign( dot( point - pointOnPlane, planeNormal ) );",
    "",
    "}",
    "",
    "vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {",
    "",
    "	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;",
    "",
    "}",
    "",
].join('\n');

var cube_uv_reflection_fragment = [
    "#ifdef ENVMAP_TYPE_CUBE_UV",
    "",
    "#define cubeUV_textureSize (1024.0)",
    "",
    "int getFaceFromDirection(vec3 direction) {",
    "	vec3 absDirection = abs(direction);",
    "	int face = -1;",
    "	if( absDirection.x > absDirection.z ) {",
    "		if(absDirection.x > absDirection.y )",
    "			face = direction.x > 0.0 ? 0 : 3;",
    "		else",
    "			face = direction.y > 0.0 ? 1 : 4;",
    "	}",
    "	else {",
    "		if(absDirection.z > absDirection.y )",
    "			face = direction.z > 0.0 ? 2 : 5;",
    "		else",
    "			face = direction.y > 0.0 ? 1 : 4;",
    "	}",
    "	return face;",
    "}",
    "#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)",
    "#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))",
    "",
    "vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {",
    "	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);",
    "	float dxRoughness = dFdx(roughness);",
    "	float dyRoughness = dFdy(roughness);",
    "	vec3 dx = dFdx( vec * scale * dxRoughness );",
    "	vec3 dy = dFdy( vec * scale * dyRoughness );",
    "	float d = max( dot( dx, dx ), dot( dy, dy ) );",
    "	// Clamp the value to the max mip level counts. hard coded to 6 mips",
    "	d = clamp(d, 1.0, cubeUV_rangeClamp);",
    "	float mipLevel = 0.5 * log2(d);",
    "	return vec2(floor(mipLevel), fract(mipLevel));",
    "}",
    "",
    "#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)",
    "#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)",
    "",
    "vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {",
    "	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;",
    "	float a = 16.0 * cubeUV_rcpTextureSize;",
    "",
    "	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );",
    "	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;",
    "	// float powScale = exp2(roughnessLevel + mipLevel);",
    "	float powScale = exp2_packed.x * exp2_packed.y;",
    "	// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);",
    "	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;",
    "	// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);",
    "	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;",
    "",
    "	bool bRes = mipLevel == 0.0;",
    "	scale =  bRes && (scale < a) ? a : scale;",
    "",
    "	vec3 r;",
    "	vec2 offset;",
    "	int face = getFaceFromDirection(direction);",
    "",
    "	float rcpPowScale = 1.0 / powScale;",
    "",
    "	if( face == 0) {",
    "		r = vec3(direction.x, -direction.z, direction.y);",
    "		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);",
    "		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;",
    "	}",
    "	else if( face == 1) {",
    "		r = vec3(direction.y, direction.x, direction.z);",
    "		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);",
    "		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;",
    "	}",
    "	else if( face == 2) {",
    "		r = vec3(direction.z, direction.x, direction.y);",
    "		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);",
    "		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;",
    "	}",
    "	else if( face == 3) {",
    "		r = vec3(direction.x, direction.z, direction.y);",
    "		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);",
    "		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;",
    "	}",
    "	else if( face == 4) {",
    "		r = vec3(direction.y, direction.x, -direction.z);",
    "		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);",
    "		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;",
    "	}",
    "	else {",
    "		r = vec3(direction.z, -direction.x, direction.y);",
    "		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);",
    "		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;",
    "	}",
    "	r = normalize(r);",
    "	float texelOffset = 0.5 * cubeUV_rcpTextureSize;",
    "	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;",
    "	vec2 base = offset + vec2( texelOffset );",
    "	return base + s * ( scale - 2.0 * texelOffset );",
    "}",
    "",
    "#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)",
    "",
    "vec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {",
    "	float roughnessVal = roughness* cubeUV_maxLods3;",
    "	float r1 = floor(roughnessVal);",
    "	float r2 = r1 + 1.0;",
    "	float t = fract(roughnessVal);",
    "	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);",
    "	float s = mipInfo.y;",
    "	float level0 = mipInfo.x;",
    "	float level1 = level0 + 1.0;",
    "	level1 = level1 > 5.0 ? 5.0 : level1;",
    "",
    "	// round to nearest mipmap if we are not interpolating.",
    "	level0 += min( floor( s + 0.5 ), 5.0 );",
    "",
    "	// Tri linear interpolation.",
    "	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);",
    "	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));",
    "",
    "	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);",
    "	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));",
    "",
    "	vec4 result = mix(color10, color20, t);",
    "",
    "	return vec4(result.rgb, 1.0);",
    "}",
    "",
    "#endif",
    "",
].join('\n');

var defaultnormal_vertex = [
    "#ifdef FLIP_SIDED",
    "",
    "	objectNormal = -objectNormal;",
    "",
    "#endif",
    "",
    "vec3 transformedNormal = normalMatrix * objectNormal;",
    "",
].join('\n');

var displacementmap_pars_vertex = [
    "#ifdef USE_DISPLACEMENTMAP",
    "",
    "	uniform sampler2D displacementMap;",
    "	uniform float displacementScale;",
    "	uniform float displacementBias;",
    "",
    "#endif",
    "",
].join('\n');

var displacementmap_vertex = [
    "#ifdef USE_DISPLACEMENTMAP",
    "",
    "	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );",
    "",
    "#endif",
    "",
].join('\n');

var emissivemap_fragment = [
    "#ifdef USE_EMISSIVEMAP",
    "",
    "	vec4 emissiveColor = texture2D( emissiveMap, vUv );",
    "",
    "	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;",
    "",
    "	totalEmissiveRadiance *= emissiveColor.rgb;",
    "",
    "#endif",
    "",
].join('\n');

var emissivemap_pars_fragment = [
    "#ifdef USE_EMISSIVEMAP",
    "",
    "	uniform sampler2D emissiveMap;",
    "",
    "#endif",
    "",
].join('\n');

var encodings_fragment = [
    "  gl_FragColor = linearToOutputTexel( gl_FragColor );",
    "",
].join('\n');

var encodings_pars_fragment = [
    "// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/",
    "",
    "vec4 LinearToLinear( in vec4 value ) {",
    "  return value;",
    "}",
    "",
    "vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {",
    "  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );",
    "}",
    "vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {",
    "  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );",
    "}",
    "",
    "vec4 sRGBToLinear( in vec4 value ) {",
    "  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );",
    "}",
    "vec4 LinearTosRGB( in vec4 value ) {",
    "  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );",
    "}",
    "",
    "vec4 RGBEToLinear( in vec4 value ) {",
    "  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );",
    "}",
    "vec4 LinearToRGBE( in vec4 value ) {",
    "  float maxComponent = max( max( value.r, value.g ), value.b );",
    "  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );",
    "  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );",
    "//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );",
    "}",
    "",
    "// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html",
    "vec4 RGBMToLinear( in vec4 value, in float maxRange ) {",
    "  return vec4( value.xyz * value.w * maxRange, 1.0 );",
    "}",
    "vec4 LinearToRGBM( in vec4 value, in float maxRange ) {",
    "  float maxRGB = max( value.x, max( value.g, value.b ) );",
    "  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );",
    "  M            = ceil( M * 255.0 ) / 255.0;",
    "  return vec4( value.rgb / ( M * maxRange ), M );",
    "}",
    "",
    "// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html",
    "vec4 RGBDToLinear( in vec4 value, in float maxRange ) {",
    "    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );",
    "}",
    "vec4 LinearToRGBD( in vec4 value, in float maxRange ) {",
    "    float maxRGB = max( value.x, max( value.g, value.b ) );",
    "    float D      = max( maxRange / maxRGB, 1.0 );",
    "    D            = min( floor( D ) / 255.0, 1.0 );",
    "    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );",
    "}",
    "",
    "// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html",
    "",
    "// M matrix, for encoding",
    "const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );",
    "vec4 LinearToLogLuv( in vec4 value )  {",
    "  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;",
    "  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));",
    "  vec4 vResult;",
    "  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;",
    "  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;",
    "  vResult.w = fract(Le);",
    "  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;",
    "  return vResult;",
    "}",
    "",
    "// Inverse M matrix, for decoding",
    "const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );",
    "vec4 LogLuvToLinear( in vec4 value ) {",
    "  float Le = value.z * 255.0 + value.w;",
    "  vec3 Xp_Y_XYZp;",
    "  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);",
    "  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;",
    "  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;",
    "  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;",
    "  return vec4( max(vRGB, 0.0), 1.0 );",
    "}",
    "",
].join('\n');

var envmap_fragment = [
    "#ifdef USE_ENVMAP",
    "",
    "	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )",
    "",
    "		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
    "",
    "		// Transforming Normal Vectors with the Inverse Transformation",
    "		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );",
    "",
    "		#ifdef ENVMAP_MODE_REFLECTION",
    "",
    "			vec3 reflectVec = reflect( cameraToVertex, worldNormal );",
    "",
    "		#else",
    "",
    "			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );",
    "",
    "		#endif",
    "",
    "	#else",
    "",
    "		vec3 reflectVec = vReflect;",
    "",
    "	#endif",
    "",
    "	#ifdef ENVMAP_TYPE_CUBE",
    "",
    "		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",
    "",
    "	#elif defined( ENVMAP_TYPE_EQUIREC )",
    "",
    "		vec2 sampleUV;",
    "		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );",
    "		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;",
    "		vec4 envColor = texture2D( envMap, sampleUV );",
    "",
    "	#elif defined( ENVMAP_TYPE_SPHERE )",
    "",
    "		vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );",
    "		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );",
    "",
    "	#else",
    "",
    "		vec4 envColor = vec4( 0.0 );",
    "",
    "	#endif",
    "",
    "	envColor = envMapTexelToLinear( envColor );",
    "",
    "	#ifdef ENVMAP_BLENDING_MULTIPLY",
    "",
    "		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );",
    "",
    "	#elif defined( ENVMAP_BLENDING_MIX )",
    "",
    "		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );",
    "",
    "	#elif defined( ENVMAP_BLENDING_ADD )",
    "",
    "		outgoingLight += envColor.xyz * specularStrength * reflectivity;",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var envmap_pars_fragment = [
    "#if defined( USE_ENVMAP ) || defined( PHYSICAL )",
    "	uniform float reflectivity;",
    "	uniform float envMapIntenstiy;",
    "#endif",
    "",
    "#ifdef USE_ENVMAP",
    "",
    "	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )",
    "		varying vec3 vWorldPosition;",
    "	#endif",
    "",
    "	#ifdef ENVMAP_TYPE_CUBE",
    "		uniform samplerCube envMap;",
    "	#else",
    "		uniform sampler2D envMap;",
    "	#endif",
    "	uniform float flipEnvMap;",
    "",
    "	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )",
    "		uniform float refractionRatio;",
    "	#else",
    "		varying vec3 vReflect;",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var envmap_pars_vertex = [
    "#ifdef USE_ENVMAP",
    "",
    "	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )",
    "		varying vec3 vWorldPosition;",
    "",
    "	#else",
    "",
    "		varying vec3 vReflect;",
    "		uniform float refractionRatio;",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var envmap_vertex = [
    "#ifdef USE_ENVMAP",
    "",
    "	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )",
    "",
    "		vWorldPosition = worldPosition.xyz;",
    "",
    "	#else",
    "",
    "		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",
    "",
    "		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );",
    "",
    "		#ifdef ENVMAP_MODE_REFLECTION",
    "",
    "			vReflect = reflect( cameraToVertex, worldNormal );",
    "",
    "		#else",
    "",
    "			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",
    "",
    "		#endif",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var fog_fragment = [
    "#ifdef USE_FOG",
    "",
    "	#ifdef USE_LOGDEPTHBUF_EXT",
    "",
    "		float depth = gl_FragDepthEXT / gl_FragCoord.w;",
    "",
    "	#else",
    "",
    "		float depth = gl_FragCoord.z / gl_FragCoord.w;",
    "",
    "	#endif",
    "",
    "	#ifdef FOG_EXP2",
    "",
    "		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );",
    "",
    "	#else",
    "",
    "		float fogFactor = smoothstep( fogNear, fogFar, depth );",
    "",
    "	#endif",
    "",
    "	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );",
    "",
    "#endif",
    "",
].join('\n');

var fog_pars_fragment = [
    "#ifdef USE_FOG",
    "",
    "	uniform vec3 fogColor;",
    "",
    "	#ifdef FOG_EXP2",
    "",
    "		uniform float fogDensity;",
    "",
    "	#else",
    "",
    "		uniform float fogNear;",
    "		uniform float fogFar;",
    "	#endif",
    "",
    "#endif",
].join('\n');

var lightmap_fragment = [
    "#ifdef USE_LIGHTMAP",
    "",
    "	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage",
    "",
    "#endif",
    "",
].join('\n');

var lightmap_pars_fragment = [
    "#ifdef USE_LIGHTMAP",
    "",
    "	uniform sampler2D lightMap;",
    "	uniform float lightMapIntensity;",
    "",
    "#endif",
].join('\n');

var lights_lambert_vertex = [
    "vec3 diffuse = vec3( 1.0 );",
    "",
    "GeometricContext geometry;",
    "geometry.position = mvPosition.xyz;",
    "geometry.normal = normalize( transformedNormal );",
    "geometry.viewDir = normalize( -mvPosition.xyz );",
    "",
    "GeometricContext backGeometry;",
    "backGeometry.position = geometry.position;",
    "backGeometry.normal = -geometry.normal;",
    "backGeometry.viewDir = geometry.viewDir;",
    "",
    "vLightFront = vec3( 0.0 );",
    "",
    "#ifdef DOUBLE_SIDED",
    "	vLightBack = vec3( 0.0 );",
    "#endif",
    "",
    "IncidentLight directLight;",
    "float dotNL;",
    "vec3 directLightColor_Diffuse;",
    "",
    "#if NUM_POINT_LIGHTS > 0",
    "",
    "	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",
    "",
    "		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );",
    "",
    "		dotNL = dot( geometry.normal, directLight.direction );",
    "		directLightColor_Diffuse = PI * directLight.color;",
    "",
    "		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;",
    "",
    "		#ifdef DOUBLE_SIDED",
    "",
    "			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;",
    "",
    "		#endif",
    "",
    "	}",
    "",
    "#endif",
    "",
    "#if NUM_SPOT_LIGHTS > 0",
    "",
    "	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {",
    "",
    "		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );",
    "",
    "		dotNL = dot( geometry.normal, directLight.direction );",
    "		directLightColor_Diffuse = PI * directLight.color;",
    "",
    "		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;",
    "",
    "		#ifdef DOUBLE_SIDED",
    "",
    "			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;",
    "",
    "		#endif",
    "	}",
    "",
    "#endif",
    "",
    "#if NUM_DIR_LIGHTS > 0",
    "",
    "	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
    "",
    "		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );",
    "",
    "		dotNL = dot( geometry.normal, directLight.direction );",
    "		directLightColor_Diffuse = PI * directLight.color;",
    "",
    "		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;",
    "",
    "		#ifdef DOUBLE_SIDED",
    "",
    "			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;",
    "",
    "		#endif",
    "",
    "	}",
    "",
    "#endif",
    "",
    "#if NUM_HEMI_LIGHTS > 0",
    "",
    "	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {",
    "",
    "		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );",
    "",
    "		#ifdef DOUBLE_SIDED",
    "",
    "			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );",
    "",
    "		#endif",
    "",
    "	}",
    "",
    "#endif",
    "",
].join('\n');

var lights_pars = [
    "uniform vec3 ambientLightColor;",
    "",
    "vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {",
    "",
    "	vec3 irradiance = ambientLightColor;",
    "",
    "	#ifndef PHYSICALLY_CORRECT_LIGHTS",
    "",
    "		irradiance *= PI;",
    "",
    "	#endif",
    "",
    "	return irradiance;",
    "",
    "}",
    "",
    "#if NUM_DIR_LIGHTS > 0",
    "",
    "	struct DirectionalLight {",
    "		vec3 direction;",
    "		vec3 color;",
    "",
    "		int shadow;",
    "		float shadowBias;",
    "		float shadowRadius;",
    "		vec2 shadowMapSize;",
    "	};",
    "",
    "	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];",
    "",
    "	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {",
    "",
    "		directLight.color = directionalLight.color;",
    "		directLight.direction = directionalLight.direction;",
    "		directLight.visible = true;",
    "",
    "	}",
    "",
    "#endif",
    "",
    "",
    "#if NUM_POINT_LIGHTS > 0",
    "",
    "	struct PointLight {",
    "		vec3 position;",
    "		vec3 color;",
    "		float distance;",
    "		float decay;",
    "",
    "		int shadow;",
    "		float shadowBias;",
    "		float shadowRadius;",
    "		vec2 shadowMapSize;",
    "	};",
    "",
    "	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];",
    "",
    "	// directLight is an out parameter as having it as a return value caused compiler errors on some devices",
    "	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {",
    "",
    "		vec3 lVector = pointLight.position - geometry.position;",
    "		directLight.direction = normalize( lVector );",
    "",
    "		float lightDistance = length( lVector );",
    "",
    "		if ( testLightInRange( lightDistance, pointLight.distance ) ) {",
    "",
    "			directLight.color = pointLight.color;",
    "			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );",
    "",
    "			directLight.visible = true;",
    "",
    "		} else {",
    "",
    "			directLight.color = vec3( 0.0 );",
    "			directLight.visible = false;",
    "",
    "		}",
    "",
    "	}",
    "",
    "#endif",
    "",
    "",
    "#if NUM_SPOT_LIGHTS > 0",
    "",
    "	struct SpotLight {",
    "		vec3 position;",
    "		vec3 direction;",
    "		vec3 color;",
    "		float distance;",
    "		float decay;",
    "		float coneCos;",
    "		float penumbraCos;",
    "",
    "		int shadow;",
    "		float shadowBias;",
    "		float shadowRadius;",
    "		vec2 shadowMapSize;",
    "	};",
    "",
    "	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];",
    "",
    "	// directLight is an out parameter as having it as a return value caused compiler errors on some devices",
    "	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {",
    "",
    "		vec3 lVector = spotLight.position - geometry.position;",
    "		directLight.direction = normalize( lVector );",
    "",
    "		float lightDistance = length( lVector );",
    "		float angleCos = dot( directLight.direction, spotLight.direction );",
    "",
    "		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {",
    "",
    "			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );",
    "",
    "			directLight.color = spotLight.color;",
    "			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );",
    "",
    "			directLight.visible = true;",
    "",
    "		} else {",
    "",
    "			directLight.color = vec3( 0.0 );",
    "			directLight.visible = false;",
    "",
    "		}",
    "",
    "	}",
    "",
    "#endif",
    "",
    "",
    "#if NUM_HEMI_LIGHTS > 0",
    "",
    "	struct HemisphereLight {",
    "		vec3 direction;",
    "		vec3 skyColor;",
    "		vec3 groundColor;",
    "	};",
    "",
    "	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];",
    "",
    "	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {",
    "",
    "		float dotNL = dot( geometry.normal, hemiLight.direction );",
    "		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;",
    "",
    "		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );",
    "",
    "		#ifndef PHYSICALLY_CORRECT_LIGHTS",
    "",
    "			irradiance *= PI;",
    "",
    "		#endif",
    "",
    "		return irradiance;",
    "",
    "	}",
    "",
    "#endif",
    "",
    "",
    "#if defined( USE_ENVMAP ) && defined( PHYSICAL )",
    "",
    "	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {",
    "",
    "		#include <normal_flip>",
    "",
    "		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );",
    "",
    "		#ifdef ENVMAP_TYPE_CUBE",
    "",
    "			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );",
    "",
    "			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level",
    "			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.",
    "",
    "			#ifdef TEXTURE_LOD_EXT",
    "",
    "				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );",
    "",
    "			#else",
    "",
    "				// force the bias high to get the last LOD level as it is the most blurred.",
    "				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );",
    "",
    "			#endif",
    "",
    "			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;",
    "",
    "		#elif defined( ENVMAP_TYPE_CUBE_UV )",
    "",
    "			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );",
    "			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );",
    "",
    "		#else",
    "",
    "			vec4 envMapColor = vec4( 0.0 );",
    "",
    "		#endif",
    "",
    "		return PI * envMapColor.rgb * envMapIntensity;",
    "",
    "	}",
    "",
    "	// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html",
    "	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {",
    "",
    "		//float envMapWidth = pow( 2.0, maxMIPLevelScalar );",
    "		//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );",
    "",
    "		float maxMIPLevelScalar = float( maxMIPLevel );",
    "		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );",
    "",
    "		// clamp to allowable LOD ranges.",
    "		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );",
    "",
    "	}",
    "",
    "	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {",
    "",
    "		#ifdef ENVMAP_MODE_REFLECTION",
    "",
    "			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );",
    "",
    "		#else",
    "",
    "			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );",
    "",
    "		#endif",
    "",
    "		#include <normal_flip>",
    "",
    "		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );",
    "",
    "		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );",
    "",
    "		#ifdef ENVMAP_TYPE_CUBE",
    "",
    "			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );",
    "",
    "			#ifdef TEXTURE_LOD_EXT",
    "",
    "				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );",
    "",
    "			#else",
    "",
    "				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );",
    "",
    "			#endif",
    "",
    "			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;",
    "",
    "		#elif defined( ENVMAP_TYPE_CUBE_UV )",
    "",
    "			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );",
    "			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));",
    "",
    "		#elif defined( ENVMAP_TYPE_EQUIREC )",
    "",
    "			vec2 sampleUV;",
    "			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );",
    "			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;",
    "",
    "			#ifdef TEXTURE_LOD_EXT",
    "",
    "				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );",
    "",
    "			#else",
    "",
    "				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );",
    "",
    "			#endif",
    "",
    "			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;",
    "",
    "		#elif defined( ENVMAP_TYPE_SPHERE )",
    "",
    "			vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );",
    "",
    "			#ifdef TEXTURE_LOD_EXT",
    "",
    "				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );",
    "",
    "			#else",
    "",
    "				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );",
    "",
    "			#endif",
    "",
    "			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;",
    "",
    "		#endif",
    "",
    "		return envMapColor.rgb * envMapIntensity;",
    "",
    "	}",
    "",
    "#endif",
    "",
].join('\n');

var lights_phong_fragment = [
    "BlinnPhongMaterial material;",
    "material.diffuseColor = diffuseColor.rgb;",
    "material.specularColor = specular;",
    "material.specularShininess = shininess;",
    "material.specularStrength = specularStrength;",
    "",
].join('\n');

var lights_phong_pars_fragment = [
    "varying vec3 vViewPosition;",
    "",
    "#ifndef FLAT_SHADED",
    "",
    "	varying vec3 vNormal;",
    "",
    "#endif",
    "",
    "",
    "struct BlinnPhongMaterial {",
    "",
    "	vec3	diffuseColor;",
    "	vec3	specularColor;",
    "	float	specularShininess;",
    "	float	specularStrength;",
    "",
    "};",
    "",
    "void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {",
    "",
    "	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );",
    "",
    "	vec3 irradiance = dotNL * directLight.color;",
    "",
    "	#ifndef PHYSICALLY_CORRECT_LIGHTS",
    "",
    "		irradiance *= PI; // punctual light",
    "",
    "	#endif",
    "",
    "	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );",
    "	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;",
    "",
    "}",
    "",
    "void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {",
    "",
    "	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );",
    "",
    "}",
    "",
    "#define RE_Direct				RE_Direct_BlinnPhong",
    "#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong",
    "",
    "#define Material_LightProbeLOD( material )	(0)",
    "",
].join('\n');

var lights_physical_fragment = [
    "PhysicalMaterial material;",
    "material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );",
    "material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );",
    "#ifdef STANDARD",
    "	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );",
    "#else",
    "	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );",
    "	material.clearCoat = saturate( clearCoat ); // Burley clearcoat model",
    "	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );",
    "#endif",
    "",
].join('\n');

var lights_physical_pars_fragment = [
    "struct PhysicalMaterial {",
    "",
    "	vec3	diffuseColor;",
    "	float	specularRoughness;",
    "	vec3	specularColor;",
    "",
    "	#ifndef STANDARD",
    "		float clearCoat;",
    "		float clearCoatRoughness;",
    "	#endif",
    "",
    "};",
    "",
    "#define MAXIMUM_SPECULAR_COEFFICIENT 0.16",
    "#define DEFAULT_SPECULAR_COEFFICIENT 0.04",
    "",
    "// Clear coat directional hemishperical reflectance (this approximation should be improved)",
    "float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {",
    "",
    "	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );",
    "",
    "}",
    "",
    "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {",
    "",
    "	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );",
    "",
    "	vec3 irradiance = dotNL * directLight.color;",
    "",
    "	#ifndef PHYSICALLY_CORRECT_LIGHTS",
    "",
    "		irradiance *= PI; // punctual light",
    "",
    "	#endif",
    "",
    "	#ifndef STANDARD",
    "		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );",
    "	#else",
    "		float clearCoatDHR = 0.0;",
    "	#endif",
    "",
    "	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );",
    "	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );",
    "",
    "	#ifndef STANDARD",
    "",
    "		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );",
    "",
    "	#endif",
    "",
    "}",
    "",
    "void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {",
    "",
    "	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );",
    "",
    "}",
    "",
    "void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {",
    "",
    "	#ifndef STANDARD",
    "		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
    "		float dotNL = dotNV;",
    "		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );",
    "	#else",
    "		float clearCoatDHR = 0.0;",
    "	#endif",
    "",
    "	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );",
    "",
    "	#ifndef STANDARD",
    "",
    "		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );",
    "",
    "	#endif",
    "",
    "}",
    "",
    "#define RE_Direct				RE_Direct_Physical",
    "#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical",
    "#define RE_IndirectSpecular		RE_IndirectSpecular_Physical",
    "",
    "#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )",
    "#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )",
    "",
    "// ref: http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf",
    "float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {",
    "",
    "	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );",
    "",
    "}",
    "",
].join('\n');

var lights_template = [
    "//",
    "// This is a template that can be used to light a material, it uses pluggable RenderEquations (RE)",
    "//   for specific lighting scenarios.",
    "//",
    "// Instructions for use:",
    "//  - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined",
    "//  - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???",
    "//  - Create a material parameter that is to be passed as the third parameter to your lighting functions.",
    "//",
    "// TODO:",
    "//  - Add area light support.",
    "//  - Add sphere light support.",
    "//  - Add diffuse light probe (irradiance cubemap) support.",
    "//",
    "",
    "GeometricContext geometry;",
    "",
    "geometry.position = - vViewPosition;",
    "geometry.normal = normal;",
    "geometry.viewDir = normalize( vViewPosition );",
    "",
    "IncidentLight directLight;",
    "",
    "#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )",
    "",
    "	PointLight pointLight;",
    "",
    "	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",
    "",
    "		pointLight = pointLights[ i ];",
    "",
    "		getPointDirectLightIrradiance( pointLight, geometry, directLight );",
    "",
    "		#ifdef USE_SHADOWMAP",
    "		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;",
    "		#endif",
    "",
    "		RE_Direct( directLight, geometry, material, reflectedLight );",
    "",
    "	}",
    "",
    "#endif",
    "",
    "#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )",
    "",
    "	SpotLight spotLight;",
    "",
    "	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {",
    "",
    "		spotLight = spotLights[ i ];",
    "",
    "		getSpotDirectLightIrradiance( spotLight, geometry, directLight );",
    "",
    "		#ifdef USE_SHADOWMAP",
    "		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;",
    "		#endif",
    "",
    "		RE_Direct( directLight, geometry, material, reflectedLight );",
    "",
    "	}",
    "",
    "#endif",
    "",
    "#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )",
    "",
    "	DirectionalLight directionalLight;",
    "",
    "	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
    "",
    "		directionalLight = directionalLights[ i ];",
    "",
    "		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );",
    "",
    "		#ifdef USE_SHADOWMAP",
    "		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;",
    "		#endif",
    "",
    "		RE_Direct( directLight, geometry, material, reflectedLight );",
    "",
    "	}",
    "",
    "#endif",
    "",
    "#if defined( RE_IndirectDiffuse )",
    "",
    "	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );",
    "",
    "	#ifdef USE_LIGHTMAP",
    "",
    "		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;",
    "",
    "		#ifndef PHYSICALLY_CORRECT_LIGHTS",
    "",
    "			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage",
    "",
    "		#endif",
    "",
    "		irradiance += lightMapIrradiance;",
    "",
    "	#endif",
    "",
    "	#if ( NUM_HEMI_LIGHTS > 0 )",
    "",
    "		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {",
    "",
    "			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );",
    "",
    "		}",
    "",
    "	#endif",
    "",
    "	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )",
    "",
    "		// TODO, replace 8 with the real maxMIPLevel",
    "	 	irradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, 8 );",
    "",
    "	#endif",
    "",
    "	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );",
    "",
    "#endif",
    "",
    "#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )",
    "",
    "	// TODO, replace 8 with the real maxMIPLevel",
    "	vec3 radiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), 8 );",
    "",
    "	#ifndef STANDARD",
    "		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );",
    "	#else",
    "		vec3 clearCoatRadiance = vec3( 0.0 );",
    "	#endif",
    "		",
    "	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );",
    "",
    "#endif",
    "",
].join('\n');

var logdepthbuf_fragment = [
    "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)",
    "",
    "	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;",
    "",
    "#endif",
].join('\n');

var logdepthbuf_pars_fragment = [
    "#ifdef USE_LOGDEPTHBUF",
    "",
    "	uniform float logDepthBufFC;",
    "",
    "	#ifdef USE_LOGDEPTHBUF_EXT",
    "",
    "		varying float vFragDepth;",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var logdepthbuf_pars_vertex = [
    "#ifdef USE_LOGDEPTHBUF",
    "",
    "	#ifdef USE_LOGDEPTHBUF_EXT",
    "",
    "		varying float vFragDepth;",
    "",
    "	#endif",
    "",
    "	uniform float logDepthBufFC;",
    "",
    "#endif",
].join('\n');

var logdepthbuf_vertex = [
    "#ifdef USE_LOGDEPTHBUF",
    "",
    "	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;",
    "",
    "	#ifdef USE_LOGDEPTHBUF_EXT",
    "",
    "		vFragDepth = 1.0 + gl_Position.w;",
    "",
    "	#else",
    "",
    "		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var map_fragment = [
    "#ifdef USE_MAP",
    "",
    "	vec4 texelColor = texture2D( map, vUv );",
    "",
    "	texelColor = mapTexelToLinear( texelColor );",
    "	diffuseColor *= texelColor;",
    "",
    "#endif",
    "",
].join('\n');

var map_pars_fragment = [
    "#ifdef USE_MAP",
    "",
    "	uniform sampler2D map;",
    "",
    "#endif",
    "",
].join('\n');

var map_particle_fragment = [
    "#ifdef USE_MAP",
    "",
    "	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );",
    "	diffuseColor *= mapTexelToLinear( mapTexel );",
    "",
    "#endif",
    "",
].join('\n');

var map_particle_pars_fragment = [
    "#ifdef USE_MAP",
    "",
    "	uniform vec4 offsetRepeat;",
    "	uniform sampler2D map;",
    "",
    "#endif",
    "",
].join('\n');

var metalnessmap_fragment = [
    "float metalnessFactor = metalness;",
    "",
    "#ifdef USE_METALNESSMAP",
    "",
    "	vec4 texelMetalness = texture2D( metalnessMap, vUv );",
    "	metalnessFactor *= texelMetalness.r;",
    "",
    "#endif",
    "",
].join('\n');

var metalnessmap_pars_fragment = [
    "#ifdef USE_METALNESSMAP",
    "",
    "	uniform sampler2D metalnessMap;",
    "",
    "#endif",
].join('\n');

var morphnormal_vertex = [
    "#ifdef USE_MORPHNORMALS",
    "",
    "	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
    "	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
    "	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
    "	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",
    "",
    "#endif",
    "",
].join('\n');

var morphtarget_pars_vertex = [
    "#ifdef USE_MORPHTARGETS",
    "",
    "	#ifndef USE_MORPHNORMALS",
    "",
    "	uniform float morphTargetInfluences[ 8 ];",
    "",
    "	#else",
    "",
    "	uniform float morphTargetInfluences[ 4 ];",
    "",
    "	#endif",
    "",
    "#endif",
].join('\n');

var morphtarget_vertex = [
    "#ifdef USE_MORPHTARGETS",
    "",
    "	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
    "	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
    "	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
    "	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",
    "",
    "	#ifndef USE_MORPHNORMALS",
    "",
    "	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
    "	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
    "	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
    "	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var normal_flip = [
    "#ifdef DOUBLE_SIDED",
    "	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );",
    "#else",
    "	float flipNormal = 1.0;",
    "#endif",
    "",
].join('\n');

var normal_fragment = [
    "#ifdef FLAT_SHADED",
    "",
    "	// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...",
    "",
    "	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );",
    "	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );",
    "	vec3 normal = normalize( cross( fdx, fdy ) );",
    "",
    "#else",
    "",
    "	vec3 normal = normalize( vNormal ) * flipNormal;",
    "",
    "#endif",
    "",
    "#ifdef USE_NORMALMAP",
    "",
    "	normal = perturbNormal2Arb( -vViewPosition, normal );",
    "",
    "#elif defined( USE_BUMPMAP )",
    "",
    "	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",
    "",
    "#endif",
    "",
].join('\n');

var normalmap_pars_fragment = [
    "#ifdef USE_NORMALMAP",
    "",
    "	uniform sampler2D normalMap;",
    "	uniform vec2 normalScale;",
    "",
    "	// Per-Pixel Tangent Space Normal Mapping",
    "	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html",
    "",
    "	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",
    "",
    "		vec3 q0 = dFdx( eye_pos.xyz );",
    "		vec3 q1 = dFdy( eye_pos.xyz );",
    "		vec2 st0 = dFdx( vUv.st );",
    "		vec2 st1 = dFdy( vUv.st );",
    "",
    "		vec3 S = normalize( q0 * st1.t - q1 * st0.t );",
    "		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
    "		vec3 N = normalize( surf_norm );",
    "",
    "		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;",
    "		mapN.xy = normalScale * mapN.xy;",
    "		mat3 tsn = mat3( S, T, N );",
    "		return normalize( tsn * mapN );",
    "",
    "	}",
    "",
    "#endif",
    "",
].join('\n');

var packing = [
    "vec3 packNormalToRGB( const in vec3 normal ) {",
    "  return normalize( normal ) * 0.5 + 0.5;",
    "}",
    "",
    "vec3 unpackRGBToNormal( const in vec3 rgb ) {",
    "  return 1.0 - 2.0 * rgb.xyz;",
    "}",
    "",
    "const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)",
    "const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)",
    "",
    "const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );",
    "const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );",
    "",
    "const float ShiftRight8 = 1. / 256.;",
    "",
    "vec4 packDepthToRGBA( const in float v ) {",
    "",
    "	vec4 r = vec4( fract( v * PackFactors ), v );",
    "	r.yzw -= r.xyz * ShiftRight8; // tidy overflow",
    "	return r * PackUpscale;",
    "",
    "}",
    "",
    "float unpackRGBAToDepth( const in vec4 v ) {",
    "",
    "	return dot( v, UnpackFactors );",
    "",
    "}",
    "",
    "// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions",
    "",
    "float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {",
    "  return ( viewZ + near ) / ( near - far );",
    "}",
    "float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {",
    "  return linearClipZ * ( near - far ) - near;",
    "}",
    "",
    "float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {",
    "  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );",
    "}",
    "float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {",
    "  return ( near * far ) / ( ( far - near ) * invClipZ - far );",
    "}",
    "",
].join('\n');

var premultiplied_alpha_fragment = [
    "#ifdef PREMULTIPLIED_ALPHA",
    "",
    "	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.",
    "	gl_FragColor.rgb *= gl_FragColor.a;",
    "",
    "#endif",
    "",
].join('\n');

var project_vertex = [
    "#ifdef USE_SKINNING",
    "",
    "	vec4 mvPosition = modelViewMatrix * skinned;",
    "",
    "#else",
    "",
    "	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );",
    "",
    "#endif",
    "",
    "gl_Position = projectionMatrix * mvPosition;",
    "",
].join('\n');

var roughnessmap_fragment = [
    "float roughnessFactor = roughness;",
    "",
    "#ifdef USE_ROUGHNESSMAP",
    "",
    "	vec4 texelRoughness = texture2D( roughnessMap, vUv );",
    "	roughnessFactor *= texelRoughness.r;",
    "",
    "#endif",
    "",
].join('\n');

var roughnessmap_pars_fragment = [
    "#ifdef USE_ROUGHNESSMAP",
    "",
    "	uniform sampler2D roughnessMap;",
    "",
    "#endif",
].join('\n');

var shadowmap_pars_fragment = [
    "#ifdef USE_SHADOWMAP",
    "",
    "	#if NUM_DIR_LIGHTS > 0",
    "",
    "		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];",
    "		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];",
    "",
    "	#endif",
    "",
    "	#if NUM_SPOT_LIGHTS > 0",
    "",
    "		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];",
    "		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];",
    "",
    "	#endif",
    "",
    "	#if NUM_POINT_LIGHTS > 0",
    "",
    "		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];",
    "		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];",
    "",
    "	#endif",
    "",
    "	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {",
    "",
    "		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );",
    "",
    "	}",
    "",
    "	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {",
    "",
    "		const vec2 offset = vec2( 0.0, 1.0 );",
    "",
    "		vec2 texelSize = vec2( 1.0 ) / size;",
    "		vec2 centroidUV = floor( uv * size + 0.5 ) / size;",
    "",
    "		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );",
    "		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );",
    "		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );",
    "		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );",
    "",
    "		vec2 f = fract( uv * size + 0.5 );",
    "",
    "		float a = mix( lb, lt, f.y );",
    "		float b = mix( rb, rt, f.y );",
    "		float c = mix( a, b, f.x );",
    "",
    "		return c;",
    "",
    "	}",
    "",
    "	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {",
    "",
    "		shadowCoord.xyz /= shadowCoord.w;",
    "		shadowCoord.z += shadowBias;",
    "",
    "		// if ( something && something ) breaks ATI OpenGL shader compiler",
    "		// if ( all( something, something ) ) using this instead",
    "",
    "		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
    "		bool inFrustum = all( inFrustumVec );",
    "",
    "		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",
    "",
    "		bool frustumTest = all( frustumTestVec );",
    "",
    "		if ( frustumTest ) {",
    "",
    "		#if defined( SHADOWMAP_TYPE_PCF )",
    "",
    "			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;",
    "",
    "			float dx0 = - texelSize.x * shadowRadius;",
    "			float dy0 = - texelSize.y * shadowRadius;",
    "			float dx1 = + texelSize.x * shadowRadius;",
    "			float dy1 = + texelSize.y * shadowRadius;",
    "",
    "			return (",
    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +",
    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +",
    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +",
    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +",
    "				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +",
    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +",
    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +",
    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +",
    "				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )",
    "			) * ( 1.0 / 9.0 );",
    "",
    "		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",
    "",
    "			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;",
    "",
    "			float dx0 = - texelSize.x * shadowRadius;",
    "			float dy0 = - texelSize.y * shadowRadius;",
    "			float dx1 = + texelSize.x * shadowRadius;",
    "			float dy1 = + texelSize.y * shadowRadius;",
    "",
    "			return (",
    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +",
    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +",
    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +",
    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +",
    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +",
    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +",
    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +",
    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +",
    "				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )",
    "			) * ( 1.0 / 9.0 );",
    "",
    "		#else // no percentage-closer filtering:",
    "",
    "			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );",
    "",
    "		#endif",
    "",
    "		}",
    "",
    "		return 1.0;",
    "",
    "	}",
    "",
    "	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D",
    "	// vector suitable for 2D texture mapping. This code uses the following layout for the",
    "	// 2D texture:",
    "	//",
    "	// xzXZ",
    "	//  y Y",
    "	//",
    "	// Y - Positive y direction",
    "	// y - Negative y direction",
    "	// X - Positive x direction",
    "	// x - Negative x direction",
    "	// Z - Positive z direction",
    "	// z - Negative z direction",
    "	//",
    "	// Source and test bed:",
    "	// https://gist.github.com/tschw/da10c43c467ce8afd0c4",
    "",
    "	vec2 cubeToUV( vec3 v, float texelSizeY ) {",
    "",
    "		// Number of texels to avoid at the edge of each square",
    "",
    "		vec3 absV = abs( v );",
    "",
    "		// Intersect unit cube",
    "",
    "		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );",
    "		absV *= scaleToCube;",
    "",
    "		// Apply scale to avoid seams",
    "",
    "		// two texels less per square (one texel will do for NEAREST)",
    "		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );",
    "",
    "		// Unwrap",
    "",
    "		// space: -1 ... 1 range for each square",
    "		//",
    "		// #X##		dim    := ( 4 , 2 )",
    "		//  # #		center := ( 1 , 1 )",
    "",
    "		vec2 planar = v.xy;",
    "",
    "		float almostATexel = 1.5 * texelSizeY;",
    "		float almostOne = 1.0 - almostATexel;",
    "",
    "		if ( absV.z >= almostOne ) {",
    "",
    "			if ( v.z > 0.0 )",
    "				planar.x = 4.0 - v.x;",
    "",
    "		} else if ( absV.x >= almostOne ) {",
    "",
    "			float signX = sign( v.x );",
    "			planar.x = v.z * signX + 2.0 * signX;",
    "",
    "		} else if ( absV.y >= almostOne ) {",
    "",
    "			float signY = sign( v.y );",
    "			planar.x = v.x + 2.0 * signY + 2.0;",
    "			planar.y = v.z * signY - 2.0;",
    "",
    "		}",
    "",
    "		// Transform to UV space",
    "",
    "		// scale := 0.5 / dim",
    "		// translate := ( center + 0.5 ) / dim",
    "		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );",
    "",
    "	}",
    "",
    "	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {",
    "",
    "		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );",
    "",
    "		// for point lights, the uniform @vShadowCoord is re-purposed to hold",
    "		// the distance from the light to the world-space position of the fragment.",
    "		vec3 lightToPosition = shadowCoord.xyz;",
    "",
    "		// bd3D = base direction 3D",
    "		vec3 bd3D = normalize( lightToPosition );",
    "		// dp = distance from light to fragment position",
    "		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;",
    "",
    "		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )",
    "",
    "			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;",
    "",
    "			return (",
    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +",
    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +",
    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +",
    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +",
    "				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +",
    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +",
    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +",
    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +",
    "				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )",
    "			) * ( 1.0 / 9.0 );",
    "",
    "		#else // no percentage-closer filtering",
    "",
    "			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );",
    "",
    "		#endif",
    "",
    "	}",
    "",
    "#endif",
    "",
].join('\n');

var shadowmap_pars_vertex = [
    "#ifdef USE_SHADOWMAP",
    "",
    "	#if NUM_DIR_LIGHTS > 0",
    "",
    "		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];",
    "		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];",
    "",
    "	#endif",
    "",
    "	#if NUM_SPOT_LIGHTS > 0",
    "",
    "		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];",
    "		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];",
    "",
    "	#endif",
    "",
    "	#if NUM_POINT_LIGHTS > 0",
    "",
    "		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];",
    "		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var shadowmap_vertex = [
    "#ifdef USE_SHADOWMAP",
    "",
    "	#if NUM_DIR_LIGHTS > 0",
    "",
    "	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
    "",
    "		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;",
    "",
    "	}",
    "",
    "	#endif",
    "",
    "	#if NUM_SPOT_LIGHTS > 0",
    "",
    "	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {",
    "",
    "		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;",
    "",
    "	}",
    "",
    "	#endif",
    "",
    "	#if NUM_POINT_LIGHTS > 0",
    "",
    "	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",
    "",
    "		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;",
    "",
    "	}",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var shadowmask_pars_fragment = [
    "float getShadowMask() {",
    "",
    "	float shadow = 1.0;",
    "",
    "	#ifdef USE_SHADOWMAP",
    "",
    "	#if NUM_DIR_LIGHTS > 0",
    "",
    "	DirectionalLight directionalLight;",
    "",
    "	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
    "",
    "		directionalLight = directionalLights[ i ];",
    "		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;",
    "",
    "	}",
    "",
    "	#endif",
    "",
    "	#if NUM_SPOT_LIGHTS > 0",
    "",
    "	SpotLight spotLight;",
    "",
    "	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {",
    "",
    "		spotLight = spotLights[ i ];",
    "		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;",
    "",
    "	}",
    "",
    "	#endif",
    "",
    "	#if NUM_POINT_LIGHTS > 0",
    "",
    "	PointLight pointLight;",
    "",
    "	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",
    "",
    "		pointLight = pointLights[ i ];",
    "		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;",
    "",
    "	}",
    "",
    "	#endif",
    "",
    "	#endif",
    "",
    "	return shadow;",
    "",
    "}",
    "",
].join('\n');

var skinbase_vertex = [
    "#ifdef USE_SKINNING",
    "",
    "	mat4 boneMatX = getBoneMatrix( skinIndex.x );",
    "	mat4 boneMatY = getBoneMatrix( skinIndex.y );",
    "	mat4 boneMatZ = getBoneMatrix( skinIndex.z );",
    "	mat4 boneMatW = getBoneMatrix( skinIndex.w );",
    "",
    "#endif",
].join('\n');

var skinning_pars_vertex = [
    "#ifdef USE_SKINNING",
    "",
    "	uniform mat4 bindMatrix;",
    "	uniform mat4 bindMatrixInverse;",
    "",
    "	#ifdef BONE_TEXTURE",
    "",
    "		uniform sampler2D boneTexture;",
    "		uniform int boneTextureWidth;",
    "		uniform int boneTextureHeight;",
    "",
    "		mat4 getBoneMatrix( const in float i ) {",
    "",
    "			float j = i * 4.0;",
    "			float x = mod( j, float( boneTextureWidth ) );",
    "			float y = floor( j / float( boneTextureWidth ) );",
    "",
    "			float dx = 1.0 / float( boneTextureWidth );",
    "			float dy = 1.0 / float( boneTextureHeight );",
    "",
    "			y = dy * ( y + 0.5 );",
    "",
    "			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
    "			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
    "			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
    "			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",
    "",
    "			mat4 bone = mat4( v1, v2, v3, v4 );",
    "",
    "			return bone;",
    "",
    "		}",
    "",
    "	#else",
    "",
    "		uniform mat4 boneMatrices[ MAX_BONES ];",
    "",
    "		mat4 getBoneMatrix( const in float i ) {",
    "",
    "			mat4 bone = boneMatrices[ int(i) ];",
    "			return bone;",
    "",
    "		}",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var skinning_vertex = [
    "#ifdef USE_SKINNING",
    "",
    "	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );",
    "",
    "	vec4 skinned = vec4( 0.0 );",
    "	skinned += boneMatX * skinVertex * skinWeight.x;",
    "	skinned += boneMatY * skinVertex * skinWeight.y;",
    "	skinned += boneMatZ * skinVertex * skinWeight.z;",
    "	skinned += boneMatW * skinVertex * skinWeight.w;",
    "	skinned  = bindMatrixInverse * skinned;",
    "",
    "#endif",
    "",
].join('\n');

var skinnormal_vertex = [
    "#ifdef USE_SKINNING",
    "",
    "	mat4 skinMatrix = mat4( 0.0 );",
    "	skinMatrix += skinWeight.x * boneMatX;",
    "	skinMatrix += skinWeight.y * boneMatY;",
    "	skinMatrix += skinWeight.z * boneMatZ;",
    "	skinMatrix += skinWeight.w * boneMatW;",
    "	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;",
    "",
    "	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;",
    "",
    "#endif",
    "",
].join('\n');

var specularmap_fragment = [
    "float specularStrength;",
    "",
    "#ifdef USE_SPECULARMAP",
    "",
    "	vec4 texelSpecular = texture2D( specularMap, vUv );",
    "	specularStrength = texelSpecular.r;",
    "",
    "#else",
    "",
    "	specularStrength = 1.0;",
    "",
    "#endif",
].join('\n');

var specularmap_pars_fragment = [
    "#ifdef USE_SPECULARMAP",
    "",
    "	uniform sampler2D specularMap;",
    "",
    "#endif",
].join('\n');

var tonemapping_fragment = [
    "#if defined( TONE_MAPPING )",
    "",
    "  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );",
    "",
    "#endif",
    "",
].join('\n');

var tonemapping_pars_fragment = [
    "#define saturate(a) clamp( a, 0.0, 1.0 )",
    "",
    "uniform float toneMappingExposure;",
    "uniform float toneMappingWhitePoint;",
    "",
    "// exposure only",
    "vec3 LinearToneMapping( vec3 color ) {",
    "",
    "  return toneMappingExposure * color;",
    "",
    "}",
    "",
    "// source: https://www.cs.utah.edu/~reinhard/cdrom/",
    "vec3 ReinhardToneMapping( vec3 color ) {",
    "",
    "  color *= toneMappingExposure;",
    "  return saturate( color / ( vec3( 1.0 ) + color ) );",
    "",
    "}",
    "",
    "// source: http://filmicgames.com/archives/75",
    "#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )",
    "vec3 Uncharted2ToneMapping( vec3 color ) {",
    "",
    "  // John Hable's filmic operator from Uncharted 2 video game",
    "  color *= toneMappingExposure;",
    "  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );",
    "",
    "}",
    "",
    "// source: http://filmicgames.com/archives/75",
    "vec3 OptimizedCineonToneMapping( vec3 color ) {",
    "",
    "  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson",
    "  color *= toneMappingExposure;",
    "  color = max( vec3( 0.0 ), color - 0.004 );",
    "  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );",
    "",
    "}",
    "",
].join('\n');

var uv_pars_fragment = [
    "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )",
    "",
    "	varying vec2 vUv;",
    "",
    "#endif",
].join('\n');

var uv_pars_vertex = [
    "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )",
    "",
    "	varying vec2 vUv;",
    "	uniform vec4 offsetRepeat;",
    "",
    "#endif",
    "",
].join('\n');

var uv_vertex = [
    "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )",
    "",
    "	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",
    "",
    "#endif",
].join('\n');

var uv2_pars_fragment = [
    "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )",
    "",
    "	varying vec2 vUv2;",
    "",
    "#endif",
].join('\n');

var uv2_pars_vertex = [
    "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )",
    "",
    "	attribute vec2 uv2;",
    "	varying vec2 vUv2;",
    "",
    "#endif",
].join('\n');

var uv2_vertex = [
    "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )",
    "",
    "	vUv2 = uv2;",
    "",
    "#endif",
].join('\n');

var worldpos_vertex = [
    "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",
    "",
    "	#ifdef USE_SKINNING",
    "",
    "		vec4 worldPosition = modelMatrix * skinned;",
    "",
    "	#else",
    "",
    "		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );",
    "",
    "	#endif",
    "",
    "#endif",
    "",
].join('\n');

var cube_frag = [
    "uniform samplerCube tCube;",
    "uniform float tFlip;",
    "uniform float opacity;",
    "",
    "varying vec3 vWorldPosition;",
    "",
    "#include <common>",
    "",
    "void main() {",
    "",
    "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
    "	gl_FragColor.a *= opacity;",
    "",
    "}",
    "",
].join('\n');

var cube_vert = [
    "varying vec3 vWorldPosition;",
    "",
    "#include <common>",
    "",
    "void main() {",
    "",
    "	vWorldPosition = transformDirection( position, modelMatrix );",
    "",
    "	#include <begin_vertex>",
    "	#include <project_vertex>",
    "",
    "}",
    "",
].join('\n');

var depth_frag = [
    "#if DEPTH_PACKING == 3200",
    "",
    "	uniform float opacity;",
    "",
    "#endif",
    "",
    "#include <common>",
    "#include <packing>",
    "#include <uv_pars_fragment>",
    "#include <map_pars_fragment>",
    "#include <alphamap_pars_fragment>",
    "#include <logdepthbuf_pars_fragment>",
    "#include <clipping_planes_pars_fragment>",
    "",
    "void main() {",
    "",
    "	#include <clipping_planes_fragment>",
    "",
    "	vec4 diffuseColor = vec4( 1.0 );",
    "",
    "	#if DEPTH_PACKING == 3200",
    "",
    "		diffuseColor.a = opacity;",
    "",
    "	#endif",
    "",
    "	#include <map_fragment>",
    "	#include <alphamap_fragment>",
    "	#include <alphatest_fragment>",
    "",
    "	#include <logdepthbuf_fragment>",
    "",
    "	#if DEPTH_PACKING == 3200",
    "",
    "		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );",
    "",
    "	#elif DEPTH_PACKING == 3201",
    "",
    "		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );",
    "",
    "	#endif",
    "",
    "}",
    "",
].join('\n');

var depth_vert = [
    "#include <common>",
    "#include <uv_pars_vertex>",
    "#include <displacementmap_pars_vertex>",
    "#include <morphtarget_pars_vertex>",
    "#include <skinning_pars_vertex>",
    "#include <logdepthbuf_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",
    "",
    "void main() {",
    "",
    "	#include <uv_vertex>",
    "",
    "	#include <skinbase_vertex>",
    "",
    "	#include <begin_vertex>",
    "	#include <displacementmap_vertex>",
    "	#include <morphtarget_vertex>",
    "	#include <skinning_vertex>",
    "	#include <project_vertex>",
    "	#include <logdepthbuf_vertex>",
    "	#include <clipping_planes_vertex>",
    "",
    "}",
    "",
].join('\n');

var distanceRGBA_frag = [
    "uniform vec3 lightPos;",
    "varying vec4 vWorldPosition;",
    "",
    "#include <common>",
    "#include <packing>",
    "#include <clipping_planes_pars_fragment>",
    "",
    "void main () {",
    "",
    "	#include <clipping_planes_fragment>",
    "",
    "	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );",
    "",
    "}",
    "",
].join('\n');

var distanceRGBA_vert = [
    "varying vec4 vWorldPosition;",
    "",
    "#include <common>",
    "#include <morphtarget_pars_vertex>",
    "#include <skinning_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",
    "",
    "void main() {",
    "",
    "	#include <skinbase_vertex>",
    "	#include <begin_vertex>",
    "	#include <morphtarget_vertex>",
    "	#include <skinning_vertex>",
    "	#include <project_vertex>",
    "	#include <worldpos_vertex>",
    "	#include <clipping_planes_vertex>",
    "",
    "	vWorldPosition = worldPosition;",
    "",
    "}",
    "",
].join('\n');

var equirect_frag = [
    "uniform sampler2D tEquirect;",
    "uniform float tFlip;",
    "",
    "varying vec3 vWorldPosition;",
    "",
    "#include <common>",
    "",
    "void main() {",
    "",
    "	// 	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
    "	vec3 direction = normalize( vWorldPosition );",
    "	vec2 sampleUV;",
    "	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
    "	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
    "	gl_FragColor = texture2D( tEquirect, sampleUV );",
    "",
    "}",
    "",
].join('\n');

var equirect_vert = [
    "varying vec3 vWorldPosition;",
    "",
    "#include <common>",
    "",
    "void main() {",
    "",
    "	vWorldPosition = transformDirection( position, modelMatrix );",
    "",
    "	#include <begin_vertex>",
    "	#include <project_vertex>",
    "",
    "}",
    "",
].join('\n');

var linedashed_frag = [
    "uniform vec3 diffuse;",
    "uniform float opacity;",
    "",
    "uniform float dashSize;",
    "uniform float totalSize;",
    "",
    "varying float vLineDistance;",
    "",
    "#include <common>",
    "#include <color_pars_fragment>",
    "#include <fog_pars_fragment>",
    "#include <logdepthbuf_pars_fragment>",
    "#include <clipping_planes_pars_fragment>",
    "",
    "void main() {",
    "",
    "	#include <clipping_planes_fragment>",
    "",
    "	if ( mod( vLineDistance, totalSize ) > dashSize ) {",
    "",
    "		discard;",
    "",
    "	}",
    "",
    "	vec3 outgoingLight = vec3( 0.0 );",
    "	vec4 diffuseColor = vec4( diffuse, opacity );",
    "",
    "	#include <logdepthbuf_fragment>",
    "	#include <color_fragment>",
    "",
    "	outgoingLight = diffuseColor.rgb; // simple shader",
    "",
    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "",
    "	#include <premultiplied_alpha_fragment>",
    "	#include <tonemapping_fragment>",
    "	#include <encodings_fragment>",
    "	#include <fog_fragment>",
    "",
    "}",
    "",
].join('\n');

var linedashed_vert = [
    "uniform float scale;",
    "attribute float lineDistance;",
    "",
    "varying float vLineDistance;",
    "",
    "#include <common>",
    "#include <color_pars_vertex>",
    "#include <logdepthbuf_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",
    "",
    "void main() {",
    "",
    "	#include <color_vertex>",
    "",
    "	vLineDistance = scale * lineDistance;",
    "",
    "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
    "	gl_Position = projectionMatrix * mvPosition;",
    "",
    "	#include <logdepthbuf_vertex>",
    "	#include <clipping_planes_vertex>",
    "",
    "}",
    "",
].join('\n');

var meshbasic_frag = [
    "uniform vec3 diffuse;",
    "uniform float opacity;",
    "",
    "#ifndef FLAT_SHADED",
    "",
    "	varying vec3 vNormal;",
    "",
    "#endif",
    "",
    "#include <common>",
    "#include <color_pars_fragment>",
    "#include <uv_pars_fragment>",
    "#include <uv2_pars_fragment>",
    "#include <map_pars_fragment>",
    "#include <alphamap_pars_fragment>",
    "#include <aomap_pars_fragment>",
    "#include <envmap_pars_fragment>",
    "#include <fog_pars_fragment>",
    "#include <specularmap_pars_fragment>",
    "#include <logdepthbuf_pars_fragment>",
    "#include <clipping_planes_pars_fragment>",
    "",
    "void main() {",
    "",
    "	#include <clipping_planes_fragment>",
    "",
    "	vec4 diffuseColor = vec4( diffuse, opacity );",
    "",
    "	#include <logdepthbuf_fragment>",
    "	#include <map_fragment>",
    "	#include <color_fragment>",
    "	#include <alphamap_fragment>",
    "	#include <alphatest_fragment>",
    "	#include <specularmap_fragment>",
    "",
    "	ReflectedLight reflectedLight;",
    "	reflectedLight.directDiffuse = vec3( 0.0 );",
    "	reflectedLight.directSpecular = vec3( 0.0 );",
    "	reflectedLight.indirectDiffuse = diffuseColor.rgb;",
    "	reflectedLight.indirectSpecular = vec3( 0.0 );",
    "",
    "	#include <aomap_fragment>",
    "",
    "	vec3 outgoingLight = reflectedLight.indirectDiffuse;",
    "",
    "	#include <normal_flip>",
    "	#include <envmap_fragment>",
    "",
    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "",
    "	#include <premultiplied_alpha_fragment>",
    "	#include <tonemapping_fragment>",
    "	#include <encodings_fragment>",
    "	#include <fog_fragment>",
    "",
    "}",
    "",
].join('\n');

var meshbasic_vert = [
    "#include <common>",
    "#include <uv_pars_vertex>",
    "#include <uv2_pars_vertex>",
    "#include <envmap_pars_vertex>",
    "#include <color_pars_vertex>",
    "#include <morphtarget_pars_vertex>",
    "#include <skinning_pars_vertex>",
    "#include <logdepthbuf_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",
    "",
    "void main() {",
    "",
    "	#include <uv_vertex>",
    "	#include <uv2_vertex>",
    "	#include <color_vertex>",
    "	#include <skinbase_vertex>",
    "",
    "	#ifdef USE_ENVMAP",
    "",
    "	#include <beginnormal_vertex>",
    "	#include <morphnormal_vertex>",
    "	#include <skinnormal_vertex>",
    "	#include <defaultnormal_vertex>",
    "",
    "	#endif",
    "",
    "	#include <begin_vertex>",
    "	#include <morphtarget_vertex>",
    "	#include <skinning_vertex>",
    "	#include <project_vertex>",
    "	#include <logdepthbuf_vertex>",
    "",
    "	#include <worldpos_vertex>",
    "	#include <clipping_planes_vertex>",
    "	#include <envmap_vertex>",
    "",
    "}",
    "",
].join('\n');

var meshlambert_frag = [
    "uniform vec3 diffuse;",
    "uniform vec3 emissive;",
    "uniform float opacity;",
    "",
    "varying vec3 vLightFront;",
    "",
    "#ifdef DOUBLE_SIDED",
    "",
    "	varying vec3 vLightBack;",
    "",
    "#endif",
    "",
    "#include <common>",
    "#include <packing>",
    "#include <color_pars_fragment>",
    "#include <uv_pars_fragment>",
    "#include <uv2_pars_fragment>",
    "#include <map_pars_fragment>",
    "#include <alphamap_pars_fragment>",
    "#include <aomap_pars_fragment>",
    "#include <lightmap_pars_fragment>",
    "#include <emissivemap_pars_fragment>",
    "#include <envmap_pars_fragment>",
    "#include <bsdfs>",
    "#include <lights_pars>",
    "#include <fog_pars_fragment>",
    "#include <shadowmap_pars_fragment>",
    "#include <shadowmask_pars_fragment>",
    "#include <specularmap_pars_fragment>",
    "#include <logdepthbuf_pars_fragment>",
    "#include <clipping_planes_pars_fragment>",
    "",
    "void main() {",
    "",
    "	#include <clipping_planes_fragment>",
    "",
    "	vec4 diffuseColor = vec4( diffuse, opacity );",
    "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
    "	vec3 totalEmissiveRadiance = emissive;",
    "",
    "	#include <logdepthbuf_fragment>",
    "	#include <map_fragment>",
    "	#include <color_fragment>",
    "	#include <alphamap_fragment>",
    "	#include <alphatest_fragment>",
    "	#include <specularmap_fragment>",
    "	#include <emissivemap_fragment>",
    "",
    "	// accumulation",
    "	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );",
    "",
    "	#include <lightmap_fragment>",
    "",
    "	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );",
    "",
    "	#ifdef DOUBLE_SIDED",
    "",
    "		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;",
    "",
    "	#else",
    "",
    "		reflectedLight.directDiffuse = vLightFront;",
    "",
    "	#endif",
    "",
    "	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();",
    "",
    "	// modulation",
    "	#include <aomap_fragment>",
    "",
    "	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;",
    "",
    "	#include <normal_flip>",
    "	#include <envmap_fragment>",
    "",
    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "",
    "	#include <premultiplied_alpha_fragment>",
    "	#include <tonemapping_fragment>",
    "	#include <encodings_fragment>",
    "	#include <fog_fragment>",
    "",
    "}",
    "",
].join('\n');

var meshlambert_vert = [
    "#define LAMBERT",
    "",
    "varying vec3 vLightFront;",
    "",
    "#ifdef DOUBLE_SIDED",
    "",
    "	varying vec3 vLightBack;",
    "",
    "#endif",
    "",
    "#include <common>",
    "#include <uv_pars_vertex>",
    "#include <uv2_pars_vertex>",
    "#include <envmap_pars_vertex>",
    "#include <bsdfs>",
    "#include <lights_pars>",
    "#include <color_pars_vertex>",
    "#include <morphtarget_pars_vertex>",
    "#include <skinning_pars_vertex>",
    "#include <shadowmap_pars_vertex>",
    "#include <logdepthbuf_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",
    "",
    "void main() {",
    "",
    "	#include <uv_vertex>",
    "	#include <uv2_vertex>",
    "	#include <color_vertex>",
    "",
    "	#include <beginnormal_vertex>",
    "	#include <morphnormal_vertex>",
    "	#include <skinbase_vertex>",
    "	#include <skinnormal_vertex>",
    "	#include <defaultnormal_vertex>",
    "",
    "	#include <begin_vertex>",
    "	#include <morphtarget_vertex>",
    "	#include <skinning_vertex>",
    "	#include <project_vertex>",
    "	#include <logdepthbuf_vertex>",
    "	#include <clipping_planes_vertex>",
    "",
    "	#include <worldpos_vertex>",
    "	#include <envmap_vertex>",
    "	#include <lights_lambert_vertex>",
    "	#include <shadowmap_vertex>",
    "",
    "}",
    "",
].join('\n');

var meshphong_frag = [
    "#define PHONG",
    "",
    "uniform vec3 diffuse;",
    "uniform vec3 emissive;",
    "uniform vec3 specular;",
    "uniform float shininess;",
    "uniform float opacity;",
    "",
    "#include <common>",
    "#include <packing>",
    "#include <color_pars_fragment>",
    "#include <uv_pars_fragment>",
    "#include <uv2_pars_fragment>",
    "#include <map_pars_fragment>",
    "#include <alphamap_pars_fragment>",
    "#include <aomap_pars_fragment>",
    "#include <lightmap_pars_fragment>",
    "#include <emissivemap_pars_fragment>",
    "#include <envmap_pars_fragment>",
    "#include <fog_pars_fragment>",
    "#include <bsdfs>",
    "#include <lights_pars>",
    "#include <lights_phong_pars_fragment>",
    "#include <shadowmap_pars_fragment>",
    "#include <bumpmap_pars_fragment>",
    "#include <normalmap_pars_fragment>",
    "#include <specularmap_pars_fragment>",
    "#include <logdepthbuf_pars_fragment>",
    "#include <clipping_planes_pars_fragment>",
    "",
    "void main() {",
    "",
    "	#include <clipping_planes_fragment>",
    "",
    "	vec4 diffuseColor = vec4( diffuse, opacity );",
    "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
    "	vec3 totalEmissiveRadiance = emissive;",
    "",
    "	#include <logdepthbuf_fragment>",
    "	#include <map_fragment>",
    "	#include <color_fragment>",
    "	#include <alphamap_fragment>",
    "	#include <alphatest_fragment>",
    "	#include <specularmap_fragment>",
    "	#include <normal_flip>",
    "	#include <normal_fragment>",
    "	#include <emissivemap_fragment>",
    "",
    "	// accumulation",
    "	#include <lights_phong_fragment>",
    "	#include <lights_template>",
    "",
    "	// modulation",
    "	#include <aomap_fragment>",
    "",
    "	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
    "",
    "	#include <envmap_fragment>",
    "",
    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "",
    "	#include <premultiplied_alpha_fragment>",
    "	#include <tonemapping_fragment>",
    "	#include <encodings_fragment>",
    "	#include <fog_fragment>",
    "",
    "}",
    "",
].join('\n');

var meshphong_vert = [
    "#define PHONG",
    "",
    "varying vec3 vViewPosition;",
    "",
    "#ifndef FLAT_SHADED",
    "",
    "	varying vec3 vNormal;",
    "",
    "#endif",
    "",
    "#include <common>",
    "#include <uv_pars_vertex>",
    "#include <uv2_pars_vertex>",
    "#include <displacementmap_pars_vertex>",
    "#include <envmap_pars_vertex>",
    "#include <color_pars_vertex>",
    "#include <morphtarget_pars_vertex>",
    "#include <skinning_pars_vertex>",
    "#include <shadowmap_pars_vertex>",
    "#include <logdepthbuf_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",
    "",
    "void main() {",
    "",
    "	#include <uv_vertex>",
    "	#include <uv2_vertex>",
    "	#include <color_vertex>",
    "",
    "	#include <beginnormal_vertex>",
    "	#include <morphnormal_vertex>",
    "	#include <skinbase_vertex>",
    "	#include <skinnormal_vertex>",
    "	#include <defaultnormal_vertex>",
    "",
    "#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED",
    "",
    "	vNormal = normalize( transformedNormal );",
    "",
    "#endif",
    "",
    "	#include <begin_vertex>",
    "	#include <displacementmap_vertex>",
    "	#include <morphtarget_vertex>",
    "	#include <skinning_vertex>",
    "	#include <project_vertex>",
    "	#include <logdepthbuf_vertex>",
    "	#include <clipping_planes_vertex>",
    "",
    "	vViewPosition = - mvPosition.xyz;",
    "",
    "	#include <worldpos_vertex>",
    "	#include <envmap_vertex>",
    "	#include <shadowmap_vertex>",
    "",
    "}",
    "",
].join('\n');

var meshphysical_frag = [
    "#define PHYSICAL",
    "",
    "uniform vec3 diffuse;",
    "uniform vec3 emissive;",
    "uniform float roughness;",
    "uniform float metalness;",
    "uniform float opacity;",
    "",
    "#ifndef STANDARD",
    "	uniform float clearCoat;",
    "	uniform float clearCoatRoughness;",
    "#endif",
    "",
    "uniform float envMapIntensity; // temporary",
    "",
    "varying vec3 vViewPosition;",
    "",
    "#ifndef FLAT_SHADED",
    "",
    "	varying vec3 vNormal;",
    "",
    "#endif",
    "",
    "#include <common>",
    "#include <packing>",
    "#include <color_pars_fragment>",
    "#include <uv_pars_fragment>",
    "#include <uv2_pars_fragment>",
    "#include <map_pars_fragment>",
    "#include <alphamap_pars_fragment>",
    "#include <aomap_pars_fragment>",
    "#include <lightmap_pars_fragment>",
    "#include <emissivemap_pars_fragment>",
    "#include <envmap_pars_fragment>",
    "#include <fog_pars_fragment>",
    "#include <bsdfs>",
    "#include <cube_uv_reflection_fragment>",
    "#include <lights_pars>",
    "#include <lights_physical_pars_fragment>",
    "#include <shadowmap_pars_fragment>",
    "#include <bumpmap_pars_fragment>",
    "#include <normalmap_pars_fragment>",
    "#include <roughnessmap_pars_fragment>",
    "#include <metalnessmap_pars_fragment>",
    "#include <logdepthbuf_pars_fragment>",
    "#include <clipping_planes_pars_fragment>",
    "",
    "void main() {",
    "",
    "	#include <clipping_planes_fragment>",
    "",
    "	vec4 diffuseColor = vec4( diffuse, opacity );",
    "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
    "	vec3 totalEmissiveRadiance = emissive;",
    "",
    "	#include <logdepthbuf_fragment>",
    "	#include <map_fragment>",
    "	#include <color_fragment>",
    "	#include <alphamap_fragment>",
    "	#include <alphatest_fragment>",
    "	#include <specularmap_fragment>",
    "	#include <roughnessmap_fragment>",
    "	#include <metalnessmap_fragment>",
    "	#include <normal_flip>",
    "	#include <normal_fragment>",
    "	#include <emissivemap_fragment>",
    "",
    "	// accumulation",
    "	#include <lights_physical_fragment>",
    "	#include <lights_template>",
    "",
    "	// modulation",
    "	#include <aomap_fragment>",
    "",
    "	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
    "",
    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "",
    "	#include <premultiplied_alpha_fragment>",
    "	#include <tonemapping_fragment>",
    "	#include <encodings_fragment>",
    "	#include <fog_fragment>",
    "",
    "}",
    "",
].join('\n');

var meshphysical_vert = [
    "#define PHYSICAL",
    "",
    "varying vec3 vViewPosition;",
    "",
    "#ifndef FLAT_SHADED",
    "",
    "	varying vec3 vNormal;",
    "",
    "#endif",
    "",
    "#include <common>",
    "#include <uv_pars_vertex>",
    "#include <uv2_pars_vertex>",
    "#include <displacementmap_pars_vertex>",
    "#include <color_pars_vertex>",
    "#include <morphtarget_pars_vertex>",
    "#include <skinning_pars_vertex>",
    "#include <shadowmap_pars_vertex>",
    "#include <specularmap_pars_fragment>",
    "#include <logdepthbuf_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",
    "",
    "void main() {",
    "",
    "	#include <uv_vertex>",
    "	#include <uv2_vertex>",
    "	#include <color_vertex>",
    "",
    "	#include <beginnormal_vertex>",
    "	#include <morphnormal_vertex>",
    "	#include <skinbase_vertex>",
    "	#include <skinnormal_vertex>",
    "	#include <defaultnormal_vertex>",
    "",
    "#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED",
    "",
    "	vNormal = normalize( transformedNormal );",
    "",
    "#endif",
    "",
    "	#include <begin_vertex>",
    "	#include <displacementmap_vertex>",
    "	#include <morphtarget_vertex>",
    "	#include <skinning_vertex>",
    "	#include <project_vertex>",
    "	#include <logdepthbuf_vertex>",
    "	#include <clipping_planes_vertex>",
    "",
    "	vViewPosition = - mvPosition.xyz;",
    "",
    "	#include <worldpos_vertex>",
    "	#include <shadowmap_vertex>",
    "",
    "}",
    "",
].join('\n');

var normal_frag = [
    "uniform float opacity;",
    "varying vec3 vNormal;",
    "",
    "#include <common>",
    "#include <packing>",
    "#include <logdepthbuf_pars_fragment>",
    "#include <clipping_planes_pars_fragment>",
    "",
    "void main() {",
    "",
    "	#include <clipping_planes_fragment>",
    "	gl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );",
    "",
    "	#include <logdepthbuf_fragment>",
    "",
    "}",
    "",
].join('\n');

var normal_vert = [
    "varying vec3 vNormal;",
    "",
    "#include <common>",
    "#include <morphtarget_pars_vertex>",
    "#include <logdepthbuf_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",
    "",
    "void main() {",
    "",
    "	vNormal = normalize( normalMatrix * normal );",
    "",
    "	#include <begin_vertex>",
    "	#include <morphtarget_vertex>",
    "	#include <project_vertex>",
    "	#include <logdepthbuf_vertex>",
    "	#include <clipping_planes_vertex>",
    "",
    "}",
    "",
].join('\n');

var points_frag = [
    "uniform vec3 diffuse;",
    "uniform float opacity;",
    "",
    "#include <common>",
    "#include <packing>",
    "#include <color_pars_fragment>",
    "#include <map_particle_pars_fragment>",
    "#include <fog_pars_fragment>",
    "#include <shadowmap_pars_fragment>",
    "#include <logdepthbuf_pars_fragment>",
    "#include <clipping_planes_pars_fragment>",
    "",
    "void main() {",
    "",
    "	#include <clipping_planes_fragment>",
    "",
    "	vec3 outgoingLight = vec3( 0.0 );",
    "	vec4 diffuseColor = vec4( diffuse, opacity );",
    "",
    "	#include <logdepthbuf_fragment>",
    "	#include <map_particle_fragment>",
    "	#include <color_fragment>",
    "	#include <alphatest_fragment>",
    "",
    "	outgoingLight = diffuseColor.rgb;",
    "",
    "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    "",
    "	#include <premultiplied_alpha_fragment>",
    "	#include <tonemapping_fragment>",
    "	#include <encodings_fragment>",
    "	#include <fog_fragment>",
    "",
    "}",
    "",
].join('\n');

var points_vert = [
    "uniform float size;",
    "uniform float scale;",
    "",
    "#include <common>",
    "#include <color_pars_vertex>",
    "#include <shadowmap_pars_vertex>",
    "#include <logdepthbuf_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",
    "",
    "void main() {",
    "",
    "	#include <color_vertex>",
    "	#include <begin_vertex>",
    "	#include <project_vertex>",
    "",
    "	#ifdef USE_SIZEATTENUATION",
    "		gl_PointSize = size * ( scale / - mvPosition.z );",
    "	#else",
    "		gl_PointSize = size;",
    "	#endif",
    "",
    "	#include <logdepthbuf_vertex>",
    "	#include <clipping_planes_vertex>",
    "	#include <worldpos_vertex>",
    "	#include <shadowmap_vertex>",
    "",
    "}",
    "",
].join('\n');

var shadow_frag = [
    "uniform float opacity;",
    "",
    "#include <common>",
    "#include <packing>",
    "#include <bsdfs>",
    "#include <lights_pars>",
    "#include <shadowmap_pars_fragment>",
    "#include <shadowmask_pars_fragment>",
    "",
    "void main() {",
    "",
    "	gl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );",
    "",
    "}",
    "",
].join('\n');

var shadow_vert = [
    "#include <shadowmap_pars_vertex>",
    "",
    "void main() {",
    "",
    "	#include <begin_vertex>",
    "	#include <project_vertex>",
    "	#include <worldpos_vertex>",
    "	#include <shadowmap_vertex>",
    "",
    "}",
    "",
].join('\n');

var ShaderChunk = {
    alphamap_fragment: alphamap_fragment,
    alphamap_pars_fragment: alphamap_pars_fragment,
    alphatest_fragment: alphatest_fragment,
    aomap_fragment: aomap_fragment,
    aomap_pars_fragment: aomap_pars_fragment,
    begin_vertex: begin_vertex,
    beginnormal_vertex: beginnormal_vertex,
    bsdfs: bsdfs,
    bumpmap_pars_fragment: bumpmap_pars_fragment,
    clipping_planes_fragment: clipping_planes_fragment,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    clipping_planes_vertex: clipping_planes_vertex,
    color_fragment: color_fragment,
    color_pars_fragment: color_pars_fragment,
    color_pars_vertex: color_pars_vertex,
    color_vertex: color_vertex,
    common: common,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    defaultnormal_vertex: defaultnormal_vertex,
    displacementmap_pars_vertex: displacementmap_pars_vertex,
    displacementmap_vertex: displacementmap_vertex,
    emissivemap_fragment: emissivemap_fragment,
    emissivemap_pars_fragment: emissivemap_pars_fragment,
    encodings_fragment: encodings_fragment,
    encodings_pars_fragment: encodings_pars_fragment,
    envmap_fragment: envmap_fragment,
    envmap_pars_fragment: envmap_pars_fragment,
    envmap_pars_vertex: envmap_pars_vertex,
    envmap_vertex: envmap_vertex,
    fog_fragment: fog_fragment,
    fog_pars_fragment: fog_pars_fragment,
    lightmap_fragment: lightmap_fragment,
    lightmap_pars_fragment: lightmap_pars_fragment,
    lights_lambert_vertex: lights_lambert_vertex,
    lights_pars: lights_pars,
    lights_phong_fragment: lights_phong_fragment,
    lights_phong_pars_fragment: lights_phong_pars_fragment,
    lights_physical_fragment: lights_physical_fragment,
    lights_physical_pars_fragment: lights_physical_pars_fragment,
    lights_template: lights_template,
    logdepthbuf_fragment: logdepthbuf_fragment,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    logdepthbuf_vertex: logdepthbuf_vertex,
    map_fragment: map_fragment,
    map_pars_fragment: map_pars_fragment,
    map_particle_fragment: map_particle_fragment,
    map_particle_pars_fragment: map_particle_pars_fragment,
    metalnessmap_fragment: metalnessmap_fragment,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    morphnormal_vertex: morphnormal_vertex,
    morphtarget_pars_vertex: morphtarget_pars_vertex,
    morphtarget_vertex: morphtarget_vertex,
    normal_flip: normal_flip,
    normal_fragment: normal_fragment,
    normalmap_pars_fragment: normalmap_pars_fragment,
    packing: packing,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    project_vertex: project_vertex,
    roughnessmap_fragment: roughnessmap_fragment,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    shadowmap_pars_fragment: shadowmap_pars_fragment,
    shadowmap_pars_vertex: shadowmap_pars_vertex,
    shadowmap_vertex: shadowmap_vertex,
    shadowmask_pars_fragment: shadowmask_pars_fragment,
    skinbase_vertex: skinbase_vertex,
    skinning_pars_vertex: skinning_pars_vertex,
    skinning_vertex: skinning_vertex,
    skinnormal_vertex: skinnormal_vertex,
    specularmap_fragment: specularmap_fragment,
    specularmap_pars_fragment: specularmap_pars_fragment,
    tonemapping_fragment: tonemapping_fragment,
    tonemapping_pars_fragment: tonemapping_pars_fragment,
    uv_pars_fragment: uv_pars_fragment,
    uv_pars_vertex: uv_pars_vertex,
    uv_vertex: uv_vertex,
    uv2_pars_fragment: uv2_pars_fragment,
    uv2_pars_vertex: uv2_pars_vertex,
    uv2_vertex: uv2_vertex,
    worldpos_vertex: worldpos_vertex,
    cube_frag: cube_frag,
    cube_vert: cube_vert,
    depth_frag: depth_frag,
    depth_vert: depth_vert,
    distanceRGBA_frag: distanceRGBA_frag,
    distanceRGBA_vert: distanceRGBA_vert,
    equirect_frag: equirect_frag,
    equirect_vert: equirect_vert,
    linedashed_frag: linedashed_frag,
    linedashed_vert: linedashed_vert,
    meshbasic_frag: meshbasic_frag,
    meshbasic_vert: meshbasic_vert,
    meshlambert_frag: meshlambert_frag,
    meshlambert_vert: meshlambert_vert,
    meshphong_frag: meshphong_frag,
    meshphong_vert: meshphong_vert,
    meshphysical_frag: meshphysical_frag,
    meshphysical_vert: meshphysical_vert,
    normal_frag: normal_frag,
    normal_vert: normal_vert,
    points_frag: points_frag,
    points_vert: points_vert,
    shadow_frag: shadow_frag,
    shadow_vert: shadow_vert
};

var UniformsLib = {
    common: {
        diffuse: { value: new Color(0xeeeeee) },
        opacity: { value: 1.0 },
        map: { value: null },
        offsetRepeat: { value: new Vector4(0, 0, 1, 1) },
        specularMap: { value: null },
        alphaMap: { value: null },
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1.0 },
        refractionRatio: { value: 0.98 }
    },
    aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 }
    },
    lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 }
    },
    emissivemap: {
        emissiveMap: { value: null }
    },
    bumpmap: {
        bumpMap: { value: null },
        bumpScale: { value: 1 }
    },
    normalmap: {
        normalMap: { value: null },
        normalScale: { value: new Vector2(1, 1) }
    },
    displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 }
    },
    roughnessmap: {
        roughnessMap: { value: null }
    },
    metalnessmap: {
        metalnessMap: { value: null }
    },
    fog: {
        fogDensity: { value: 0.00025 },
        fogNear: { value: 1 },
        fogFar: { value: 2000 },
        fogColor: { value: new Color(0xffffff) }
    },
    lights: {
        ambientLightColor: { value: [] },
        directionalLights: { value: [], properties: {
                direction: {},
                color: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            } },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: { value: [], properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            } },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: { value: [], properties: {
                color: {},
                position: {},
                decay: {},
                distance: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            } },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: { value: [], properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            } }
    },
    points: {
        diffuse: { value: new Color(0xeeeeee) },
        opacity: { value: 1.0 },
        size: { value: 1.0 },
        scale: { value: 1.0 },
        map: { value: null },
        offsetRepeat: { value: new Vector4(0, 0, 1, 1) }
    }
};

var ShaderLib = {
    basic: {
        uniforms: UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: { value: new Color(0x000000) }
            }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: { value: new Color(0x000000) },
                specular: { value: new Color(0x111111) },
                shininess: { value: 30 }
            }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.roughnessmap,
            UniformsLib.metalnessmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: { value: new Color(0x000000) },
                roughness: { value: 0.5 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
            }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    points: {
        uniforms: UniformsUtils.merge([
            UniformsLib.points,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.fog,
            {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 }
            }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: {
            opacity: { value: 1.0 }
        },
        vertexShader: ShaderChunk.normal_vert,
        fragmentShader: ShaderChunk.normal_frag
    },
    /* -------------------------------------------------------------------------
    //  Cube map shader
     ------------------------------------------------------------------------- */
    cube: {
        uniforms: {
            tCube: { value: null },
            tFlip: { value: -1 },
            opacity: { value: 1.0 }
        },
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    /* -------------------------------------------------------------------------
    //  Cube map shader
     ------------------------------------------------------------------------- */
    equirect: {
        uniforms: {
            tEquirect: { value: null },
            tFlip: { value: -1 }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: {
            lightPos: { value: new Vector3() }
        },
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    }
};
ShaderLib.physical = {
    uniforms: UniformsUtils.merge([
        ShaderLib.standard.uniforms,
        {
            clearCoat: { value: 0 },
            clearCoatRoughness: { value: 0 }
        }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};

/**
 * @author bhouston / http://clara.io
 */
var Box2 = (function () {
    function Box2(min, max) {
        if (min === void 0) { min = new Vector2(+Infinity, +Infinity); }
        if (max === void 0) { max = new Vector2(-Infinity, -Infinity); }
        this.min = min;
        this.max = max;
    }
    Box2.prototype.set = function (min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    };
    Box2.prototype.setFromPoints = function (points) {
        this.makeEmpty();
        for (var i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
        }
        return this;
    };
    Box2.prototype.setFromCenterAndSize = function (center, size) {
        var v1 = Box2._setFromCenterAndSize_v1;
        var halfSize = v1.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    };
    Box2.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Box2.prototype.copy = function (box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    };
    Box2.prototype.makeEmpty = function () {
        this.min.x = this.min.y = +Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    };
    Box2.prototype.isEmpty = function () {
        // this is a more robust check for empty than (volume <= 0) because volume can get positive with two negative axes
        return (this.max.x < this.min.x) || (this.max.y < this.min.y);
    };
    Box2.prototype.getCenter = function (result) {
        if (result === void 0) { result = new Vector2(); }
        return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
    };
    Box2.prototype.getSize = function (result) {
        if (result === void 0) { result = new Vector2(); }
        return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);
    };
    Box2.prototype.expandByPoint = function (point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    };
    Box2.prototype.expandByVector = function (vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    };
    Box2.prototype.expandByScalar = function (scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    };
    Box2.prototype.containsPoint = function (point) {
        if (point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y) {
            return false;
        }
        return true;
    };
    Box2.prototype.containsBox = function (box) {
        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) &&
            (this.min.y <= box.min.y) && (box.max.y <= this.max.y)) {
            return true;
        }
        return false;
    };
    Box2.prototype.getParameter = function (point, result) {
        if (result === void 0) { result = new Vector2(); }
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    };
    Box2.prototype.intersectsBox = function (box) {
        // using 6 splitting planes to rule out intersections.
        if (box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y) {
            return false;
        }
        return true;
    };
    Box2.prototype.clampPoint = function (point, result) {
        if (result === void 0) { result = new Vector2(); }
        return result.copy(point).clamp(this.min, this.max);
    };
    Box2.prototype.distanceToPoint = function (point) {
        var v1 = Box2._distanceToPoint_v1;
        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    };
    Box2.prototype.intersect = function (box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    };
    Box2.prototype.union = function (box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    };
    Box2.prototype.translate = function (offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    };
    Box2.prototype.equals = function (box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    };
    Box2.prototype.empty = function () {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
    };
    Box2.prototype.center = function (optionalTarget) {
        if (optionalTarget === void 0) { optionalTarget = new Vector2(); }
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
    };
    Box2.prototype.size = function (optionalTarget) {
        if (optionalTarget === void 0) { optionalTarget = new Vector2(); }
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
    };
    Box2.prototype.isIntersectionBox = function (box) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
    };
    Box2._setFromCenterAndSize_v1 = new Vector2();
    Box2._distanceToPoint_v1 = new Vector2();
    return Box2;
}());

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */
var LensFlarePlugin = (function () {
    function LensFlarePlugin(renderer, flares) {
        this.renderer = renderer;
        this.flares = flares;
    }
    LensFlarePlugin.prototype.init = function () {
        var gl = this.renderer.context;
        var state = this.renderer.state;
        var vertices = new Float32Array([
            -1, -1, 0, 0,
            1, -1, 1, 0,
            1, 1, 1, 1,
            -1, 1, 0, 1
        ]);
        var faces = new Uint16Array([
            0, 1, 2,
            0, 2, 3
        ]);
        // buffers
        var vertexBuffer = this.vertexBuffer = gl.createBuffer();
        var elementBuffer = this.elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        // textures
        var tempTexture = this.tempTexture = gl.createTexture();
        var occlusionTexture = this.occlusionTexture = gl.createTexture();
        state.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        var shader = this.shader = {
            vertexShader: [
                "uniform lowp int renderType;",
                "uniform vec3 screenPosition;",
                "uniform vec2 scale;",
                "uniform float rotation;",
                "uniform sampler2D occlusionMap;",
                "attribute vec2 position;",
                "attribute vec2 uv;",
                "varying vec2 vUV;",
                "varying float vVisibility;",
                "void main() {",
                "vUV = uv;",
                "vec2 pos = position;",
                "if (renderType == 2) {",
                "vec4 visibility = texture2D(occlusionMap, vec2(0.1, 0.1));",
                "visibility += texture2D(occlusionMap, vec2(0.5, 0.1));",
                "visibility += texture2D(occlusionMap, vec2(0.9, 0.1));",
                "visibility += texture2D(occlusionMap, vec2(0.9, 0.5));",
                "visibility += texture2D(occlusionMap, vec2(0.9, 0.9));",
                "visibility += texture2D(occlusionMap, vec2(0.5, 0.9));",
                "visibility += texture2D(occlusionMap, vec2(0.1, 0.9));",
                "visibility += texture2D(occlusionMap, vec2(0.1, 0.5));",
                "visibility += texture2D(occlusionMap, vec2(0.5, 0.5));",
                "vVisibility =        visibility.r / 9.0;",
                "vVisibility *= 1.0 - visibility.g / 9.0;",
                "vVisibility *=       visibility.b / 9.0;",
                "vVisibility *= 1.0 - visibility.a / 9.0;",
                "pos.x = cos(rotation) * position.x - sin(rotation) * position.y;",
                "pos.y = sin(rotation) * position.x + cos(rotation) * position.y;",
                "}",
                "gl_Position = vec4((pos * scale + screenPosition.xy).xy, screenPosition.z, 1.0);",
                "}"
            ].join("\n"),
            fragmentShader: [
                "uniform lowp int renderType;",
                "uniform sampler2D map;",
                "uniform float opacity;",
                "uniform vec3 color;",
                "varying vec2 vUV;",
                "varying float vVisibility;",
                "void main() {",
                // pink square
                "if (renderType == 0) {",
                "gl_FragColor = vec4(1.0, 0.0, 1.0, 0.0);",
                // restore
                "} else if (renderType == 1) {",
                "gl_FragColor = texture2D(map, vUV);",
                // flare
                "} else {",
                "vec4 texture = texture2D(map, vUV);",
                "texture.a *= opacity * vVisibility;",
                "gl_FragColor = texture;",
                "gl_FragColor.rgb *= color;",
                "}",
                "}"
            ].join("\n")
        };
        var program = this.program = this.createProgram(shader);
        this.attributes = {
            vertex: gl.getAttribLocation(program, "position"),
            uv: gl.getAttribLocation(program, "uv")
        };
        this.uniforms = {
            renderType: gl.getUniformLocation(program, "renderType"),
            map: gl.getUniformLocation(program, "map"),
            occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
            opacity: gl.getUniformLocation(program, "opacity"),
            color: gl.getUniformLocation(program, "color"),
            scale: gl.getUniformLocation(program, "scale"),
            rotation: gl.getUniformLocation(program, "rotation"),
            screenPosition: gl.getUniformLocation(program, "screenPosition")
        };
    };
    /*
     * Render lens flares
     * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
     *         reads these back and calculates occlusion.
     */
    LensFlarePlugin.prototype.render = function (scene, camera, viewport) {
        var gl = this.renderer.context;
        var state = this.renderer.state;
        var flares = this.flares;
        if (flares.length === 0)
            return;
        var tempPosition = new Vector3();
        var invAspect = viewport.w / viewport.z;
        var halfViewportWidth = viewport.z * 0.5;
        var halfViewportHeight = viewport.w * 0.5;
        var size = 16 / viewport.w;
        var scale = new Vector2(size * invAspect, size);
        var screenPosition = new Vector3(1, 1, 0);
        var screenPositionPixels = new Vector2(1, 1);
        var validArea = new Box2();
        validArea.min.set(viewport.x, viewport.y);
        validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
        if (this.program === undefined) {
            this.init();
        }
        var uniforms = this.uniforms;
        var attributes = this.attributes;
        gl.useProgram(this.program);
        state.initAttributes();
        state.enableAttribute(attributes.vertex);
        state.enableAttribute(attributes.uv);
        state.disableUnusedAttributes();
        // loop through all lens flares to update their occlusion and positions
        // setup gl and common used attribs/uniforms
        gl.uniform1i(uniforms.occlusionMap, 0);
        gl.uniform1i(uniforms.map, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
        state.disable(gl.CULL_FACE);
        state.setDepthWrite(false);
        for (var i = 0, l = flares.length; i < l; i++) {
            size = 16 / viewport.w;
            scale.set(size * invAspect, size);
            // calc object screen position
            var flare = flares[i];
            tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
            tempPosition.applyMatrix4(camera.matrixWorldInverse);
            tempPosition.applyProjection(camera.projectionMatrix);
            // setup arrays for gl programs
            screenPosition.copy(tempPosition);
            // horizontal and vertical coordinate of the lower left corner of the pixels to copy
            screenPositionPixels.x = viewport.x + (screenPosition.x * halfViewportWidth) + halfViewportWidth - 8;
            screenPositionPixels.y = viewport.y + (screenPosition.y * halfViewportHeight) + halfViewportHeight - 8;
            // screen cull
            if (validArea.containsPoint(screenPositionPixels) === true) {
                // save current RGB to temp texture
                state.activeTexture(gl.TEXTURE0);
                state.bindTexture(gl.TEXTURE_2D, null);
                state.activeTexture(gl.TEXTURE1);
                state.bindTexture(gl.TEXTURE_2D, this.tempTexture);
                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                // render pink quad
                gl.uniform1i(uniforms.renderType, 0);
                gl.uniform2f(uniforms.scale, scale.x, scale.y);
                gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                state.disable(gl.BLEND);
                state.enable(gl.DEPTH_TEST);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                // copy result to occlusionMap
                state.activeTexture(gl.TEXTURE0);
                state.bindTexture(gl.TEXTURE_2D, this.occlusionTexture);
                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                // restore graphics
                gl.uniform1i(uniforms.renderType, 1);
                state.disable(gl.DEPTH_TEST);
                state.activeTexture(gl.TEXTURE1);
                state.bindTexture(gl.TEXTURE_2D, this.tempTexture);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                // update object positions
                flare.positionScreen.copy(screenPosition);
                if (flare.customUpdateCallback) {
                    flare.customUpdateCallback(flare);
                }
                else {
                    flare.updateLensFlares();
                }
                // render flares
                gl.uniform1i(uniforms.renderType, 2);
                state.enable(gl.BLEND);
                for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                    var sprite = flare.lensFlares[j];
                    if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
                        screenPosition.x = sprite.x;
                        screenPosition.y = sprite.y;
                        screenPosition.z = sprite.z;
                        size = sprite.size * sprite.scale / viewport.w;
                        scale.x = size * invAspect;
                        scale.y = size;
                        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                        gl.uniform2f(uniforms.scale, scale.x, scale.y);
                        gl.uniform1f(uniforms.rotation, sprite.rotation);
                        gl.uniform1f(uniforms.opacity, sprite.opacity);
                        gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                        state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                        this.renderer.setTexture2D(sprite.texture, 1);
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    }
                }
            }
        }
        // restore gl
        state.enable(gl.CULL_FACE);
        state.enable(gl.DEPTH_TEST);
        state.setDepthWrite(true);
        this.renderer.resetGLState();
    };
    LensFlarePlugin.prototype.createProgram = function (shader) {
        var gl = this.renderer.context;
        var program = gl.createProgram();
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var prefix = "precision " + this.renderer.getPrecision() + " float;\n";
        gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
        gl.shaderSource(vertexShader, prefix + shader.vertexShader);
        gl.compileShader(fragmentShader);
        gl.compileShader(vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.linkProgram(program);
        return program;
    };
    return LensFlarePlugin;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
var Fog = (function () {
    function Fog(color, near, far) {
        if (near === void 0) { near = 1; }
        if (far === void 0) { far = 1000; }
        this.name = '';
        this.isFog = true;
        this.color = new Color(color);
        this.near = near;
        this.far = far;
    }
    Fog.prototype.clone = function () {
        return new this.constructor(this.color.getHex(), this.near, this.far);
    };
    Fog.prototype.toJSON = function (meta) {
        return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    };
    return Fog;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
var FogExp2 = (function () {
    function FogExp2(color, density) {
        if (density === void 0) { density = 0.00025; }
        this.name = '';
        this.isFogExp2 = true;
        this.color = new Color(color);
        this.density = density;
    }
    FogExp2.prototype.clone = function () {
        return new this.constructor(this.color.getHex(), this.density);
    };
    FogExp2.prototype.toJSON = function (meta) {
        return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density
        };
    };
    return FogExp2;
}());

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */
var SpritePlugin = (function () {
    function SpritePlugin(renderer, sprites) {
        this.renderer = renderer;
        this.sprites = sprites;
    }
    SpritePlugin.prototype.init = function () {
        var renderer = this.renderer;
        var gl = renderer.context;
        var vertices = new Float32Array([
            -0.5, -0.5, 0, 0,
            0.5, -0.5, 1, 0,
            0.5, 0.5, 1, 1,
            -0.5, 0.5, 0, 1
        ]);
        var faces = new Uint16Array([
            0, 1, 2,
            0, 2, 3
        ]);
        var vertexBuffer = this.vertexBuffer = gl.createBuffer();
        var elementBuffer = this.elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        var program = this.program = this.createProgram();
        this.attributes = {
            position: gl.getAttribLocation(program, 'position'),
            uv: gl.getAttribLocation(program, 'uv')
        };
        this.uniforms = {
            uvOffset: gl.getUniformLocation(program, 'uvOffset'),
            uvScale: gl.getUniformLocation(program, 'uvScale'),
            rotation: gl.getUniformLocation(program, 'rotation'),
            scale: gl.getUniformLocation(program, 'scale'),
            color: gl.getUniformLocation(program, 'color'),
            map: gl.getUniformLocation(program, 'map'),
            opacity: gl.getUniformLocation(program, 'opacity'),
            modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
            projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
            fogType: gl.getUniformLocation(program, 'fogType'),
            fogDensity: gl.getUniformLocation(program, 'fogDensity'),
            fogNear: gl.getUniformLocation(program, 'fogNear'),
            fogFar: gl.getUniformLocation(program, 'fogFar'),
            fogColor: gl.getUniformLocation(program, 'fogColor'),
            alphaTest: gl.getUniformLocation(program, 'alphaTest')
        };
        var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        canvas.width = 8;
        canvas.height = 8;
        var context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 8, 8);
        var texture = this.texture = new Texture(canvas);
        texture.needsUpdate = true;
    };
    SpritePlugin.prototype.render = function (scene, camera) {
        // decompose matrixWorld
        var spritePosition = new Vector3();
        var spriteRotation = new Quaternion();
        var spriteScale = new Vector3();
        var renderer = this.renderer;
        var sprites = this.sprites;
        var gl = renderer.context;
        var state = renderer.state;
        if (sprites.length === 0)
            return;
        // setup gl
        if (this.program === undefined) {
            this.init();
        }
        var program = this.program;
        var attributes = this.attributes;
        var uniforms = this.uniforms;
        gl.useProgram(program);
        state.initAttributes();
        state.enableAttribute(attributes.position);
        state.enableAttribute(attributes.uv);
        state.disableUnusedAttributes();
        state.disable(gl.CULL_FACE);
        state.enable(gl.BLEND);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
        gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
        state.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uniforms.map, 0);
        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;
        if (fog) {
            gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
            if ((fog && fog instanceof Fog)) {
                gl.uniform1f(uniforms.fogNear, fog.near);
                gl.uniform1f(uniforms.fogFar, fog.far);
                gl.uniform1i(uniforms.fogType, 1);
                oldFogType = 1;
                sceneFogType = 1;
            }
            else if ((fog && fog instanceof FogExp2)) {
                gl.uniform1f(uniforms.fogDensity, fog.density);
                gl.uniform1i(uniforms.fogType, 2);
                oldFogType = 2;
                sceneFogType = 2;
            }
        }
        else {
            gl.uniform1i(uniforms.fogType, 0);
            oldFogType = 0;
            sceneFogType = 0;
        }
        // update positions and sort
        for (var i = 0, l = sprites.length; i < l; i++) {
            var sprite = sprites[i];
            sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
            sprite.z = -sprite.modelViewMatrix.elements[14];
        }
        sprites.sort(SpritePlugin.painterSortStable);
        // render all sprites
        var scale = [];
        for (var i = 0, l = sprites.length; i < l; i++) {
            var sprite = sprites[i];
            var material = sprite.material;
            if (material.visible === false)
                continue;
            gl.uniform1f(uniforms.alphaTest, material.alphaTest);
            gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
            sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
            scale[0] = spriteScale.x;
            scale[1] = spriteScale.y;
            var fogType = 0;
            if (scene.fog && material.fog) {
                fogType = sceneFogType;
            }
            if (oldFogType !== fogType) {
                gl.uniform1i(uniforms.fogType, fogType);
                oldFogType = fogType;
            }
            if (material.map !== null) {
                gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
            }
            else {
                gl.uniform2f(uniforms.uvOffset, 0, 0);
                gl.uniform2f(uniforms.uvScale, 1, 1);
            }
            gl.uniform1f(uniforms.opacity, material.opacity);
            gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
            gl.uniform1f(uniforms.rotation, material.rotation);
            gl.uniform2fv(uniforms.scale, scale);
            state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
            state.setDepthTest(material.depthTest);
            state.setDepthWrite(material.depthWrite);
            if (material.map) {
                renderer.setTexture2D(material.map, 0);
            }
            else {
                renderer.setTexture2D(this.texture, 0);
            }
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }
        // restore gl
        state.enable(gl.CULL_FACE);
        renderer.resetGLState();
    };
    SpritePlugin.prototype.createProgram = function () {
        var renderer = this.renderer;
        var gl = renderer.context;
        var program = gl.createProgram();
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, [
            'precision ' + renderer.getPrecision() + ' float;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform float rotation;',
            'uniform vec2 scale;',
            'uniform vec2 uvOffset;',
            'uniform vec2 uvScale;',
            'attribute vec2 position;',
            'attribute vec2 uv;',
            'varying vec2 vUV;',
            'void main() {',
            'vUV = uvOffset + uv * uvScale;',
            'vec2 alignedPosition = position * scale;',
            'vec2 rotatedPosition;',
            'rotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;',
            'rotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;',
            'vec4 finalPosition;',
            'finalPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);',
            'finalPosition.xy += rotatedPosition;',
            'finalPosition = projectionMatrix * finalPosition;',
            'gl_Position = finalPosition;',
            '}'
        ].join('\n'));
        gl.shaderSource(fragmentShader, [
            'precision ' + renderer.getPrecision() + ' float;',
            'uniform vec3 color;',
            'uniform sampler2D map;',
            'uniform float opacity;',
            'uniform int fogType;',
            'uniform vec3 fogColor;',
            'uniform float fogDensity;',
            'uniform float fogNear;',
            'uniform float fogFar;',
            'uniform float alphaTest;',
            'varying vec2 vUV;',
            'void main() {',
            'vec4 texture = texture2D(map, vUV);',
            'if (texture.a < alphaTest) discard;',
            'gl_FragColor = vec4(color * texture.xyz, texture.a * opacity);',
            'if (fogType > 0) {',
            'float depth = gl_FragCoord.z / gl_FragCoord.w;',
            'float fogFactor = 0.0;',
            'if (fogType == 1) {',
            'fogFactor = smoothstep(fogNear, fogFar, depth);',
            '} else {',
            'const float LOG2 = 1.442695;',
            'fogFactor = exp2(- fogDensity * fogDensity * depth * depth * LOG2);',
            'fogFactor = 1.0 - clamp(fogFactor, 0.0, 1.0);',
            '}',
            'gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);',
            '}',
            '}'
        ].join('\n'));
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        return program;
    };
    SpritePlugin.painterSortStable = function (a, b) {
        if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        }
        else if (a.z !== b.z) {
            return b.z - a.z;
        }
        else {
            return b.id - a.id;
        }
    };
    return SpritePlugin;
}());

var Material = (function (_super) {
    __extends(Material, _super);
    function Material() {
        _super.call(this);
        this.id = MaterialIdCount();
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'Material';
        this.fog = true;
        this.lights = true;
        this.blending = BlendingMode.Normal;
        this.side = SideMode.Front;
        this.shading = ShadingMode.Smooth; // THREE.ShadingMode.Flat, THREE.ShadingMode.Smooth
        this.vertexColors = ColorsMode.None; // THREE.ColorsMode.No, THREE.ColorsMode.Vertex, THREE.ColorsMode.Face
        this._opacity = 1;
        this.transparent = false;
        this.blendSrc = BlendingFactor.SrcAlpha;
        this.blendDst = BlendingFactor.OneMinusSrcAlpha;
        this.blendEquation = BlendingEquation.Add;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = DepthFunction.LessEqual;
        this.depthTest = true;
        this.depthWrite = true;
        this.clipping = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.colorWrite = true;
        this.precision = null; // override the renderer's default precision for this material
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.alphaTest = 0;
        this.premultipliedAlpha = false;
        this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
        this.visible = true;
        this._needsUpdate = true;
        // }
        this.isMaterial = true;
        this.isMultiMaterial = false;
    }
    Object.defineProperty(Material.prototype, "opacity", {
        get: function () {
            return this._opacity;
        },
        set: function (value) {
            this._opacity = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "needsUpdate", {
        get: function () {
            return this._needsUpdate;
        },
        set: function (value) {
            if (value === true)
                this.update();
            this._needsUpdate = value;
        },
        enumerable: true,
        configurable: true
    });
    Material.prototype.setValues = function (values) {
        if (values === undefined)
            return;
        for (var key in values) {
            var newValue = values[key];
            if (newValue === undefined) {
                console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                continue;
            }
            var currentValue = this[key];
            if (currentValue === undefined) {
                console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                continue;
            }
            if ((currentValue && currentValue instanceof Color)) {
                currentValue.set(newValue);
            }
            else if ((currentValue && currentValue instanceof Vector3) && (newValue && newValue instanceof Vector3)) {
                currentValue.copy(newValue);
            }
            else if (key === 'overdraw') {
                // ensure overdraw is backwards-compatible with legacy boolean type
                this[key] = Number(newValue);
            }
            else {
                this[key] = newValue;
            }
        }
    };
    Material.prototype.toJSON = function (meta) {
        var isRoot = meta === undefined;
        if (isRoot) {
            meta = {
                textures: {},
                images: {}
            };
        }
        var data = {
            metadata: {
                version: 4.4,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };
        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
            data.name = this.name;
        if ((this.color && this.color instanceof Color))
            data.color = this.color.getHex();
        if (this.roughness !== undefined)
            data.roughness = this.roughness;
        if (this.metalness !== undefined)
            data.metalness = this.metalness;
        if ((this.emissive && this.emissive instanceof Color))
            data.emissive = this.emissive.getHex();
        if ((this.specular && this.specular instanceof Color))
            data.specular = this.specular.getHex();
        if (this.shininess !== undefined)
            data.shininess = this.shininess;
        if ((this.map && this.map instanceof Texture))
            data.map = this.map.toJSON(meta).uuid;
        if ((this.alphaMap && this.alphaMap instanceof Texture))
            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if ((this.lightMap && this.lightMap instanceof Texture))
            data.lightMap = this.lightMap.toJSON(meta).uuid;
        if ((this.bumpMap && this.bumpMap instanceof Texture)) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
        }
        if ((this.normalMap && this.normalMap instanceof Texture)) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalScale = this.normalScale.toArray();
        }
        if ((this.displacementMap && this.displacementMap instanceof Texture)) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
        }
        if ((this.roughnessMap && this.roughnessMap instanceof Texture))
            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if ((this.metalnessMap && this.metalnessMap instanceof Texture))
            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if ((this.emissiveMap && this.emissiveMap instanceof Texture))
            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if ((this.specularMap && this.specularMap instanceof Texture))
            data.specularMap = this.specularMap.toJSON(meta).uuid;
        if ((this.envMap && this.envMap instanceof Texture)) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            data.reflectivity = this.reflectivity; // Scale behind envMap
        }
        if (this.size !== undefined)
            data.size = this.size;
        if (this.sizeAttenuation !== undefined)
            data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== BlendingMode.Normal)
            data.blending = this.blending;
        if (this.shading !== ShadingMode.Smooth)
            data.shading = this.shading;
        if (this.side !== SideMode.Front)
            data.side = this.side;
        if (this.vertexColors !== ColorsMode.None)
            data.vertexColors = this.vertexColors;
        if (this.opacity < 1)
            data.opacity = this.opacity;
        if (this.transparent === true)
            data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        if (this.alphaTest > 0)
            data.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true)
            data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true)
            data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1)
            data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== 'round')
            data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== 'round')
            data.wireframeLinejoin = this.wireframeLinejoin;
        data.skinning = this.skinning;
        data.morphTargets = this.morphTargets;
        // TODO: Copied from Object3D.toJSON
        function extractFromCache(cache) {
            var values = [];
            for (var key in cache) {
                var data_1 = cache[key];
                delete data_1.metadata;
                values.push(data_1);
            }
            return values;
        }
        if (isRoot) {
            var textures = extractFromCache(meta.textures);
            var images = extractFromCache(meta.images);
            if (textures.length > 0)
                data.textures = textures;
            if (images.length > 0)
                data.images = images;
        }
        return data;
    };
    Material.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Material.prototype.copy = function (source) {
        this.name = source.name;
        this.fog = source.fog;
        this.lights = source.lights;
        this.blending = source.blending;
        this.side = source.side;
        this.shading = source.shading;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.overdraw = source.overdraw;
        this.visible = source.visible;
        this.clipShadows = source.clipShadows;
        this.clipIntersection = source.clipIntersection;
        var srcPlanes = source.clippingPlanes, dstPlanes = null;
        if (srcPlanes !== null) {
            var n = srcPlanes.length;
            dstPlanes = new Array(n);
            for (var i = 0; i !== n; ++i)
                dstPlanes[i] = srcPlanes[i].clone();
        }
        this.clippingPlanes = dstPlanes;
        return this;
    };
    Material.prototype.update = function () {
        this.dispatchEvent({ type: 'update' });
    };
    Material.prototype.dispose = function () {
        this.dispatchEvent({ type: 'dispose' });
    };
    Object.defineProperty(Material.prototype, "wrapAround", {
        get: function () {
            console.warn("THREE." + this.type + ": .wrapAround has been removed.");
            return false;
        },
        set: function (value) {
            console.warn("THREE." + this.type + ": .wrapAround has been removed.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "wrapRGB", {
        get: function () {
            console.warn("THREE." + this.type + ": .wrapRGB has been removed.");
            return new Color();
        },
        enumerable: true,
        configurable: true
    });
    return Material;
}(EventDispatcher));
var count$1 = 0;
function MaterialIdCount() { return count$1++; }

var ShaderMaterial = (function (_super) {
    __extends(ShaderMaterial, _super);
    function ShaderMaterial(parameters) {
        _super.call(this);
        // }
        this.isShaderMaterial = true;
        this.type = 'ShaderMaterial';
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}';
        this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}';
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false; // set to use scene fog
        this.lights = false; // set to use scene lights
        this.clipping = false; // set to use user-defined clipping planes
        this.skinning = false; // set to use skinning attribute streams
        this.morphTargets = false; // set to use morph targets
        this.morphNormals = false; // set to use morph normals
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false // set to use shader texture LOD
        };
        // When rendered geometry doesn't include these attributes but the material does,
        // use these default values in WebGL. This avoids errors when buffer data is missing.
        this.defaultAttributeValues = {
            'color': [1, 1, 1],
            'uv': [0, 0],
            'uv2': [0, 0]
        };
        this.index0AttributeName = undefined;
        if (parameters !== undefined) {
            this.setValues(parameters);
        }
    }
    ShaderMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = UniformsUtils.clone(source.uniforms);
        this.defines = source.defines;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.extensions = source.extensions;
        return this;
    };
    ShaderMaterial.prototype.toJSON = function (meta) {
        var data = _super.prototype.toJSON.call(this, meta);
        data.uniforms = this.uniforms;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        return data;
    };
    Object.defineProperty(ShaderMaterial.prototype, "derivatives", {
        get: function () {
            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            return this.extensions.derivatives;
        },
        set: function (value) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            this.extensions.derivatives = value;
        },
        enumerable: true,
        configurable: true
    });
    return ShaderMaterial;
}(Material));

var MeshDepthMaterial = (function (_super) {
    __extends(MeshDepthMaterial, _super);
    function MeshDepthMaterial(parameters) {
        _super.call(this);
        this.isMeshDepthMaterial = true;
        this.type = 'MeshDepthMaterial';
        this.depthPacking = DepthPacking.Basic;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.setValues(parameters);
    }
    MeshDepthMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.depthPacking = source.depthPacking;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    };
    
    return MeshDepthMaterial;
}(Material));

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
var Face3 = (function () {
    function Face3(a, b, c, normal, color, materialIndex) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = (normal && normal instanceof Vector3) ? normal : new Vector3();
        this.vertexNormals = Array.isArray(normal) ? normal : [];
        this.color = (color && color instanceof Color) ? color : new Color();
        this.vertexColors = Array.isArray(color) ? color : [];
        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    }
    Face3.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Face3.prototype.copy = function (source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
            this.vertexNormals[i] = source.vertexNormals[i].clone();
        }
        for (var i = 0, il = source.vertexColors.length; i < il; i++) {
            this.vertexColors[i] = source.vertexColors[i].clone();
        }
        return this;
    };
    return Face3;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var Layers = (function () {
    function Layers() {
        this.mask = 1;
    }
    Layers.prototype.set = function (channel) {
        this.mask = 1 << channel;
    };
    Layers.prototype.enable = function (channel) {
        this.mask |= 1 << channel;
    };
    Layers.prototype.toggle = function (channel) {
        this.mask ^= 1 << channel;
    };
    Layers.prototype.disable = function (channel) {
        this.mask &= ~(1 << channel);
    };
    Layers.prototype.test = function (layers) {
        return (this.mask & layers.mask) !== 0;
    };
    return Layers;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */
var Object3D = (function (_super) {
    __extends(Object3D, _super);
    function Object3D() {
        _super.call(this);
        this.id = Object3DIdCount();
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'Object3D';
        this.parent = null;
        this.children = [];
        this.up = Object3D.DefaultUp.clone();
        this.position = new Vector3();
        this.rotation = new Euler();
        this.quaternion = new Quaternion();
        this.scale = new Vector3(1, 1, 1);
        this.modelViewMatrix = new Matrix4();
        this.normalMatrix = new Matrix3();
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.userData = {};
        this.onBeforeRender = function () { };
        this.onAfterRender = function () { };
        this.geometry = undefined;
        this.material = undefined;
        // }
        this.isObject3D = true;
        var rotation = this.rotation;
        var quaternion = this.quaternion;
        function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, undefined, false);
        }
        rotation.onChange(onRotationChange);
        quaternion.onChange(onQuaternionChange);
    }
    Object3D.prototype.applyMatrix = function (matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    };
    Object3D.prototype.setRotationFromAxisAngle = function (axis, angle) {
        // assumes axis is normalized
        this.quaternion.setFromAxisAngle(axis, angle);
    };
    Object3D.prototype.setRotationFromEuler = function (euler) {
        this.quaternion.setFromEuler(euler, true);
    };
    Object3D.prototype.setRotationFromMatrix = function (m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        this.quaternion.setFromRotationMatrix(m);
    };
    Object3D.prototype.setRotationFromQuaternion = function (q) {
        // assumes q is normalized
        this.quaternion.copy(q);
    };
    Object3D.prototype.rotateOnAxis = function (axis, angle) {
        // rotate object on axis in object space
        // axis is assumed to be normalized
        var q1 = Object3D._rotateOnAxis_q1;
        q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(q1);
        return this;
    };
    Object3D.prototype.rotateX = function (angle) {
        var v1 = Object3D._rotateX_v1;
        return this.rotateOnAxis(v1, angle);
    };
    Object3D.prototype.rotateY = function (angle) {
        var v1 = Object3D._rotateY_v1;
        return this.rotateOnAxis(v1, angle);
    };
    Object3D.prototype.rotateZ = function (angle) {
        var v1 = Object3D._rotateZ_v1;
        return this.rotateOnAxis(v1, angle);
    };
    Object3D.prototype.translateOnAxis = function (axis, distance) {
        // translate object by distance along axis in object space
        // axis is assumed to be normalized
        var v1 = Object3D._translateOnAxis_v1;
        v1.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(v1.multiplyScalar(distance));
        return this;
    };
    Object3D.prototype.translateX = function (distance) {
        var v1 = Object3D._translateX_v1;
        return this.translateOnAxis(v1, distance);
    };
    Object3D.prototype.translateY = function (distance) {
        var v1 = Object3D._translateY_v1;
        return this.translateOnAxis(v1, distance);
    };
    Object3D.prototype.translateZ = function (distance) {
        var v1 = Object3D._translateZ_v1;
        return this.translateOnAxis(v1, distance);
    };
    Object3D.prototype.localToWorld = function (vector) {
        return vector.applyMatrix4(this.matrixWorld);
    };
    Object3D.prototype.worldToLocal = function (vector) {
        var m1 = Object3D._worldToLocal_m1;
        return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
    };
    Object3D.prototype.lookAt = function (vector) {
        // This routine does not support objects with rotated and/or translated parent(s)
        var m1 = Object3D._lookAt_m1;
        m1.lookAt(vector, this.position, this.up);
        this.quaternion.setFromRotationMatrix(m1);
    };
    Object3D.prototype.add = function (object) {
        if (arguments.length > 1) {
            for (var i = 0; i < arguments.length; i++) {
                this.add(arguments[i]);
            }
            return this;
        }
        if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
        }
        if ((object && object instanceof Object3D)) {
            if (object.parent !== null) {
                object.parent.remove(object);
            }
            object.parent = this;
            object.dispatchEvent({ type: 'added' });
            this.children.push(object);
        }
        else {
            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
    };
    Object3D.prototype.remove = function (object) {
        if (arguments.length > 1) {
            for (var i = 0; i < arguments.length; i++) {
                this.remove(arguments[i]);
            }
        }
        var index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = null;
            object.dispatchEvent({ type: 'removed' });
            this.children.splice(index, 1);
        }
    };
    Object3D.prototype.getObjectById = function (id) {
        return this.getObjectByProperty('id', id);
    };
    Object3D.prototype.getObjectByName = function (name) {
        return this.getObjectByProperty('name', name);
    };
    Object3D.prototype.getObjectByProperty = function (name, value) {
        if (this[name] === value)
            return this;
        for (var i = 0, l = this.children.length; i < l; i++) {
            var child = this.children[i];
            var object = child.getObjectByProperty(name, value);
            if (object !== undefined) {
                return object;
            }
        }
        return undefined;
    };
    Object3D.prototype.getWorldPosition = function (result) {
        if (result === void 0) { result = new Vector3(); }
        this.updateMatrixWorld(true);
        return result.setFromMatrixPosition(this.matrixWorld);
    };
    Object3D.prototype.getWorldQuaternion = function (result) {
        if (result === void 0) { result = new Quaternion(); }
        var position = Object3D._getWorldQuaternion_position;
        var scale = Object3D._getWorldQuaternion_scale;
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(position, result, scale);
        return result;
    };
    Object3D.prototype.getWorldRotation = function (result) {
        if (result === void 0) { result = new Euler(); }
        var quaternion = Object3D._getWorldRotation_quaternion;
        this.getWorldQuaternion(quaternion);
        return result.setFromQuaternion(quaternion, this.rotation.order, false);
    };
    Object3D.prototype.getWorldScale = function (result) {
        if (result === void 0) { result = new Vector3(); }
        var position = Object3D._getWorldScale_position;
        var quaternion = Object3D._getWorldScale_quaternion;
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(position, quaternion, result);
        return result;
    };
    Object3D.prototype.getWorldDirection = function (result) {
        if (result === void 0) { result = new Vector3(); }
        var quaternion = Object3D._getWorldDirection_quaternion;
        this.getWorldQuaternion(quaternion);
        return result.set(0, 0, 1).applyQuaternion(quaternion);
    };
    Object3D.prototype.raycast = function (raycaster, intersects) {
        return intersects;
    };
    Object3D.prototype.traverse = function (callback) {
        callback(this);
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            children[i].traverse(callback);
        }
    };
    Object3D.prototype.traverseVisible = function (callback) {
        if (this.visible === false)
            return;
        callback(this);
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            children[i].traverseVisible(callback);
        }
    };
    Object3D.prototype.traverseAncestors = function (callback) {
        var parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    };
    Object3D.prototype.updateMatrix = function () {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    };
    Object3D.prototype.updateMatrixWorld = function (force) {
        if (force === void 0) { force = false; }
        if (this.matrixAutoUpdate === true)
            this.updateMatrix();
        if (this.matrixWorldNeedsUpdate === true || force === true) {
            if (this.parent === null) {
                this.matrixWorld.copy(this.matrix);
            }
            else {
                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        // update children
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            children[i].updateMatrixWorld(force);
        }
    };
    Object3D.prototype.toJSON = function (meta) {
        // meta is '' when called from JSON.stringify
        var isRootObject = (meta === undefined || meta === '');
        var output = {};
        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if (isRootObject) {
            // initialize meta obj
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            };
            output.metadata = {
                version: 4.4,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };
        }
        // standard Object3D serialization
        var object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '')
            object.name = this.name;
        if (JSON.stringify(this.userData) !== '{}')
            object.userData = this.userData;
        if (this.castShadow === true)
            object.castShadow = true;
        if (this.receiveShadow === true)
            object.receiveShadow = true;
        if (this.visible === false)
            object.visible = false;
        object.matrix = this.matrix.toArray();
        //
        if (this.geometry !== undefined) {
            if (meta.geometries[this.geometry.uuid] === undefined) {
                meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
            }
            object.geometry = this.geometry.uuid;
        }
        if (this.material !== undefined) {
            if (meta.materials[this.material.uuid] === undefined) {
                meta.materials[this.material.uuid] = this.material.toJSON(meta);
            }
            object.material = this.material.uuid;
        }
        //
        if (this.children.length > 0) {
            object.children = [];
            for (var i = 0; i < this.children.length; i++) {
                object.children.push(this.children[i].toJSON(meta).object);
            }
        }
        if (isRootObject) {
            var geometries = extractFromCache(meta.geometries);
            var materials = extractFromCache(meta.materials);
            var textures = extractFromCache(meta.textures);
            var images = extractFromCache(meta.images);
            if (geometries.length > 0)
                output.geometries = geometries;
            if (materials.length > 0)
                output.materials = materials;
            if (textures.length > 0)
                output.textures = textures;
            if (images.length > 0)
                output.images = images;
        }
        output.object = object;
        return output;
        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache(cache) {
            var values = [];
            for (var key in cache) {
                var data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
    };
    Object3D.prototype.clone = function (recursive) {
        if (recursive === void 0) { recursive = true; }
        return new this.constructor().copy(this, recursive);
    };
    Object3D.prototype.copy = function (source, recursive) {
        if (recursive === void 0) { recursive = true; }
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
            for (var i = 0; i < source.children.length; i++) {
                var child = source.children[i];
                this.add(child.clone());
            }
        }
        return this;
    };
    Object3D.prototype.getChildByName = function (name) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
    };
    Object3D.prototype.renderDepth = function (value) {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    };
    Object3D.prototype.translate = function (distance, axis) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis(axis, distance) instead.");
        return this.translateOnAxis(axis, distance);
    };
    Object.defineProperty(Object3D.prototype, "eulerOrder", {
        get: function () {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            return this.rotation.order;
        },
        set: function (value) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            this.rotation.order = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Object3D.prototype, "useQuaternion", {
        get: function () {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
            return true;
        },
        set: function (value) {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        enumerable: true,
        configurable: true
    });
    Object3D.DefaultUp = new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    Object3D._rotateOnAxis_q1 = new Quaternion();
    Object3D._rotateX_v1 = new Vector3(1, 0, 0);
    Object3D._rotateY_v1 = new Vector3(0, 1, 0);
    Object3D._rotateZ_v1 = new Vector3(0, 0, 1);
    Object3D._translateOnAxis_v1 = new Vector3();
    Object3D._translateX_v1 = new Vector3(1, 0, 0);
    Object3D._translateY_v1 = new Vector3(0, 1, 0);
    Object3D._translateZ_v1 = new Vector3(0, 0, 1);
    Object3D._worldToLocal_m1 = new Matrix4();
    Object3D._lookAt_m1 = new Matrix4();
    Object3D._getWorldQuaternion_position = new Vector3();
    Object3D._getWorldQuaternion_scale = new Vector3();
    Object3D._getWorldRotation_quaternion = new Quaternion();
    Object3D._getWorldScale_position = new Vector3();
    Object3D._getWorldScale_quaternion = new Quaternion();
    Object3D._getWorldDirection_quaternion = new Quaternion();
    return Object3D;
}(EventDispatcher));
var count$3 = 0;
function Object3DIdCount() { return count$3++; }

/**
 * @author bhouston / http://clara.io
 */
var Ray = (function () {
    function Ray(origin, direction) {
        if (origin === void 0) { origin = new Vector3(); }
        if (direction === void 0) { direction = new Vector3(); }
        this.origin = origin;
        this.direction = direction;
    }
    Ray.prototype.set = function (origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    };
    Ray.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Ray.prototype.copy = function (ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    };
    Ray.prototype.at = function (t, result) {
        if (result === void 0) { result = new Vector3(); }
        return result.copy(this.direction).multiplyScalar(t).add(this.origin);
    };
    Ray.prototype.lookAt = function (v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    };
    Ray.prototype.recast = function (t) {
        var v1 = Ray.recast_v1;
        this.origin.copy(this.at(t, v1));
        return this;
    };
    Ray.prototype.closestPointToPoint = function (point, result) {
        if (result === void 0) { result = new Vector3(); }
        result.subVectors(point, this.origin);
        var directionDistance = result.dot(this.direction);
        if (directionDistance < 0) {
            return result.copy(this.origin);
        }
        return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    };
    Ray.prototype.distanceToPoint = function (point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    };
    Ray.prototype.distanceSqToPoint = function (point) {
        var v1 = Ray.distanceSqToPoint_v1;
        var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
        // point behind the ray
        if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
        }
        v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return v1.distanceToSquared(point);
    };
    Ray.prototype.distanceSqToSegment = function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        var segCenter = Ray.distanceSqToSegment_segCenter;
        var segDir = Ray.distanceSqToSegment_segDir;
        var diff = Ray.distanceSqToSegment_diff;
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment
        segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        segDir.copy(v1).sub(v0).normalize();
        diff.copy(this.origin).sub(segCenter);
        var segExtent = v0.distanceTo(v1) * 0.5;
        var a01 = -this.direction.dot(segDir);
        var b0 = diff.dot(this.direction);
        var b1 = -diff.dot(segDir);
        var c = diff.lengthSq();
        var det = Math.abs(1 - a01 * a01);
        var s0, s1, sqrDist, extDet;
        if (det > 0) {
            // The ray and segment are not parallel.
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        // region 0
                        // Minimum at interior points of ray and segment.
                        var invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    }
                    else {
                        // region 1
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
                else {
                    // region 5
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
            else {
                if (s1 <= -extDet) {
                    // region 4
                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                    s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
                else if (s1 <= extDet) {
                    // region 3
                    s0 = 0;
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = s1 * (s1 + 2 * b1) + c;
                }
                else {
                    // region 2
                    s0 = Math.max(0, -(a01 * segExtent + b0));
                    s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
        }
        else {
            // Ray and segment are parallel.
            s1 = (a01 > 0) ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        }
        if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
        }
        return sqrDist;
    };
    Ray.prototype.intersectSphere = function (sphere, optionalTarget) {
        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
        var v1 = Ray.intersectSphere_v1;
        v1.subVectors(sphere.center, this.origin);
        var tca = v1.dot(this.direction);
        var d2 = v1.dot(v1) - tca * tca;
        var radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2)
            return null;
        var thc = Math.sqrt(radius2 - d2);
        // t0 = first intersect point - entrance on front of sphere
        var t0 = tca - thc;
        // t1 = second intersect point - exit point on back of sphere
        var t1 = tca + thc;
        // test to see if both t0 and t1 are behind the ray - if so, return null
        if (t0 < 0 && t1 < 0)
            return null;
        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        if (t0 < 0)
            return this.at(t1, optionalTarget);
        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return this.at(t0, optionalTarget);
    };
    Ray.prototype.intersectsSphere = function (sphere) {
        return this.distanceToPoint(sphere.center) <= sphere.radius;
    };
    Ray.prototype.distanceToPlane = function (plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (plane.distanceToPoint(this.origin) === 0) {
                return 0;
            }
            // Null is preferable to undefined since undefined means.... it is undefined
            return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        // Return if the ray never intersects the plane
        return t >= 0 ? t : null;
    };
    Ray.prototype.intersectPlane = function (plane, optionalTarget) {
        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
        var t = this.distanceToPlane(plane);
        if (t === null) {
            return null;
        }
        return this.at(t, optionalTarget);
    };
    Ray.prototype.intersectsPlane = function (plane) {
        // check if the ray lies on the plane first
        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
            return true;
        }
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
            return true;
        }
        // ray origin is behind the plane (and is pointing behind it)
        return false;
    };
    Ray.prototype.intersectBox = function (box, optionalTarget) {
        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
        var tmin, tmax, tymin, tymax, tzmin, tzmax;
        var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
        }
        else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
        }
        else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
        }
        if ((tmin > tymax) || (tymin > tmax))
            return null;
        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN
        if (tymin > tmin || tmin !== tmin)
            tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
            tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
        }
        else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
        }
        if ((tmin > tzmax) || (tzmin > tmax))
            return null;
        if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
        //return point closest to the ray (positive side)
        if (tmax < 0)
            return null;
        return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
    };
    Ray.prototype.intersectsBox = function (box) {
        var v = Ray.intersectsBox_v;
        return this.intersectBox(box, v) !== null;
    };
    Ray.prototype.intersectTriangle = function (a, b, c, backfaceCulling, optionalTarget) {
        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
        // Compute the offset origin, edges, and normal.
        var diff = Ray.intersectTriangle_diff;
        var edge1 = Ray.intersectTriangle_edge1;
        var edge2 = Ray.intersectTriangle_edge2;
        var normal = Ray.intersectTriangle_normal;
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
        edge1.subVectors(b, a);
        edge2.subVectors(c, a);
        normal.crossVectors(edge1, edge2);
        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        var DdN = this.direction.dot(normal);
        var sign;
        if (DdN > 0) {
            if (backfaceCulling)
                return null;
            sign = 1;
        }
        else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
        }
        else {
            return null;
        }
        diff.subVectors(this.origin, a);
        var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
        // b1 < 0, no intersection
        if (DdQxE2 < 0) {
            return null;
        }
        var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
        // b2 < 0, no intersection
        if (DdE1xQ < 0) {
            return null;
        }
        // b1+b2 > 1, no intersection
        if (DdQxE2 + DdE1xQ > DdN) {
            return null;
        }
        // Line intersects triangle, check if ray does.
        var QdN = -sign * diff.dot(normal);
        // t < 0, no intersection
        if (QdN < 0) {
            return null;
        }
        // Ray intersects triangle.
        return this.at(QdN / DdN, optionalTarget);
    };
    Ray.prototype.applyMatrix4 = function (matrix4) {
        this.direction.add(this.origin).applyMatrix4(matrix4);
        this.origin.applyMatrix4(matrix4);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this;
    };
    Ray.prototype.equals = function (ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    };
    Ray.prototype.isIntersectionBox = function (box) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
    };
    Ray.prototype.isIntersectionPlane = function (plane) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(plane);
    };
    Ray.prototype.isIntersectionSphere = function (sphere) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
    };
    Ray.recast_v1 = new Vector3();
    Ray.distanceSqToPoint_v1 = new Vector3();
    Ray.distanceSqToSegment_segCenter = new Vector3();
    Ray.distanceSqToSegment_segDir = new Vector3();
    Ray.distanceSqToSegment_diff = new Vector3();
    Ray.intersectSphere_v1 = new Vector3();
    Ray.intersectsBox_v = new Vector3();
    Ray.intersectTriangle_diff = new Vector3();
    Ray.intersectTriangle_edge1 = new Vector3();
    Ray.intersectTriangle_edge2 = new Vector3();
    Ray.intersectTriangle_normal = new Vector3();
    return Ray;
}());

/**
 * @author bhouston / http://clara.io
 */
var Line3 = (function () {
    function Line3(start, end) {
        if (start === void 0) { start = new Vector3(); }
        if (end === void 0) { end = new Vector3(); }
        this.start = start;
        this.end = end;
    }
    Line3.prototype.set = function (start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    };
    Line3.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Line3.prototype.copy = function (line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    };
    Line3.prototype.getCenter = function (result) {
        if (result === void 0) { result = new Vector3(); }
        return result.addVectors(this.start, this.end).multiplyScalar(0.5);
    };
    Line3.prototype.delta = function (result) {
        if (result === void 0) { result = new Vector3(); }
        return result.subVectors(this.end, this.start);
    };
    Line3.prototype.distanceSq = function () {
        return this.start.distanceToSquared(this.end);
    };
    Line3.prototype.distance = function () {
        return this.start.distanceTo(this.end);
    };
    Line3.prototype.at = function (t, result) {
        if (result === void 0) { result = new Vector3(); }
        return this.delta(result).multiplyScalar(t).add(this.start);
    };
    Line3.prototype.closestPointToPointParameter = function (point, clampToLine) {
        var startP = Line3.closestPointToPointParameter_startP;
        var startEnd = Line3.closestPointToPointParameter_startEnd;
        startP.subVectors(point, this.start);
        startEnd.subVectors(this.end, this.start);
        var startEnd2 = startEnd.dot(startEnd);
        var startEnd_startP = startEnd.dot(startP);
        var t = startEnd_startP / startEnd2;
        if (clampToLine) {
            t = _Math.clamp(t, 0, 1);
        }
        return t;
    };
    Line3.prototype.closestPointToPoint = function (point, clampToLine, result) {
        if (result === void 0) { result = new Vector3(); }
        var t = this.closestPointToPointParameter(point, clampToLine);
        return this.delta(result).multiplyScalar(t).add(this.start);
    };
    Line3.prototype.applyMatrix4 = function (matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    };
    Line3.prototype.equals = function (line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    };
    Line3.prototype.center = function (result) {
        console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
        return this.getCenter(result);
    };
    Line3.closestPointToPointParameter_startP = new Vector3();
    Line3.closestPointToPointParameter_startEnd = new Vector3();
    return Line3;
}());

/**
 * @author bhouston / http://clara.io
 */
var Plane = (function () {
    function Plane(normal, constant) {
        if (normal === void 0) { normal = new Vector3(1, 0, 0); }
        if (constant === void 0) { constant = 0; }
        this.normal = normal;
        this.constant = constant;
    }
    Plane.prototype.set = function (normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
    };
    Plane.prototype.setComponents = function (x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
    };
    Plane.prototype.setFromNormalAndCoplanarPoint = function (normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal); // must be this.normal, not normal, as this.normal is normalized
        return this;
    };
    Plane.prototype.setFromCoplanarPoints = function (a, b, c) {
        var v1 = Plane.setFromCoplanarPoints_v1;
        var v2 = Plane.setFromCoplanarPoints_v2;
        var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
    };
    Plane.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Plane.prototype.copy = function (plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    };
    Plane.prototype.normalize = function () {
        // Note: will lead to a divide by zero if the plane is invalid.
        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    };
    Plane.prototype.negate = function () {
        this.constant *= -1;
        this.normal.negate();
        return this;
    };
    Plane.prototype.distanceToPoint = function (point) {
        return this.normal.dot(point) + this.constant;
    };
    Plane.prototype.distanceToSphere = function (sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    };
    Plane.prototype.projectPoint = function (point, result) {
        if (result === void 0) { result = new Vector3(); }
        return this.orthoPoint(point, result).sub(point).negate();
    };
    Plane.prototype.orthoPoint = function (point, result) {
        if (result === void 0) { result = new Vector3(); }
        var perpendicularMagnitude = this.distanceToPoint(point);
        return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
    };
    Plane.prototype.intersectLine = function (line, result) {
        if (result === void 0) { result = new Vector3(); }
        var v1 = Plane.intersectLine_v1;
        var direction = line.delta(v1);
        var denominator = this.normal.dot(direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (this.distanceToPoint(line.start) === 0) {
                return result.copy(line.start);
            }
            // Unsure if this is the correct method to handle this case.
            return undefined;
        }
        var t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) {
            return undefined;
        }
        return result.copy(direction).multiplyScalar(t).add(line.start);
    };
    Plane.prototype.intersectsLine = function (line) {
        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
    };
    Plane.prototype.intersectsBox = function (box) {
        return box.intersectsPlane(this);
    };
    Plane.prototype.intersectsSphere = function (sphere) {
        return sphere.intersectsPlane(this);
    };
    Plane.prototype.coplanarPoint = function (result) {
        if (result === void 0) { result = new Vector3(); }
        return result.copy(this.normal).multiplyScalar(-this.constant);
    };
    Plane.prototype.applyMatrix4 = function (matrix, optionalNormalMatrix) {
        var v1 = Plane.applyMatrix4_v1;
        var m1 = Plane.applyMatrix4_m1;
        var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
        // transform normal based on theory here:
        // http://www.songho.ca/opengl/gl_normaltransform.html
        var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
        var normal = this.normal.applyMatrix3(normalMatrix).normalize();
        // recalculate constant (like in setFromNormalAndCoplanarPoint)
        this.constant = -referencePoint.dot(normal);
        return this;
    };
    Plane.prototype.translate = function (offset) {
        this.constant = this.constant - offset.dot(this.normal);
        return this;
    };
    Plane.prototype.equals = function (plane) {
        return plane.normal.equals(this.normal) && (plane.constant === this.constant);
    };
    Plane.prototype.isIntersectionLine = function (line) {
        console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
        return this.intersectsLine(line);
    };
    Plane.setFromCoplanarPoints_v1 = new Vector3();
    Plane.setFromCoplanarPoints_v2 = new Vector3();
    Plane.intersectLine_v1 = new Vector3();
    Plane.applyMatrix4_v1 = new Vector3();
    Plane.applyMatrix4_m1 = new Matrix3();
    return Plane;
}());

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */
var Triangle = (function () {
    function Triangle(a, b, c) {
        if (a === void 0) { a = new Vector3(); }
        if (b === void 0) { b = new Vector3(); }
        if (c === void 0) { c = new Vector3(); }
        this.a = a;
        this.b = b;
        this.c = c;
    }
    Triangle.normal = function (a, b, c, result) {
        if (result === void 0) { result = new Vector3(); }
        var v0 = Triangle.normal_v0;
        result.subVectors(c, b);
        v0.subVectors(a, b);
        result.cross(v0);
        var resultLengthSq = result.lengthSq();
        if (resultLengthSq > 0) {
            return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
        }
        return result.set(0, 0, 0);
    };
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    Triangle.barycoordFromPoint = function (point, a, b, c, result) {
        if (result === void 0) { result = new Vector3(); }
        var v0 = new Vector3();
        var v1 = new Vector3();
        var v2 = new Vector3();
        v0.subVectors(c, a);
        v1.subVectors(b, a);
        v2.subVectors(point, a);
        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);
        var denom = (dot00 * dot11 - dot01 * dot01);
        // collinear or singular triangle
        if (denom === 0) {
            // arbitrary location outside of triangle?
            // not sure if this is the best idea, maybe should be returning undefined
            return result.set(-2, -1, -1);
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // barycentric coordinates must always sum to 1
        return result.set(1 - u - v, v, u);
    };
    Triangle.containsPoint = function (point, a, b, c) {
        var v1 = new Vector3();
        var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
        return (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);
    };
    Triangle.prototype.set = function (a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    };
    Triangle.prototype.setFromPointsAndIndices = function (points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
    };
    Triangle.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Triangle.prototype.copy = function (triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    };
    Triangle.prototype.area = function () {
        var v0 = new Vector3();
        var v1 = new Vector3();
        v0.subVectors(this.c, this.b);
        v1.subVectors(this.a, this.b);
        return v0.cross(v1).length() * 0.5;
    };
    Triangle.prototype.midpoint = function (result) {
        if (result === void 0) { result = new Vector3(); }
        return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    };
    Triangle.prototype.normal = function (result) {
        if (result === void 0) { result = new Vector3(); }
        return Triangle.normal(this.a, this.b, this.c, result);
    };
    Triangle.prototype.plane = function (result) {
        if (result === void 0) { result = new Plane(); }
        return result.setFromCoplanarPoints(this.a, this.b, this.c);
    };
    Triangle.prototype.barycoordFromPoint = function (point, result) {
        if (result === void 0) { result = new Vector3(); }
        return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, result);
    };
    Triangle.prototype.containsPoint = function (point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
    };
    Triangle.prototype.closestPointToPoint = function (point, result) {
        if (result === void 0) { result = new Vector3(); }
        var plane = new Plane();
        var edgeList = [new Line3(), new Line3(), new Line3()];
        var projectedPoint = new Vector3();
        var closestPoint = new Vector3();
        var minDistance = Infinity;
        // project the point onto the plane of the triangle
        plane.setFromCoplanarPoints(this.a, this.b, this.c);
        plane.projectPoint(point, projectedPoint);
        // check if the projection lies within the triangle
        if (this.containsPoint(projectedPoint) === true) {
            // if so, this is the closest point
            result.copy(projectedPoint);
        }
        else {
            // if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
            edgeList[0].set(this.a, this.b);
            edgeList[1].set(this.b, this.c);
            edgeList[2].set(this.c, this.a);
            for (var i = 0; i < edgeList.length; i++) {
                edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
                var distance = projectedPoint.distanceToSquared(closestPoint);
                if (distance < minDistance) {
                    minDistance = distance;
                    result.copy(closestPoint);
                }
            }
        }
        return result;
    };
    Triangle.prototype.equals = function (triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    };
    Triangle.normal_v0 = new Vector3();
    return Triangle;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var MultiMaterial = (function () {
    function MultiMaterial(materials) {
        if (materials === void 0) { materials = []; }
        this.uuid = _Math.generateUUID();
        this.type = 'MultiMaterial';
        this.visible = true;
        this.isMultiMaterial = true;
        this.materials = materials;
    }
    // }
    MultiMaterial.prototype.dispose = function () { };
    MultiMaterial.prototype.toJSON = function (meta) {
        var output = {
            metadata: {
                version: 4.2,
                type: 'material',
                generator: 'MaterialExporter'
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        };
        var materials = this.materials;
        for (var i = 0, l = materials.length; i < l; i++) {
            var material = materials[i].toJSON(meta);
            delete material.metadata;
            output.materials.push(material);
        }
        output.visible = this.visible;
        return output;
    };
    MultiMaterial.prototype.clone = function () {
        var material = new this.constructor();
        for (var i = 0; i < this.materials.length; i++) {
            material.materials.push(this.materials[i].clone());
        }
        material.visible = this.visible;
        return material;
    };
    return MultiMaterial;
}());

var MeshBasicMaterial = (function (_super) {
    __extends(MeshBasicMaterial, _super);
    function MeshBasicMaterial(parameters) {
        _super.call(this);
        this.isMeshBasicMaterial = true;
        this.type = 'MeshBasicMaterial';
        this.color = new Color(0xffffff); // emissive
        this.map = null;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = BlendingOperation.Multiply;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.lights = false;
        this.setValues(parameters);
    }
    MeshBasicMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        return this;
    };
    return MeshBasicMaterial;
}(Material));

var BufferAttribute = (function () {
    function BufferAttribute(array, itemSize, normalized) {
        if (normalized === void 0) { normalized = false; }
        this.uuid = _Math.generateUUID();
        this.dynamic = false;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
        this.isBufferAttribute = true;
        this.isInterleavedBufferAttribute = false;
        if (Array.isArray(array)) {
            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        }
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== undefined ? array.length / itemSize : 0;
        this.normalized = normalized === true;
    }
    Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
        set: function (value) {
            if (value === true)
                this.version++;
        },
        enumerable: true,
        configurable: true
    });
    BufferAttribute.prototype.setArray = function (array) {
        if (Array.isArray(array)) {
            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        }
        this.count = array !== undefined ? array.length / this.itemSize : 0;
        this.array = array;
    };
    BufferAttribute.prototype.setDynamic = function (value) {
        this.dynamic = value;
        return this;
    };
    BufferAttribute.prototype.copy = function (source) {
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.dynamic = source.dynamic;
        return this;
    };
    BufferAttribute.prototype.copyAt = function (index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (var i = 0, l = this.itemSize; i < l; i++) {
            this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
    };
    BufferAttribute.prototype.copyArray = function (array) {
        this.array.set(array, 0);
        return this;
    };
    BufferAttribute.prototype.copyColorsArray = function (colors) {
        var array = this.array;
        var offset = 0;
        for (var i = 0, l = colors.length; i < l; i++) {
            var color = colors[i];
            if (color === undefined) {
                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                color = new Color();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
        }
        return this;
    };
    BufferAttribute.prototype.copyIndicesArray = function (indices) {
        var array = this.array;
        var offset = 0;
        for (var i = 0, l = indices.length; i < l; i++) {
            var index = indices[i];
            array[offset++] = index.a;
            array[offset++] = index.b;
            array[offset++] = index.c;
        }
        return this;
    };
    BufferAttribute.prototype.copyVector2sArray = function (vectors) {
        var array = this.array;
        var offset = 0;
        for (var i = 0, l = vectors.length; i < l; i++) {
            var vector = vectors[i];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                vector = new Vector2();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
        }
        return this;
    };
    BufferAttribute.prototype.copyVector3sArray = function (vectors) {
        var array = this.array;
        var offset = 0;
        for (var i = 0, l = vectors.length; i < l; i++) {
            var vector = vectors[i];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                vector = new Vector3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
        }
        return this;
    };
    BufferAttribute.prototype.copyVector4sArray = function (vectors) {
        var array = this.array;
        var offset = 0;
        for (var i = 0, l = vectors.length; i < l; i++) {
            var vector = vectors[i];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
        }
        return this;
    };
    BufferAttribute.prototype.set = function (value, offset) {
        if (offset === void 0) { offset = 0; }
        this.array.set(value, offset);
        return this;
    };
    BufferAttribute.prototype.getX = function (index) {
        return this.array[index * this.itemSize];
    };
    BufferAttribute.prototype.setX = function (index, x) {
        this.array[index * this.itemSize] = x;
        return this;
    };
    BufferAttribute.prototype.getY = function (index) {
        return this.array[index * this.itemSize + 1];
    };
    BufferAttribute.prototype.setY = function (index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
    };
    BufferAttribute.prototype.getZ = function (index) {
        return this.array[index * this.itemSize + 2];
    };
    BufferAttribute.prototype.setZ = function (index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
    };
    BufferAttribute.prototype.getW = function (index) {
        return this.array[index * this.itemSize + 3];
    };
    BufferAttribute.prototype.setW = function (index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
    };
    BufferAttribute.prototype.setXY = function (index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
    };
    BufferAttribute.prototype.setXYZ = function (index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
    };
    BufferAttribute.prototype.setXYZW = function (index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
    };
    BufferAttribute.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Object.defineProperty(BufferAttribute.prototype, "length", {
        get: function () {
            console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count.");
            return this.array.length;
        },
        enumerable: true,
        configurable: true
    });
    return BufferAttribute;
}());
//
function Int8Attribute(array, itemSize) {
    return new BufferAttribute(new Int8Array(array), itemSize);
}
function Uint8Attribute(array, itemSize) {
    return new BufferAttribute(new Uint8Array(array), itemSize);
}
function Uint8ClampedAttribute(array, itemSize) {
    return new BufferAttribute(new Uint8ClampedArray(array), itemSize);
}
function Int16Attribute(array, itemSize) {
    return new BufferAttribute(new Int16Array(array), itemSize);
}
function Uint16Attribute(array, itemSize) {
    return new BufferAttribute(new Uint16Array(array), itemSize);
}
function Int32Attribute(array, itemSize) {
    return new BufferAttribute(new Int32Array(array), itemSize);
}
function Uint32Attribute(array, itemSize) {
    return new BufferAttribute(new Uint32Array(array), itemSize);
}
function Float32Attribute(array, itemSize) {
    return new BufferAttribute(new Float32Array(array), itemSize);
}
function Float64Attribute(array, itemSize) {
    return new BufferAttribute(new Float64Array(array), itemSize);
}
// Deprecated
function DynamicBufferAttribute(array, itemSize) {
    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic(true) instead.');
    return new BufferAttribute(array, itemSize).setDynamic(true);
}

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
var InterleavedBufferAttribute = (function () {
    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
        this.uuid = _Math.generateUUID();
        this.isInterleavedBufferAttribute = true;
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized === true;
    }
    Object.defineProperty(InterleavedBufferAttribute.prototype, "count", {
        get: function () {
            return this.data.count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InterleavedBufferAttribute.prototype, "array", {
        get: function () {
            return this.data.array;
        },
        enumerable: true,
        configurable: true
    });
    InterleavedBufferAttribute.prototype.setX = function (index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
    };
    InterleavedBufferAttribute.prototype.setY = function (index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
    };
    InterleavedBufferAttribute.prototype.setZ = function (index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
    };
    InterleavedBufferAttribute.prototype.setW = function (index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
    };
    InterleavedBufferAttribute.prototype.getX = function (index) {
        return this.data.array[index * this.data.stride + this.offset];
    };
    InterleavedBufferAttribute.prototype.getY = function (index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
    };
    InterleavedBufferAttribute.prototype.getZ = function (index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
    };
    InterleavedBufferAttribute.prototype.getW = function (index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
    };
    InterleavedBufferAttribute.prototype.setXY = function (index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
    };
    InterleavedBufferAttribute.prototype.setXYZ = function (index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
    };
    InterleavedBufferAttribute.prototype.setXYZW = function (index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
    };
    return InterleavedBufferAttribute;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var DirectGeometry = (function (_super) {
    __extends(DirectGeometry, _super);
    function DirectGeometry() {
        _super.call(this);
        this.id = GeometryIdCount();
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'DirectGeometry';
        this.indices = [];
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = { position: undefined, normal: undefined };
        this.skinWeights = [];
        this.skinIndices = [];
        // lineDistances: number[] = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // update flags
        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    DirectGeometry.prototype.computeBoundingBox = function () {
        if (this.boundingBox === null) {
            this.boundingBox = new Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
    };
    DirectGeometry.prototype.computeBoundingSphere = function () {
        if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
    };
    DirectGeometry.prototype.computeFaceNormals = function () {
        console.warn('THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.');
    };
    DirectGeometry.prototype.computeVertexNormals = function () {
        console.warn('THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.');
    };
    DirectGeometry.prototype.computeGroups = function (geometry) {
        var group;
        var groups = [];
        var materialIndex;
        var faces = geometry.faces;
        var i;
        for (i = 0; i < faces.length; i++) {
            var face = faces[i];
            // materials
            if (face.materialIndex !== materialIndex) {
                materialIndex = face.materialIndex;
                if (group !== undefined) {
                    group.count = (i * 3) - group.start;
                    groups.push(group);
                }
                group = {
                    start: i * 3,
                    materialIndex: materialIndex
                };
            }
        }
        if (group !== undefined) {
            group.count = (i * 3) - group.start;
            groups.push(group);
        }
        this.groups = groups;
    };
    DirectGeometry.prototype.fromGeometry = function (geometry) {
        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;
        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        // morphs
        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;
        var morphTargetsPosition;
        if (morphTargetsLength > 0) {
            morphTargetsPosition = [];
            for (var i = 0; i < morphTargetsLength; i++) {
                morphTargetsPosition[i] = [];
            }
            this.morphTargets.position = morphTargetsPosition;
        }
        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;
        var morphTargetsNormal;
        if (morphNormalsLength > 0) {
            morphTargetsNormal = [];
            for (var i = 0; i < morphNormalsLength; i++) {
                morphTargetsNormal[i] = [];
            }
            this.morphTargets.normal = morphTargetsNormal;
        }
        // skins
        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;
        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;
        //
        for (var i = 0; i < faces.length; i++) {
            var face = faces[i];
            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
            var vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
            }
            else {
                var normal = face.normal;
                this.normals.push(normal, normal, normal);
            }
            var vertexColors = face.vertexColors;
            if (vertexColors.length === 3) {
                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
            }
            else {
                var color = face.color;
                this.colors.push(color, color, color);
            }
            if (hasFaceVertexUv === true) {
                var vertexUvs = faceVertexUvs[0][i];
                if (vertexUvs !== undefined) {
                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                }
                else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
                    this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                }
            }
            if (hasFaceVertexUv2 === true) {
                var vertexUvs = faceVertexUvs[1][i];
                if (vertexUvs !== undefined) {
                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                }
                else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                }
            }
            // morphs
            for (var j = 0; j < morphTargetsLength; j++) {
                var morphTarget = morphTargets[j].vertices;
                morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
            }
            for (var j = 0; j < morphNormalsLength; j++) {
                var morphNormal = morphNormals[j].vertexNormals[i];
                morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
            }
            // skins
            if (hasSkinIndices) {
                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
            }
            if (hasSkinWeights) {
                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
            }
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        return this;
    };
    DirectGeometry.prototype.dispose = function () {
        this.dispatchEvent({ type: 'dispose' });
    };
    return DirectGeometry;
}(EventDispatcher));

var PointsMaterial = (function (_super) {
    __extends(PointsMaterial, _super);
    function PointsMaterial(parameters) {
        _super.call(this);
        this.isPointsMaterial = true;
        this.type = 'PointsMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.lights = false;
        this.setValues(parameters);
    }
    PointsMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
    };
    return PointsMaterial;
}(Material));

/**
 * @author alteredq / http://alteredqualia.com/
 */
var Points = (function (_super) {
    __extends(Points, _super);
    function Points(geometry, material) {
        if (geometry === void 0) { geometry = new BufferGeometry(); }
        if (material === void 0) { material = new PointsMaterial({ color: Math.random() * 0xffffff }); }
        _super.call(this);
        this.isPoints = true;
        this.type = 'Points';
        this.geometry = geometry;
        this.material = material;
    }
    Points.prototype.raycast = function (raycaster, intersects) {
        var inverseMatrix = new Matrix4();
        var ray = new Ray();
        var sphere = new Sphere();
        //return function raycast(raycaster, intersects) {
        var object = this;
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        var threshold = raycaster.params.Points.threshold;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(sphere) === false)
            return intersects;
        //
        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localThresholdSq = localThreshold * localThreshold;
        var position = new Vector3();
        function testPoint(point, index) {
            var rayPointDistanceSq = ray.distanceSqToPoint(point);
            if (rayPointDistanceSq < localThresholdSq) {
                var intersectPoint = ray.closestPointToPoint(point);
                intersectPoint.applyMatrix4(matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                if (distance < raycaster.near || distance > raycaster.far)
                    return;
                intersects.push({
                    distance: distance,
                    distanceToRay: Math.sqrt(rayPointDistanceSq),
                    point: intersectPoint.clone(),
                    index: index,
                    face: null,
                    object: object
                });
            }
        }
        if ((geometry && geometry instanceof BufferGeometry)) {
            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;
            if (index !== null) {
                var indices = index.array;
                for (var i = 0, il = indices.length; i < il; i++) {
                    var a = indices[i];
                    position.fromArray(positions, a * 3);
                    testPoint(position, a);
                }
            }
            else {
                for (var i = 0, l = positions.length / 3; i < l; i++) {
                    position.fromArray(positions, i * 3);
                    testPoint(position, i);
                }
            }
        }
        else if (geometry && geometry instanceof Geometry) {
            var vertices = geometry.vertices;
            for (var i = 0, l = vertices.length; i < l; i++) {
                testPoint(vertices[i], i);
            }
        }
        return intersects;
        //};
    };
    Points.prototype.clone = function () {
        return new this.constructor(this.geometry, this.material).copy(this);
    };
    return Points;
}(Object3D));

var LineBasicMaterial = (function (_super) {
    __extends(LineBasicMaterial, _super);
    function LineBasicMaterial(parameters) {
        _super.call(this);
        this.isLineBasicMaterial = true;
        this.type = 'LineBasicMaterial';
        this.color = new Color(0xffffff);
        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';
        this.lights = false;
        this.setValues(parameters);
    }
    LineBasicMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        return this;
    };
    return LineBasicMaterial;
}(Material));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var Line = (function (_super) {
    __extends(Line, _super);
    function Line(geometry, material, mode) {
        if (geometry === void 0) { geometry = new BufferGeometry(); }
        if (material === void 0) { material = new LineBasicMaterial({ color: Math.random() * 0xffffff }); }
        _super.call(this);
        this._step = 1;
        this.isLine = true;
        this.isLineSegments = false;
        if (mode === 1) {
            console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
        }
        this.type = 'Line';
        this.geometry = geometry;
        this.material = material;
    }
    Line.prototype.raycast = function (raycaster, intersects) {
        var inverseMatrix = new Matrix4();
        var ray = new Ray();
        var sphere = new Sphere();
        //return function raycast(raycaster, intersects) {
        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(sphere) === false)
            return intersects;
        //
        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        var vStart = new Vector3();
        var vEnd = new Vector3();
        var interSegment = new Vector3();
        var interRay = new Vector3();
        var step = this._step; //(this && this instanceof LineSegments) ? 2 : 1;
        if ((geometry && geometry instanceof BufferGeometry)) {
            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;
            if (index !== null) {
                var indices = index.array;
                for (var i = 0, l = indices.length - 1; i < l; i += step) {
                    var a = indices[i];
                    var b = indices[i + 1];
                    vStart.fromArray(positions, a * 3);
                    vEnd.fromArray(positions, b * 3);
                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > precisionSq)
                        continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    var distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far)
                        continue;
                    intersects.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at(distance),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
            else {
                for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                    vStart.fromArray(positions, 3 * i);
                    vEnd.fromArray(positions, 3 * i + 3);
                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > precisionSq)
                        continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    var distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far)
                        continue;
                    intersects.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at(distance),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
        }
        else if ((geometry && geometry instanceof Geometry)) {
            var vertices = geometry.vertices;
            var nbVertices = vertices.length;
            for (var i = 0; i < nbVertices - 1; i += step) {
                var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                if (distSq > precisionSq)
                    continue;
                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                var distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                    continue;
                intersects.push({
                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at(distance),
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        }
        return intersects;
        //};
    };
    Line.prototype.clone = function () {
        return new this.constructor(this.geometry, this.material).copy(this);
    };
    return Line;
}(Object3D));

var BufferGeometry = (function (_super) {
    __extends(BufferGeometry, _super);
    function BufferGeometry() {
        _super.call(this);
        this.id = GeometryIdCount();
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'BufferGeometry';
        this.index = null;
        this.attributes = {};
        this.parameters = undefined;
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = { start: 0, count: Infinity };
        // }
        this.isGeometry = false;
        this.isBufferGeometry = true;
    }
    BufferGeometry.prototype.getIndex = function () {
        return this.index;
    };
    BufferGeometry.prototype.setIndex = function (index) {
        this.index = index;
    };
    BufferGeometry.prototype.addAttribute = function (name, attribute) {
        if ((attribute && attribute instanceof BufferAttribute) === false && (attribute && attribute instanceof InterleavedBufferAttribute) === false) {
            console.warn('THREE.BufferGeometry: .addAttribute() now expects (name, attribute).');
            this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
            return this;
        }
        if (name === 'index') {
            console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
            this.setIndex(attribute);
            return this;
        }
        this.attributes[name] = attribute;
        return this;
    };
    BufferGeometry.prototype.getAttribute = function (name) {
        return this.attributes[name];
    };
    BufferGeometry.prototype.removeAttribute = function (name) {
        delete this.attributes[name];
        return this;
    };
    BufferGeometry.prototype.addGroup = function (start, count, materialIndex) {
        if (materialIndex === void 0) { materialIndex = 0; }
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex
        });
    };
    BufferGeometry.prototype.clearGroups = function () {
        this.groups = [];
    };
    BufferGeometry.prototype.setDrawRange = function (start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    };
    BufferGeometry.prototype.applyMatrix = function (matrix) {
        var position = this.attributes.position;
        if (position !== undefined) {
            matrix.applyToVector3Array(position.array);
            position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== undefined) {
            var normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normalMatrix.applyToVector3Array(normal.array);
            normal.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
        }
        return this;
    };
    BufferGeometry.prototype.rotateX = function (angle) {
        // rotate geometry around world x-axis
        var m1 = new Matrix4();
        //return function rotateX(angle) {
        m1.makeRotationX(angle);
        this.applyMatrix(m1);
        return this;
        //};
    };
    BufferGeometry.prototype.rotateY = function (angle) {
        // rotate geometry around world y-axis
        var m1 = new Matrix4();
        //return function rotateY(angle) {
        m1.makeRotationY(angle);
        this.applyMatrix(m1);
        return this;
        //};
    };
    BufferGeometry.prototype.rotateZ = function (angle) {
        // rotate geometry around world z-axis
        var m1 = new Matrix4();
        //return function rotateZ(angle) {
        m1.makeRotationZ(angle);
        this.applyMatrix(m1);
        return this;
        //};
    };
    BufferGeometry.prototype.translate = function (x, y, z) {
        // translate geometry
        var m1 = new Matrix4();
        //return function translate(x, y, z) {
        m1.makeTranslation(x, y, z);
        this.applyMatrix(m1);
        return this;
        //};
    };
    BufferGeometry.prototype.scale = function (x, y, z) {
        // scale geometry
        var m1 = new Matrix4();
        //return function scale(x, y, z) {
        m1.makeScale(x, y, z);
        this.applyMatrix(m1);
        return this;
        //};
    };
    BufferGeometry.prototype.lookAt = function (vector) {
        var obj = new Object3D();
        //return function lookAt(vector) {
        obj.lookAt(vector);
        obj.updateMatrix();
        this.applyMatrix(obj.matrix);
        //};
    };
    BufferGeometry.prototype.center = function () {
        this.computeBoundingBox();
        var offset = this.boundingBox.getCenter().negate();
        this.translate(offset.x, offset.y, offset.z);
        return offset;
    };
    BufferGeometry.prototype.setFromObject = function (object) {
        // console.log('THREE.BufferGeometry.setFromObject(). Converting', object, this);
        var geometry = object.geometry;
        if ((object && object instanceof Points) || (object && object instanceof Line)) {
            var positions = Float32Attribute(geometry.vertices.length * 3, 3);
            var colors = Float32Attribute(geometry.colors.length * 3, 3);
            this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
            this.addAttribute('color', colors.copyColorsArray(geometry.colors));
            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                var lineDistances = Float32Attribute(geometry.lineDistances.length, 1);
                this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
        }
        else if ((object && object instanceof Mesh)) {
            if ((geometry && geometry instanceof Geometry)) {
                this.fromGeometry(geometry);
            }
        }
        return this;
    };
    BufferGeometry.prototype.updateFromObject = function (object) {
        var geometry = object.geometry;
        if ((object && object instanceof Mesh)) {
            var direct = geometry.__directGeometry;
            if (geometry.elementsNeedUpdate === true) {
                direct = undefined;
                geometry.elementsNeedUpdate = false;
            }
            if (direct === undefined) {
                return this.fromGeometry(geometry);
            }
            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;
            geometry = direct;
        }
        var attribute;
        if (geometry.verticesNeedUpdate === true) {
            attribute = this.attributes.position;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.vertices);
                attribute.needsUpdate = true;
            }
            geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
            attribute = this.attributes.normal;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.normals);
                attribute.needsUpdate = true;
            }
            geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
            attribute = this.attributes.color;
            if (attribute !== undefined) {
                attribute.copyColorsArray(geometry.colors);
                attribute.needsUpdate = true;
            }
            geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
            attribute = this.attributes.uv;
            if (attribute !== undefined) {
                attribute.copyVector2sArray(geometry.uvs);
                attribute.needsUpdate = true;
            }
            geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
            attribute = this.attributes.lineDistance;
            if (attribute !== undefined) {
                attribute.copyArray(geometry.lineDistances);
                attribute.needsUpdate = true;
            }
            geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
            geometry.computeGroups(object.geometry);
            this.groups = geometry.groups;
            geometry.groupsNeedUpdate = false;
        }
        return this;
    };
    BufferGeometry.prototype.fromGeometry = function (geometry) {
        geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
    };
    BufferGeometry.prototype.fromDirectGeometry = function (geometry) {
        var positions = new Float32Array(geometry.vertices.length * 3);
        this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
            var normals = new Float32Array(geometry.normals.length * 3);
            this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
            var colors = new Float32Array(geometry.colors.length * 3);
            this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
            var uvs = new Float32Array(geometry.uvs.length * 2);
            this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
            var uvs2 = new Float32Array(geometry.uvs2.length * 2);
            this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
        }
        if (geometry.indices.length > 0) {
            var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
            var indices = new TypeArray(geometry.indices.length * 3);
            this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
        }
        // groups
        this.groups = geometry.groups;
        // morphs
        for (var name in geometry.morphTargets) {
            if (!geometry.morphTargets[name])
                continue;
            var array = [];
            var morphTargets = geometry.morphTargets[name];
            for (var i = 0, l = morphTargets.length; i < l; i++) {
                var morphTarget = morphTargets[i];
                var attribute = Float32Attribute(morphTarget.length * 3, 3);
                array.push(attribute.copyVector3sArray(morphTarget));
            }
            this.morphAttributes[name] = array;
        }
        // skinning
        if (geometry.skinIndices.length > 0) {
            var skinIndices = Float32Attribute(geometry.skinIndices.length * 4, 4);
            this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
            var skinWeights = Float32Attribute(geometry.skinWeights.length * 4, 4);
            this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        //
        if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
    };
    BufferGeometry.prototype.computeBoundingBox = function () {
        if (this.boundingBox === null) {
            this.boundingBox = new Box3();
        }
        var positions = this.attributes.position.array;
        if (positions !== undefined) {
            this.boundingBox.setFromArray(positions);
        }
        else {
            this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
    };
    BufferGeometry.prototype.computeBoundingSphere = function () {
        var box = new Box3();
        var vector = new Vector3();
        //return function computeBoundingSphere() {
        if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
        }
        var positions = this.attributes.position;
        if (positions) {
            var array = positions.array;
            var center = this.boundingSphere.center;
            box.setFromArray(array);
            box.getCenter(center);
            // hoping to find a boundingSphere with a radius smaller than the
            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
            var maxRadiusSq = 0;
            for (var i = 0, il = array.length; i < il; i += 3) {
                vector.fromArray(array, i);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
                console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
        }
        //};
    };
    BufferGeometry.prototype.computeFaceNormals = function () {
        // backwards compatibility
    };
    BufferGeometry.prototype.computeVertexNormals = function () {
        var index = this.index;
        var attributes = this.attributes;
        var groups = this.groups;
        if (attributes.position) {
            var positions = attributes.position.array;
            if (attributes.normal === undefined) {
                this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
            }
            else {
                // reset existing normals to zero
                var array = attributes.normal.array;
                for (var i = 0, il = array.length; i < il; i++) {
                    array[i] = 0;
                }
            }
            var normals = attributes.normal.array;
            var vA = void 0, vB = void 0, vC = void 0, pA = new Vector3(), pB = new Vector3(), pC = new Vector3(), cb = new Vector3(), ab = new Vector3();
            // indexed elements
            if (index) {
                var indices = index.array;
                if (groups.length === 0) {
                    this.addGroup(0, indices.length);
                }
                for (var j = 0, jl = groups.length; j < jl; ++j) {
                    var group = groups[j];
                    var start = group.start;
                    var count = group.count;
                    for (var i = start, il = start + count; i < il; i += 3) {
                        vA = indices[i + 0] * 3;
                        vB = indices[i + 1] * 3;
                        vC = indices[i + 2] * 3;
                        pA.fromArray(positions, vA);
                        pB.fromArray(positions, vB);
                        pC.fromArray(positions, vC);
                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);
                        normals[vA] += cb.x;
                        normals[vA + 1] += cb.y;
                        normals[vA + 2] += cb.z;
                        normals[vB] += cb.x;
                        normals[vB + 1] += cb.y;
                        normals[vB + 2] += cb.z;
                        normals[vC] += cb.x;
                        normals[vC + 1] += cb.y;
                        normals[vC + 2] += cb.z;
                    }
                }
            }
            else {
                // non-indexed elements (unconnected triangle soup)
                for (var i = 0, il = positions.length; i < il; i += 9) {
                    pA.fromArray(positions, i);
                    pB.fromArray(positions, i + 3);
                    pC.fromArray(positions, i + 6);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    normals[i] = cb.x;
                    normals[i + 1] = cb.y;
                    normals[i + 2] = cb.z;
                    normals[i + 3] = cb.x;
                    normals[i + 4] = cb.y;
                    normals[i + 5] = cb.z;
                    normals[i + 6] = cb.x;
                    normals[i + 7] = cb.y;
                    normals[i + 8] = cb.z;
                }
            }
            this.normalizeNormals();
            attributes.normal.needsUpdate = true;
        }
    };
    BufferGeometry.prototype.merge = function (geometry, offset) {
        if (offset === void 0) { offset = 0; }
        if ((geometry && geometry instanceof BufferGeometry) === false) {
            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
            return this;
        }
        var attributes = this.attributes;
        for (var key in attributes) {
            var attribute1 = attributes[key];
            if (attribute1 === undefined)
                continue;
            var attributeArray1 = attribute1.array;
            var attribute2 = geometry.attributes[key];
            if (attribute2 === undefined)
                continue;
            var attributeArray2 = attribute2.array;
            var attributeSize = attribute2.itemSize;
            for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
                attributeArray1[j] = attributeArray2[i];
            }
        }
        return this;
    };
    BufferGeometry.prototype.normalizeNormals = function () {
        var normals = this.attributes.normal.array;
        for (var i = 0, il = normals.length; i < il; i += 3) {
            var x = normals[i];
            var y = normals[i + 1];
            var z = normals[i + 2];
            var n = 1.0 / Math.sqrt(x * x + y * y + z * z);
            normals[i] *= n;
            normals[i + 1] *= n;
            normals[i + 2] *= n;
        }
    };
    BufferGeometry.prototype.toNonIndexed = function () {
        if (this.index === null) {
            console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
            return this;
        }
        var geometry2 = new BufferGeometry();
        var indices = this.index.array;
        var attributes = this.attributes;
        for (var name in attributes) {
            var attribute = attributes[name];
            if (attribute === undefined)
                continue;
            var array = attribute.array;
            var itemSize = attribute.itemSize;
            var array2 = new array.constructor(indices.length * itemSize);
            var index = 0, index2 = 0;
            for (var i = 0, l = indices.length; i < l; i++) {
                index = indices[i] * itemSize;
                for (var j = 0; j < itemSize; j++) {
                    array2[index2++] = array[index++];
                }
            }
            geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
        }
        return geometry2;
    };
    BufferGeometry.prototype.toJSON = function (meta) {
        var data = {
            metadata: {
                version: 4.4,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };
        // standard BufferGeometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
            data.name = this.name;
        if (this.parameters !== undefined) {
            var parameters = this.parameters;
            for (var key in parameters) {
                if (parameters[key] !== undefined)
                    data[key] = parameters[key];
            }
            return data;
        }
        data.data = { attributes: {} };
        var index = this.index;
        if (index !== null) {
            var array = Array.prototype.slice.call(index.array);
            data.data.index = {
                type: index.array.constructor.name,
                array: array
            };
        }
        var attributes = this.attributes;
        for (var key in attributes) {
            var attribute = attributes[key];
            if (attribute === undefined)
                continue;
            var array = Array.prototype.slice.call(attribute.array);
            data.data.attributes[key] = {
                itemSize: attribute.itemSize,
                type: attribute.array.constructor.name,
                array: array,
                normalized: attribute.normalized
            };
        }
        var groups = this.groups;
        if (groups.length > 0) {
            data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        var boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
            data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            };
        }
        return data;
    };
    BufferGeometry.prototype.clone = function () {
        /*
        // Handle primitives
        const parameters = this.parameters;
        if (parameters !== undefined) {
          const values = [];
          for (let key in parameters) {
            values.push(parameters[key]);
          }
          const geometry = Object.create(this.constructor.prototype);
          this.constructor.apply(geometry, values);
          return geometry;
        }
        return new this.constructor().copy(this);
        */
        return new this.constructor().copy(this);
    };
    BufferGeometry.prototype.copy = function (source) {
        var index = source.index;
        if (index !== null) {
            this.setIndex(index.clone());
        }
        var attributes = source.attributes;
        for (var name in attributes) {
            var attribute = attributes[name];
            if (attribute === undefined)
                continue;
            this.addAttribute(name, attribute.clone());
        }
        var groups = source.groups;
        for (var i = 0, l = groups.length; i < l; i++) {
            var group = groups[i];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        return this;
    };
    BufferGeometry.prototype.dispose = function () {
        this.dispatchEvent({ type: 'dispose' });
    };
    BufferGeometry.prototype.addIndex = function (index) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(index);
    };
    BufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {
        if (indexOffset !== undefined) {
            console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        }
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(start, count);
    };
    BufferGeometry.prototype.clearDrawCalls = function () {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups();
    };
    BufferGeometry.prototype.computeTangents = function () {
        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
    };
    BufferGeometry.prototype.computeOffsets = function () {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    };
    Object.defineProperty(BufferGeometry.prototype, "drawcalls", {
        get: function () {
            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
            return this.groups;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BufferGeometry.prototype, "offsets", {
        get: function () {
            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
            return this.groups;
        },
        enumerable: true,
        configurable: true
    });
    BufferGeometry.MaxIndex = 65535;
    return BufferGeometry;
}(EventDispatcher));

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */
var Mesh = (function (_super) {
    __extends(Mesh, _super);
    function Mesh(geometry, material) {
        if (geometry === void 0) { geometry = new BufferGeometry(); }
        if (material === void 0) { material = new MeshBasicMaterial({ color: Math.random() * 0xffffff }); }
        _super.call(this);
        this.drawMode = DrawMode.Triangles;
        this.isMesh = true;
        this.type = 'Mesh';
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
    }
    Mesh.prototype.setDrawMode = function (value) {
        this.drawMode = value;
    };
    Mesh.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.drawMode = source.drawMode;
        return this;
    };
    Mesh.prototype.updateMorphTargets = function () {
        var morphTargets = this.geometry.morphTargets;
        if (morphTargets !== undefined && morphTargets.length > 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (var m = 0, ml = morphTargets.length; m < ml; m++) {
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[morphTargets[m].name] = m;
            }
        }
    };
    Mesh.prototype.raycast = function (raycaster, intersects) {
        var inverseMatrix = new Matrix4();
        var ray = new Ray();
        var sphere = new Sphere();
        var vA = new Vector3();
        var vB = new Vector3();
        var vC = new Vector3();
        var tempA = new Vector3();
        var tempB = new Vector3();
        var tempC = new Vector3();
        var uvA = new Vector2();
        var uvB = new Vector2();
        var uvC = new Vector2();
        var barycoord = new Vector3();
        var intersectionPoint = new Vector3();
        var intersectionPointWorld = new Vector3();
        function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
            Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
            uv1.multiplyScalar(barycoord.x);
            uv2.multiplyScalar(barycoord.y);
            uv3.multiplyScalar(barycoord.z);
            uv1.add(uv2).add(uv3);
            return uv1.clone();
        }
        function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
            var intersect;
            var material = object.material;
            if (material.side === SideMode.Back) {
                intersect = ray.intersectTriangle(pC, pB, pA, true, point);
            }
            else {
                intersect = ray.intersectTriangle(pA, pB, pC, material.side !== SideMode.Double, point);
            }
            if (intersect === null)
                return null;
            intersectionPointWorld.copy(point);
            intersectionPointWorld.applyMatrix4(object.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
            if (distance < raycaster.near || distance > raycaster.far)
                return null;
            return {
                distance: distance,
                point: intersectionPointWorld.clone(),
                index: 0,
                face: null,
                faceIndex: 0,
                uv: null,
                object: object
            };
        }
        function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
            if (intersection) {
                if (uvs) {
                    uvA.fromArray(uvs, a * 2);
                    uvB.fromArray(uvs, b * 2);
                    uvC.fromArray(uvs, c * 2);
                    intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
                }
                intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
                intersection.faceIndex = a;
            }
            return intersection;
        }
        //return function raycast(raycaster, intersects) {
        var geometry = this.geometry;
        var material = this.material;
        var matrixWorld = this.matrixWorld;
        if (material === undefined)
            return intersects;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(sphere) === false)
            return intersects;
        //
        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        // Check boundingBox before continuing
        if (geometry.boundingBox !== null) {
            if (ray.intersectsBox(geometry.boundingBox) === false)
                return intersects;
        }
        var uvs, intersection;
        if ((geometry && geometry instanceof BufferGeometry)) {
            var a = void 0, b = void 0, c = void 0;
            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;
            if (attributes.uv !== undefined) {
                uvs = attributes.uv.array;
            }
            if (index !== null) {
                var indices = index.array;
                for (var i = 0, l = indices.length; i < l; i += 3) {
                    a = indices[i];
                    b = indices[i + 1];
                    c = indices[i + 2];
                    intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
                    if (intersection) {
                        intersection.faceIndex = Math.floor(i / 3); // triangle number in indices buffer semantics
                        intersects.push(intersection);
                    }
                }
            }
            else {
                for (var i = 0, l = positions.length; i < l; i += 9) {
                    a = i / 3;
                    b = a + 1;
                    c = a + 2;
                    intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
                    if (intersection) {
                        intersection.index = a; // triangle number in positions buffer semantics
                        intersects.push(intersection);
                    }
                }
            }
        }
        else if ((geometry && geometry instanceof Geometry)) {
            var fvA = void 0, fvB = void 0, fvC = void 0;
            var isFaceMaterial = (material && material instanceof MultiMaterial);
            var materials = isFaceMaterial === true ? material.materials : null;
            var vertices = geometry.vertices;
            var faces = geometry.faces;
            var faceVertexUvs = geometry.faceVertexUvs[0];
            if (faceVertexUvs.length > 0)
                uvs = faceVertexUvs;
            for (var f = 0, fl = faces.length; f < fl; f++) {
                var face = faces[f];
                var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
                if (faceMaterial === undefined)
                    continue;
                fvA = vertices[face.a];
                fvB = vertices[face.b];
                fvC = vertices[face.c];
                if (faceMaterial.morphTargets === true) {
                    var morphTargets = geometry.morphTargets;
                    var morphInfluences = this.morphTargetInfluences;
                    vA.set(0, 0, 0);
                    vB.set(0, 0, 0);
                    vC.set(0, 0, 0);
                    for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                        var influence = morphInfluences[t];
                        if (influence === 0)
                            continue;
                        var targets = morphTargets[t].vertices;
                        vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                        vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                        vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                    }
                    vA.add(fvA);
                    vB.add(fvB);
                    vC.add(fvC);
                    fvA = vA;
                    fvB = vB;
                    fvC = vC;
                }
                intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
                if (intersection) {
                    if (uvs) {
                        var uvs_f = uvs[f];
                        uvA.copy(uvs_f[0]);
                        uvB.copy(uvs_f[1]);
                        uvC.copy(uvs_f[2]);
                        intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                    }
                    intersection.face = face;
                    intersection.faceIndex = f;
                    intersects.push(intersection);
                }
            }
        }
        return intersects;
        //};
    };
    Mesh.prototype.clone = function () {
        return new this.constructor(this.geometry, this.material).copy(this);
    };
    return Mesh;
}(Object3D));

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */
var Geometry = (function (_super) {
    __extends(Geometry, _super);
    function Geometry() {
        _super.call(this);
        this.id = GeometryIdCount();
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'Geometry';
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // update flags
        this.elementsNeedUpdate = false;
        this.verticesNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.lineDistancesNeedUpdate = false;
        this.groupsNeedUpdate = false;
        this.parameters = undefined;
        // }
        this.isGeometry = true;
        this.isBufferGeometry = false;
    }
    Geometry.prototype.applyMatrix = function (matrix) {
        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
        for (var i = 0, il = this.vertices.length; i < il; i++) {
            var vertex = this.vertices[i];
            vertex.applyMatrix4(matrix);
        }
        for (var i = 0, il = this.faces.length; i < il; i++) {
            var face = this.faces[i];
            face.normal.applyMatrix3(normalMatrix).normalize();
            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
            }
        }
        if (this.boundingBox !== null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
        return this;
    };
    Geometry.prototype.rotateX = function (angle) {
        // rotate geometry around world x-axis
        var m1 = new Matrix4();
        //return function rotateX(angle) {
        m1.makeRotationX(angle);
        this.applyMatrix(m1);
        return this;
        //};
    };
    Geometry.prototype.rotateY = function (angle) {
        // rotate geometry around world y-axis
        var m1 = new Matrix4();
        //return function rotateY(angle) {
        m1.makeRotationY(angle);
        this.applyMatrix(m1);
        return this;
        //};
    };
    Geometry.prototype.rotateZ = function (angle) {
        // rotate geometry around world z-axis
        var m1 = new Matrix4();
        //return function rotateZ(angle) {
        m1.makeRotationZ(angle);
        this.applyMatrix(m1);
        return this;
        //};
    };
    Geometry.prototype.translate = function (x, y, z) {
        // translate geometry
        var m1 = new Matrix4();
        //return function translate(x, y, z) {
        m1.makeTranslation(x, y, z);
        this.applyMatrix(m1);
        return this;
        //};
    };
    Geometry.prototype.scale = function (x, y, z) {
        // scale geometry
        var m1 = new Matrix4();
        //return function scale(x, y, z) {
        m1.makeScale(x, y, z);
        this.applyMatrix(m1);
        return this;
        //};
    };
    Geometry.prototype.lookAt = function (vector) {
        var obj = new Object3D();
        //return function lookAt(vector) {
        obj.lookAt(vector);
        obj.updateMatrix();
        this.applyMatrix(obj.matrix);
        //};
    };
    Geometry.prototype.fromBufferGeometry = function (geometry) {
        var scope = this;
        var indices = geometry.index !== null ? geometry.index.array : undefined;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
        if (uvs2 !== undefined)
            this.faceVertexUvs[1] = [];
        var tempNormals = [];
        var tempUVs = [];
        var tempUVs2 = [];
        for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
            scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));
            if (normals !== undefined) {
                tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));
            }
            if (colors !== undefined) {
                scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));
            }
            if (uvs !== undefined) {
                tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
            }
            if (uvs2 !== undefined) {
                tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
            }
        }
        function addFace(a, b, c, materialIndex) {
            var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
            var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
            var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
            scope.faces.push(face);
            if (uvs !== undefined) {
                scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
            }
            if (uvs2 !== undefined) {
                scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
            }
        }
        if (indices !== undefined) {
            var groups = geometry.groups;
            if (groups.length > 0) {
                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    var start = group.start;
                    var count_1 = group.count;
                    for (var j = start, jl = start + count_1; j < jl; j += 3) {
                        addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                    }
                }
            }
            else {
                for (var i = 0; i < indices.length; i += 3) {
                    addFace(indices[i], indices[i + 1], indices[i + 2]);
                }
            }
        }
        else {
            for (var i = 0; i < positions.length / 3; i += 3) {
                addFace(i, i + 1, i + 2);
            }
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
        }
        if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
        }
        return this;
    };
    Geometry.prototype.center = function () {
        this.computeBoundingBox();
        var offset = this.boundingBox.getCenter().negate();
        this.translate(offset.x, offset.y, offset.z);
        return offset;
    };
    Geometry.prototype.normalize = function () {
        this.computeBoundingSphere();
        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;
        var s = radius === 0 ? 1 : 1.0 / radius;
        var matrix = new Matrix4();
        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
        this.applyMatrix(matrix);
        return this;
    };
    Geometry.prototype.computeFaceNormals = function () {
        var cb = new Vector3(), ab = new Vector3();
        for (var f = 0, fl = this.faces.length; f < fl; f++) {
            var face = this.faces[f];
            var vA = this.vertices[face.a];
            var vB = this.vertices[face.b];
            var vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            cb.normalize();
            face.normal.copy(cb);
        }
    };
    Geometry.prototype.computeVertexNormals = function (areaWeighted) {
        if (areaWeighted === void 0) { areaWeighted = true; }
        var v, vl, f, fl, face, vertices;
        vertices = new Array(this.vertices.length);
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
            vertices[v] = new Vector3();
        }
        if (areaWeighted) {
            // vertex normals weighted by triangle areas
            // http://www.iquilezles.org/www/articles/normals/normals.htm
            var vA = void 0, vB = void 0, vC = void 0;
            var cb = new Vector3(), ab = new Vector3();
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                vA = this.vertices[face.a];
                vB = this.vertices[face.b];
                vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                vertices[face.a].add(cb);
                vertices[face.b].add(cb);
                vertices[face.c].add(cb);
            }
        }
        else {
            this.computeFaceNormals();
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                vertices[face.a].add(face.normal);
                vertices[face.b].add(face.normal);
                vertices[face.c].add(face.normal);
            }
        }
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
            vertices[v].normalize();
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            var vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(vertices[face.a]);
                vertexNormals[1].copy(vertices[face.b]);
                vertexNormals[2].copy(vertices[face.c]);
            }
            else {
                vertexNormals[0] = vertices[face.a].clone();
                vertexNormals[1] = vertices[face.b].clone();
                vertexNormals[2] = vertices[face.c].clone();
            }
        }
        if (this.faces.length > 0) {
            this.normalsNeedUpdate = true;
        }
    };
    Geometry.prototype.computeFlatVertexNormals = function () {
        this.computeFaceNormals();
        for (var f = 0, fl = this.faces.length; f < fl; f++) {
            var face = this.faces[f];
            var vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(face.normal);
                vertexNormals[1].copy(face.normal);
                vertexNormals[2].copy(face.normal);
            }
            else {
                vertexNormals[0] = face.normal.clone();
                vertexNormals[1] = face.normal.clone();
                vertexNormals[2] = face.normal.clone();
            }
        }
        if (this.faces.length > 0) {
            this.normalsNeedUpdate = true;
        }
    };
    Geometry.prototype.computeMorphNormals = function () {
        var i, il, f, fl, face;
        // save original normals
        // - create temp variables on first access
        //   otherwise just copy (for faster repeated calls)
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            if (!face.__originalFaceNormal) {
                face.__originalFaceNormal = face.normal.clone();
            }
            else {
                face.__originalFaceNormal.copy(face.normal);
            }
            if (!face.__originalVertexNormals)
                face.__originalVertexNormals = [];
            for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                if (!face.__originalVertexNormals[i]) {
                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                }
                else {
                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                }
            }
        }
        // use temp geometry to compute face and vertex normals for each morph
        var tmpGeo = new Geometry();
        tmpGeo.faces = this.faces;
        for (i = 0, il = this.morphTargets.length; i < il; i++) {
            // create on first access
            if (!this.morphNormals[i]) {
                this.morphNormals[i] = {};
                this.morphNormals[i].faceNormals = [];
                this.morphNormals[i].vertexNormals = [];
                var dstNormalsFace = this.morphNormals[i].faceNormals;
                var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                var faceNormal_1 = void 0, vertexNormals_1 = void 0;
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    faceNormal_1 = new Vector3();
                    vertexNormals_1 = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
                    dstNormalsFace.push(faceNormal_1);
                    dstNormalsVertex.push(vertexNormals_1);
                }
            }
            var morphNormals = this.morphNormals[i];
            // set vertices to morph target
            tmpGeo.vertices = this.morphTargets[i].vertices;
            // compute morph normals
            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();
            // store morph normals
            var faceNormal = void 0, vertexNormals = void 0;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                faceNormal = morphNormals.faceNormals[f];
                vertexNormals = morphNormals.vertexNormals[f];
                faceNormal.copy(face.normal);
                vertexNormals.a.copy(face.vertexNormals[0]);
                vertexNormals.b.copy(face.vertexNormals[1]);
                vertexNormals.c.copy(face.vertexNormals[2]);
            }
        }
        // restore original normals
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;
        }
    };
    Geometry.prototype.computeTangents = function () {
        console.warn('THREE.Geometry: .computeTangents() has been removed.');
    };
    Geometry.prototype.computeLineDistances = function () {
        var d = 0;
        var vertices = this.vertices;
        for (var i = 0, il = vertices.length; i < il; i++) {
            if (i > 0) {
                d += vertices[i].distanceTo(vertices[i - 1]);
            }
            this.lineDistances[i] = d;
        }
    };
    Geometry.prototype.computeBoundingBox = function () {
        if (this.boundingBox === null) {
            this.boundingBox = new Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
    };
    Geometry.prototype.computeBoundingSphere = function () {
        if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
    };
    Geometry.prototype.merge = function (geometry, matrix, materialIndexOffset) {
        if (materialIndexOffset === void 0) { materialIndexOffset = 0; }
        var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
        if (matrix !== undefined) {
            normalMatrix = new Matrix3().getNormalMatrix(matrix);
        }
        // vertices
        for (var i = 0, il = vertices2.length; i < il; i++) {
            var vertex = vertices2[i];
            var vertexCopy = vertex.clone();
            if (matrix !== undefined)
                vertexCopy.applyMatrix4(matrix);
            vertices1.push(vertexCopy);
        }
        // colors
        for (var i = 0, il = colors2.length; i < il; i++) {
            colors1.push(colors2[i].clone());
        }
        // faces
        for (var i = 0, il = faces2.length; i < il; i++) {
            var face = faces2[i], faceCopy = void 0, normal = void 0, color = void 0, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
            faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
            faceCopy.normal.copy(face.normal);
            if (normalMatrix !== undefined) {
                faceCopy.normal.applyMatrix3(normalMatrix).normalize();
            }
            for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                normal = faceVertexNormals[j].clone();
                if (normalMatrix !== undefined) {
                    normal.applyMatrix3(normalMatrix).normalize();
                }
                faceCopy.vertexNormals.push(normal);
            }
            faceCopy.color.copy(face.color);
            for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                color = faceVertexColors[j];
                faceCopy.vertexColors.push(color.clone());
            }
            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
            faces1.push(faceCopy);
        }
        // uvs
        for (var i = 0, il = uvs2.length; i < il; i++) {
            var uv = uvs2[i], uvCopy = [];
            if (uv === undefined) {
                continue;
            }
            for (var j = 0, jl = uv.length; j < jl; j++) {
                uvCopy.push(uv[j].clone());
            }
            uvs1.push(uvCopy);
        }
    };
    Geometry.prototype.mergeMesh = function (mesh) {
        if ((mesh && mesh instanceof Mesh) === false) {
            console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
            return;
        }
        mesh.matrixAutoUpdate && mesh.updateMatrix();
        if (mesh.geometry instanceof Geometry) {
            this.merge(mesh.geometry, mesh.matrix);
        }
    };
    /*
     * Checks for duplicate vertices with hashmap.
     * Duplicated vertices are removed
     * and faces' vertices are updated.
     */
    Geometry.prototype.mergeVertices = function () {
        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var unique = [], changes = [];
        var v, key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow(10, precisionPoints);
        var i, il, face;
        var indices, j, jl;
        for (i = 0, il = this.vertices.length; i < il; i++) {
            v = this.vertices[i];
            key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
            if (verticesMap[key] === undefined) {
                verticesMap[key] = i;
                unique.push(this.vertices[i]);
                changes[i] = unique.length - 1;
            }
            else {
                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                changes[i] = changes[verticesMap[key]];
            }
        }
        // if faces are completely degenerate after merging vertices, we
        // have to remove them from the geometry.
        var faceIndicesToRemove = [];
        for (i = 0, il = this.faces.length; i < il; i++) {
            face = this.faces[i];
            face.a = changes[face.a];
            face.b = changes[face.b];
            face.c = changes[face.c];
            indices = [face.a, face.b, face.c];
            var dupIndex = -1;
            // if any duplicate vertices are found in a Face3
            // we have to remove the face as nothing can be saved
            for (var n = 0; n < 3; n++) {
                if (indices[n] === indices[(n + 1) % 3]) {
                    dupIndex = n;
                    faceIndicesToRemove.push(i);
                    break;
                }
            }
        }
        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
            var idx = faceIndicesToRemove[i];
            this.faces.splice(idx, 1);
            for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                this.faceVertexUvs[j].splice(idx, 1);
            }
        }
        // Use unique set of vertices
        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
    };
    Geometry.prototype.sortFacesByMaterialIndex = function () {
        var faces = this.faces;
        var length = faces.length;
        // tag faces
        for (var i = 0; i < length; i++) {
            faces[i]._id = i;
        }
        // sort faces
        function materialIndexSort(a, b) {
            return a.materialIndex - b.materialIndex;
        }
        faces.sort(materialIndexSort);
        // sort uvs
        var uvs1 = this.faceVertexUvs[0];
        var uvs2 = this.faceVertexUvs[1];
        var newUvs1, newUvs2;
        if (uvs1 && uvs1.length === length)
            newUvs1 = [];
        if (uvs2 && uvs2.length === length)
            newUvs2 = [];
        for (var i = 0; i < length; i++) {
            var id = faces[i]._id;
            if (newUvs1)
                newUvs1.push(uvs1[id]);
            if (newUvs2)
                newUvs2.push(uvs2[id]);
        }
        if (newUvs1)
            this.faceVertexUvs[0] = newUvs1;
        if (newUvs2)
            this.faceVertexUvs[1] = newUvs2;
    };
    Geometry.prototype.toJSON = function (meta) {
        var data = {
            metadata: {
                version: 4.4,
                type: 'Geometry',
                generator: 'Geometry.toJSON'
            }
        };
        // standard Geometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
            data.name = this.name;
        if (this.parameters !== undefined) {
            var parameters = this.parameters;
            for (var key in parameters) {
                if (parameters[key] !== undefined)
                    data[key] = parameters[key];
            }
            return data;
        }
        var vertices = [];
        for (var i = 0; i < this.vertices.length; i++) {
            var vertex = this.vertices[i];
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};
        for (var i = 0; i < this.faces.length; i++) {
            var face = this.faces[i];
            var hasMaterial = true;
            var hasFaceUv = false; // deprecated
            var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
            var hasFaceNormal = face.normal.length() > 0;
            var hasFaceVertexNormal = face.vertexNormals.length > 0;
            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            var hasFaceVertexColor = face.vertexColors.length > 0;
            var faceType = 0;
            faceType = setBit(faceType, 0, false); // isQuad
            faceType = setBit(faceType, 1, hasMaterial);
            faceType = setBit(faceType, 2, hasFaceUv);
            faceType = setBit(faceType, 3, hasFaceVertexUv);
            faceType = setBit(faceType, 4, hasFaceNormal);
            faceType = setBit(faceType, 5, hasFaceVertexNormal);
            faceType = setBit(faceType, 6, hasFaceColor);
            faceType = setBit(faceType, 7, hasFaceVertexColor);
            faces.push(faceType);
            faces.push(face.a, face.b, face.c);
            faces.push(face.materialIndex);
            if (hasFaceVertexUv) {
                var faceVertexUvs = this.faceVertexUvs[0][i];
                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
            }
            if (hasFaceNormal) {
                faces.push(getNormalIndex(face.normal));
            }
            if (hasFaceVertexNormal) {
                var vertexNormals = face.vertexNormals;
                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
            }
            if (hasFaceColor) {
                faces.push(getColorIndex(face.color));
            }
            if (hasFaceVertexColor) {
                var vertexColors = face.vertexColors;
                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
            }
        }
        function setBit(value, position, enabled) {
            return enabled ? value | (1 << position) : value & (~(1 << position));
        }
        function getNormalIndex(normal) {
            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
            if (normalsHash[hash] !== undefined) {
                return normalsHash[hash];
            }
            normalsHash[hash] = normals.length / 3;
            normals.push(normal.x, normal.y, normal.z);
            return normalsHash[hash];
        }
        function getColorIndex(color) {
            var hash = color.r.toString() + color.g.toString() + color.b.toString();
            if (colorsHash[hash] !== undefined) {
                return colorsHash[hash];
            }
            colorsHash[hash] = colors.length;
            colors.push(color.getHex());
            return colorsHash[hash];
        }
        function getUvIndex(uv) {
            var hash = uv.x.toString() + uv.y.toString();
            if (uvsHash[hash] !== undefined) {
                return uvsHash[hash];
            }
            uvsHash[hash] = uvs.length / 2;
            uvs.push(uv.x, uv.y);
            return uvsHash[hash];
        }
        data.data = {};
        data.data.vertices = vertices;
        data.data.normals = normals;
        if (colors.length > 0)
            data.data.colors = colors;
        if (uvs.length > 0)
            data.data.uvs = [uvs]; // temporal backward compatibility
        data.data.faces = faces;
        return data;
    };
    Geometry.prototype.clone = function () {
        /*
        // Handle primitives
        const parameters = this.parameters;
        if (parameters !== undefined) {
          const values = [];
          for (let key in parameters) {
            values.push(parameters[key]);
          }
          const geometry = Object.create(this.constructor.prototype);
          this.constructor.apply(geometry, values);
          return geometry;
        }
        return new this.constructor().copy(this);
        */
        return new this.constructor().copy(this);
    };
    Geometry.prototype.copy = function (source) {
        this.vertices = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.colors = [];
        var vertices = source.vertices;
        for (var i = 0, il = vertices.length; i < il; i++) {
            this.vertices.push(vertices[i].clone());
        }
        var colors = source.colors;
        for (var i = 0, il = colors.length; i < il; i++) {
            this.colors.push(colors[i].clone());
        }
        var faces = source.faces;
        for (var i = 0, il = faces.length; i < il; i++) {
            this.faces.push(faces[i].clone());
        }
        for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {
            var faceVertexUvs = source.faceVertexUvs[i];
            if (this.faceVertexUvs[i] === undefined) {
                this.faceVertexUvs[i] = [];
            }
            for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                var uvs = faceVertexUvs[j], uvsCopy = [];
                for (var k = 0, kl = uvs.length; k < kl; k++) {
                    var uv = uvs[k];
                    uvsCopy.push(uv.clone());
                }
                this.faceVertexUvs[i].push(uvsCopy);
            }
        }
        return this;
    };
    Geometry.prototype.dispose = function () {
        this.dispatchEvent({ type: 'dispose' });
    };
    return Geometry;
}(EventDispatcher));
var count$2 = 0;
function GeometryIdCount() { return count$2++; }

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */
var Box3 = (function () {
    function Box3(min, max) {
        if (min === void 0) { min = new Vector3(+Infinity, +Infinity, +Infinity); }
        if (max === void 0) { max = new Vector3(-Infinity, -Infinity, -Infinity); }
        this.isBox3 = true;
        this.min = min;
        this.max = max;
    }
    Box3.prototype.set = function (min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    };
    Box3.prototype.setFromArray = function (array) {
        var minX = +Infinity;
        var minY = +Infinity;
        var minZ = +Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        for (var i = 0, l = array.length; i < l; i += 3) {
            var x = array[i];
            var y = array[i + 1];
            var z = array[i + 2];
            if (x < minX)
                minX = x;
            if (y < minY)
                minY = y;
            if (z < minZ)
                minZ = z;
            if (x > maxX)
                maxX = x;
            if (y > maxY)
                maxY = y;
            if (z > maxZ)
                maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
    };
    Box3.prototype.setFromPoints = function (points) {
        this.makeEmpty();
        for (var i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
        }
        return this;
    };
    Box3.prototype.setFromCenterAndSize = function (center, size) {
        var v1 = Box3._setFromCenterAndSize_v1;
        var halfSize = v1.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    };
    Box3.prototype.setFromObject = function (object) {
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms
        var v1 = Box3._setFromObject_v1;
        var scope = this;
        object.updateMatrixWorld(true);
        this.makeEmpty();
        object.traverse(function (node) {
            var geometry = node.geometry;
            if (geometry !== undefined) {
                if ((geometry && geometry instanceof Geometry)) {
                    var vertices = geometry.vertices;
                    for (var i = 0, il = vertices.length; i < il; i++) {
                        v1.copy(vertices[i]);
                        v1.applyMatrix4(node.matrixWorld);
                        scope.expandByPoint(v1);
                    }
                }
                else if ((geometry && geometry instanceof BufferGeometry)) {
                    var attribute = geometry.attributes.position;
                    if (attribute !== undefined) {
                        var array = void 0, offset = void 0, stride = void 0;
                        if ((attribute && attribute instanceof InterleavedBufferAttribute)) {
                            array = attribute.data.array;
                            offset = attribute.offset;
                            stride = attribute.data.stride;
                        }
                        else {
                            array = attribute.array;
                            offset = 0;
                            stride = 3;
                        }
                        for (var i = offset, il = array.length; i < il; i += stride) {
                            v1.fromArray(array, i);
                            v1.applyMatrix4(node.matrixWorld);
                            scope.expandByPoint(v1);
                        }
                    }
                }
            }
        });
        return this;
    };
    Box3.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Box3.prototype.copy = function (box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    };
    Box3.prototype.makeEmpty = function () {
        this.min.x = this.min.y = this.min.z = +Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    };
    Box3.prototype.isEmpty = function () {
        // this is a more robust check for empty than (volume <= 0) because volume can get positive with two negative axes
        return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
    };
    Box3.prototype.getCenter = function (result) {
        if (result === void 0) { result = new Vector3(); }
        return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
    };
    Box3.prototype.getSize = function (result) {
        if (result === void 0) { result = new Vector3(); }
        return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
    };
    Box3.prototype.expandByPoint = function (point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    };
    Box3.prototype.expandByVector = function (vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    };
    Box3.prototype.expandByScalar = function (scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    };
    Box3.prototype.containsPoint = function (point) {
        if (point.x < this.min.x || point.x > this.max.x ||
            point.y < this.min.y || point.y > this.max.y ||
            point.z < this.min.z || point.z > this.max.z) {
            return false;
        }
        return true;
    };
    Box3.prototype.containsBox = function (box) {
        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) &&
            (this.min.y <= box.min.y) && (box.max.y <= this.max.y) &&
            (this.min.z <= box.min.z) && (box.max.z <= this.max.z)) {
            return true;
        }
        return false;
    };
    Box3.prototype.getParameter = function (point, result) {
        if (result === void 0) { result = new Vector3(); }
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    };
    Box3.prototype.intersectsBox = function (box) {
        // using 6 splitting planes to rule out intersections.
        if (box.max.x < this.min.x || box.min.x > this.max.x ||
            box.max.y < this.min.y || box.min.y > this.max.y ||
            box.max.z < this.min.z || box.min.z > this.max.z) {
            return false;
        }
        return true;
    };
    Box3.prototype.intersectsSphere = function (sphere) {
        var closestPoint = Box3._intersectsSphere_closestPoint;
        // Find the point on the AABB closest to the sphere center.
        this.clampPoint(sphere.center, closestPoint);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
    };
    Box3.prototype.intersectsPlane = function (plane) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        var min, max;
        if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
        }
        else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
        }
        else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
        }
        else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
        }
        return (min <= plane.constant && max >= plane.constant);
    };
    Box3.prototype.clampPoint = function (point, result) {
        if (result === void 0) { result = new Vector3(); }
        return result.copy(point).clamp(this.min, this.max);
    };
    Box3.prototype.distanceToPoint = function (point) {
        var v1 = Box3._distanceToPoint_v1;
        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    };
    Box3.prototype.getBoundingSphere = function (result) {
        if (result === void 0) { result = new Sphere(); }
        var v1 = Box3._getBoundingSphere_v1;
        this.getCenter(result.center);
        result.radius = this.getSize(v1).length() * 0.5;
        return result;
    };
    Box3.prototype.intersect = function (box) {
        this.min.max(box.min);
        this.max.min(box.max);
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty())
            this.makeEmpty();
        return this;
    };
    Box3.prototype.union = function (box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    };
    Box3.prototype.applyMatrix4 = function (matrix) {
        // transform of empty box is an empty box.
        if (this.isEmpty())
            return this;
        var points = Box3._applyMatrix4_points;
        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
        points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
        points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
        points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
        points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
        points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
        points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
        points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
        this.setFromPoints(points);
        return this;
    };
    Box3.prototype.translate = function (offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    };
    Box3.prototype.equals = function (box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    };
    Box3.prototype.center = function (optionalTarget) {
        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
    };
    Box3.prototype.empty = function () {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
    };
    Box3.prototype.isIntersectionBox = function (box) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
    };
    Box3.prototype.isIntersectionSphere = function (sphere) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
    };
    Box3.prototype.size = function (optionalTarget) {
        if (optionalTarget === void 0) { optionalTarget = new Vector3(); }
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
    };
    Box3._setFromCenterAndSize_v1 = new Vector3();
    Box3._setFromObject_v1 = new Vector3();
    Box3._intersectsSphere_closestPoint = new Vector3();
    Box3._distanceToPoint_v1 = new Vector3();
    Box3._getBoundingSphere_v1 = new Vector3();
    Box3._applyMatrix4_points = [
        new Vector3(), new Vector3(), new Vector3(), new Vector3(),
        new Vector3(), new Vector3(), new Vector3(), new Vector3()
    ];
    return Box3;
}());

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */
var Sphere = (function () {
    function Sphere(center, radius) {
        if (center === void 0) { center = new Vector3(); }
        if (radius === void 0) { radius = 0; }
        this.center = center;
        this.radius = radius;
    }
    Sphere.prototype.set = function (center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    };
    Sphere.prototype.setFromPoints = function (points, optionalCenter) {
        var box = Sphere.setFromPoints_box;
        var center = this.center;
        if (optionalCenter !== undefined) {
            center.copy(optionalCenter);
        }
        else {
            box.setFromPoints(points).getCenter(center);
        }
        var maxRadiusSq = 0;
        for (var i = 0, il = points.length; i < il; i++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
    };
    Sphere.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Sphere.prototype.copy = function (sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    };
    Sphere.prototype.empty = function () {
        return (this.radius <= 0);
    };
    Sphere.prototype.containsPoint = function (point) {
        return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
    };
    Sphere.prototype.distanceToPoint = function (point) {
        return (point.distanceTo(this.center) - this.radius);
    };
    Sphere.prototype.intersectsSphere = function (sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
    };
    Sphere.prototype.intersectsBox = function (box) {
        return box.intersectsSphere(this);
    };
    Sphere.prototype.intersectsPlane = function (plane) {
        // We use the following equation to compute the signed distance from
        // the center of the sphere to the plane.
        //
        // distance = q * n - d
        //
        // If this distance is greater than the radius of the sphere,
        // then there is no intersection.
        return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
    };
    Sphere.prototype.clampPoint = function (point, result) {
        if (result === void 0) { result = new Vector3(); }
        var deltaLengthSq = this.center.distanceToSquared(point);
        result.copy(point);
        if (deltaLengthSq > (this.radius * this.radius)) {
            result.sub(this.center).normalize();
            result.multiplyScalar(this.radius).add(this.center);
        }
        return result;
    };
    Sphere.prototype.getBoundingBox = function (box) {
        if (box === void 0) { box = new Box3(); }
        box.set(this.center, this.center);
        box.expandByScalar(this.radius);
        return box;
    };
    Sphere.prototype.applyMatrix4 = function (matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    };
    Sphere.prototype.translate = function (offset) {
        this.center.add(offset);
        return this;
    };
    Sphere.prototype.equals = function (sphere) {
        return sphere.center.equals(this.center) && (sphere.radius === this.radius);
    };
    Sphere.setFromPoints_box = new Box3();
    return Sphere;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */
var Frustum = (function () {
    function Frustum(p0, p1, p2, p3, p4, p5) {
        if (p0 === void 0) { p0 = new Plane(); }
        if (p1 === void 0) { p1 = new Plane(); }
        if (p2 === void 0) { p2 = new Plane(); }
        if (p3 === void 0) { p3 = new Plane(); }
        if (p4 === void 0) { p4 = new Plane(); }
        if (p5 === void 0) { p5 = new Plane(); }
        this.planes = [p0, p1, p2, p3, p4, p5];
    }
    Frustum.prototype.set = function (p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    };
    Frustum.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Frustum.prototype.copy = function (frustum) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
            planes[i].copy(frustum.planes[i]);
        }
        return this;
    };
    Frustum.prototype.setFromMatrix = function (m) {
        var planes = this.planes;
        var me = m.elements;
        var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    };
    Frustum.prototype.intersectsObject = function (object) {
        var sphere = Frustum.intersectsObject_sphere;
        var geometry = object.geometry;
        if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere)
            .applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(sphere);
    };
    Frustum.prototype.intersectsSprite = function (sprite) {
        var sphere = Frustum.intersectsSprite_sphere;
        sphere.center.set(0, 0, 0);
        sphere.radius = 0.7071067811865476;
        sphere.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(sphere);
    };
    Frustum.prototype.intersectsSphere = function (sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for (var i = 0; i < 6; i++) {
            var distance = planes[i].distanceToPoint(center);
            if (distance < negRadius) {
                return false;
            }
        }
        return true;
    };
    Frustum.prototype.intersectsBox = function (box) {
        var p1 = Frustum.intersectsBox_p1, p2 = Frustum.intersectsBox_p2;
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
            var plane = planes[i];
            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
            p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
            p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
            p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            var d1 = plane.distanceToPoint(p1);
            var d2 = plane.distanceToPoint(p2);
            // if both outside plane, no intersection
            if (d1 < 0 && d2 < 0) {
                return false;
            }
        }
        return true;
    };
    Frustum.prototype.containsPoint = function (point) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
            if (planes[i].distanceToPoint(point) < 0) {
                return false;
            }
        }
        return true;
    };
    Frustum.intersectsObject_sphere = new Sphere();
    Frustum.intersectsSprite_sphere = new Sphere();
    Frustum.intersectsBox_p1 = new Vector3();
    Frustum.intersectsBox_p2 = new Vector3();
    return Frustum;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/
var Camera = (function (_super) {
    __extends(Camera, _super);
    function Camera() {
        _super.call(this);
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
        // }
        this.isCamera = true;
        this.type = 'Camera';
    }
    Camera.prototype.updateProjectionMatrix = function () { };
    Camera.prototype.getWorldDirection = function (result) {
        if (result === void 0) { result = new Vector3(); }
        var quaternion = new Quaternion();
        //return function getWorldDirection(result) {
        this.getWorldQuaternion(quaternion);
        return result.set(0, 0, -1).applyQuaternion(quaternion);
        //};
    };
    Camera.prototype.lookAt = function (vector) {
        // This routine does not support cameras with rotated and/or translated parent(s)
        var m1 = new Matrix4();
        //return function lookAt(vector) {
        m1.lookAt(this.position, vector, this.up);
        this.quaternion.setFromRotationMatrix(m1);
        //};
    };
    Camera.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Camera.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        return this;
    };
    return Camera;
}(Object3D));

/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */
var OrthographicCamera = (function (_super) {
    __extends(OrthographicCamera, _super);
    function OrthographicCamera(left, right, top, bottom, near, far) {
        if (near === void 0) { near = 0.1; }
        if (far === void 0) { far = 2000; }
        _super.call(this);
        this.zoom = 1;
        this.view = null;
        this.isOrthographicCamera = true;
        this.type = 'OrthographicCamera';
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = near;
        this.far = far;
        this.updateProjectionMatrix();
    }
    OrthographicCamera.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
    };
    OrthographicCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
        this.view = {
            fullWidth: fullWidth,
            fullHeight: fullHeight,
            offsetX: x,
            offsetY: y,
            width: width,
            height: height
        };
        this.updateProjectionMatrix();
    };
    OrthographicCamera.prototype.clearViewOffset = function () {
        this.view = null;
        this.updateProjectionMatrix();
    };
    OrthographicCamera.prototype.updateProjectionMatrix = function () {
        var dx = (this.right - this.left) / (2 * this.zoom);
        var dy = (this.top - this.bottom) / (2 * this.zoom);
        var cx = (this.right + this.left) / 2;
        var cy = (this.top + this.bottom) / 2;
        var left = cx - dx;
        var right = cx + dx;
        var top = cy + dy;
        var bottom = cy - dy;
        if (this.view !== null) {
            var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
            var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
            var scaleW = (this.right - this.left) / this.view.width;
            var scaleH = (this.top - this.bottom) / this.view.height;
            left += scaleW * (this.view.offsetX / zoomW);
            right = left + scaleW * (this.view.width / zoomW);
            top -= scaleH * (this.view.offsetY / zoomH);
            bottom = top - scaleH * (this.view.height / zoomH);
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    };
    OrthographicCamera.prototype.toJSON = function (meta) {
        var data = _super.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
        return data;
    };
    return OrthographicCamera;
}(Camera));

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */
var PerspectiveCamera = (function (_super) {
    __extends(PerspectiveCamera, _super);
    function PerspectiveCamera(fov, aspect, near, far) {
        if (fov === void 0) { fov = 50; }
        if (aspect === void 0) { aspect = 1; }
        if (near === void 0) { near = 0.1; }
        if (far === void 0) { far = 2000; }
        _super.call(this);
        this.zoom = 1;
        this.focus = 10;
        this.view = null;
        this.filmGauge = 35; // width of the film (default in millimeters)
        this.filmOffset = 0; // horizontal film offset (same unit as gauge)
        this.isPerspectiveCamera = true;
        this.type = 'PerspectiveCamera';
        this.fov = fov;
        this.near = near;
        this.far = far;
        this.aspect = aspect;
        this.updateProjectionMatrix();
    }
    PerspectiveCamera.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    };
    PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. " +
            "Use .setFocalLength and .filmGauge for a photographic setup.");
        if (filmGauge !== undefined)
            this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
    };
    /**
     * Sets the FOV by focal length in respect to the current .filmGauge.
     *
     * The default film gauge is 35, so that the focal length can be specified for
     * a 35mm (full frame) camera.
     *
     * Values for focal length and film gauge must have the same unit.
     */
    PerspectiveCamera.prototype.setFocalLength = function (focalLength) {
        // see http://www.bobatkins.com/photography/technical/field_of_view.html
        var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    };
    /**
     * Calculates the focal length from the current .fov and .filmGauge.
     */
    PerspectiveCamera.prototype.getFocalLength = function () {
        var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    };
    PerspectiveCamera.prototype.getEffectiveFOV = function () {
        return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
    };
    PerspectiveCamera.prototype.getFilmWidth = function () {
        // film not completely covered in portrait format (aspect < 1)
        return this.filmGauge * Math.min(this.aspect, 1);
    };
    PerspectiveCamera.prototype.getFilmHeight = function () {
        // film not completely covered in landscape format (aspect > 1)
        return this.filmGauge / Math.max(this.aspect, 1);
    };
    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or
     * multi-monitor/multi-machine setups.
     *
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
     * the monitors are in grid like this
     *
     *   +---+---+---+
     *   | A | B | C |
     *   +---+---+---+
     *   | D | E | F |
     *   +---+---+---+
     *
     * then for each monitor you would call it like this
     *
     *   let w = 1920;
     *   let h = 1080;
     *   let fullWidth = w * 3;
     *   let fullHeight = h * 2;
     *
     *   --A--
     *   camera.setOffset(fullWidth, fullHeight, w * 0, h * 0, w, h);
     *   --B--
     *   camera.setOffset(fullWidth, fullHeight, w * 1, h * 0, w, h);
     *   --C--
     *   camera.setOffset(fullWidth, fullHeight, w * 2, h * 0, w, h);
     *   --D--
     *   camera.setOffset(fullWidth, fullHeight, w * 0, h * 1, w, h);
     *   --E--
     *   camera.setOffset(fullWidth, fullHeight, w * 1, h * 1, w, h);
     *   --F--
     *   camera.setOffset(fullWidth, fullHeight, w * 2, h * 1, w, h);
     *
     *   Note there is no reason monitors have to be the same size or in a grid.
     */
    PerspectiveCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        this.view = {
            fullWidth: fullWidth,
            fullHeight: fullHeight,
            offsetX: x,
            offsetY: y,
            width: width,
            height: height
        };
        this.updateProjectionMatrix();
    };
    PerspectiveCamera.prototype.clearViewOffset = function () {
        this.view = null;
        this.updateProjectionMatrix();
    };
    PerspectiveCamera.prototype.updateProjectionMatrix = function () {
        var near = this.near;
        var top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom;
        var height = 2 * top;
        var width = this.aspect * height;
        var left = -0.5 * width;
        var view = this.view;
        if (view !== null) {
            var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        var skew = this.filmOffset;
        if (skew !== 0)
            left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makeFrustum(left, left + width, top - height, top, near, this.far);
    };
    PerspectiveCamera.prototype.toJSON = function (meta) {
        var data = _super.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    };
    return PerspectiveCamera;
}(Camera));

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
var Light = (function (_super) {
    __extends(Light, _super);
    function Light(color, intensity) {
        if (intensity === void 0) { intensity = 1; }
        _super.call(this);
        this.isLight = true;
        this.type = 'Light';
        this.color = new Color(color);
        this.intensity = intensity !== undefined ? intensity : 1;
        this.receiveShadow = undefined;
    }
    Light.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    };
    Light.prototype.toJSON = function (meta) {
        var data = _super.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined)
            data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined)
            data.object.distance = this.distance;
        if (this.angle !== undefined)
            data.object.angle = this.angle;
        if (this.decay !== undefined)
            data.object.decay = this.decay;
        if (this.penumbra !== undefined)
            data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined)
            data.object.shadow = this.shadow.toJSON();
        return data;
    };
    Object.defineProperty(Light.prototype, "onlyShadow", {
        set: function (value) {
            console.warn("THREE.Light: .onlyShadow has been removed.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowCameraFov", {
        set: function (value) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
            if (this.shadow.camera instanceof PerspectiveCamera) {
                this.shadow.camera.fov = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowCameraLeft", {
        set: function (value) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
            if (this.shadow.camera instanceof OrthographicCamera) {
                this.shadow.camera.left = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowCameraRight", {
        set: function (value) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
            if (this.shadow.camera instanceof OrthographicCamera) {
                this.shadow.camera.right = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowCameraTop", {
        set: function (value) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
            if (this.shadow.camera instanceof OrthographicCamera) {
                this.shadow.camera.top = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowCameraBottom", {
        set: function (value) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
            if (this.shadow.camera instanceof OrthographicCamera) {
                this.shadow.camera.bottom = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowCameraNear", {
        set: function (value) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
            if (this.shadow.camera instanceof OrthographicCamera) {
                this.shadow.camera.near = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowCameraFar", {
        set: function (value) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
            if (this.shadow.camera instanceof OrthographicCamera) {
                this.shadow.camera.far = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowCameraVisible", {
        set: function (value) {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper(light.shadow.camera) instead.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowBias", {
        set: function (value) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
            this.shadow.bias = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowDarkness", {
        set: function (value) {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowMapWidth", {
        set: function (value) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
            this.shadow.mapSize.width = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Light.prototype, "shadowMapHeight", {
        set: function (value) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
            this.shadow.mapSize.height = value;
        },
        enumerable: true,
        configurable: true
    });
    return Light;
}(Object3D));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var LightShadow = (function () {
    function LightShadow(camera) {
        this.bias = 0;
        this.radius = 1;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.matrix = new Matrix4();
        this.camera = camera;
    }
    LightShadow.prototype.copy = function (source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    };
    LightShadow.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    LightShadow.prototype.toJSON = function () {
        var object = {};
        if (this.bias !== 0)
            object.bias = this.bias;
        if (this.radius !== 1)
            object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
            object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    };
    return LightShadow;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var PointLight = (function (_super) {
    __extends(PointLight, _super);
    function PointLight(color, intensity, distance, decay) {
        if (distance === void 0) { distance = 0; }
        if (decay === void 0) { decay = 1; }
        _super.call(this, color, intensity);
        this.isPointLight = true;
        this.type = 'PointLight';
        this.distance = distance;
        this.decay = decay; // for physically correct lights, should be 2.
        this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
    }
    Object.defineProperty(PointLight.prototype, "power", {
        get: function () {
            // intensity = power per solid angle.
            // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
            return this.intensity * 4 * Math.PI;
        },
        set: function (value) {
            // intensity = power per solid angle.
            // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
            this.intensity = value / (4 * Math.PI);
        },
        enumerable: true,
        configurable: true
    });
    PointLight.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
    };
    return PointLight;
}(Light));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var SpotLightShadow = (function (_super) {
    __extends(SpotLightShadow, _super);
    function SpotLightShadow() {
        _super.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
        this.isSpotLightShadow = true;
    }
    SpotLightShadow.prototype.update = function (light) {
        var fov = _Math.RAD2DEG * 2 * light.angle;
        var aspect = this.mapSize.width / this.mapSize.height;
        var far = light.distance || 500;
        var camera = this.camera;
        if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
            camera.fov = fov;
            camera.aspect = aspect;
            camera.far = far;
            camera.updateProjectionMatrix();
        }
    };
    return SpotLightShadow;
}(LightShadow));

/**
 * @author alteredq / http://alteredqualia.com/
 */
var DataTexture = (function (_super) {
    __extends(DataTexture, _super);
    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        if (magFilter === void 0) { magFilter = TextureFilter.Nearest; }
        if (minFilter === void 0) { minFilter = TextureFilter.Nearest; }
        _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.isDataTexture = true;
        this.image = { data: data, width: width, height: height };
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
    }
    return DataTexture;
}(Texture));

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */
var Bone = (function (_super) {
    __extends(Bone, _super);
    function Bone(skin) {
        _super.call(this);
        this.isBone = true;
        this.type = 'Bone';
        this.skin = skin;
    }
    Bone.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.skin = source.skin;
        return this;
    };
    return Bone;
}(Object3D));

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */
var Skeleton = (function () {
    function Skeleton(bones, boneInverses, useVertexTexture) {
        if (bones === void 0) { bones = []; }
        if (useVertexTexture === void 0) { useVertexTexture = true; }
        this.identityMatrix = new Matrix4();
        this.useVertexTexture = useVertexTexture;
        // copy the bone array
        this.bones = bones.slice(0);
        // create a bone texture or an array of floats
        if (this.useVertexTexture) {
            // layout (1 matrix = 4 pixels)
            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
            var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
            size = _Math.nextPowerOfTwo(Math.ceil(size));
            size = Math.max(size, 4);
            this.boneTextureWidth = size;
            this.boneTextureHeight = size;
            this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4); // 4 floats per RGBA pixel
            this.boneTexture = new DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, TextureFormat.RGBA, TextureType.Float);
        }
        else {
            this.boneMatrices = new Float32Array(16 * this.bones.length);
        }
        // use the supplied bone inverses or calculate the inverses
        if (boneInverses === undefined) {
            this.calculateInverses();
        }
        else {
            if (this.bones.length === boneInverses.length) {
                this.boneInverses = boneInverses.slice(0);
            }
            else {
                console.warn('THREE.Skeleton bonInverses is the wrong length.');
                this.boneInverses = [];
                for (var b = 0, bl = this.bones.length; b < bl; b++) {
                    this.boneInverses.push(new Matrix4());
                }
            }
        }
    }
    Skeleton.prototype.calculateInverses = function () {
        this.boneInverses = [];
        for (var b = 0, bl = this.bones.length; b < bl; b++) {
            var inverse = new Matrix4();
            if (this.bones[b]) {
                inverse.getInverse(this.bones[b].matrixWorld);
            }
            this.boneInverses.push(inverse);
        }
    };
    Skeleton.prototype.pose = function () {
        var bone;
        // recover the bind-time world matrices
        for (var b = 0, bl = this.bones.length; b < bl; b++) {
            bone = this.bones[b];
            if (bone) {
                bone.matrixWorld.getInverse(this.boneInverses[b]);
            }
        }
        // compute the local matrices, positions, rotations and scales
        for (var b = 0, bl = this.bones.length; b < bl; b++) {
            bone = this.bones[b];
            if (bone) {
                if ((bone.parent && bone.parent instanceof Bone)) {
                    bone.matrix.getInverse(bone.parent.matrixWorld);
                    bone.matrix.multiply(bone.matrixWorld);
                }
                else {
                    bone.matrix.copy(bone.matrixWorld);
                }
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
        }
    };
    Skeleton.prototype.update = function () {
        var offsetMatrix = Skeleton.update_offsetMatrix;
        //return function update() {
        // flatten bone matrices to array
        for (var b = 0, bl = this.bones.length; b < bl; b++) {
            // compute the offset between the current and the original transform
            var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
            offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
            offsetMatrix.toArray(this.boneMatrices, b * 16);
        }
        if (this.useVertexTexture) {
            this.boneTexture.needsUpdate = true;
        }
        //};
    };
    Skeleton.prototype.clone = function () {
        return new this.constructor(this.bones, this.boneInverses, this.useVertexTexture);
    };
    Skeleton.update_offsetMatrix = new Matrix4();
    return Skeleton;
}());

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */
var SkinnedMesh = (function (_super) {
    __extends(SkinnedMesh, _super);
    function SkinnedMesh(geometry, material, useVertexTexture) {
        if (useVertexTexture === void 0) { useVertexTexture = true; }
        _super.call(this, geometry, material);
        this.bindMode = "attached";
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
        this.isSkinnedMesh = true;
        this.type = 'SkinnedMesh';
        // init bones
        // TODO: remove bone creation as there is no reason (other than
        // convenience) for THREE.SkinnedMesh to do this.
        var bones = [];
        if (this.geometry && this.geometry.bones !== undefined) {
            var bone = void 0, gbone = void 0;
            for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
                gbone = this.geometry.bones[b];
                bone = new Bone(this);
                bones.push(bone);
                bone.name = gbone.name;
                bone.position.fromArray(gbone.pos);
                bone.quaternion.fromArray(gbone.rotq);
                if (gbone.scl !== undefined)
                    bone.scale.fromArray(gbone.scl);
            }
            for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
                gbone = this.geometry.bones[b];
                if (gbone.parent !== -1 && gbone.parent !== null &&
                    bones[gbone.parent] !== undefined) {
                    bones[gbone.parent].add(bones[b]);
                }
                else {
                    this.add(bones[b]);
                }
            }
        }
        this.normalizeSkinWeights();
        this.updateMatrixWorld(true);
        this.bind(new Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);
    }
    SkinnedMesh.prototype.bind = function (skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.getInverse(bindMatrix);
    };
    SkinnedMesh.prototype.pose = function () {
        this.skeleton.pose();
    };
    SkinnedMesh.prototype.normalizeSkinWeights = function () {
        if ((this.geometry && this.geometry instanceof Geometry)) {
            for (var i = 0; i < this.geometry.skinWeights.length; i++) {
                var sw = this.geometry.skinWeights[i];
                var scale = 1.0 / sw.lengthManhattan();
                if (scale !== Infinity) {
                    sw.multiplyScalar(scale);
                }
                else {
                    sw.set(1, 0, 0, 0); // do something reasonable
                }
            }
        }
        else if ((this.geometry && this.geometry instanceof BufferGeometry)) {
            var vec = new Vector4();
            var skinWeight = this.geometry.attributes.skinWeight;
            for (var i = 0; i < skinWeight.count; i++) {
                vec.x = skinWeight.getX(i);
                vec.y = skinWeight.getY(i);
                vec.z = skinWeight.getZ(i);
                vec.w = skinWeight.getW(i);
                var scale = 1.0 / vec.lengthManhattan();
                if (scale !== Infinity) {
                    vec.multiplyScalar(scale);
                }
                else {
                    vec.set(1, 0, 0, 0); // do something reasonable
                }
                skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
            }
        }
    };
    SkinnedMesh.prototype.updateMatrixWorld = function (force) {
        _super.prototype.updateMatrixWorld.call(this, true);
        if (this.bindMode === "attached") {
            this.bindMatrixInverse.getInverse(this.matrixWorld);
        }
        else if (this.bindMode === "detached") {
            this.bindMatrixInverse.getInverse(this.bindMatrix);
        }
        else {
            console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);
        }
    };
    SkinnedMesh.prototype.clone = function () {
        return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this);
    };
    return SkinnedMesh;
}(Mesh));

var WebGLShadowMap = (function () {
    function WebGLShadowMap(_renderer, _lights, _objects, capabilities) {
        this._renderer = _renderer;
        this._lights = _lights;
        this._objects = _objects;
        this.capabilities = capabilities;
        this._gl = _renderer.context;
        this._state = _renderer.state;
        this._frustum = new Frustum();
        this._projScreenMatrix = new Matrix4();
        this._lightShadows = _lights.shadows;
        this._shadowMapSize = new Vector2();
        this._maxShadowMapSize = new Vector2(capabilities.maxTextureSize, capabilities.maxTextureSize);
        this._lookTarget = new Vector3();
        this._lightPositionWorld = new Vector3();
        this._renderList = [];
        this._MorphingFlag = 1;
        this._SkinningFlag = 2;
        this._NumberOfMaterialVariants = (this._MorphingFlag | this._SkinningFlag) + 1;
        this._depthMaterials = new Array(this._NumberOfMaterialVariants);
        this._distanceMaterials = new Array(this._NumberOfMaterialVariants);
        this._materialCache = {};
        this.cubeDirections = [
            new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1),
            new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)
        ];
        this.cubeUps = [
            new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),
            new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)
        ];
        this.cube2DViewPorts = [
            new Vector4(), new Vector4(), new Vector4(),
            new Vector4(), new Vector4(), new Vector4()
        ];
        // init
        var depthMaterialTemplate = new MeshDepthMaterial();
        depthMaterialTemplate.depthPacking = DepthPacking.RGBA;
        depthMaterialTemplate.clipping = true;
        var distanceShader = ShaderLib["distanceRGBA"];
        var distanceUniforms = UniformsUtils.clone(distanceShader.uniforms);
        for (var i = 0; i !== this._NumberOfMaterialVariants; ++i) {
            var useMorphing = (i & this._MorphingFlag) !== 0;
            var useSkinning = (i & this._SkinningFlag) !== 0;
            var depthMaterial = depthMaterialTemplate.clone();
            depthMaterial.morphTargets = useMorphing;
            depthMaterial.skinning = useSkinning;
            this._depthMaterials[i] = depthMaterial;
            var distanceMaterial = new ShaderMaterial({
                defines: {
                    'USE_SHADOWMAP': ''
                },
                uniforms: distanceUniforms,
                vertexShader: distanceShader.vertexShader,
                fragmentShader: distanceShader.fragmentShader,
                morphTargets: useMorphing,
                skinning: useSkinning,
                clipping: true
            });
            this._distanceMaterials[i] = distanceMaterial;
        }
        //
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = ShadowMap.PCF;
        this.renderReverseSided = true;
        this.renderSingleSided = true;
    }
    WebGLShadowMap.prototype.render = function (scene, camera) {
        if (this.enabled === false)
            return;
        if (this.autoUpdate === false && this.needsUpdate === false)
            return;
        if (this._lightShadows.length === 0)
            return;
        // Set GL state for depth map.
        this._state.clearColor(1, 1, 1, 1);
        this._state.disable(this._gl.BLEND);
        this._state.setDepthTest(true);
        this._state.setScissorTest(false);
        // render depth map
        var faceCount, isPointLight;
        for (var i = 0, il = this._lightShadows.length; i < il; i++) {
            var light = this._lightShadows[i];
            var shadow = light.shadow;
            if (shadow === undefined) {
                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                continue;
            }
            var shadowCamera = shadow.camera;
            this._shadowMapSize.copy(shadow.mapSize);
            this._shadowMapSize.min(this._maxShadowMapSize);
            if ((light && light instanceof PointLight)) {
                faceCount = 6;
                isPointLight = true;
                var vpWidth = this._shadowMapSize.x;
                var vpHeight = this._shadowMapSize.y;
                // These viewports map a cube-map onto a 2D texture with the
                // following orientation:
                //
                //  xzXZ
                //   y Y
                //
                // X - Positive x direction
                // x - Negative x direction
                // Y - Positive y direction
                // y - Negative y direction
                // Z - Positive z direction
                // z - Negative z direction
                // positive X
                this.cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                // negative X
                this.cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                // positive Z
                this.cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                // negative Z
                this.cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                // positive Y
                this.cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                // negative Y
                this.cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
                this._shadowMapSize.x *= 4.0;
                this._shadowMapSize.y *= 2.0;
            }
            else {
                faceCount = 1;
                isPointLight = false;
            }
            if (shadow.map === null) {
                var pars = { minFilter: TextureFilter.Nearest, magFilter: TextureFilter.Nearest, format: TextureFormat.RGBA };
                shadow.map = new WebGLRenderTarget(this._shadowMapSize.x, this._shadowMapSize.y, pars);
                shadowCamera.updateProjectionMatrix();
            }
            if ((shadow && shadow instanceof SpotLightShadow)) {
                shadow.update(light);
            }
            var shadowMap = shadow.map;
            var shadowMatrix = shadow.matrix;
            this._lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
            shadowCamera.position.copy(this._lightPositionWorld);
            this._renderer.setRenderTarget(shadowMap);
            this._renderer.clear();
            // render shadow map for each cube face (if omni-directional) or
            // run a single pass if not
            for (var face = 0; face < faceCount; face++) {
                if (isPointLight) {
                    this._lookTarget.copy(shadowCamera.position);
                    this._lookTarget.add(this.cubeDirections[face]);
                    shadowCamera.up.copy(this.cubeUps[face]);
                    shadowCamera.lookAt(this._lookTarget);
                    var vpDimensions = this.cube2DViewPorts[face];
                    this._state.viewport(vpDimensions);
                }
                else {
                    this._lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                    shadowCamera.lookAt(this._lookTarget);
                }
                shadowCamera.updateMatrixWorld();
                shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
                // compute shadow matrix
                shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                shadowMatrix.multiply(shadowCamera.projectionMatrix);
                shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                // update camera matrices and frustum
                this._projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                this._frustum.setFromMatrix(this._projScreenMatrix);
                // set object matrices & frustum culling
                this._renderList.length = 0;
                this.projectObject(scene, camera, shadowCamera);
                // render shadow map
                // render regular objects
                for (var j = 0, jl = this._renderList.length; j < jl; j++) {
                    var object = this._renderList[j];
                    var geometry = this._objects.update(object);
                    var material = object.material;
                    if ((material && material instanceof MultiMaterial)) {
                        var groups = geometry.groups;
                        var materials = material.materials;
                        for (var k = 0, kl = groups.length; k < kl; k++) {
                            var group = groups[k];
                            var groupMaterial = materials[group.materialIndex];
                            if (groupMaterial.visible === true) {
                                var depthMaterial = this.getDepthMaterial(object, groupMaterial, isPointLight, this._lightPositionWorld);
                                this._renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                            }
                        }
                    }
                    else {
                        var depthMaterial = this.getDepthMaterial(object, material, isPointLight, this._lightPositionWorld);
                        this._renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                    }
                }
            }
        }
        // Restore GL state.
        var clearColor = this._renderer.getClearColor(), clearAlpha = this._renderer.getClearAlpha();
        this._renderer.setClearColor(clearColor, clearAlpha);
        this.needsUpdate = false;
    };
    WebGLShadowMap.prototype.getDepthMaterial = function (object, material, isPointLight, lightPositionWorld) {
        var geometry = object.geometry;
        var result = null;
        var materialVariants = this._depthMaterials;
        var customMaterial = object.customDepthMaterial;
        if (isPointLight) {
            materialVariants = this._distanceMaterials;
            customMaterial = object.customDistanceMaterial;
        }
        if (!customMaterial) {
            var useMorphing = false;
            if (material.morphTargets) {
                if ((geometry && geometry instanceof BufferGeometry)) {
                    useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                }
                else if ((geometry && geometry instanceof Geometry)) {
                    useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
                }
            }
            var useSkinning = object instanceof SkinnedMesh && material.skinning;
            var variantIndex = 0;
            if (useMorphing)
                variantIndex |= this._MorphingFlag;
            if (useSkinning)
                variantIndex |= this._SkinningFlag;
            result = materialVariants[variantIndex];
        }
        else {
            result = customMaterial;
        }
        if (this._renderer.localClippingEnabled &&
            material.clipShadows === true &&
            material.clippingPlanes.length !== 0) {
            // in this case we need a unique material instance reflecting the
            // appropriate state
            var keyA = result.uuid, keyB = material.uuid;
            var materialsForVariant = this._materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {};
                this._materialCache[keyA] = materialsForVariant;
            }
            var cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        var side = material.side;
        if (this.renderSingleSided && side === SideMode.Double) {
            side = SideMode.Front;
        }
        if (this.renderReverseSided) {
            if (side === SideMode.Front)
                side = SideMode.Back;
            else if (side === SideMode.Back)
                side = SideMode.Front;
        }
        result.side = side;
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (isPointLight && result.uniforms.lightPos !== undefined) {
            result.uniforms.lightPos.value.copy(lightPositionWorld);
        }
        return result;
    };
    WebGLShadowMap.prototype.projectObject = function (object, camera, shadowCamera) {
        if (object.visible === false)
            return;
        var visible = (object.layers.mask & camera.layers.mask) !== 0;
        if (visible && (object instanceof Mesh || object instanceof Line || object instanceof Points)) {
            if (object.castShadow && (object.frustumCulled === false || this._frustum.intersectsObject(object) === true)) {
                var material = object.material;
                if (material.visible === true) {
                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    this._renderList.push(object);
                }
            }
        }
        var children = object.children;
        for (var i = 0, l = children.length; i < l; i++) {
            this.projectObject(children[i], camera, shadowCamera);
        }
    };
    Object.defineProperty(WebGLShadowMap.prototype, "cullFace", {
        get: function () {
            return this.renderReverseSided ? CullFace.Front : CullFace.Back;
        },
        set: function (cullFace) {
            var value = (cullFace !== CullFace.Back);
            console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + ".");
            this.renderReverseSided = value;
        },
        enumerable: true,
        configurable: true
    });
    return WebGLShadowMap;
}());

/**
 * @author Mugen87 / https://github.com/Mugen87
 */
var BoxBufferGeometry = (function (_super) {
    __extends(BoxBufferGeometry, _super);
    function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        _super.call(this);
        this.type = 'BoxBufferGeometry';
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        var scope = this;
        // segments
        widthSegments = Math.floor(widthSegments) || 1;
        heightSegments = Math.floor(heightSegments) || 1;
        depthSegments = Math.floor(depthSegments) || 1;
        // these are used to calculate buffer length
        var vertexCount = calculateVertexCount(widthSegments, heightSegments, depthSegments);
        var indexCount = calculateIndexCount(widthSegments, heightSegments, depthSegments);
        // buffers
        var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
        var vertices = new Float32Array(vertexCount * 3);
        var normals = new Float32Array(vertexCount * 3);
        var uvs = new Float32Array(vertexCount * 2);
        // offset variables
        var vertexBufferOffset = 0;
        var uvBufferOffset = 0;
        var indexBufferOffset = 0;
        var numberOfVertices = 0;
        // group variables
        var groupStart = 0;
        // build each side of the box geometry
        buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
        buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
        buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
        buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
        buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
        buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
        // build geometry
        this.setIndex(new BufferAttribute(indices, 1));
        this.addAttribute('position', new BufferAttribute(vertices, 3));
        this.addAttribute('normal', new BufferAttribute(normals, 3));
        this.addAttribute('uv', new BufferAttribute(uvs, 2));
        // helper functions
        function calculateVertexCount(w, h, d) {
            var vertices = 0;
            // calculate the amount of vertices for each side (plane)
            vertices += (w + 1) * (h + 1) * 2; // xy
            vertices += (w + 1) * (d + 1) * 2; // xz
            vertices += (d + 1) * (h + 1) * 2; // zy
            return vertices;
        }
        function calculateIndexCount(w, h, d) {
            var index = 0;
            // calculate the amount of squares for each side
            index += w * h * 2; // xy
            index += w * d * 2; // xz
            index += d * h * 2; // zy
            return index * 6; // two triangles per square => six vertices per square
        }
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            var segmentWidth = width / gridX;
            var segmentHeight = height / gridY;
            var widthHalf = width / 2;
            var heightHalf = height / 2;
            var depthHalf = depth / 2;
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var vertexCounter = 0;
            var groupCount = 0;
            var vector = new Vector3();
            // generate vertices, normals and uvs
            for (var iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (var ix = 0; ix < gridX1; ix++) {
                    var x = ix * segmentWidth - widthHalf;
                    // set values to correct vector component
                    vector[u] = x * udir;
                    vector[v] = y * vdir;
                    vector[w] = depthHalf;
                    // now apply vector to vertex buffer
                    vertices[vertexBufferOffset] = vector.x;
                    vertices[vertexBufferOffset + 1] = vector.y;
                    vertices[vertexBufferOffset + 2] = vector.z;
                    // set values to correct vector component
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w] = depth > 0 ? 1 : -1;
                    // now apply vector to normal buffer
                    normals[vertexBufferOffset] = vector.x;
                    normals[vertexBufferOffset + 1] = vector.y;
                    normals[vertexBufferOffset + 2] = vector.z;
                    // uvs
                    uvs[uvBufferOffset] = ix / gridX;
                    uvs[uvBufferOffset + 1] = 1 - (iy / gridY);
                    // update offsets and counters
                    vertexBufferOffset += 3;
                    uvBufferOffset += 2;
                    vertexCounter += 1;
                }
            }
            // 1. you need three indices to draw a single face
            // 2. a single segment consists of two faces
            // 3. so we need to generate six (2*3) indices per segment
            for (var iy = 0; iy < gridY; iy++) {
                for (var ix = 0; ix < gridX; ix++) {
                    // indices
                    var a = numberOfVertices + ix + gridX1 * iy;
                    var b = numberOfVertices + ix + gridX1 * (iy + 1);
                    var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                    var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                    // face one
                    indices[indexBufferOffset] = a;
                    indices[indexBufferOffset + 1] = b;
                    indices[indexBufferOffset + 2] = d;
                    // face two
                    indices[indexBufferOffset + 3] = b;
                    indices[indexBufferOffset + 4] = c;
                    indices[indexBufferOffset + 5] = d;
                    // update offsets and counters
                    indexBufferOffset += 6;
                    groupCount += 6;
                }
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, materialIndex);
            // calculate new start value for groups
            groupStart += groupCount;
            // update total number of vertices
            numberOfVertices += vertexCounter;
        }
    }
    return BoxBufferGeometry;
}(BufferGeometry));

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */
var PlaneBufferGeometry = (function (_super) {
    __extends(PlaneBufferGeometry, _super);
    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
        _super.call(this);
        this.type = 'PlaneBufferGeometry';
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        var width_half = width / 2;
        var height_half = height / 2;
        var gridX = Math.floor(widthSegments) || 1;
        var gridY = Math.floor(heightSegments) || 1;
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var segment_width = width / gridX;
        var segment_height = height / gridY;
        var vertices = new Float32Array(gridX1 * gridY1 * 3);
        var normals = new Float32Array(gridX1 * gridY1 * 3);
        var uvs = new Float32Array(gridX1 * gridY1 * 2);
        var offset = 0;
        var offset2 = 0;
        for (var iy = 0; iy < gridY1; iy++) {
            var y = iy * segment_height - height_half;
            for (var ix = 0; ix < gridX1; ix++) {
                var x = ix * segment_width - width_half;
                vertices[offset] = x;
                vertices[offset + 1] = -y;
                normals[offset + 2] = 1;
                uvs[offset2] = ix / gridX;
                uvs[offset2 + 1] = 1 - (iy / gridY);
                offset += 3;
                offset2 += 2;
            }
        }
        offset = 0;
        var indices = new ((vertices.length / 3) > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
        for (var iy = 0; iy < gridY; iy++) {
            for (var ix = 0; ix < gridX; ix++) {
                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * (iy + 1);
                var c = (ix + 1) + gridX1 * (iy + 1);
                var d = (ix + 1) + gridX1 * iy;
                indices[offset] = a;
                indices[offset + 1] = b;
                indices[offset + 2] = d;
                indices[offset + 3] = b;
                indices[offset + 4] = c;
                indices[offset + 5] = d;
                offset += 6;
            }
        }
        this.setIndex(new BufferAttribute(indices, 1));
        this.addAttribute('position', new BufferAttribute(vertices, 3));
        this.addAttribute('normal', new BufferAttribute(normals, 3));
        this.addAttribute('uv', new BufferAttribute(uvs, 2));
    }
    return PlaneBufferGeometry;
}(BufferGeometry));

var MeshPhongMaterial = (function (_super) {
    __extends(MeshPhongMaterial, _super);
    function MeshPhongMaterial(parameters) {
        _super.call(this);
        this.isMeshPhongMaterial = true;
        this.type = 'MeshPhongMaterial';
        this.color = new Color(0xffffff); // diffuse
        this.specular = new Color(0x111111);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = BlendingOperation.Multiply;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshPhongMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    Object.defineProperty(MeshPhongMaterial.prototype, "metal", {
        get: function () {
            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
            return false;
        },
        set: function (value) {
            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
        },
        enumerable: true,
        configurable: true
    });
    return MeshPhongMaterial;
}(Material));

var MeshStandardMaterial = (function (_super) {
    __extends(MeshStandardMaterial, _super);
    function MeshStandardMaterial(parameters) {
        _super.call(this);
        this.isMeshStandardMaterial = true;
        this.defines = { 'STANDARD': '' };
        this.type = 'MeshStandardMaterial';
        this.color = new Color(0xffffff); // diffuse
        this.roughness = 0.5;
        this.metalness = 0.5;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1.0;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshStandardMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.defines = { 'STANDARD': '' };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    return MeshStandardMaterial;
}(Material));

var MeshLambertMaterial = (function (_super) {
    __extends(MeshLambertMaterial, _super);
    function MeshLambertMaterial(parameters) {
        _super.call(this);
        this.isMeshLambertMaterial = true;
        this.type = 'MeshLambertMaterial';
        this.color = new Color(0xffffff); // diffuse
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = BlendingOperation.Multiply;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshLambertMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    return MeshLambertMaterial;
}(Material));

var MeshPhysicalMaterial = (function (_super) {
    __extends(MeshPhysicalMaterial, _super);
    function MeshPhysicalMaterial(parameters) {
        _super.call(this, parameters);
        this.isMeshPhysicalMaterial = true;
        this.defines = { 'PHYSICAL': '' };
        this.type = 'MeshPhysicalMaterial';
        this.reflectivity = 0.5; // maps to F0 = 0.04
        this.clearCoat = 0.0;
        this.clearCoatRoughness = 0.0;
        this.setValues(parameters);
    }
    MeshPhysicalMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.defines = { 'PHYSICAL': '' };
        this.reflectivity = source.reflectivity;
        this.clearCoat = source.clearCoat;
        this.clearCoatRoughness = source.clearCoatRoughness;
        return this;
    };
    
    return MeshPhysicalMaterial;
}(MeshStandardMaterial));

var MeshNormalMaterial = (function (_super) {
    __extends(MeshNormalMaterial, _super);
    function MeshNormalMaterial(parameters) {
        _super.call(this);
        this.isMeshNormalMaterial = true;
        this.type = 'MeshNormalMaterial';
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.morphTargets = false;
        this.setValues(parameters);
    }
    MeshNormalMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    };
    
    return MeshNormalMaterial;
}(Material));

var RawShaderMaterial = (function (_super) {
    __extends(RawShaderMaterial, _super);
    function RawShaderMaterial(parameters) {
        _super.call(this, parameters);
        this.isRawShaderMaterial = true;
        this.type = 'RawShaderMaterial';
    }
    return RawShaderMaterial;
}(ShaderMaterial));

var LineDashedMaterial = (function (_super) {
    __extends(LineDashedMaterial, _super);
    function LineDashedMaterial(parameters) {
        _super.call(this);
        this.isLineDashedMaterial = true;
        this.type = 'LineDashedMaterial';
        this.color = new Color(0xffffff);
        this.linewidth = 1;
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.lights = false;
        this.setValues(parameters);
    }
    LineDashedMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
    };
    
    return LineDashedMaterial;
}(Material));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var WebGLIndexedBufferRenderer = (function () {
    function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
        this.gl = gl;
        this.extensions = extensions;
        this.infoRender = infoRender;
    }
    WebGLIndexedBufferRenderer.prototype.setMode = function (value) {
        this.mode = value;
    };
    WebGLIndexedBufferRenderer.prototype.setIndex = function (index) {
        if (index.array instanceof Uint32Array && this.extensions.get('OES_element_index_uint')) {
            this.type = this.gl.UNSIGNED_INT;
            this.size = 4;
        }
        else {
            this.type = this.gl.UNSIGNED_SHORT;
            this.size = 2;
        }
    };
    WebGLIndexedBufferRenderer.prototype.render = function (start, count) {
        this.gl.drawElements(this.mode, count, this.type, start * this.size);
        this.infoRender.calls++;
        this.infoRender.vertices += count;
        if (this.mode === this.gl.TRIANGLES)
            this.infoRender.faces += count / 3;
    };
    WebGLIndexedBufferRenderer.prototype.renderInstances = function (geometry, start, count) {
        var extension = this.extensions.get('ANGLE_instanced_arrays');
        if (extension === null) {
            console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
            return;
        }
        extension.drawElementsInstancedANGLE(this.mode, count, this.type, start * this.size, geometry.maxInstancedCount);
        this.infoRender.calls++;
        this.infoRender.vertices += count * geometry.maxInstancedCount;
        if (this.mode === this.gl.TRIANGLES)
            this.infoRender.faces += geometry.maxInstancedCount * count / 3;
    };
    return WebGLIndexedBufferRenderer;
}());

var WebGLBufferRenderer = (function () {
    function WebGLBufferRenderer(gl, extensions, infoRender) {
        this.gl = gl;
        this.extensions = extensions;
        this.infoRender = infoRender;
    }
    WebGLBufferRenderer.prototype.setMode = function (value) {
        this.mode = value;
    };
    WebGLBufferRenderer.prototype.render = function (start, count) {
        var gl = this.gl;
        gl.drawArrays(this.mode, start, count);
        this.infoRender.calls++;
        this.infoRender.vertices += count;
        if (this.mode === gl.TRIANGLES)
            this.infoRender.faces += count / 3;
    };
    WebGLBufferRenderer.prototype.renderInstances = function (geometry) {
        var gl = this.gl;
        var extension = this.extensions.get('ANGLE_instanced_arrays');
        if (extension === null) {
            console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
            return;
        }
        var position = geometry.attributes.position;
        var count = 0;
        if ((position && position instanceof InterleavedBufferAttribute)) {
            count = position.data.count;
            extension.drawArraysInstancedANGLE(this.mode, 0, count, geometry.maxInstancedCount);
        }
        else {
            count = position.count;
            extension.drawArraysInstancedANGLE(this.mode, 0, count, geometry.maxInstancedCount);
        }
        this.infoRender.calls++;
        this.infoRender.vertices += count * geometry.maxInstancedCount;
        if (this.mode === gl.TRIANGLES)
            this.infoRender.faces += geometry.maxInstancedCount * count / 3;
    };
    return WebGLBufferRenderer;
}());

var WebGLLights = (function () {
    function WebGLLights() {
        this.lights = {};
    }
    WebGLLights.prototype.get = function (light) {
        if (this.lights[light.id] !== undefined) {
            return this.lights[light.id];
        }
        var uniforms;
        switch (light.type) {
            case 'DirectionalLight':
                uniforms = {
                    direction: new Vector3(),
                    color: new Color(),
                    shadow: false,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2()
                };
                break;
            case 'SpotLight':
                uniforms = {
                    position: new Vector3(),
                    direction: new Vector3(),
                    color: new Color(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                    shadow: false,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2()
                };
                break;
            case 'PointLight':
                uniforms = {
                    position: new Vector3(),
                    color: new Color(),
                    distance: 0,
                    decay: 0,
                    shadow: false,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2()
                };
                break;
            case 'HemisphereLight':
                uniforms = {
                    direction: new Vector3(),
                    skyColor: new Color(),
                    groundColor: new Color()
                };
                break;
        }
        this.lights[light.id] = uniforms;
        return uniforms;
    };
    return WebGLLights;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
function addLineNumbers(code) {
    var lines = code.split('\n');
    for (var i = 0; i < lines.length; i++) {
        lines[i] = (i + 1) + ': ' + lines[i];
    }
    return lines.join('\n');
}
function WebGLShader(gl, type, code) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, code);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
        console.error('THREE.WebGLShader: Shader couldn\'t compile.');
    }
    if (gl.getShaderInfoLog(shader) !== '') {
        console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(code));
    }
    // --enable-privileged-webgl-extension
    // console.log(type, gl.getExtension('WEBGL_debug_shaders').getTranslatedShaderSource(shader));
    return shader;
}

var programIdCount = 0;
function getEncodingComponents(encoding) {
    switch (encoding) {
        case TextureEncoding.Linear:
            return ['Linear', '(value)'];
        case TextureEncoding.sRGB:
            return ['sRGB', '(value)'];
        case TextureEncoding.RGBE:
            return ['RGBE', '(value)'];
        case TextureEncoding.RGBM7:
            return ['RGBM', '(value, 7.0)'];
        case TextureEncoding.RGBM16:
            return ['RGBM', '(value, 16.0)'];
        case TextureEncoding.RGBD:
            return ['RGBD', '(value, 256.0)'];
        case TextureEncoding.Gamma:
            return ['Gamma', '(value, float(GAMMA_FACTOR))'];
        default:
            throw new Error('unsupported encoding: ' + encoding);
    }
}
function getTexelDecodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "(vec4 value) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "(vec4 value) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
    var toneMappingName;
    switch (toneMapping) {
        case ToneMapping.Linear:
            toneMappingName = "Linear";
            break;
        case ToneMapping.Reinhard:
            toneMappingName = "Reinhard";
            break;
        case ToneMapping.Uncharted2:
            toneMappingName = "Uncharted2";
            break;
        case ToneMapping.Cineon:
            toneMappingName = "OptimizedCineon";
            break;
        default:
            throw new Error('unsupported toneMapping: ' + toneMapping);
    }
    return "vec3 " + functionName + "(vec3 color) { return " + toneMappingName + "ToneMapping(color); }";
}
function generateExtensions(extensions, parameters, rendererExtensions) {
    extensions = extensions || {};
    var chunks = [
        (extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '',
        (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',
        (extensions.drawBuffers) && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',
        (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : '',
    ];
    return chunks.filter(filterEmptyLine).join('\n');
}
function generateDefines(defines) {
    var chunks = [];
    for (var name in defines) {
        var value = defines[name];
        if (value === false)
            continue;
        chunks.push('#define ' + name + ' ' + value);
    }
    return chunks.join('\n');
}
function fetchAttributeLocations(gl, program, identifiers) {
    var attributes = {};
    var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < n; i++) {
        var info = gl.getActiveAttrib(program, i);
        var name = info.name;
        // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i);
        attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
}
function filterEmptyLine(code) {
    return code !== '';
}
function replaceLightNums(code, parameters) {
    return code
        .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
        .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
}
function parseIncludes(code) {
    var pattern = /#include +<([\w\d.]+)>/g;
    function replace(match, include) {
        var replace = ShaderChunk[include];
        if (replace === undefined) {
            throw new Error('Can not resolve #include <' + include + '>');
        }
        return parseIncludes(replace);
    }
    return code.replace(pattern, replace);
}
function unrollLoops(code) {
    var pattern = /for \(int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    function replace(match, start, end, snippet) {
        var unroll = '';
        for (var i = parseInt(start); i < parseInt(end); i++) {
            unroll += snippet.replace(/\[i \]/g, '[' + i + ']');
        }
        return unroll;
    }
    return code.replace(pattern, replace);
}
var WebGLProgram = (function () {
    function WebGLProgram(renderer, code, material, parameters) {
        this.renderer = renderer;
        var gl = this.gl = renderer.context;
        var extensions = material.extensions;
        var defines = material.defines;
        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
        if (parameters.shadowMapType === ShadowMap.PCF) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        }
        else if (parameters.shadowMapType === ShadowMap.PCFSoft) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        }
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        if (parameters.envMap) {
            switch (material.envMap.mapping) {
                case TextureMapping.CubeReflection:
                case TextureMapping.CubeRefraction:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;
                case TextureMapping.CubeUVReflection:
                case TextureMapping.CubeUVRefraction:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                    break;
                case TextureMapping.EquirectangularReflection:
                case TextureMapping.EquirectangularRefraction:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;
                case TextureMapping.SphericalReflection:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;
            }
            switch (material.envMap.mapping) {
                case TextureMapping.CubeRefraction:
                case TextureMapping.EquirectangularRefraction:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;
            }
            switch (material.combine) {
                case BlendingOperation.Multiply:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;
                case BlendingOperation.Mix:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;
                case BlendingOperation.Add:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;
            }
        }
        var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
        // console.log('building new program ');
        //
        var customExtensions = generateExtensions(extensions, parameters, renderer.extensions);
        var customDefines = generateDefines(defines);
        //
        var program = gl.createProgram();
        var prefixVertex, prefixFragment;
        if (material instanceof RawShaderMaterial) {
            prefixVertex = [
                customDefines,
                '\n'
            ].filter(filterEmptyLine).join('\n');
            prefixFragment = [
                customExtensions,
                customDefines,
                '\n'
            ].filter(filterEmptyLine).join('\n');
        }
        else {
            prefixVertex = [
                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',
                '#define SHADER_NAME ' + material.__webglShader.name,
                customDefines,
                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,
                '#define MAX_BONES ' + parameters.maxBones,
                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',
                parameters.flatShading ? '#define FLAT_SHADED' : '',
                parameters.skinning ? '#define USE_SKINNING' : '',
                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',
                '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',
                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',
                '#ifdef USE_COLOR',
                '  attribute vec3 color;',
                '#endif',
                '#ifdef USE_MORPHTARGETS',
                '  attribute vec3 morphTarget0;',
                '  attribute vec3 morphTarget1;',
                '  attribute vec3 morphTarget2;',
                '  attribute vec3 morphTarget3;',
                '  #ifdef USE_MORPHNORMALS',
                '    attribute vec3 morphNormal0;',
                '    attribute vec3 morphNormal1;',
                '    attribute vec3 morphNormal2;',
                '    attribute vec3 morphNormal3;',
                '  #else',
                '    attribute vec3 morphTarget4;',
                '    attribute vec3 morphTarget5;',
                '    attribute vec3 morphTarget6;',
                '    attribute vec3 morphTarget7;',
                '  #endif',
                '#endif',
                '#ifdef USE_SKINNING',
                '  attribute vec4 skinIndex;',
                '  attribute vec4 skinWeight;',
                '#endif',
                '\n'
            ].filter(filterEmptyLine).join('\n');
            prefixFragment = [
                customExtensions,
                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',
                '#define SHADER_NAME ' + material.__webglShader.name,
                customDefines,
                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,
                (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
                (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',
                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapTypeDefine : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',
                parameters.flatShading ? '#define FLAT_SHADED' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',
                '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
                '#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),
                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',
                parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',
                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
                parameters.envMap && renderer.extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '',
                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',
                (parameters.toneMapping !== ToneMapping.None) ? "#define TONE_MAPPING" : '',
                (parameters.toneMapping !== ToneMapping.None) ? ShaderChunk['tonemapping_pars_fragment'] : '',
                (parameters.toneMapping !== ToneMapping.None) ? getToneMappingFunction("toneMapping", parameters.toneMapping) : '',
                (parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding) ? ShaderChunk['encodings_pars_fragment'] : '',
                parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
                parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
                parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
                parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : '',
                parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',
                '\n'
            ].filter(filterEmptyLine).join('\n');
        }
        vertexShader = parseIncludes(vertexShader /*, parameters*/);
        vertexShader = replaceLightNums(vertexShader, parameters);
        fragmentShader = parseIncludes(fragmentShader /*, parameters*/);
        fragmentShader = replaceLightNums(fragmentShader, parameters);
        if (!(material instanceof ShaderMaterial)) {
            vertexShader = unrollLoops(vertexShader);
            fragmentShader = unrollLoops(fragmentShader);
        }
        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;
        // console.log('*VERTEX*', vertexGlsl);
        // console.log('*FRAGMENT*', fragmentGlsl);
        var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
        var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);
        // Force a particular attribute to index 0.
        if (material.index0AttributeName !== undefined) {
            gl.bindAttribLocation(program, 0, material.index0AttributeName);
        }
        else if (parameters.morphTargets === true) {
            // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation(program, 0, 'position');
        }
        gl.linkProgram(program);
        var programLog = gl.getProgramInfoLog(program);
        var vertexLog = gl.getShaderInfoLog(glVertexShader);
        var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
        var runnable = true;
        var haveDiagnostics = true;
        // console.log('**VERTEX**', gl.getExtension('WEBGL_debug_shaders').getTranslatedShaderSource(glVertexShader));
        // console.log('**FRAGMENT**', gl.getExtension('WEBGL_debug_shaders').getTranslatedShaderSource(glFragmentShader));
        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
            runnable = false;
            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
        }
        else if (programLog !== '') {
            console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        }
        else if (vertexLog === '' || fragmentLog === '') {
            haveDiagnostics = false;
        }
        if (haveDiagnostics) {
            this.diagnostics = {
                runnable: runnable,
                material: material,
                programLog: programLog,
                vertexShader: {
                    log: vertexLog,
                    prefix: prefixVertex
                },
                fragmentShader: {
                    log: fragmentLog,
                    prefix: prefixFragment
                }
            };
        }
        // clean up
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);
        //
        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
    }
    // set up caching for uniform locations
    WebGLProgram.prototype.getUniforms = function () {
        var gl = this.gl;
        if (this.cachedUniforms === undefined) {
            this.cachedUniforms = new WebGLUniforms(gl, this.program, this.renderer);
        }
        return this.cachedUniforms;
    };
    // set up caching for attribute locations
    WebGLProgram.prototype.getAttributes = function () {
        var gl = this.gl;
        if (this.cachedAttributes === undefined) {
            this.cachedAttributes = fetchAttributeLocations(gl, this.program);
        }
        return this.cachedAttributes;
    };
    // free resource
    WebGLProgram.prototype.destroy = function () {
        var gl = this.gl;
        gl.deleteProgram(this.program);
        this.program = undefined;
    };
    Object.defineProperty(WebGLProgram.prototype, "uniforms", {
        // DEPRECATED
        get: function () {
            console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
            return this.getUniforms();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLProgram.prototype, "attributes", {
        get: function () {
            console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
            return this.getAttributes();
        },
        enumerable: true,
        configurable: true
    });
    return WebGLProgram;
}());

var WebGLPrograms = (function () {
    function WebGLPrograms(renderer, capabilities) {
        this.renderer = renderer;
        this.capabilities = capabilities;
        var programs = [];
        // Exposed for resource monitoring & error feedback via renderer.info:
        this.programs = programs;
    }
    WebGLPrograms.prototype.getParameters = function (material, lights, fog, nClipPlanes, nClipIntersection, object) {
        var capabilities = this.capabilities;
        function allocateBones(object) {
            if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
                return 1024;
            }
            else {
                // default for when object is not specified
                // (for example when prebuilding shader to be used with multiple objects)
                //
                //  - leave some extra space for other uniforms
                //  - limit here is ANGLE's 254 max uniform vectors
                //    (up to 54 should be safe)
                var nVertexUniforms = capabilities.maxVertexUniforms;
                var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                var maxBones_1 = nVertexMatrices;
                if (object !== undefined && (object && object instanceof SkinnedMesh)) {
                    maxBones_1 = Math.min(object.skeleton.bones.length, maxBones_1);
                    if (maxBones_1 < object.skeleton.bones.length) {
                        console.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones_1 + ' (try OpenGL instead of ANGLE)');
                    }
                }
                return maxBones_1;
            }
        }
        function getTextureEncodingFromMap(map, gammaOverrideLinear) {
            var encoding;
            if (!map) {
                encoding = TextureEncoding.Linear;
            }
            else if ((map && map instanceof Texture)) {
                encoding = map.encoding;
            }
            else if ((map && map instanceof WebGLRenderTarget)) {
                console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                encoding = map.texture.encoding;
            }
            // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
            if (encoding === TextureEncoding.Linear && gammaOverrideLinear) {
                encoding = TextureEncoding.Gamma;
            }
            return encoding;
        }
        var shaderIDs = {
            MeshDepthMaterial: 'depth',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points'
        };
        var shaderID = shaderIDs[material.type];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)
        var maxBones = allocateBones(object);
        var precision = this.renderer.getPrecision();
        if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) {
                console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
            }
        }
        var currentRenderTarget = this.renderer.getCurrentRenderTarget();
        var parameters = {
            shaderID: shaderID,
            precision: precision,
            supportsVertexTextures: capabilities.vertexTextures,
            outputEncoding: getTextureEncodingFromMap((!currentRenderTarget) ? null : currentRenderTarget.texture, this.renderer.gammaOutput),
            map: !!material.map,
            mapEncoding: getTextureEncodingFromMap(material.map, this.renderer.gammaInput),
            envMap: !!material.envMap,
            envMapMode: material.envMap && material.envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(material.envMap, this.renderer.gammaInput),
            envMapCubeUV: (!!material.envMap) && ((material.envMap.mapping === TextureMapping.CubeUVReflection) || (material.envMap.mapping === TextureMapping.CubeUVRefraction)),
            lightMap: !!material.lightMap,
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, this.renderer.gammaInput),
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,
            combine: material.combine,
            vertexColors: material.vertexColors,
            fog: !!fog,
            useFog: material.fog,
            fogExp: (fog && fog instanceof FogExp2),
            flatShading: material.shading === ShadingMode.Flat,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
            skinning: material.skinning,
            maxBones: maxBones,
            useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: this.renderer.maxMorphTargets,
            maxMorphNormals: this.renderer.maxMorphNormals,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numHemiLights: lights.hemi.length,
            numClippingPlanes: nClipPlanes,
            numClipIntersection: nClipIntersection,
            shadowMapEnabled: this.renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
            shadowMapType: this.renderer.shadowMap.type,
            toneMapping: this.renderer.toneMapping,
            physicallyCorrectLights: this.renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            alphaTest: material.alphaTest,
            doubleSided: material.side === SideMode.Double,
            flipSided: material.side === SideMode.Back,
            depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false
        };
        return parameters;
    };
    WebGLPrograms.prototype.getProgramCode = function (material /*Material*/, parameters) {
        var parameterNames = [
            "precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
            "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
            "roughnessMap", "metalnessMap",
            "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
            "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
            "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
            "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
            "numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
            "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
            "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking"
        ];
        var array = [];
        if (parameters.shaderID) {
            array.push(parameters.shaderID);
        }
        else {
            array.push(material.fragmentShader);
            array.push(material.vertexShader);
        }
        if (material.defines !== undefined) {
            for (var name in material.defines) {
                array.push(name);
                array.push(material.defines[name]);
            }
        }
        for (var i = 0; i < parameterNames.length; i++) {
            array.push(parameters[parameterNames[i]]);
        }
        return array.join();
    };
    WebGLPrograms.prototype.acquireProgram = function (material /*Material*/, parameters, code) {
        var program;
        // Check if code has been already compiled
        for (var p = 0, pl = this.programs.length; p < pl; p++) {
            var programInfo = this.programs[p];
            if (programInfo.code === code) {
                program = programInfo;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new WebGLProgram(this.renderer, code, material, parameters);
            this.programs.push(program);
        }
        return program;
    };
    WebGLPrograms.prototype.releaseProgram = function (program) {
        if (--program.usedTimes === 0) {
            // Remove from unordered set
            var i = this.programs.indexOf(program);
            this.programs[i] = this.programs[this.programs.length - 1];
            this.programs.pop();
            // Free WebGL resources
            program.destroy();
        }
    };
    return WebGLPrograms;
}());

var WebGLGeometries = (function () {
    function WebGLGeometries(gl, properties, info) {
        this.geometries = {};
        this.gl = gl;
        this.properties = properties;
        this.info = info;
    }
    WebGLGeometries.prototype.get = function (object) {
        var gl = this.gl;
        var properties = this.properties;
        var info = this.info;
        var geometries = this.geometries;
        var geometry = object.geometry;
        if (geometries[geometry.id] !== undefined) {
            return geometries[geometry.id];
        }
        geometry.addEventListener('dispose', onGeometryDispose);
        function onGeometryDispose(event) {
            var geometry = event.target;
            var buffergeometry = geometries[geometry.id];
            if (buffergeometry.index !== null) {
                deleteAttribute(buffergeometry.index);
            }
            deleteAttributes(buffergeometry.attributes);
            geometry.removeEventListener('dispose', onGeometryDispose);
            delete geometries[geometry.id];
            // TODO
            var property = properties.get(geometry);
            if (property.wireframe) {
                deleteAttribute(property.wireframe);
            }
            properties.delete(geometry);
            var bufferproperty = properties.get(buffergeometry);
            if (bufferproperty.wireframe) {
                deleteAttribute(bufferproperty.wireframe);
            }
            properties.delete(buffergeometry);
            //
            info.memory.geometries--;
        }
        function getAttributeBuffer(attribute) {
            if (attribute instanceof InterleavedBufferAttribute) {
                return properties.get(attribute.data).__webglBuffer;
            }
            return properties.get(attribute).__webglBuffer;
        }
        function deleteAttribute(attribute) {
            var buffer = getAttributeBuffer(attribute);
            if (buffer !== undefined) {
                gl.deleteBuffer(buffer);
                removeAttributeBuffer(attribute);
            }
        }
        function deleteAttributes(attributes) {
            for (var name in attributes) {
                var attribute = attributes[name];
                if (attribute === undefined)
                    continue;
                deleteAttribute(attribute);
            }
        }
        function removeAttributeBuffer(attribute) {
            if (attribute instanceof InterleavedBufferAttribute) {
                properties.delete(attribute.data);
            }
            else {
                properties.delete(attribute);
            }
        }
        var buffergeometry;
        if (geometry instanceof BufferGeometry) {
            buffergeometry = geometry;
        }
        else if (geometry instanceof Geometry) {
            if (geometry._bufferGeometry === undefined) {
                geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
            }
            buffergeometry = geometry._bufferGeometry;
        }
        geometries[geometry.id] = buffergeometry;
        info.memory.geometries++;
        return buffergeometry;
    };
    return WebGLGeometries;
}());

var WebGLObjects = (function () {
    function WebGLObjects(gl, properties, info) {
        this.gl = gl;
        this.properties = properties;
        this.info = info;
        this.geometries = new WebGLGeometries(gl, properties, info);
    }
    //
    WebGLObjects.prototype.update = function (object) {
        var gl = this.gl;
        // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
        var geometry = this.geometries.get(object);
        if (object.geometry instanceof Geometry) {
            geometry.updateFromObject(object);
        }
        var index = geometry.index;
        var attributes = geometry.attributes;
        if (index !== null) {
            this.updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
        }
        for (var name in attributes) {
            var attribute = attributes[name];
            if (attribute === undefined)
                continue;
            this.updateAttribute(attribute, gl.ARRAY_BUFFER);
        }
        // morph targets
        var morphAttributes = geometry.morphAttributes;
        for (var name in morphAttributes) {
            var array = morphAttributes[name];
            for (var i = 0, l = array.length; i < l; i++) {
                this.updateAttribute(array[i], gl.ARRAY_BUFFER);
            }
        }
        return geometry;
    };
    WebGLObjects.prototype.updateAttribute = function (attribute, bufferType) {
        if (!attribute)
            return;
        var data = (attribute instanceof InterleavedBufferAttribute) ? attribute.data : attribute;
        var attributeProperties = this.properties.get(data);
        if (attributeProperties.__webglBuffer === undefined) {
            this.createBuffer(attributeProperties, data, bufferType);
        }
        else if (attributeProperties.version !== data.version) {
            this.updateBuffer(attributeProperties, data, bufferType);
        }
    };
    WebGLObjects.prototype.createBuffer = function (attributeProperties, data, bufferType) {
        var gl = this.gl;
        attributeProperties.__webglBuffer = gl.createBuffer();
        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
        var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        gl.bufferData(bufferType, data.array, usage);
        attributeProperties.version = data.version;
    };
    WebGLObjects.prototype.updateBuffer = function (attributeProperties, data, bufferType) {
        var gl = this.gl;
        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
        if (data.dynamic === false) {
            gl.bufferData(bufferType, data.array, gl.STATIC_DRAW);
        }
        else if (data.updateRange.count === -1) {
            // Not using update ranges
            gl.bufferSubData(bufferType, 0, data.array);
        }
        else if (data.updateRange.count === 0) {
            console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
        }
        else {
            gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));
            data.updateRange.count = 0; // reset range
        }
        attributeProperties.version = data.version;
    };
    WebGLObjects.prototype.getAttributeBuffer = function (attribute) {
        if (attribute instanceof InterleavedBufferAttribute) {
            return this.properties.get(attribute.data).__webglBuffer;
        }
        return this.properties.get(attribute).__webglBuffer;
    };
    WebGLObjects.prototype.getWireframeAttribute = function (geometry) {
        var gl = this.gl;
        var property = this.properties.get(geometry);
        if (property.wireframe !== undefined) {
            return property.wireframe;
        }
        var indices = [];
        var index = geometry.index;
        var attributes = geometry.attributes;
        var position = attributes.position;
        // console.time('wireframe');
        if (index !== null) {
            //const edges = {};
            var array = index.array;
            for (var i = 0, l = array.length; i < l; i += 3) {
                var a = array[i + 0];
                var b = array[i + 1];
                var c = array[i + 2];
                indices.push(a, b, b, c, c, a);
            }
        }
        else {
            var array = attributes.position.array;
            for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {
                var a = i + 0;
                var b = i + 1;
                var c = i + 2;
                indices.push(a, b, b, c, c, a);
            }
        }
        // console.timeEnd('wireframe');
        var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
        var attribute = new BufferAttribute(new TypeArray(indices), 1);
        this.updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
        property.wireframe = attribute;
        return attribute;
    };
    return WebGLObjects;
}());

/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */
var DepthTexture = (function (_super) {
    __extends(DepthTexture, _super);
    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        if (type === void 0) { type = TextureType.UnsignedShort; }
        if (magFilter === void 0) { magFilter = TextureFilter.Nearest; }
        if (minFilter === void 0) { minFilter = TextureFilter.Nearest; }
        if (format === void 0) { format = TextureFormat.Depth; }
        _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.isDepthTexture = true;
        if (format !== TextureFormat.Depth && format !== TextureFormat.DepthStencil) {
            throw new Error('DepthTexture format must be either THREE.TextureFormat.Depth or THREE.TextureFormat.DepthStencil');
        }
        this.image = { width: width, height: height };
        this.type = type;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.flipY = false;
        this.generateMipmaps = false;
    }
    return DepthTexture;
}(Texture));

/**
 * @author alteredq / http://alteredqualia.com/
 */
var CompressedTexture = (function (_super) {
    __extends(CompressedTexture, _super);
    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.isCompressedTexture = true;
        this.image = { width: width, height: height };
        this.mipmaps = mipmaps;
        // no flipping for cube textures
        // (also flipping doesn't work for compressed textures)
        this.flipY = false;
        // can't generate mipmaps for compressed textures
        // mips must be embedded in DDS files
        this.generateMipmaps = false;
    }
    return CompressedTexture;
}(Texture));

var WebGLTextures = (function () {
    function WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, info) {
        this._gl = _gl;
        this.extensions = extensions;
        this.state = state;
        this.properties = properties;
        this.capabilities = capabilities;
        this.paramThreeToGL = paramThreeToGL;
        this.info = info;
        this._infoMemory = info.memory;
        this._isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext);
    }
    //
    WebGLTextures.clampToMaxSize = function (image, maxSize) {
        if (image.width > maxSize || image.height > maxSize) {
            // Warning: Scaling through the canvas will only work with images that use
            // premultiplied alpha.
            var scale = maxSize / Math.max(image.width, image.height);
            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            canvas.width = Math.floor(image.width * scale);
            canvas.height = Math.floor(image.height * scale);
            var context = canvas.getContext('2d');
            context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
            console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
            return canvas;
        }
        return image;
    };
    WebGLTextures.isPowerOfTwo = function (image) {
        return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
    };
    WebGLTextures.makePowerOfTwo = function (image) {
        if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            canvas.width = _Math.nearestPowerOfTwo(image.width);
            canvas.height = _Math.nearestPowerOfTwo(image.height);
            var context = canvas.getContext('2d');
            context.drawImage(image, 0, 0, canvas.width, canvas.height);
            console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
            return canvas;
        }
        return image;
    };
    WebGLTextures.textureNeedsPowerOfTwo = function (texture) {
        if (texture.wrapS !== TextureWrapping.ClampToEdge || texture.wrapT !== TextureWrapping.ClampToEdge)
            return true;
        if (texture.minFilter !== TextureFilter.Nearest && texture.minFilter !== TextureFilter.Linear)
            return true;
        return false;
    };
    // Fallback filters for non-power-of-2 textures
    WebGLTextures.prototype.filterFallback = function (f) {
        var _gl = this._gl;
        if (f === TextureFilter.Nearest || f === TextureFilter.NearestMipMapNearest || f === TextureFilter.NearestMipMapLinear) {
            return _gl.NEAREST;
        }
        return _gl.LINEAR;
    };
    //
    WebGLTextures.prototype.onTextureDispose = function (event) {
        var texture = event.target;
        texture.removeEventListener('dispose', this.onTextureDispose.bind(this));
        this.deallocateTexture(texture);
        this._infoMemory.textures--;
    };
    WebGLTextures.prototype.onRenderTargetDispose = function (event) {
        var renderTarget = event.target;
        renderTarget.removeEventListener('dispose', this.onRenderTargetDispose.bind(this));
        this.deallocateRenderTarget(renderTarget);
        this._infoMemory.textures--;
    };
    //
    WebGLTextures.prototype.deallocateTexture = function (texture) {
        var _gl = this._gl;
        var textureProperties = this.properties.get(texture);
        if (texture.image && textureProperties.__image__webglTextureCube) {
            // cube texture
            _gl.deleteTexture(textureProperties.__image__webglTextureCube);
        }
        else {
            // 2D texture
            if (textureProperties.__webglInit === undefined)
                return;
            _gl.deleteTexture(textureProperties.__webglTexture);
        }
        // remove all webgl this.properties
        this.properties.delete(texture);
    };
    WebGLTextures.prototype.deallocateRenderTarget = function (renderTarget) {
        var _gl = this._gl;
        var renderTargetProperties = this.properties.get(renderTarget);
        var textureProperties = this.properties.get(renderTarget.texture);
        if (!renderTarget)
            return;
        if (textureProperties.__webglTexture !== undefined) {
            _gl.deleteTexture(textureProperties.__webglTexture);
        }
        if (renderTarget.depthTexture) {
            renderTarget.depthTexture.dispose();
        }
        if ((renderTarget && renderTarget instanceof WebGLRenderTargetCube)) {
            for (var i = 0; i < 6; i++) {
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                if (renderTargetProperties.__webglDepthbuffer)
                    _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
            }
        }
        else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer)
                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        }
        this.properties.delete(renderTarget.texture);
        this.properties.delete(renderTarget);
    };
    //
    WebGLTextures.prototype.setTexture2D = function (texture, slot) {
        var _gl = this._gl;
        var textureProperties = this.properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            var image = texture.image;
            if (image === undefined) {
                console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
            }
            else if (image.complete === false) {
                console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
            }
            else {
                this.uploadTexture(textureProperties, texture, slot);
                return;
            }
        }
        this.state.activeTexture(_gl.TEXTURE0 + slot);
        this.state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
    };
    WebGLTextures.prototype.setTextureCube = function (texture, slot) {
        var _gl = this._gl;
        var textureProperties = this.properties.get(texture);
        if (texture.image.length === 6) {
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                if (!textureProperties.__image__webglTextureCube) {
                    texture.addEventListener('dispose', this.onTextureDispose.bind(this));
                    textureProperties.__image__webglTextureCube = _gl.createTexture();
                    this._infoMemory.textures++;
                }
                this.state.activeTexture(_gl.TEXTURE0 + slot);
                this.state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                var isCompressed = (texture && texture instanceof CompressedTexture);
                var isDataTexture = (texture.image[0] && texture.image[0] instanceof DataTexture);
                var cubeImage = [];
                for (var i = 0; i < 6; i++) {
                    if (!isCompressed && !isDataTexture) {
                        cubeImage[i] = WebGLTextures.clampToMaxSize(texture.image[i], this.capabilities.maxCubemapSize);
                    }
                    else {
                        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                    }
                }
                var image = cubeImage[0], isPowerOfTwoImage = WebGLTextures.isPowerOfTwo(image), glFormat = this.paramThreeToGL(texture.format), glType = this.paramThreeToGL(texture.type);
                this.setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                for (var i = 0; i < 6; i++) {
                    if (!isCompressed) {
                        if (isDataTexture) {
                            this.state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                        }
                        else {
                            this.state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                        }
                    }
                    else {
                        var mipmap = void 0;
                        var mipmaps = cubeImage[i].mipmaps;
                        for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                            mipmap = mipmaps[j];
                            if (texture.format !== TextureFormat.RGBA && texture.format !== TextureFormat.RGB) {
                                if (this.state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                    this.state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                }
                                else {
                                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                                }
                            }
                            else {
                                this.state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                            }
                        }
                    }
                }
                if (texture.generateMipmaps && isPowerOfTwoImage) {
                    _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                }
                textureProperties.__version = texture.version;
                if (texture.onUpdate)
                    texture.onUpdate(texture);
            }
            else {
                this.state.activeTexture(_gl.TEXTURE0 + slot);
                this.state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
            }
        }
    };
    WebGLTextures.prototype.setTextureCubeDynamic = function (texture, slot) {
        var _gl = this._gl;
        this.state.activeTexture(_gl.TEXTURE0 + slot);
        this.state.bindTexture(_gl.TEXTURE_CUBE_MAP, this.properties.get(texture).__webglTexture);
    };
    WebGLTextures.prototype.setTextureParameters = function (textureType, texture, isPowerOfTwoImage) {
        var _gl = this._gl;
        var extension;
        if (isPowerOfTwoImage) {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, this.paramThreeToGL(texture.wrapS));
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, this.paramThreeToGL(texture.wrapT));
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, this.paramThreeToGL(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, this.paramThreeToGL(texture.minFilter));
        }
        else {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
            if (texture.wrapS !== TextureWrapping.ClampToEdge || texture.wrapT !== TextureWrapping.ClampToEdge) {
                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.TextureWrapping.ClampToEdge.', texture);
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, this.filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, this.filterFallback(texture.minFilter));
            if (texture.minFilter !== TextureFilter.Nearest && texture.minFilter !== TextureFilter.Linear) {
                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.TextureFilter.Nearest or THREE.TextureFilter.Linear.', texture);
            }
        }
        extension = this.extensions.get('EXT_texture_filter_anisotropic');
        if (extension) {
            if (texture.type === TextureType.Float && this.extensions.get('OES_texture_float_linear') === null)
                return;
            if (texture.type === TextureType.HalfFloat && this.extensions.get('OES_texture_half_float_linear') === null)
                return;
            if (texture.anisotropy > 1 || this.properties.get(texture).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, this.capabilities.getMaxAnisotropy()));
                this.properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
        }
    };
    WebGLTextures.prototype.uploadTexture = function (textureProperties, texture, slot) {
        var _gl = this._gl;
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture.addEventListener('dispose', this.onTextureDispose.bind(this));
            textureProperties.__webglTexture = _gl.createTexture();
            this._infoMemory.textures++;
        }
        this.state.activeTexture(_gl.TEXTURE0 + slot);
        this.state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        var image = WebGLTextures.clampToMaxSize(texture.image, this.capabilities.maxTextureSize);
        if (WebGLTextures.textureNeedsPowerOfTwo(texture) && WebGLTextures.isPowerOfTwo(image) === false) {
            image = WebGLTextures.makePowerOfTwo(image);
        }
        var isPowerOfTwoImage = WebGLTextures.isPowerOfTwo(image), glFormat = this.paramThreeToGL(texture.format), glType = this.paramThreeToGL(texture.type);
        this.setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
        var mipmap;
        var mipmaps = texture.mipmaps;
        if ((texture && texture instanceof DepthTexture)) {
            // populate depth texture with dummy data
            var internalFormat = _gl.DEPTH_COMPONENT;
            if (texture.type === TextureType.Float) {
                if (!this._isWebGL2)
                    throw new Error('Float Depth Texture only supported in WebGL2.0');
                internalFormat = _gl.DEPTH_COMPONENT32F;
            }
            else if (this._isWebGL2) {
                // WebGL 2.0 requires signed internalformat for glTexImage2D
                internalFormat = _gl.DEPTH_COMPONENT16;
            }
            // Depth stencil textures need the DEPTH_STENCIL internal format
            // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
            if (texture.format === TextureFormat.DepthStencil) {
                internalFormat = _gl.DEPTH_STENCIL;
            }
            this.state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
        }
        else if ((texture && texture instanceof DataTexture)) {
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    this.state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture.generateMipmaps = false;
            }
            else {
                this.state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
            }
        }
        else if ((texture && texture instanceof CompressedTexture)) {
            for (var i = 0, il = mipmaps.length; i < il; i++) {
                mipmap = mipmaps[i];
                if (texture.format !== TextureFormat.RGBA && texture.format !== TextureFormat.RGB) {
                    if (this.state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                        this.state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    }
                    else {
                        console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    }
                }
                else {
                    this.state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
            }
        }
        else {
            // regular Texture (image, video, canvas)
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    this.state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                }
                texture.generateMipmaps = false;
            }
            else {
                this.state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
            }
        }
        if (texture.generateMipmaps && isPowerOfTwoImage)
            _gl.generateMipmap(_gl.TEXTURE_2D);
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
            texture.onUpdate(texture);
    };
    // Render targets
    // Setup storage for target texture and bind it to correct framebuffer
    WebGLTextures.prototype.setupFrameBufferTexture = function (framebuffer, renderTarget, attachment, textureTarget) {
        var _gl = this._gl;
        var glFormat = this.paramThreeToGL(renderTarget.texture.format);
        var glType = this.paramThreeToGL(renderTarget.texture.type);
        this.state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, this.properties.get(renderTarget.texture).__webglTexture, 0);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    };
    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    WebGLTextures.prototype.setupRenderBufferStorage = function (renderbuffer, renderTarget) {
        var _gl = this._gl;
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        }
        else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        }
        else {
            // FIXME: We don't support !depth !stencil
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    };
    // Setup resources for a Depth Texture for a FBO (needs an extension)
    WebGLTextures.prototype.setupDepthTexture = function (framebuffer, renderTarget) {
        var _gl = this._gl;
        var isCube = ((renderTarget && renderTarget instanceof WebGLRenderTargetCube));
        if (isCube)
            throw new Error('Depth Texture with cube render targets is not supported!');
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        if (!((renderTarget.depthTexture && renderTarget.depthTexture instanceof DepthTexture))) {
            throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
        }
        // upload an empty depth texture with framebuffer size
        if (!this.properties.get(renderTarget.depthTexture).__webglTexture ||
            renderTarget.depthTexture.image.width !== renderTarget.width ||
            renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
        }
        this.setTexture2D(renderTarget.depthTexture, 0);
        var webglDepthTexture = this.properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === TextureFormat.Depth) {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        }
        else if (renderTarget.depthTexture.format === TextureFormat.DepthStencil) {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        }
        else {
            throw new Error('Unknown depthTexture format');
        }
    };
    // Setup GL resources for a non-texture depth buffer
    WebGLTextures.prototype.setupDepthRenderbuffer = function (renderTarget) {
        var _gl = this._gl;
        var renderTargetProperties = this.properties.get(renderTarget);
        var isCube = ((renderTarget && renderTarget instanceof WebGLRenderTargetCube));
        if (renderTarget.depthTexture) {
            if (isCube)
                throw new Error('target.depthTexture not supported in Cube render targets');
            this.setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        }
        else {
            if (isCube) {
                renderTargetProperties.__webglDepthbuffer = [];
                for (var i = 0; i < 6; i++) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                    renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                    this.setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                }
            }
            else {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                this.setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
            }
        }
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    };
    // Set up GL resources for the render target
    WebGLTextures.prototype.setupRenderTarget = function (renderTarget) {
        var _gl = this._gl;
        var renderTargetProperties = this.properties.get(renderTarget);
        var textureProperties = this.properties.get(renderTarget.texture);
        renderTarget.addEventListener('dispose', this.onRenderTargetDispose.bind(this));
        textureProperties.__webglTexture = _gl.createTexture();
        this._infoMemory.textures++;
        var isCube = ((renderTarget && renderTarget instanceof WebGLRenderTargetCube));
        var isTargetPowerOfTwo = WebGLTextures.isPowerOfTwo(renderTarget);
        // Setup framebuffer
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for (var i = 0; i < 6; i++) {
                renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
            }
        }
        else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        }
        // Setup color buffer
        if (isCube) {
            this.state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            this.setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
            for (var i = 0; i < 6; i++) {
                this.setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
            }
            if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
                _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            this.state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        }
        else {
            this.state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            this.setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
            this.setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
            if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
                _gl.generateMipmap(_gl.TEXTURE_2D);
            this.state.bindTexture(_gl.TEXTURE_2D, null);
        }
        // Setup depth and stencil buffers
        if (renderTarget.depthBuffer) {
            this.setupDepthRenderbuffer(renderTarget);
        }
    };
    WebGLTextures.prototype.updateRenderTargetMipmap = function (renderTarget) {
        var _gl = this._gl;
        var texture = renderTarget.texture;
        if (texture.generateMipmaps && WebGLTextures.isPowerOfTwo(renderTarget) &&
            texture.minFilter !== TextureFilter.Nearest &&
            texture.minFilter !== TextureFilter.Linear) {
            var target = (renderTarget && renderTarget instanceof WebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
            var webglTexture = this.properties.get(texture).__webglTexture;
            this.state.bindTexture(target, webglTexture);
            _gl.generateMipmap(target);
            this.state.bindTexture(target, null);
        }
    };
    return WebGLTextures;
}());

/**
 * @author fordacious / fordacious.github.io
 */
var WebGLProperties = (function () {
    function WebGLProperties() {
        this.properties = {};
    }
    WebGLProperties.prototype.get = function (object) {
        var uuid = object.uuid;
        var map = this.properties[uuid];
        if (map === undefined) {
            map = {};
            this.properties[uuid] = map;
        }
        return map;
    };
    WebGLProperties.prototype.delete = function (object) {
        delete this.properties[object.uuid];
    };
    WebGLProperties.prototype.clear = function () {
        this.properties = {};
    };
    return WebGLProperties;
}());

var ColorBuffer = (function () {
    function ColorBuffer(state) {
        this.locked = false;
        this.color = new Vector4();
        this.currentColorMask = null;
        this.currentColorClear = new Vector4();
        this.state = state;
    }
    ColorBuffer.prototype.setMask = function (colorMask) {
        if (this.currentColorMask !== colorMask && !this.locked) {
            this.state.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            this.currentColorMask = colorMask;
        }
    };
    ColorBuffer.prototype.setLocked = function (lock) {
        this.locked = lock;
    };
    ColorBuffer.prototype.setClear = function (r, g, b, a) {
        this.color.set(r, g, b, a);
        if (this.currentColorClear.equals(this.color) === false) {
            this.state.gl.clearColor(r, g, b, a);
            this.currentColorClear.copy(this.color);
        }
    };
    ColorBuffer.prototype.reset = function () {
        this.locked = false;
        this.currentColorMask = null;
        this.currentColorClear.set(0, 0, 0, 1);
    };
    return ColorBuffer;
}());
var DepthBuffer = (function () {
    function DepthBuffer(state) {
        this.locked = false;
        this.currentDepthMask = null;
        this.currentDepthFunc = null;
        this.currentDepthClear = null;
        this.state = state;
    }
    DepthBuffer.prototype.setTest = function (depthTest) {
        var gl = this.state.gl;
        if (depthTest) {
            this.state.enable(gl.DEPTH_TEST);
        }
        else {
            this.state.disable(gl.DEPTH_TEST);
        }
    };
    DepthBuffer.prototype.setMask = function (depthMask) {
        var gl = this.state.gl;
        if (this.currentDepthMask !== depthMask && !this.locked) {
            gl.depthMask(depthMask);
            this.currentDepthMask = depthMask;
        }
    };
    DepthBuffer.prototype.setFunc = function (depthFunc) {
        var gl = this.state.gl;
        if (this.currentDepthFunc !== depthFunc) {
            if (depthFunc) {
                switch (depthFunc) {
                    case DepthFunction.Never:
                        gl.depthFunc(gl.NEVER);
                        break;
                    case DepthFunction.Always:
                        gl.depthFunc(gl.ALWAYS);
                        break;
                    case DepthFunction.Less:
                        gl.depthFunc(gl.LESS);
                        break;
                    case DepthFunction.LessEqual:
                        gl.depthFunc(gl.LEQUAL);
                        break;
                    case DepthFunction.Equal:
                        gl.depthFunc(gl.EQUAL);
                        break;
                    case DepthFunction.GreaterEqual:
                        gl.depthFunc(gl.GEQUAL);
                        break;
                    case DepthFunction.Greater:
                        gl.depthFunc(gl.GREATER);
                        break;
                    case DepthFunction.NotEqual:
                        gl.depthFunc(gl.NOTEQUAL);
                        break;
                    default:
                        gl.depthFunc(gl.LEQUAL);
                }
            }
            else {
                gl.depthFunc(gl.LEQUAL);
            }
            this.currentDepthFunc = depthFunc;
        }
    };
    DepthBuffer.prototype.setLocked = function (lock) {
        this.locked = lock;
    };
    DepthBuffer.prototype.setClear = function (depth) {
        var gl = this.state.gl;
        if (this.currentDepthClear !== depth) {
            gl.clearDepth(depth);
            this.currentDepthClear = depth;
        }
    };
    DepthBuffer.prototype.reset = function () {
        this.locked = false;
        this.currentDepthMask = null;
        this.currentDepthFunc = null;
        this.currentDepthClear = null;
    };
    return DepthBuffer;
}());
var StencilBuffer = (function () {
    function StencilBuffer(state) {
        this.locked = false;
        this.currentStencilMask = null;
        this.currentStencilFunc = null;
        this.currentStencilRef = null;
        this.currentStencilFuncMask = null;
        this.currentStencilFail = null;
        this.currentStencilZFail = null;
        this.currentStencilZPass = null;
        this.currentStencilClear = null;
        this.state = state;
    }
    StencilBuffer.prototype.setTest = function (stencilTest) {
        var gl = this.state.gl;
        if (stencilTest) {
            this.state.enable(gl.STENCIL_TEST);
        }
        else {
            this.state.disable(gl.STENCIL_TEST);
        }
    };
    StencilBuffer.prototype.setMask = function (stencilMask) {
        var gl = this.state.gl;
        if (this.currentStencilMask !== stencilMask && !this.locked) {
            gl.stencilMask(stencilMask);
            this.currentStencilMask = stencilMask;
        }
    };
    StencilBuffer.prototype.setFunc = function (stencilFunc, stencilRef, stencilMask) {
        var gl = this.state.gl;
        if (this.currentStencilFunc !== stencilFunc ||
            this.currentStencilRef !== stencilRef ||
            this.currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            this.currentStencilFunc = stencilFunc;
            this.currentStencilRef = stencilRef;
            this.currentStencilFuncMask = stencilMask;
        }
    };
    StencilBuffer.prototype.setOp = function (stencilFail, stencilZFail, stencilZPass) {
        var gl = this.state.gl;
        if (this.currentStencilFail !== stencilFail ||
            this.currentStencilZFail !== stencilZFail ||
            this.currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            this.currentStencilFail = stencilFail;
            this.currentStencilZFail = stencilZFail;
            this.currentStencilZPass = stencilZPass;
        }
    };
    StencilBuffer.prototype.setLocked = function (lock) {
        this.locked = lock;
    };
    StencilBuffer.prototype.setClear = function (stencil) {
        var gl = this.state.gl;
        if (this.currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            this.currentStencilClear = stencil;
        }
    };
    StencilBuffer.prototype.reset = function () {
        this.locked = false;
        this.currentStencilMask = null;
        this.currentStencilFunc = null;
        this.currentStencilRef = null;
        this.currentStencilFuncMask = null;
        this.currentStencilFail = null;
        this.currentStencilZFail = null;
        this.currentStencilZPass = null;
        this.currentStencilClear = null;
    };
    return StencilBuffer;
}());
var WebGLState = (function () {
    function WebGLState(gl, extensions, paramThreeToGL) {
        this.capabilities = {};
        this.compressedTextureFormats = null;
        this.currentBlending = null;
        this.currentBlendEquation = null;
        this.currentBlendSrc = null;
        this.currentBlendDst = null;
        this.currentBlendEquationAlpha = null;
        this.currentBlendSrcAlpha = null;
        this.currentBlendDstAlpha = null;
        this.currentPremultipledAlpha = false;
        this.currentFlipSided = null;
        this.currentCullFace = null;
        this.currentLineWidth = null;
        this.currentPolygonOffsetFactor = null;
        this.currentPolygonOffsetUnits = null;
        this.currentScissorTest = null;
        this.currentTextureSlot = null;
        this.currentBoundTextures = {};
        this.currentScissor = new Vector4();
        this.currentViewport = new Vector4();
        this.emptyTextures = {};
        this.gl = gl;
        this.extensions = extensions;
        this.paramThreeToGL = paramThreeToGL;
        this.colorBuffer = new ColorBuffer(this);
        this.depthBuffer = new DepthBuffer(this);
        this.stencilBuffer = new StencilBuffer(this);
        this.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        this.newAttributes = new Uint8Array(this.maxVertexAttributes);
        this.enabledAttributes = new Uint8Array(this.maxVertexAttributes);
        this.attributeDivisors = new Uint8Array(this.maxVertexAttributes);
        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.emptyTextures[gl.TEXTURE_2D] = this.createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = this.createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        this.buffers = {
            color: this.colorBuffer,
            depth: this.depthBuffer,
            stencil: this.stencilBuffer
        };
    }
    WebGLState.prototype.createTexture = function (type, target, count) {
        var gl = this.gl;
        var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
        var texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        for (var i = 0; i < count; i++) {
            gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        }
        return texture;
    };
    //
    WebGLState.prototype.init = function () {
        var gl = this.gl;
        this.clearColor(0, 0, 0, 1);
        this.clearDepth(1);
        this.clearStencil(0);
        this.enable(gl.DEPTH_TEST);
        this.setDepthFunc(DepthFunction.LessEqual);
        this.setFlipSided(false);
        this.setCullFace(CullFace.Back);
        this.enable(gl.CULL_FACE);
        this.enable(gl.BLEND);
        this.setBlending(BlendingMode.Normal);
    };
    WebGLState.prototype.initAttributes = function () {
        for (var i = 0, l = this.newAttributes.length; i < l; i++) {
            this.newAttributes[i] = 0;
        }
    };
    WebGLState.prototype.enableAttribute = function (attribute) {
        var gl = this.gl;
        this.newAttributes[attribute] = 1;
        if (this.enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            this.enabledAttributes[attribute] = 1;
        }
        if (this.attributeDivisors[attribute] !== 0) {
            var extension = this.extensions.get('ANGLE_instanced_arrays');
            extension.vertexAttribDivisorANGLE(attribute, 0);
            this.attributeDivisors[attribute] = 0;
        }
    };
    WebGLState.prototype.enableAttributeAndDivisor = function (attribute, meshPerAttribute, extension) {
        var gl = this.gl;
        this.newAttributes[attribute] = 1;
        if (this.enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            this.enabledAttributes[attribute] = 1;
        }
        if (this.attributeDivisors[attribute] !== meshPerAttribute) {
            extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
            this.attributeDivisors[attribute] = meshPerAttribute;
        }
    };
    WebGLState.prototype.disableUnusedAttributes = function () {
        var gl = this.gl;
        for (var i = 0, l = this.enabledAttributes.length; i !== l; ++i) {
            if (this.enabledAttributes[i] !== this.newAttributes[i]) {
                gl.disableVertexAttribArray(i);
                this.enabledAttributes[i] = 0;
            }
        }
    };
    WebGLState.prototype.enable = function (id) {
        var gl = this.gl;
        if (this.capabilities[id] !== true) {
            gl.enable(id);
            this.capabilities[id] = true;
        }
    };
    WebGLState.prototype.disable = function (id) {
        var gl = this.gl;
        if (this.capabilities[id] !== false) {
            gl.disable(id);
            this.capabilities[id] = false;
        }
    };
    WebGLState.prototype.getCompressedTextureFormats = function () {
        var gl = this.gl;
        if (this.compressedTextureFormats === null) {
            this.compressedTextureFormats = [];
            if (this.extensions.get('WEBGL_compressed_texture_pvrtc') ||
                this.extensions.get('WEBGL_compressed_texture_s3tc') ||
                this.extensions.get('WEBGL_compressed_texture_etc1')) {
                var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
                for (var i = 0; i < formats.length; i++) {
                    this.compressedTextureFormats.push(formats[i]);
                }
            }
        }
        return this.compressedTextureFormats;
    };
    WebGLState.prototype.setBlending = function (blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        var gl = this.gl;
        if (blending !== BlendingMode.None) {
            this.enable(gl.BLEND);
        }
        else {
            this.disable(gl.BLEND);
        }
        if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
            if (blending === BlendingMode.Additive) {
                if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
                }
                else {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                }
            }
            else if (blending === BlendingMode.Subtractive) {
                if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                }
                else {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                }
            }
            else if (blending === BlendingMode.Multiply) {
                if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                }
                else {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                }
            }
            else {
                if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                }
                else {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                }
            }
            this.currentBlending = blending;
            this.currentPremultipledAlpha = premultipliedAlpha;
        }
        if (blending === BlendingMode.Custom) {
            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;
            if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
                gl.blendEquationSeparate(this.paramThreeToGL(blendEquation), this.paramThreeToGL(blendEquationAlpha));
                this.currentBlendEquation = blendEquation;
                this.currentBlendEquationAlpha = blendEquationAlpha;
            }
            if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {
                gl.blendFuncSeparate(this.paramThreeToGL(blendSrc), this.paramThreeToGL(blendDst), this.paramThreeToGL(blendSrcAlpha), this.paramThreeToGL(blendDstAlpha));
                this.currentBlendSrc = blendSrc;
                this.currentBlendDst = blendDst;
                this.currentBlendSrcAlpha = blendSrcAlpha;
                this.currentBlendDstAlpha = blendDstAlpha;
            }
        }
        else {
            this.currentBlendEquation = null;
            this.currentBlendSrc = null;
            this.currentBlendDst = null;
            this.currentBlendEquationAlpha = null;
            this.currentBlendSrcAlpha = null;
            this.currentBlendDstAlpha = null;
        }
    };
    // TODO Deprecate
    WebGLState.prototype.setColorWrite = function (colorWrite) {
        this.colorBuffer.setMask(colorWrite);
    };
    WebGLState.prototype.setDepthTest = function (depthTest) {
        this.depthBuffer.setTest(depthTest);
    };
    WebGLState.prototype.setDepthWrite = function (depthWrite) {
        this.depthBuffer.setMask(depthWrite);
    };
    WebGLState.prototype.setDepthFunc = function (depthFunc) {
        this.depthBuffer.setFunc(depthFunc);
    };
    WebGLState.prototype.setStencilTest = function (stencilTest) {
        this.stencilBuffer.setTest(stencilTest);
    };
    WebGLState.prototype.setStencilWrite = function (stencilWrite) {
        this.stencilBuffer.setMask(stencilWrite);
    };
    WebGLState.prototype.setStencilFunc = function (stencilFunc, stencilRef, stencilMask) {
        this.stencilBuffer.setFunc(stencilFunc, stencilRef, stencilMask);
    };
    WebGLState.prototype.setStencilOp = function (stencilFail, stencilZFail, stencilZPass) {
        this.stencilBuffer.setOp(stencilFail, stencilZFail, stencilZPass);
    };
    //
    WebGLState.prototype.setFlipSided = function (flipSided) {
        var gl = this.gl;
        if (this.currentFlipSided !== flipSided) {
            if (flipSided) {
                gl.frontFace(gl.CW);
            }
            else {
                gl.frontFace(gl.CCW);
            }
            this.currentFlipSided = flipSided;
        }
    };
    WebGLState.prototype.setCullFace = function (cullFace) {
        var gl = this.gl;
        if (cullFace !== CullFace.None) {
            gl.enable(gl.CULL_FACE);
            if (cullFace !== this.currentCullFace) {
                if (cullFace === CullFace.Back) {
                    gl.cullFace(gl.BACK);
                }
                else if (cullFace === CullFace.Front) {
                    gl.cullFace(gl.FRONT);
                }
                else {
                    gl.cullFace(gl.FRONT_AND_BACK);
                }
            }
        }
        else {
            this.disable(gl.CULL_FACE);
        }
        this.currentCullFace = cullFace;
    };
    WebGLState.prototype.setLineWidth = function (width) {
        var gl = this.gl;
        if (width !== this.currentLineWidth) {
            gl.lineWidth(width);
            this.currentLineWidth = width;
        }
    };
    WebGLState.prototype.setPolygonOffset = function (polygonOffset, factor, units) {
        var gl = this.gl;
        if (polygonOffset) {
            this.enable(gl.POLYGON_OFFSET_FILL);
            if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                this.currentPolygonOffsetFactor = factor;
                this.currentPolygonOffsetUnits = units;
            }
        }
        else {
            this.disable(gl.POLYGON_OFFSET_FILL);
        }
    };
    WebGLState.prototype.getScissorTest = function () {
        return this.currentScissorTest;
    };
    WebGLState.prototype.setScissorTest = function (scissorTest) {
        var gl = this.gl;
        this.currentScissorTest = scissorTest;
        if (scissorTest) {
            this.enable(gl.SCISSOR_TEST);
        }
        else {
            this.disable(gl.SCISSOR_TEST);
        }
    };
    // texture
    WebGLState.prototype.activeTexture = function (webglSlot) {
        var gl = this.gl;
        if (webglSlot === undefined)
            webglSlot = gl.TEXTURE0 + this.maxTextures - 1;
        if (this.currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            this.currentTextureSlot = webglSlot;
        }
    };
    WebGLState.prototype.bindTexture = function (webglType, webglTexture) {
        var gl = this.gl;
        if (this.currentTextureSlot === null) {
            this.activeTexture();
        }
        var boundTexture = this.currentBoundTextures[this.currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = { type: undefined, texture: undefined };
            this.currentBoundTextures[this.currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || this.emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    };
    WebGLState.prototype.compressedTexImage2D = function () {
        var gl = this.gl;
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        }
        catch (error) {
            console.error(error);
        }
    };
    WebGLState.prototype.texImage2D = function () {
        var gl = this.gl;
        try {
            gl.texImage2D.apply(gl, arguments);
        }
        catch (error) {
            console.error(error);
        }
    };
    // TODO Deprecate
    WebGLState.prototype.clearColor = function (r, g, b, a) {
        this.colorBuffer.setClear(r, g, b, a);
    };
    WebGLState.prototype.clearDepth = function (depth) {
        this.depthBuffer.setClear(depth);
    };
    WebGLState.prototype.clearStencil = function (stencil) {
        this.stencilBuffer.setClear(stencil);
    };
    //
    WebGLState.prototype.scissor = function (scissor) {
        var gl = this.gl;
        if (this.currentScissor.equals(scissor) === false) {
            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
            this.currentScissor.copy(scissor);
        }
    };
    WebGLState.prototype.viewport = function (viewport) {
        var gl = this.gl;
        if (this.currentViewport.equals(viewport) === false) {
            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
            this.currentViewport.copy(viewport);
        }
    };
    //
    WebGLState.prototype.reset = function () {
        var gl = this.gl;
        for (var i = 0; i < this.enabledAttributes.length; i++) {
            if (this.enabledAttributes[i] === 1) {
                gl.disableVertexAttribArray(i);
                this.enabledAttributes[i] = 0;
            }
        }
        this.capabilities = {};
        this.compressedTextureFormats = null;
        this.currentTextureSlot = null;
        this.currentBoundTextures = {};
        this.currentBlending = null;
        this.currentFlipSided = null;
        this.currentCullFace = null;
        this.colorBuffer.reset();
        this.depthBuffer.reset();
        this.stencilBuffer.reset();
    };
    return WebGLState;
}());

var WebGLCapabilities = (function () {
    function WebGLCapabilities(gl, extensions, parameters) {
        this.gl = gl;
        this.extensions = extensions;
        this.parameters = parameters;
        this.precision = parameters.precision !== undefined ? parameters.precision : 'highp';
        this.maxPrecision = this.getMaxPrecision(this.precision);
        if (this.maxPrecision !== this.precision) {
            console.warn('THREE.WebGLRenderer:', this.precision, 'not supported, using', this.maxPrecision, 'instead.');
            this.precision = this.maxPrecision;
        }
        this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !!extensions.get('EXT_frag_depth');
        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
        this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        this.vertexTextures = this.maxVertexTextures > 0;
        this.floatFragmentTextures = !!extensions.get('OES_texture_float');
        this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
    }
    WebGLCapabilities.prototype.getMaxAnisotropy = function () {
        var gl = this.gl;
        if (this.maxAnisotropy !== undefined)
            return this.maxAnisotropy;
        var extension = this.extensions.get('EXT_texture_filter_anisotropic');
        if (extension !== null) {
            this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        }
        else {
            this.maxAnisotropy = 0;
        }
        return this.maxAnisotropy;
    };
    WebGLCapabilities.prototype.getMaxPrecision = function (precision) {
        var gl = this.gl;
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                return 'highp';
            }
            precision = 'mediump';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                return 'mediump';
            }
        }
        return 'lowp';
    };
    return WebGLCapabilities;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var WebGLExtensions = (function () {
    function WebGLExtensions(gl) {
        this.extensions = {};
        this.gl = gl;
    }
    WebGLExtensions.prototype.get = function (name) {
        var gl = this.gl;
        var extensions = this.extensions;
        if (extensions[name] !== undefined) {
            return extensions[name];
        }
        var extension;
        switch (name) {
            case 'WEBGL_depth_texture':
                extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
            case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
            case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
            case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
            case 'WEBGL_compressed_texture_etc1':
                extension = gl.getExtension('WEBGL_compressed_texture_etc1');
                break;
            default:
                extension = gl.getExtension(name);
        }
        if (extension === null) {
            console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
        }
        extensions[name] = extension;
        return extension;
    };
    return WebGLExtensions;
}());

var WebGLClipping = (function () {
    function WebGLClipping() {
        this.globalState = null;
        this.numGlobalPlanes = 0;
        this.localClippingEnabled = false;
        this.renderingShadows = false;
        this.plane = new Plane();
        this.viewNormalMatrix = new Matrix3();
        this.uniform = { value: null, needsUpdate: false };
        this.numPlanes = 0;
        this.numIntersection = 0;
    }
    WebGLClipping.prototype.init = function (planes, enableLocalClipping, camera) {
        var enabled = planes.length !== 0 ||
            enableLocalClipping ||
            // enable state of previous frame - the clipping code has to
            // run another frame in order to reset the state:
            this.numGlobalPlanes !== 0 ||
            this.localClippingEnabled;
        this.localClippingEnabled = enableLocalClipping;
        this.globalState = this.projectPlanes(planes, camera, 0);
        this.numGlobalPlanes = planes.length;
        return enabled;
    };
    WebGLClipping.prototype.beginShadows = function () {
        this.renderingShadows = true;
        this.projectPlanes(null);
    };
    WebGLClipping.prototype.endShadows = function () {
        this.renderingShadows = false;
        this.resetGlobalState();
    };
    WebGLClipping.prototype.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
        if (!this.localClippingEnabled ||
            planes === null || planes.length === 0 ||
            this.renderingShadows && !clipShadows) {
            // there's no local clipping
            if (this.renderingShadows) {
                // there's no global clipping
                this.projectPlanes(null);
            }
            else {
                this.resetGlobalState();
            }
        }
        else {
            var nGlobal = this.renderingShadows ? 0 : this.numGlobalPlanes;
            var lGlobal = nGlobal * 4;
            var dstArray = cache.clippingState || null;
            this.uniform.value = dstArray; // ensure unique state
            dstArray = this.projectPlanes(planes, camera, lGlobal, fromCache);
            for (var i = 0; i !== lGlobal; ++i) {
                dstArray[i] = this.globalState[i];
            }
            cache.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
        }
    };
    WebGLClipping.prototype.resetGlobalState = function () {
        if (this.uniform.value !== this.globalState) {
            this.uniform.value = this.globalState;
            this.uniform.needsUpdate = this.numGlobalPlanes > 0;
        }
        this.numPlanes = this.numGlobalPlanes;
        this.numIntersection = 0;
    };
    WebGLClipping.prototype.projectPlanes = function (planes, camera, dstOffset, skipTransform) {
        var nPlanes = planes !== null ? planes.length : 0;
        var dstArray = null;
        if (nPlanes !== 0) {
            dstArray = this.uniform.value;
            if (skipTransform !== true || dstArray === null) {
                var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                this.viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) {
                    dstArray = new Float32Array(flatSize);
                }
                for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                    this.plane.copy(planes[i]).
                        applyMatrix4(viewMatrix, this.viewNormalMatrix);
                    this.plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = this.plane.constant;
                }
            }
            this.uniform.value = dstArray;
            this.uniform.needsUpdate = true;
        }
        this.numPlanes = nPlanes;
        return dstArray;
    };
    return WebGLClipping;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var AmbientLight = (function (_super) {
    __extends(AmbientLight, _super);
    function AmbientLight(color, intensity) {
        _super.call(this, color, intensity);
        this.isAmbientLight = true;
        this.type = 'AmbientLight';
        this.castShadow = undefined;
    }
    return AmbientLight;
}(Light));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var DirectionalLightShadow = (function (_super) {
    __extends(DirectionalLightShadow, _super);
    function DirectionalLightShadow(light) {
        _super.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
    return DirectionalLightShadow;
}(LightShadow));

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
var DirectionalLight = (function (_super) {
    __extends(DirectionalLight, _super);
    function DirectionalLight(color, intensity) {
        _super.call(this, color, intensity);
        this.target = new Object3D();
        this.isDirectionalLight = true;
        this.type = 'DirectionalLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.shadow = new DirectionalLightShadow();
    }
    DirectionalLight.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    };
    return DirectionalLight;
}(Light));

/**
 * @author alteredq / http://alteredqualia.com/
 */
var HemisphereLight = (function (_super) {
    __extends(HemisphereLight, _super);
    function HemisphereLight(skyColor, groundColor, intensity) {
        _super.call(this, skyColor, intensity);
        this.isHemisphereLight = true;
        this.type = 'HemisphereLight';
        this.castShadow = undefined;
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.groundColor = new Color(groundColor);
    }
    HemisphereLight.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
    };
    return HemisphereLight;
}(Light));

/**
 * @author alteredq / http://alteredqualia.com/
 */
var SpotLight = (function (_super) {
    __extends(SpotLight, _super);
    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
        if (distance === void 0) { distance = 0; }
        if (angle === void 0) { angle = Math.PI / 3; }
        if (penumbra === void 0) { penumbra = 0; }
        if (decay === void 0) { decay = 1; }
        _super.call(this, color, intensity);
        this.target = new Object3D();
        this.isSpotLight = true;
        this.type = 'SpotLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.distance = distance;
        this.angle = angle;
        this.penumbra = penumbra;
        this.decay = decay; // for physically correct lights, should be 2.
        this.shadow = new SpotLightShadow();
    }
    Object.defineProperty(SpotLight.prototype, "power", {
        get: function () {
            // intensity = power per solid angle.
            // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
            return this.intensity * Math.PI;
        },
        set: function (value) {
            // intensity = power per solid angle.
            // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
            this.intensity = value / Math.PI;
        },
        enumerable: true,
        configurable: true
    });
    SpotLight.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    };
    return SpotLight;
}(Light));

var SpriteMaterial = (function (_super) {
    __extends(SpriteMaterial, _super);
    function SpriteMaterial(parameters) {
        _super.call(this);
        this.isSpriteMaterial = true;
        this.type = 'SpriteMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.rotation = 0;
        this.fog = false;
        this.lights = false;
        this.setValues(parameters);
    }
    SpriteMaterial.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.rotation = source.rotation;
        return this;
    };
    
    return SpriteMaterial;
}(Material));

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */
var Sprite = (function (_super) {
    __extends(Sprite, _super);
    function Sprite(material) {
        if (material === void 0) { material = new SpriteMaterial(); }
        _super.call(this);
        this.isSprite = true;
        this.type = 'Sprite';
        this.material = material;
    }
    Sprite.prototype.raycast = function (raycaster, intersects) {
        var matrixPosition = Sprite.raycast_matrixPosition;
        //return function raycast(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
        var guessSizeSq = this.scale.x * this.scale.y / 4;
        if (distanceSq > guessSizeSq) {
            return intersects;
        }
        intersects.push({
            distance: Math.sqrt(distanceSq),
            point: this.position,
            index: 0,
            face: null,
            faceIndex: 0,
            uv: null,
            object: this
        });
        return intersects;
        //};
    };
    Sprite.prototype.clone = function () {
        return new this.constructor(this.material).copy(this);
    };
    Sprite.raycast_matrixPosition = new Vector3();
    return Sprite;
}(Object3D));

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */
var LensFlare = (function (_super) {
    __extends(LensFlare, _super);
    function LensFlare(texture, size, distance, blending, color) {
        _super.call(this);
        this.lensFlares = [];
        this.positionScreen = new Vector3();
        this.isLensFlare = true;
        if (texture !== undefined) {
            this.addFlare(texture, size, distance, blending, color);
        }
    }
    LensFlare.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.positionScreen.copy(source.positionScreen);
        this.customUpdateCallback = source.customUpdateCallback;
        for (var i = 0, l = source.lensFlares.length; i < l; i++) {
            this.lensFlares.push(source.lensFlares[i]);
        }
        return this;
    };
    LensFlare.prototype.add = function (object) {
        if (object instanceof Texture) {
            console.warn("LensFlare:add is now LensFlare:addFlare");
            return this.addFlare.call(this, arguments);
        }
        return _super.prototype.add.call(this, object);
    };
    LensFlare.prototype.addFlare = function (texture, size, distance, blending, color, opacity) {
        if (size === void 0) { size = -1; }
        if (distance === void 0) { distance = 0; }
        if (blending === void 0) { blending = BlendingMode.Normal; }
        if (color === void 0) { color = new Color(0xffffff); }
        if (opacity === void 0) { opacity = 1; }
        distance = Math.min(distance, Math.max(0, distance));
        this.lensFlares.push({
            texture: texture,
            size: size,
            distance: distance,
            x: 0, y: 0, z: 0,
            scale: 1,
            rotation: 0,
            opacity: opacity,
            color: color,
            blending: blending // blending
        });
    };
    /*
     * Update lens flares update positions on all flares based on the screen position
     * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
     */
    LensFlare.prototype.updateLensFlares = function () {
        var f, fl = this.lensFlares.length;
        var flare;
        var vecX = -this.positionScreen.x * 2;
        var vecY = -this.positionScreen.y * 2;
        for (f = 0; f < fl; f++) {
            flare = this.lensFlares[f];
            flare.x = this.positionScreen.x + vecX * flare.distance;
            flare.y = this.positionScreen.y + vecY * flare.distance;
            flare.wantedRotation = flare.x * Math.PI * 0.25;
            flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
        }
    };
    return LensFlare;
}(Object3D));

/**
 * @author alteredq / http://alteredqualia.com/
 */
var ImmediateRenderObject = (function (_super) {
    __extends(ImmediateRenderObject, _super);
    function ImmediateRenderObject(material) {
        _super.call(this);
        this.isImmediateRenderObject = true;
        this.material = material;
    }
    ImmediateRenderObject.prototype.render = function (renderCallback) {
    };
    return ImmediateRenderObject;
}(Object3D));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var LineSegments = (function (_super) {
    __extends(LineSegments, _super);
    function LineSegments(geometry, material) {
        _super.call(this, geometry, material);
        this.isLineSegments = true;
        this.type = 'LineSegments';
        this._step = 2; // Line:raycast step
    }
    return LineSegments;
}(Line));

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
var InstancedBufferGeometry = (function (_super) {
    __extends(InstancedBufferGeometry, _super);
    function InstancedBufferGeometry() {
        _super.call(this);
        this.type = 'InstancedBufferGeometry';
        this.maxInstancedCount = undefined;
        this.isInstancedBufferGeometry = true;
    }
    InstancedBufferGeometry.prototype.addGroup = function (start, count, materialIndex) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex
        });
    };
    InstancedBufferGeometry.prototype.copy = function (source) {
        var index = source.index;
        if (index !== null) {
            this.setIndex(index.clone());
        }
        var attributes = source.attributes;
        for (var name in attributes) {
            var attribute = attributes[name];
            if (attribute === undefined)
                continue;
            this.addAttribute(name, attribute.clone());
        }
        var groups = source.groups;
        for (var i = 0, l = groups.length; i < l; i++) {
            var group = groups[i];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        return this;
    };
    return InstancedBufferGeometry;
}(BufferGeometry));

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
var InstancedBufferAttribute = (function (_super) {
    __extends(InstancedBufferAttribute, _super);
    function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
        if (meshPerAttribute === void 0) { meshPerAttribute = 1; }
        _super.call(this, array, itemSize);
        this.isInstancedBufferAttribute = true;
        this.meshPerAttribute = meshPerAttribute;
    }
    InstancedBufferAttribute.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    };
    return InstancedBufferAttribute;
}(BufferAttribute));

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
var InterleavedBuffer = (function () {
    function InterleavedBuffer(array, stride) {
        this.uuid = _Math.generateUUID();
        this.isInterleavedBuffer = true;
        this.array = array;
        this.stride = stride;
        this.count = array !== undefined ? array.length / stride : 0;
        this.dynamic = false;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
    }
    Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
        set: function (value) {
            if (value === true)
                this.version++;
        },
        enumerable: true,
        configurable: true
    });
    InterleavedBuffer.prototype.setArray = function (array) {
        if (Array.isArray(array)) {
            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        }
        this.count = array !== undefined ? array.length / this.stride : 0;
        this.array = array;
    };
    InterleavedBuffer.prototype.setDynamic = function (value) {
        this.dynamic = value;
        return this;
    };
    InterleavedBuffer.prototype.copy = function (source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.dynamic = source.dynamic;
        return this;
    };
    InterleavedBuffer.prototype.copyAt = function (index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (var i = 0, l = this.stride; i < l; i++) {
            this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
    };
    InterleavedBuffer.prototype.set = function (value, offset) {
        if (offset === void 0) { offset = 0; }
        this.array.set(value, offset);
        return this;
    };
    InterleavedBuffer.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    return InterleavedBuffer;
}());

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
var InstancedInterleavedBuffer = (function (_super) {
    __extends(InstancedInterleavedBuffer, _super);
    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
        if (meshPerAttribute === void 0) { meshPerAttribute = 1; }
        _super.call(this, array, stride);
        this.isInstancedInterleavedBuffer = true;
        this.meshPerAttribute = meshPerAttribute;
    }
    InstancedInterleavedBuffer.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    };
    return InstancedInterleavedBuffer;
}(InterleavedBuffer));

var WebGLRenderer = (function () {
    function WebGLRenderer(parameters) {
        this.lights = [];
        this.opaqueObjects = [];
        this.opaqueObjectsLastIndex = -1;
        this.transparentObjects = [];
        this.transparentObjectsLastIndex = -1;
        this.morphInfluences = new Float32Array(8);
        this.sprites = [];
        this.lensFlares = [];
        this.context = null;
        // clearing
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        // scene graph
        this.sortObjects = true;
        // user-defined clipping
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        // physically based shading
        this.gammaFactor = 2.0; // for backwards compatibility
        this.gammaInput = false;
        this.gammaOutput = false;
        // physical lights
        this.physicallyCorrectLights = false;
        // tone mapping
        this.toneMapping = ToneMapping.Linear;
        this.toneMappingExposure = 1.0;
        this.toneMappingWhitePoint = 1.0;
        // morphs
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;
        // internal state cache
        this._currentProgram = null;
        this._currentRenderTarget = null;
        this._currentFramebuffer = null;
        this._currentMaterialId = -1;
        this._currentGeometryProgram = '';
        this._currentCamera = null;
        this._currentScissor = new Vector4();
        this._currentScissorTest = null;
        this._currentViewport = new Vector4();
        //
        this._usedTextureUnits = 0;
        //
        this._clearColor = new Color(0x000000);
        this._clearAlpha = 0;
        this._pixelRatio = 1;
        this._scissorTest = false;
        // frustum
        this._frustum = new Frustum();
        // clipping
        this._clipping = new WebGLClipping();
        this._clippingEnabled = false;
        this._localClippingEnabled = false;
        this._sphere = new Sphere();
        // camera matrices cache
        this._projScreenMatrix = new Matrix4();
        this._vector3 = new Vector3();
        // light arrays cache
        this._lights = {
            hash: '',
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            shadows: []
        };
        // info
        this.info = {
            render: {
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            },
            memory: {
                geometries: 0,
                textures: 0
            },
            programs: null
        };
        this._infoRender = this.info.render;
        console.log('THREE.WebGLRenderer', REVISION);
        parameters = parameters || {};
        this._canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        this._context = parameters.context !== undefined ? parameters.context : null;
        this._alpha = parameters.alpha !== undefined ? parameters.alpha : false,
            this._depth = parameters.depth !== undefined ? parameters.depth : true,
            this._stencil = parameters.stencil !== undefined ? parameters.stencil : true,
            this._antialias = parameters.antialias !== undefined ? parameters.antialias : false,
            this._premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
            this._preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
        this.domElement = this._canvas;
        this._width = this._canvas.width;
        this._height = this._canvas.height;
        this._scissor = new Vector4(0, 0, this._width, this._height);
        this._viewport = new Vector4(0, 0, this._width, this._height);
        // initialize
        ///let _gl;
        try {
            var attributes = {
                alpha: this._alpha,
                depth: this._depth,
                stencil: this._stencil,
                antialias: this._antialias,
                premultipliedAlpha: this._premultipliedAlpha,
                preserveDrawingBuffer: this._preserveDrawingBuffer
            };
            this._gl = (this._context || this._canvas.getContext('webgl', attributes) || this._canvas.getContext('experimental-webgl', attributes));
            if (this._gl === null) {
                if (this._canvas.getContext('webgl') !== null) {
                    throw 'Error creating WebGL context with your selected attributes.';
                }
                else {
                    throw 'Error creating WebGL context.';
                }
            }
            // Some experimental-webgl implementations do not have getShaderPrecisionFormat
            if (this._gl.getShaderPrecisionFormat === undefined) {
                this._gl.getShaderPrecisionFormat = function () {
                    return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
                };
            }
            this._canvas.addEventListener('webglcontextlost', this.onContextLost.bind(this), false);
        }
        catch (error) {
            console.error('THREE.WebGLRenderer: ' + error);
        }
        this.extensions = new WebGLExtensions(this._gl);
        this.extensions.get('WEBGL_depth_texture');
        this.extensions.get('OES_texture_float');
        this.extensions.get('OES_texture_float_linear');
        this.extensions.get('OES_texture_half_float');
        this.extensions.get('OES_texture_half_float_linear');
        this.extensions.get('OES_standard_derivatives');
        this.extensions.get('ANGLE_instanced_arrays');
        if (this.extensions.get('OES_element_index_uint')) {
            BufferGeometry.MaxIndex = 4294967296;
        }
        this.capabilities = new WebGLCapabilities(this._gl, this.extensions, parameters);
        this.state = new WebGLState(this._gl, this.extensions, this.paramThreeToGL.bind(this));
        this.properties = new WebGLProperties();
        this.textures = new WebGLTextures(this._gl, this.extensions, this.state, this.properties, this.capabilities, this.paramThreeToGL.bind(this), this.info);
        this.objects = new WebGLObjects(this._gl, this.properties, this.info);
        this.programCache = new WebGLPrograms(this, this.capabilities);
        this.lightCache = new WebGLLights();
        this.info.programs = this.programCache.programs;
        this.bufferRenderer = new WebGLBufferRenderer(this._gl, this.extensions, this._infoRender);
        this.indexedBufferRenderer = new WebGLIndexedBufferRenderer(this._gl, this.extensions, this._infoRender);
        //
        this.backgroundCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.backgroundCamera2 = new PerspectiveCamera();
        this.backgroundPlaneMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({ depthTest: false, depthWrite: false, fog: false }));
        this.backgroundBoxShader = ShaderLib['cube'];
        this.backgroundBoxMesh = new Mesh(new BoxBufferGeometry(5, 5, 5), new ShaderMaterial({
            uniforms: this.backgroundBoxShader.uniforms,
            vertexShader: this.backgroundBoxShader.vertexShader,
            fragmentShader: this.backgroundBoxShader.fragmentShader,
            side: SideMode.Back,
            depthTest: false,
            depthWrite: false,
            fog: false
        }));
        this.setDefaultGLState();
        this.context = this._gl;
        // shadow map
        this.shadowMap = new WebGLShadowMap(this, this._lights, this.objects, this.capabilities);
        // Plugins
        this.spritePlugin = new SpritePlugin(this, this.sprites);
        this.lensFlarePlugin = new LensFlarePlugin(this, this.lensFlares);
    }
    WebGLRenderer.prototype.getTargetPixelRatio = function () {
        return this._currentRenderTarget === null ? this._pixelRatio : 1;
    };
    WebGLRenderer.prototype.glClearColor = function (r, g, b, a) {
        if (this._premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
        }
        this.state.clearColor(r, g, b, a);
    };
    WebGLRenderer.prototype.setDefaultGLState = function () {
        this.state.init();
        this.state.scissor(this._currentScissor.copy(this._scissor).multiplyScalar(this._pixelRatio));
        this.state.viewport(this._currentViewport.copy(this._viewport).multiplyScalar(this._pixelRatio));
        this.glClearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
    };
    WebGLRenderer.prototype.resetGLState = function () {
        this._currentProgram = null;
        this._currentCamera = null;
        this._currentGeometryProgram = '';
        this._currentMaterialId = -1;
        this.state.reset();
    };
    // API
    WebGLRenderer.prototype.getContext = function () {
        return this._gl;
    };
    WebGLRenderer.prototype.getContextAttributes = function () {
        return this._gl.getContextAttributes();
    };
    WebGLRenderer.prototype.forceContextLoss = function () {
        this.extensions.get('WEBGL_lose_context').loseContext();
    };
    WebGLRenderer.prototype.getMaxAnisotropy = function () {
        return this.capabilities.getMaxAnisotropy();
    };
    WebGLRenderer.prototype.getPrecision = function () {
        return this.capabilities.precision;
    };
    WebGLRenderer.prototype.getPixelRatio = function () {
        return this._pixelRatio;
    };
    WebGLRenderer.prototype.setPixelRatio = function (value) {
        if (value === undefined)
            return;
        this._pixelRatio = value;
        this.setSize(this._viewport.z, this._viewport.w, false);
    };
    WebGLRenderer.prototype.getSize = function () {
        return {
            width: this._width,
            height: this._height
        };
    };
    WebGLRenderer.prototype.setSize = function (width, height, updateStyle) {
        this._width = width;
        this._height = height;
        this._canvas.width = width * this._pixelRatio;
        this._canvas.height = height * this._pixelRatio;
        if (updateStyle !== false) {
            this._canvas.style.width = width + 'px';
            this._canvas.style.height = height + 'px';
        }
        this.setViewport(0, 0, width, height);
    };
    WebGLRenderer.prototype.setViewport = function (x, y, width, height) {
        this.state.viewport(this._viewport.set(x, y, width, height));
    };
    WebGLRenderer.prototype.setScissor = function (x, y, width, height) {
        this.state.scissor(this._scissor.set(x, y, width, height));
    };
    WebGLRenderer.prototype.setScissorTest = function (test) {
        this.state.setScissorTest(this._scissorTest = test);
    };
    // Clearing
    WebGLRenderer.prototype.getClearColor = function () {
        return this._clearColor;
    };
    WebGLRenderer.prototype.setClearColor = function (color, alpha) {
        if (alpha === void 0) { alpha = 1; }
        this._clearColor.set(color);
        this._clearAlpha = alpha;
        this.glClearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
    };
    WebGLRenderer.prototype.getClearAlpha = function () {
        return this._clearAlpha;
    };
    WebGLRenderer.prototype.setClearAlpha = function (alpha) {
        this._clearAlpha = alpha;
        this.glClearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
    };
    WebGLRenderer.prototype.clear = function (color, depth, stencil) {
        var bits = 0;
        if (color === undefined || color)
            bits |= this._gl.COLOR_BUFFER_BIT;
        if (depth === undefined || depth)
            bits |= this._gl.DEPTH_BUFFER_BIT;
        if (stencil === undefined || stencil)
            bits |= this._gl.STENCIL_BUFFER_BIT;
        this._gl.clear(bits);
    };
    WebGLRenderer.prototype.clearColor = function () {
        this.clear(true, false, false);
    };
    WebGLRenderer.prototype.clearDepth = function () {
        this.clear(false, true, false);
    };
    WebGLRenderer.prototype.clearStencil = function () {
        this.clear(false, false, true);
    };
    WebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
    };
    // Reset
    ///this.resetGLState = resetGLState;
    WebGLRenderer.prototype.dispose = function () {
        this.transparentObjects = [];
        this.transparentObjectsLastIndex = -1;
        this.opaqueObjects = [];
        this.opaqueObjectsLastIndex = -1;
        this._canvas.removeEventListener('webglcontextlost', this.onContextLost.bind(this), false);
    };
    // Events
    WebGLRenderer.prototype.onContextLost = function (event) {
        event.preventDefault();
        this.resetGLState();
        this.setDefaultGLState();
        this.properties.clear();
    };
    WebGLRenderer.prototype.onMaterialDispose = function (event) {
        var material = event.target;
        material.removeEventListener('dispose', this.onMaterialDispose.bind(this));
        this.deallocateMaterial(material);
    };
    // Buffer deallocation
    WebGLRenderer.prototype.deallocateMaterial = function (material) {
        this.releaseMaterialProgramReference(material);
        this.properties.delete(material);
    };
    WebGLRenderer.prototype.releaseMaterialProgramReference = function (material) {
        var programInfo = this.properties.get(material).program;
        material.program = undefined;
        if (programInfo !== undefined) {
            this.programCache.releaseProgram(programInfo);
        }
    };
    // Buffer rendering
    WebGLRenderer.prototype.renderBufferImmediate = function (object, program, material) {
        this.state.initAttributes();
        var buffers = this.properties.get(object);
        if (object.hasPositions && !buffers.position)
            buffers.position = this._gl.createBuffer();
        if (object.hasNormals && !buffers.normal)
            buffers.normal = this._gl.createBuffer();
        if (object.hasUvs && !buffers.uv)
            buffers.uv = this._gl.createBuffer();
        if (object.hasColors && !buffers.color)
            buffers.color = this._gl.createBuffer();
        var attributes = program.getAttributes();
        if (object.hasPositions) {
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.position);
            this._gl.bufferData(this._gl.ARRAY_BUFFER, object.positionArray, this._gl.DYNAMIC_DRAW);
            this.state.enableAttribute(attributes.position);
            this._gl.vertexAttribPointer(attributes.position, 3, this._gl.FLOAT, false, 0, 0);
        }
        if (object.hasNormals) {
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.normal);
            if (!(material instanceof MeshPhongMaterial) && !(material instanceof MeshStandardMaterial) && material.shading === ShadingMode.Flat) {
                for (var i = 0, l = object.count * 3; i < l; i += 9) {
                    var array = object.normalArray;
                    var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                    var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                    var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                    array[i + 0] = nx;
                    array[i + 1] = ny;
                    array[i + 2] = nz;
                    array[i + 3] = nx;
                    array[i + 4] = ny;
                    array[i + 5] = nz;
                    array[i + 6] = nx;
                    array[i + 7] = ny;
                    array[i + 8] = nz;
                }
            }
            this._gl.bufferData(this._gl.ARRAY_BUFFER, object.normalArray, this._gl.DYNAMIC_DRAW);
            this.state.enableAttribute(attributes.normal);
            this._gl.vertexAttribPointer(attributes.normal, 3, this._gl.FLOAT, false, 0, 0);
        }
        if (object.hasUvs && material.map) {
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.uv);
            this._gl.bufferData(this._gl.ARRAY_BUFFER, object.uvArray, this._gl.DYNAMIC_DRAW);
            this.state.enableAttribute(attributes.uv);
            this._gl.vertexAttribPointer(attributes.uv, 2, this._gl.FLOAT, false, 0, 0);
        }
        if (object.hasColors && material.vertexColors !== ColorsMode.None) {
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.color);
            this._gl.bufferData(this._gl.ARRAY_BUFFER, object.colorArray, this._gl.DYNAMIC_DRAW);
            this.state.enableAttribute(attributes.color);
            this._gl.vertexAttribPointer(attributes.color, 3, this._gl.FLOAT, false, 0, 0);
        }
        this.state.disableUnusedAttributes();
        this._gl.drawArrays(this._gl.TRIANGLES, 0, object.count);
        object.count = 0;
    };
    WebGLRenderer.prototype.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
        var _gl = this._gl;
        this.setMaterial(material);
        var program = this.setProgram(camera, fog, material, object);
        var updateBuffers = false;
        var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
        if (geometryProgram !== this._currentGeometryProgram) {
            this._currentGeometryProgram = geometryProgram;
            updateBuffers = true;
        }
        // morph targets
        var morphTargetInfluences = object.morphTargetInfluences;
        if (morphTargetInfluences !== undefined) {
            var activeInfluences = [];
            for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {
                var influence = morphTargetInfluences[i];
                activeInfluences.push([influence, i]);
            }
            activeInfluences.sort(WebGLRenderer.absNumericalSort);
            if (activeInfluences.length > 8) {
                activeInfluences.length = 8;
            }
            var morphAttributes = geometry.morphAttributes;
            for (var i = 0, l = activeInfluences.length; i < l; i++) {
                var influence = activeInfluences[i];
                this.morphInfluences[i] = influence[0];
                if (influence[0] !== 0) {
                    var index_1 = influence[1];
                    if (material.morphTargets === true && morphAttributes.position)
                        geometry.addAttribute('morphTarget' + i, morphAttributes.position[index_1]);
                    if (material.morphNormals === true && morphAttributes.normal)
                        geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index_1]);
                }
                else {
                    if (material.morphTargets === true)
                        geometry.removeAttribute('morphTarget' + i);
                    if (material.morphNormals === true)
                        geometry.removeAttribute('morphNormal' + i);
                }
            }
            for (var i = activeInfluences.length, il = this.morphInfluences.length; i < il; i++) {
                this.morphInfluences[i] = 0.0;
            }
            program.getUniforms().setValue(this._gl, 'morphTargetInfluences', this.morphInfluences);
            updateBuffers = true;
        }
        //
        var index = geometry.index;
        var position = geometry.attributes.position;
        var rangeFactor = 1;
        if (material.wireframe === true) {
            index = this.objects.getWireframeAttribute(geometry);
            rangeFactor = 2;
        }
        var renderer;
        if (index !== null) {
            renderer = this.indexedBufferRenderer;
            renderer.setIndex(index);
        }
        else {
            renderer = this.bufferRenderer;
        }
        if (updateBuffers) {
            this.setupVertexAttributes(material, program, geometry);
            if (index !== null) {
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this.objects.getAttributeBuffer(index));
            }
        }
        //
        var dataCount = 0;
        if (index !== null) {
            dataCount = index.count;
        }
        else if (position !== undefined) {
            dataCount = position.count;
        }
        var rangeStart = geometry.drawRange.start * rangeFactor;
        var rangeCount = geometry.drawRange.count * rangeFactor;
        var groupStart = group !== null ? group.start * rangeFactor : 0;
        var groupCount = group !== null ? group.count * rangeFactor : Infinity;
        var drawStart = Math.max(rangeStart, groupStart);
        var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        var drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0)
            return;
        //
        if (object instanceof Mesh) {
            if (material.wireframe === true) {
                this.state.setLineWidth(material.wireframeLinewidth * this.getTargetPixelRatio());
                renderer.setMode(_gl.LINES);
            }
            else {
                switch (object.drawMode) {
                    case DrawMode.Triangles:
                        renderer.setMode(_gl.TRIANGLES);
                        break;
                    case DrawMode.TriangleStrip:
                        renderer.setMode(_gl.TRIANGLE_STRIP);
                        break;
                    case DrawMode.TriangleFan:
                        renderer.setMode(_gl.TRIANGLE_FAN);
                        break;
                }
            }
        }
        else if (object instanceof Line) {
            var lineWidth = material.linewidth;
            if (lineWidth === undefined)
                lineWidth = 1; // Not using Line*Material
            this.state.setLineWidth(lineWidth * this.getTargetPixelRatio());
            if (object instanceof LineSegments) {
                renderer.setMode(_gl.LINES);
            }
            else {
                renderer.setMode(_gl.LINE_STRIP);
            }
        }
        else if (object instanceof Points) {
            renderer.setMode(_gl.POINTS);
        }
        if (geometry && geometry instanceof InstancedBufferGeometry) {
            if (geometry.maxInstancedCount > 0) {
                renderer.renderInstances(geometry, drawStart, drawCount);
            }
        }
        else {
            renderer.render(drawStart, drawCount);
        }
    };
    WebGLRenderer.prototype.setupVertexAttributes = function (material, program, geometry, startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        var _gl = this._gl;
        var extension;
        if (geometry && geometry instanceof InstancedBufferGeometry) {
            extension = this.extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        this.state.initAttributes();
        var geometryAttributes = geometry.attributes;
        var programAttributes = program.getAttributes();
        var materialDefaultAttributeValues = material.defaultAttributeValues;
        for (var name in programAttributes) {
            var programAttribute = programAttributes[name];
            if (programAttribute >= 0) {
                var geometryAttribute = geometryAttributes[name];
                if (geometryAttribute !== undefined) {
                    var type = _gl.FLOAT;
                    var array = geometryAttribute.array;
                    var normalized = geometryAttribute.normalized;
                    if (array instanceof Float32Array) {
                        type = _gl.FLOAT;
                    }
                    else if (array instanceof Float64Array) {
                        console.warn("Unsupported data buffer format: Float64Array");
                    }
                    else if (array instanceof Uint16Array) {
                        type = _gl.UNSIGNED_SHORT;
                    }
                    else if (array instanceof Int16Array) {
                        type = _gl.SHORT;
                    }
                    else if (array instanceof Uint32Array) {
                        type = _gl.UNSIGNED_INT;
                    }
                    else if (array instanceof Int32Array) {
                        type = _gl.INT;
                    }
                    else if (array instanceof Int8Array) {
                        type = _gl.BYTE;
                    }
                    else if (array instanceof Uint8Array) {
                        type = _gl.UNSIGNED_BYTE;
                    }
                    var size = geometryAttribute.itemSize;
                    var buffer = this.objects.getAttributeBuffer(geometryAttribute);
                    if (geometryAttribute instanceof InterleavedBufferAttribute) {
                        var data = geometryAttribute.data;
                        var stride = data.stride;
                        var offset = geometryAttribute.offset;
                        if (data && data instanceof InstancedInterleavedBuffer) {
                            this.state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
                            if (geometry.maxInstancedCount === undefined) {
                                geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                            }
                        }
                        else {
                            this.state.enableAttribute(programAttribute);
                        }
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
                    }
                    else {
                        if (geometryAttribute instanceof InstancedBufferAttribute) {
                            this.state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
                            if (geometry.maxInstancedCount === undefined) {
                                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                            }
                        }
                        else {
                            this.state.enableAttribute(programAttribute);
                        }
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT);
                    }
                }
                else if (materialDefaultAttributeValues !== undefined) {
                    var value = materialDefaultAttributeValues[name];
                    if (value !== undefined) {
                        switch (value.length) {
                            case 2:
                                _gl.vertexAttrib2fv(programAttribute, value);
                                break;
                            case 3:
                                _gl.vertexAttrib3fv(programAttribute, value);
                                break;
                            case 4:
                                _gl.vertexAttrib4fv(programAttribute, value);
                                break;
                            default:
                                _gl.vertexAttrib1fv(programAttribute, value);
                        }
                    }
                }
            }
        }
        this.state.disableUnusedAttributes();
    };
    // Sorting
    WebGLRenderer.absNumericalSort = function (a, b) {
        return Math.abs(b[0]) - Math.abs(a[0]);
    };
    WebGLRenderer.painterSortStable = function (a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
            return a.object.renderOrder - b.object.renderOrder;
        }
        else if (a.material.program && b.material.program && a.material.program !== b.material.program) {
            return a.material.program.id - b.material.program.id;
        }
        else if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
        }
        else if (a.z !== b.z) {
            return a.z - b.z;
        }
        else {
            return a.id - b.id;
        }
    };
    WebGLRenderer.reversePainterSortStable = function (a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
            return a.object.renderOrder - b.object.renderOrder;
        }
        if (a.z !== b.z) {
            return b.z - a.z;
        }
        else {
            return a.id - b.id;
        }
    };
    // Rendering
    WebGLRenderer.prototype.render = function (scene, camera, renderTarget, forceClear) {
        if (camera !== undefined && camera instanceof Camera !== true) {
            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
            return;
        }
        // reset caching for this frame
        this._currentGeometryProgram = '';
        this._currentMaterialId = -1;
        this._currentCamera = null;
        // update scene graph
        if (scene.autoUpdate === true)
            scene.updateMatrixWorld();
        // update camera matrices and frustum
        if (camera.parent === null)
            camera.updateMatrixWorld();
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        this._projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromMatrix(this._projScreenMatrix);
        this.lights.length = 0;
        this.opaqueObjectsLastIndex = -1;
        this.transparentObjectsLastIndex = -1;
        this.sprites.length = 0;
        this.lensFlares.length = 0;
        this._localClippingEnabled = this.localClippingEnabled;
        this._clippingEnabled = this._clipping.init(this.clippingPlanes, this._localClippingEnabled, camera);
        this.projectObject(scene, camera);
        this.opaqueObjects.length = this.opaqueObjectsLastIndex + 1;
        this.transparentObjects.length = this.transparentObjectsLastIndex + 1;
        if (this.sortObjects === true) {
            this.opaqueObjects.sort(WebGLRenderer.painterSortStable);
            this.transparentObjects.sort(WebGLRenderer.reversePainterSortStable);
        }
        //
        if (this._clippingEnabled)
            this._clipping.beginShadows();
        this.setupShadows(this.lights);
        this.shadowMap.render(scene, camera);
        this.setupLights(this.lights, camera);
        if (this._clippingEnabled)
            this._clipping.endShadows();
        //
        this._infoRender.calls = 0;
        this._infoRender.vertices = 0;
        this._infoRender.faces = 0;
        this._infoRender.points = 0;
        if (renderTarget === undefined) {
            renderTarget = null;
        }
        this.setRenderTarget(renderTarget);
        //
        var background = scene.background;
        if (background === null) {
            this.glClearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
        }
        else if (background && background instanceof Color) {
            this.glClearColor(background.r, background.g, background.b, 1);
            forceClear = true;
        }
        if (this.autoClear || forceClear) {
            this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }
        if (background && background instanceof CubeTexture) {
            this.backgroundCamera2.projectionMatrix.copy(camera.projectionMatrix);
            this.backgroundCamera2.matrixWorld.extractRotation(camera.matrixWorld);
            this.backgroundCamera2.matrixWorldInverse.getInverse(this.backgroundCamera2.matrixWorld);
            this.backgroundBoxMesh.material.uniforms["tCube"].value = background;
            this.backgroundBoxMesh.modelViewMatrix.multiplyMatrices(this.backgroundCamera2.matrixWorldInverse, this.backgroundBoxMesh.matrixWorld);
            this.objects.update(this.backgroundBoxMesh);
            this.renderBufferDirect(this.backgroundCamera2, null, this.backgroundBoxMesh.geometry, this.backgroundBoxMesh.material, this.backgroundBoxMesh, null);
        }
        else if (background && background instanceof Texture) {
            this.backgroundPlaneMesh.material.map = background;
            this.objects.update(this.backgroundPlaneMesh);
            this.renderBufferDirect(this.backgroundCamera, null, this.backgroundPlaneMesh.geometry, this.backgroundPlaneMesh.material, this.backgroundPlaneMesh, null);
        }
        //
        if (scene.overrideMaterial) {
            var overrideMaterial = scene.overrideMaterial;
            this.renderObjects(this.opaqueObjects, camera, scene, overrideMaterial);
            this.renderObjects(this.transparentObjects, camera, scene, overrideMaterial);
        }
        else {
            // opaque pass (front-to-back order)
            this.state.setBlending(BlendingMode.None);
            this.renderObjects(this.opaqueObjects, camera, scene);
            // transparent pass (back-to-front order)
            this.renderObjects(this.transparentObjects, camera, scene);
        }
        // custom render plugins (post pass)
        this.spritePlugin.render(scene, camera);
        this.lensFlarePlugin.render(scene, camera, this._currentViewport);
        // Generate mipmap if we're using any kind of mipmap filtering
        if (renderTarget) {
            this.textures.updateRenderTargetMipmap(renderTarget);
        }
        // Ensure depth buffer writing is enabled so it can be cleared on next render
        this.state.setDepthTest(true);
        this.state.setDepthWrite(true);
        this.state.setColorWrite(true);
        // _gl.finish();
    };
    WebGLRenderer.prototype.pushRenderItem = function (object, geometry, material, z, group) {
        var array, index;
        // allocate the next position in the appropriate array
        if (material.transparent) {
            array = this.transparentObjects;
            index = ++this.transparentObjectsLastIndex;
        }
        else {
            array = this.opaqueObjects;
            index = ++this.opaqueObjectsLastIndex;
        }
        // recycle existing render item or grow the array
        var renderItem = array[index];
        if (renderItem !== undefined) {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.z = this._vector3.z;
            renderItem.group = group;
        }
        else {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                z: this._vector3.z,
                group: group
            };
            // assert(index === array.length);
            array.push(renderItem);
        }
    };
    // TODO Duplicated code (Frustum)
    WebGLRenderer.prototype.isObjectViewable = function (object) {
        var geometry = object.geometry;
        if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
        this._sphere.copy(geometry.boundingSphere).
            applyMatrix4(object.matrixWorld);
        return this.isSphereViewable(this._sphere);
    };
    WebGLRenderer.prototype.isSpriteViewable = function (sprite) {
        this._sphere.center.set(0, 0, 0);
        this._sphere.radius = 0.7071067811865476;
        this._sphere.applyMatrix4(sprite.matrixWorld);
        return this.isSphereViewable(this._sphere);
    };
    WebGLRenderer.prototype.isSphereViewable = function (sphere) {
        if (!this._frustum.intersectsSphere(sphere))
            return false;
        var numPlanes = this._clipping.numPlanes;
        if (numPlanes === 0)
            return true;
        var planes = this.clippingPlanes;
        var center = sphere.center;
        var negRad = -sphere.radius;
        var i = 0;
        do {
            // out when deeper than radius in the negative halfspace
            if (planes[i].distanceToPoint(center) < negRad)
                return false;
        } while (++i !== numPlanes);
        return true;
    };
    WebGLRenderer.prototype.projectObject = function (object, camera) {
        if (object.visible === false)
            return;
        var visible = (object.layers.mask & camera.layers.mask) !== 0;
        if (visible) {
            if (object instanceof Light) {
                this.lights.push(object);
            }
            else if (object instanceof Sprite) {
                if (object.frustumCulled === false || this.isSpriteViewable(object) === true) {
                    this.sprites.push(object);
                }
            }
            else if (object instanceof LensFlare) {
                this.lensFlares.push(object);
            }
            else if (object instanceof ImmediateRenderObject) {
                if (this.sortObjects === true) {
                    this._vector3.setFromMatrixPosition(object.matrixWorld);
                    this._vector3.applyProjection(this._projScreenMatrix);
                }
                this.pushRenderItem(object, null, object.material, this._vector3.z, null);
            }
            else if (object instanceof Mesh || object instanceof Line || object instanceof Points) {
                if (object instanceof SkinnedMesh) {
                    object.skeleton.update();
                }
                if (object.frustumCulled === false || this.isObjectViewable(object) === true) {
                    var material = object.material;
                    if (material.visible === true) {
                        if (this.sortObjects === true) {
                            this._vector3.setFromMatrixPosition(object.matrixWorld);
                            this._vector3.applyProjection(this._projScreenMatrix);
                        }
                        var geometry = this.objects.update(object);
                        if (material instanceof MultiMaterial) {
                            var groups = geometry.groups;
                            var materials = material.materials;
                            for (var i = 0, l = groups.length; i < l; i++) {
                                var group = groups[i];
                                var groupMaterial = materials[group.materialIndex];
                                if (!groupMaterial)
                                    continue; /// HACK
                                if (groupMaterial.visible === true) {
                                    this.pushRenderItem(object, geometry, groupMaterial, this._vector3.z, group);
                                }
                            }
                        }
                        else {
                            this.pushRenderItem(object, geometry, material, this._vector3.z, null);
                        }
                    }
                }
            }
        }
        var children = object.children;
        for (var i = 0, l = children.length; i < l; i++) {
            this.projectObject(children[i], camera);
        }
    };
    WebGLRenderer.prototype.renderObjects = function (renderList, camera, scene, overrideMaterial) {
        var _loop_1 = function(i, l) {
            var renderItem = renderList[i];
            var object = renderItem.object;
            var geometry = renderItem.geometry;
            var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
            var group = renderItem.group;
            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            object.onBeforeRender(this_1, scene, camera, geometry, material, group);
            if (object instanceof ImmediateRenderObject) {
                this_1.setMaterial(material);
                var program_1 = this_1.setProgram(camera, scene.fog, material, object);
                this_1._currentGeometryProgram = '';
                var that_1 = this_1;
                object.render(function (object) {
                    that_1.renderBufferImmediate(object, program_1, material);
                });
            }
            else {
                this_1.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
            }
            object.onAfterRender(this_1, scene, camera, geometry, material, group);
        };
        var this_1 = this;
        for (var i = 0, l = renderList.length; i < l; i++) {
            _loop_1(i, l);
        }
    };
    WebGLRenderer.prototype.initMaterial = function (material, fog, object) {
        var materialProperties = this.properties.get(material);
        var parameters = this.programCache.getParameters(material, this._lights, fog, this._clipping.numPlanes, this._clipping.numIntersection, object);
        var code = this.programCache.getProgramCode(material, parameters);
        var program = materialProperties.program;
        var programChange = true;
        if (program === undefined) {
            // new material
            material.addEventListener('dispose', this.onMaterialDispose.bind(this));
        }
        else if (program.code !== code) {
            // changed glsl or parameters
            this.releaseMaterialProgramReference(material);
        }
        else if (parameters.shaderID !== undefined) {
            // same glsl and uniform list
            return;
        }
        else {
            // only rebuild uniform list
            programChange = false;
        }
        if (programChange) {
            if (parameters.shaderID) {
                var shader = ShaderLib[parameters.shaderID];
                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: UniformsUtils.clone(shader.uniforms),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                };
            }
            else {
                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };
            }
            material.__webglShader = materialProperties.__webglShader;
            program = this.programCache.acquireProgram(material, parameters, code);
            materialProperties.program = program;
            material.program = program;
        }
        var attributes = program.getAttributes();
        if (material.morphTargets) {
            material.numSupportedMorphTargets = 0;
            for (var i = 0; i < this.maxMorphTargets; i++) {
                if (attributes['morphTarget' + i] >= 0) {
                    material.numSupportedMorphTargets++;
                }
            }
        }
        if (material.morphNormals) {
            material.numSupportedMorphNormals = 0;
            for (var i = 0; i < this.maxMorphNormals; i++) {
                if (attributes['morphNormal' + i] >= 0) {
                    material.numSupportedMorphNormals++;
                }
            }
        }
        var uniforms = materialProperties.__webglShader.uniforms;
        if (!(material instanceof ShaderMaterial) &&
            !(material instanceof RawShaderMaterial) ||
            material.clipping === true) {
            materialProperties.numClippingPlanes = this._clipping.numPlanes;
            materialProperties.numIntersection = this._clipping.numIntersection;
            uniforms.clippingPlanes = this._clipping.uniform;
        }
        materialProperties.fog = fog;
        // store the light setup it was created for
        materialProperties.lightsHash = this._lights.hash;
        if (material.lights) {
            // wire up the material to this renderer's lighting state
            uniforms.ambientLightColor.value = this._lights.ambient;
            uniforms.directionalLights.value = this._lights.directional;
            uniforms.spotLights.value = this._lights.spot;
            uniforms.pointLights.value = this._lights.point;
            uniforms.hemisphereLights.value = this._lights.hemi;
            uniforms.directionalShadowMap.value = this._lights.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = this._lights.directionalShadowMatrix;
            uniforms.spotShadowMap.value = this._lights.spotShadowMap;
            uniforms.spotShadowMatrix.value = this._lights.spotShadowMatrix;
            uniforms.pointShadowMap.value = this._lights.pointShadowMap;
            uniforms.pointShadowMatrix.value = this._lights.pointShadowMatrix;
        }
        var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.uniformsList = uniformsList;
    };
    WebGLRenderer.prototype.setMaterial = function (material) {
        material.side === SideMode.Double
            ? this.state.disable(this._gl.CULL_FACE)
            : this.state.enable(this._gl.CULL_FACE);
        this.state.setFlipSided(material.side === SideMode.Back);
        material.transparent === true
            ? this.state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha)
            : this.state.setBlending(BlendingMode.None);
        this.state.setDepthFunc(material.depthFunc);
        this.state.setDepthTest(material.depthTest);
        this.state.setDepthWrite(material.depthWrite);
        this.state.setColorWrite(material.colorWrite);
        this.state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    };
    WebGLRenderer.prototype.setProgram = function (camera, fog, material, object) {
        this._usedTextureUnits = 0;
        var materialProperties = this.properties.get(material);
        if (this._clippingEnabled) {
            if (this._localClippingEnabled || camera !== this._currentCamera) {
                var useCache = camera === this._currentCamera &&
                    material.id === this._currentMaterialId;
                // we might want to call this function with some ClippingGroup
                // object instead of the material, once it becomes feasible
                // (#8465, #8379)
                this._clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
            }
        }
        if (material.needsUpdate === false) {
            if (materialProperties.program === undefined) {
                material.needsUpdate = true;
            }
            else if (material.fog && materialProperties.fog !== fog) {
                material.needsUpdate = true;
            }
            else if (material.lights && materialProperties.lightsHash !== this._lights.hash) {
                material.needsUpdate = true;
            }
            else if (materialProperties.numClippingPlanes !== undefined &&
                (materialProperties.numClippingPlanes !== this._clipping.numPlanes ||
                    materialProperties.numIntersection !== this._clipping.numIntersection)) {
                material.needsUpdate = true;
            }
        }
        if (material.needsUpdate) {
            this.initMaterial(material, fog, object);
            material.needsUpdate = false;
        }
        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;
        var program = materialProperties.program;
        var p_uniforms = program.getUniforms();
        var m_uniforms = materialProperties.__webglShader.uniforms;
        if (program.id !== this._currentProgram) {
            this._gl.useProgram(program.program);
            this._currentProgram = program.id;
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== this._currentMaterialId) {
            this._currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || camera !== this._currentCamera) {
            p_uniforms.set(this._gl, camera, 'projectionMatrix');
            if (this.capabilities.logarithmicDepthBuffer) {
                p_uniforms.setValue(this._gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
            }
            if (camera !== this._currentCamera) {
                this._currentCamera = camera;
                // lighting uniforms depend on the camera so enforce an update
                // now, in case this material supports lights - or later, when
                // the next material that does gets activated:
                refreshMaterial = true; // set to true on material change
                refreshLights = true; // remains set until update done
            }
            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)
            if (material instanceof ShaderMaterial ||
                material instanceof MeshPhongMaterial ||
                material instanceof MeshStandardMaterial ||
                material.envMap) {
                var uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) {
                    uCamPos.setValue(this._gl, this._vector3.setFromMatrixPosition(camera.matrixWorld));
                }
            }
            if (material instanceof MeshPhongMaterial ||
                material instanceof MeshLambertMaterial ||
                material instanceof MeshBasicMaterial ||
                material instanceof MeshStandardMaterial ||
                material instanceof ShaderMaterial ||
                material.skinning) {
                p_uniforms.setValue(this._gl, 'viewMatrix', camera.matrixWorldInverse);
            }
            p_uniforms.set(this._gl, this, 'toneMappingExposure');
            p_uniforms.set(this._gl, this, 'toneMappingWhitePoint');
        }
        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // not sure why, but otherwise weird things happen
        if (material.skinning) {
            p_uniforms.setOptional(this._gl, object, 'bindMatrix');
            p_uniforms.setOptional(this._gl, object, 'bindMatrixInverse');
            var skeleton = object.skeleton;
            if (skeleton) {
                if (this.capabilities.floatVertexTextures && skeleton.useVertexTexture) {
                    p_uniforms.set(this._gl, skeleton, 'boneTexture');
                    p_uniforms.set(this._gl, skeleton, 'boneTextureWidth');
                    p_uniforms.set(this._gl, skeleton, 'boneTextureHeight');
                }
                else {
                    p_uniforms.setOptional(this._gl, skeleton, 'boneMatrices');
                }
            }
        }
        if (refreshMaterial) {
            if (material.lights) {
                // the current material requires lighting info
                // note: all lighting uniforms are always set correctly
                // they simply reference the renderer's state for their
                // values
                //
                // use the current material's .needsUpdate flags to set
                // the GL state when required
                this.markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            }
            // refresh uniforms common to several materials
            if (fog && material.fog) {
                this.refreshUniformsFog(m_uniforms, fog);
            }
            if (material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshDepthMaterial) {
                this.refreshUniformsCommon(m_uniforms, material);
            }
            // refresh single material specific uniforms
            if (material instanceof LineBasicMaterial) {
                this.refreshUniformsLine(m_uniforms, material);
            }
            else if (material instanceof LineDashedMaterial) {
                this.refreshUniformsLine(m_uniforms, material);
                this.refreshUniformsDash(m_uniforms, material);
            }
            else if (material instanceof PointsMaterial) {
                this.refreshUniformsPoints(m_uniforms, material);
            }
            else if (material instanceof MeshLambertMaterial) {
                this.refreshUniformsLambert(m_uniforms, material);
            }
            else if (material instanceof MeshPhongMaterial) {
                this.refreshUniformsPhong(m_uniforms, material);
            }
            else if (material instanceof MeshPhysicalMaterial) {
                this.refreshUniformsPhysical(m_uniforms, material);
            }
            else if (material instanceof MeshStandardMaterial) {
                this.refreshUniformsStandard(m_uniforms, material);
            }
            else if (material instanceof MeshDepthMaterial) {
                if (material.displacementMap) {
                    m_uniforms.displacementMap.value = material.displacementMap;
                    m_uniforms.displacementScale.value = material.displacementScale;
                    m_uniforms.displacementBias.value = material.displacementBias;
                }
            }
            else if (material instanceof MeshNormalMaterial) {
                m_uniforms.opacity.value = material.opacity;
            }
            WebGLUniforms.upload(this._gl, materialProperties.uniformsList, m_uniforms, this);
        }
        // common matrices
        p_uniforms.set(this._gl, object, 'modelViewMatrix');
        p_uniforms.set(this._gl, object, 'normalMatrix');
        p_uniforms.setValue(this._gl, 'modelMatrix', object.matrixWorld);
        return program;
    };
    // Uniforms (refresh uniforms objects)
    WebGLRenderer.prototype.refreshUniformsCommon = function (uniforms, material) {
        uniforms.opacity.value = material.opacity;
        uniforms.diffuse.value = material.color;
        if (material.emissive) {
            uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        }
        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;
        if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map
        var uvScaleMap;
        if (material.map) {
            uvScaleMap = material.map;
        }
        else if (material.specularMap) {
            uvScaleMap = material.specularMap;
        }
        else if (material.displacementMap) {
            uvScaleMap = material.displacementMap;
        }
        else if (material.normalMap) {
            uvScaleMap = material.normalMap;
        }
        else if (material.bumpMap) {
            uvScaleMap = material.bumpMap;
        }
        else if (material.roughnessMap) {
            uvScaleMap = material.roughnessMap;
        }
        else if (material.metalnessMap) {
            uvScaleMap = material.metalnessMap;
        }
        else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
        }
        else if (material.emissiveMap) {
            uvScaleMap = material.emissiveMap;
        }
        if (uvScaleMap !== undefined) {
            // backwards compatibility
            if (uvScaleMap instanceof WebGLRenderTarget) {
                uvScaleMap = uvScaleMap.texture;
            }
            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;
            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
        uniforms.envMap.value = material.envMap;
        // don't flip CubeTexture envMaps, flip everything else:
        //  WebGLRenderTargetCube will be flipped for backwards compatibility
        //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
        // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
        uniforms.flipEnvMap.value = (!(material.envMap && material.envMap instanceof CubeTexture)) ? 1 : -1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
    };
    WebGLRenderer.prototype.refreshUniformsLine = function (uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
    };
    WebGLRenderer.prototype.refreshUniformsDash = function (uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    };
    WebGLRenderer.prototype.refreshUniformsPoints = function (uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * this._pixelRatio;
        uniforms.scale.value = this._height * 0.5;
        uniforms.map.value = material.map;
        if (material.map !== null) {
            var offset = material.map.offset;
            var repeat = material.map.repeat;
            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
    };
    WebGLRenderer.prototype.refreshUniformsFog = function (uniforms, fog) {
        uniforms.fogColor.value = fog.color;
        if (fog instanceof Fog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        }
        else if (fog instanceof FogExp2) {
            uniforms.fogDensity.value = fog.density;
        }
    };
    WebGLRenderer.prototype.refreshUniformsLambert = function (uniforms, material) {
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
        }
    };
    WebGLRenderer.prototype.refreshUniformsPhong = function (uniforms, material) {
        uniforms.specular.value = material.specular;
        uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow(0.0, 0.0)
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    };
    WebGLRenderer.prototype.refreshUniformsStandard = function (uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) {
            uniforms.roughnessMap.value = material.roughnessMap;
        }
        if (material.metalnessMap) {
            uniforms.metalnessMap.value = material.metalnessMap;
        }
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        if (material.envMap) {
            //uniforms.envMap.value = material.envMap; // part of uniforms common
            uniforms.envMapIntensity.value = material.envMapIntensity;
        }
    };
    WebGLRenderer.prototype.refreshUniformsPhysical = function (uniforms, material) {
        uniforms.clearCoat.value = material.clearCoat;
        uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
        this.refreshUniformsStandard(uniforms, material);
    };
    // If uniforms are marked as clean, they don't need to be loaded to the GPU.
    WebGLRenderer.prototype.markUniformsLightsNeedsUpdate = function (uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    };
    // Lighting
    WebGLRenderer.prototype.setupShadows = function (lights) {
        var lightShadowsLength = 0;
        for (var i = 0, l = lights.length; i < l; i++) {
            var light = lights[i];
            if (light.castShadow) {
                this._lights.shadows[lightShadowsLength++] = light;
            }
        }
        this._lights.shadows.length = lightShadowsLength;
    };
    WebGLRenderer.prototype.setupLights = function (lights, camera) {
        var r = 0, g = 0, b = 0;
        var viewMatrix = camera.matrixWorldInverse;
        var directionalLength = 0;
        var pointLength = 0;
        var spotLength = 0;
        var hemiLength = 0;
        for (var l = 0, ll = lights.length; l < ll; l++) {
            var light = lights[l];
            var color = light.color;
            var intensity = light.intensity;
            var distance = light.distance;
            var shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;
            if (light instanceof AmbientLight) {
                r += color.r * intensity;
                g += color.g * intensity;
                b += color.b * intensity;
            }
            else if (light instanceof DirectionalLight) {
                var uniforms = this.lightCache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                this._vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(this._vector3);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.shadow = light.castShadow;
                if (light.castShadow) {
                    uniforms.shadowBias = light.shadow.bias;
                    uniforms.shadowRadius = light.shadow.radius;
                    uniforms.shadowMapSize = light.shadow.mapSize;
                }
                this._lights.directionalShadowMap[directionalLength] = shadowMap;
                this._lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                this._lights.directional[directionalLength++] = uniforms;
            }
            else if (light instanceof SpotLight) {
                var uniforms = this.lightCache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.distance = distance;
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                this._vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(this._vector3);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
                uniforms.shadow = light.castShadow;
                if (light.castShadow) {
                    uniforms.shadowBias = light.shadow.bias;
                    uniforms.shadowRadius = light.shadow.radius;
                    uniforms.shadowMapSize = light.shadow.mapSize;
                }
                this._lights.spotShadowMap[spotLength] = shadowMap;
                this._lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
                this._lights.spot[spotLength++] = uniforms;
            }
            else if (light instanceof PointLight) {
                var uniforms = this.lightCache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.distance = light.distance;
                uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
                uniforms.shadow = light.castShadow;
                if (light.castShadow) {
                    uniforms.shadowBias = light.shadow.bias;
                    uniforms.shadowRadius = light.shadow.radius;
                    uniforms.shadowMapSize = light.shadow.mapSize;
                }
                this._lights.pointShadowMap[pointLength] = shadowMap;
                if (this._lights.pointShadowMatrix[pointLength] === undefined) {
                    this._lights.pointShadowMatrix[pointLength] = new Matrix4();
                }
                // for point lights we set the shadow matrix to be a translation-only matrix
                // equal to inverse of the light's position
                this._vector3.setFromMatrixPosition(light.matrixWorld).negate();
                this._lights.pointShadowMatrix[pointLength].identity().setPosition(this._vector3);
                this._lights.point[pointLength++] = uniforms;
            }
            else if (light instanceof HemisphereLight) {
                var uniforms = this.lightCache.get(light);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.direction.normalize();
                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                this._lights.hemi[hemiLength++] = uniforms;
            }
        }
        this._lights.ambient[0] = r;
        this._lights.ambient[1] = g;
        this._lights.ambient[2] = b;
        this._lights.directional.length = directionalLength;
        this._lights.spot.length = spotLength;
        this._lights.point.length = pointLength;
        this._lights.hemi.length = hemiLength;
        this._lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + this._lights.shadows.length;
    };
    // GL state setting
    WebGLRenderer.prototype.setFaceCulling = function (cullFace, frontFaceDirection) {
        this.state.setCullFace(cullFace);
        this.state.setFlipSided(frontFaceDirection === FrontFaceDirection.CW);
    };
    // Textures
    WebGLRenderer.prototype.allocTextureUnit = function () {
        var textureUnit = this._usedTextureUnits;
        if (textureUnit >= this.capabilities.maxTextures) {
            console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + this.capabilities.maxTextures);
        }
        this._usedTextureUnits += 1;
        return textureUnit;
    };
    ///this.allocTextureUnit = allocTextureUnit;
    // this.setTexture2D = setTexture2D;
    WebGLRenderer.prototype.setTexture2D = function (texture, slot) {
        var warned = false;
        // backwards compatibility: peel texture.texture
        //return function setTexture2D(texture, slot) {
        if (texture && texture instanceof WebGLRenderTarget) {
            if (!warned) {
                console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                warned = true;
            }
            texture = texture.texture;
        }
        this.textures.setTexture2D(texture, slot);
        //};
    };
    WebGLRenderer.prototype.setTexture = function (texture, slot) {
        var warned = false;
        //return function setTexture(texture, slot) {
        if (!warned) {
            console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
            warned = true;
        }
        this.textures.setTexture2D(texture, slot);
        //};
    };
    WebGLRenderer.prototype.setTextureCube = function (texture, slot) {
        var warned = false;
        //return function setTextureCube(texture, slot) {
        // backwards compatibility: peel texture.texture
        if (texture && texture instanceof WebGLRenderTargetCube) {
            if (!warned) {
                console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                warned = true;
            }
            texture = texture.texture;
        }
        // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
        // TODO: unify these code paths
        if ((texture && texture instanceof CubeTexture) ||
            (Array.isArray(texture.image) && texture.image.length === 6)) {
            // CompressedTexture can have Array in image :/
            // this function alone should take care of cube textures
            this.textures.setTextureCube(texture, slot);
        }
        else {
            // assumed: texture property of THREE.WebGLRenderTargetCube
            this.textures.setTextureCubeDynamic(texture, slot);
        }
        //};
    };
    WebGLRenderer.prototype.getCurrentRenderTarget = function () {
        return this._currentRenderTarget;
    };
    WebGLRenderer.prototype.setRenderTarget = function (renderTarget) {
        var _gl = this._gl;
        this._currentRenderTarget = renderTarget;
        if (renderTarget && this.properties.get(renderTarget).__webglFramebuffer === undefined) {
            this.textures.setupRenderTarget(renderTarget);
        }
        var framebuffer;
        if (renderTarget) {
            var renderTargetProperties = this.properties.get(renderTarget);
            if (renderTarget && renderTarget instanceof WebGLRenderTargetCube) {
                framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
            }
            else {
                framebuffer = renderTargetProperties.__webglFramebuffer;
            }
            this._currentScissor.copy(renderTarget.scissor);
            this._currentScissorTest = renderTarget.scissorTest;
            this._currentViewport.copy(renderTarget.viewport);
        }
        else {
            framebuffer = null;
            this._currentScissor.copy(this._scissor).multiplyScalar(this._pixelRatio);
            this._currentScissorTest = this._scissorTest;
            this._currentViewport.copy(this._viewport).multiplyScalar(this._pixelRatio);
        }
        if (this._currentFramebuffer !== framebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            this._currentFramebuffer = framebuffer;
        }
        this.state.scissor(this._currentScissor);
        this.state.setScissorTest(this._currentScissorTest);
        this.state.viewport(this._currentViewport);
        if (renderTarget && renderTarget instanceof WebGLRenderTargetCube) {
            var textureProperties = this.properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
        }
    };
    WebGLRenderer.prototype.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {
        var _gl = this._gl;
        if ((renderTarget && renderTarget instanceof WebGLRenderTarget) === false) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            return;
        }
        var framebuffer = this.properties.get(renderTarget).__webglFramebuffer;
        if (framebuffer) {
            var restore = false;
            if (framebuffer !== this._currentFramebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                restore = true;
            }
            try {
                var texture = renderTarget.texture;
                var textureFormat = texture.format;
                var textureType = texture.type;
                if (textureFormat !== TextureFormat.RGBA && this.paramThreeToGL(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                }
                if (textureType !== TextureType.UnsignedByte && this.paramThreeToGL(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) &&
                    !(textureType === TextureType.Float && (this.extensions.get('OES_texture_float') || this.extensions.get('WEBGL_color_buffer_float'))) &&
                    !(textureType === TextureType.HalfFloat && this.extensions.get('EXT_color_buffer_half_float'))) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in TextureType.UnsignedByte or implementation defined type.');
                    return;
                }
                if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                    // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                    if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
                        _gl.readPixels(x, y, width, height, this.paramThreeToGL(textureFormat), this.paramThreeToGL(textureType), buffer);
                    }
                }
                else {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                }
            }
            finally {
                if (restore) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, this._currentFramebuffer);
                }
            }
        }
    };
    // Map three.js constants to WebGL constants
    WebGLRenderer.prototype.paramThreeToGL = function (p) {
        var _gl = this._gl;
        var extension;
        if (p === TextureWrapping.Repeat)
            return _gl.REPEAT;
        if (p === TextureWrapping.ClampToEdge)
            return _gl.CLAMP_TO_EDGE;
        if (p === TextureWrapping.MirroredRepeat)
            return _gl.MIRRORED_REPEAT;
        if (p === TextureFilter.Nearest)
            return _gl.NEAREST;
        if (p === TextureFilter.NearestMipMapNearest)
            return _gl.NEAREST_MIPMAP_NEAREST;
        if (p === TextureFilter.NearestMipMapLinear)
            return _gl.NEAREST_MIPMAP_LINEAR;
        if (p === TextureFilter.Linear)
            return _gl.LINEAR;
        if (p === TextureFilter.LinearMipMapNearest)
            return _gl.LINEAR_MIPMAP_NEAREST;
        if (p === TextureFilter.LinearMipMapLinear)
            return _gl.LINEAR_MIPMAP_LINEAR;
        if (p === TextureType.UnsignedByte)
            return _gl.UNSIGNED_BYTE;
        if (p === TextureType.UnsignedShort4444)
            return _gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === TextureType.UnsignedShort5551)
            return _gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === TextureType.UnsignedShort565)
            return _gl.UNSIGNED_SHORT_5_6_5;
        if (p === TextureType.Byte)
            return _gl.BYTE;
        if (p === TextureType.Short)
            return _gl.SHORT;
        if (p === TextureType.UnsignedShort)
            return _gl.UNSIGNED_SHORT;
        if (p === TextureType.Int)
            return _gl.INT;
        if (p === TextureType.UnsignedInt)
            return _gl.UNSIGNED_INT;
        if (p === TextureType.Float)
            return _gl.FLOAT;
        if (p === TextureType.HalfFloat) {
            extension = this.extensions.get('OES_texture_half_float');
            if (extension !== null)
                return extension.HALF_FLOAT_OES;
        }
        if (p === TextureFormat.Alpha)
            return _gl.ALPHA;
        if (p === TextureFormat.RGB)
            return _gl.RGB;
        if (p === TextureFormat.RGBA)
            return _gl.RGBA;
        if (p === TextureFormat.Luminance)
            return _gl.LUMINANCE;
        if (p === TextureFormat.LuminanceAlpha)
            return _gl.LUMINANCE_ALPHA;
        if (p === TextureFormat.Depth)
            return _gl.DEPTH_COMPONENT;
        if (p === TextureFormat.DepthStencil)
            return _gl.DEPTH_STENCIL;
        if (p === BlendingEquation.Add)
            return _gl.FUNC_ADD;
        if (p === BlendingEquation.Subtract)
            return _gl.FUNC_SUBTRACT;
        if (p === BlendingEquation.ReverseSubtract)
            return _gl.FUNC_REVERSE_SUBTRACT;
        if (p === BlendingFactor.Zero)
            return _gl.ZERO;
        if (p === BlendingFactor.One)
            return _gl.ONE;
        if (p === BlendingFactor.SrcColor)
            return _gl.SRC_COLOR;
        if (p === BlendingFactor.OneMinusSrcColor)
            return _gl.ONE_MINUS_SRC_COLOR;
        if (p === BlendingFactor.SrcAlpha)
            return _gl.SRC_ALPHA;
        if (p === BlendingFactor.OneMinusSrcAlpha)
            return _gl.ONE_MINUS_SRC_ALPHA;
        if (p === BlendingFactor.DstAlpha)
            return _gl.DST_ALPHA;
        if (p === BlendingFactor.OneMinusDstAlpha)
            return _gl.ONE_MINUS_DST_ALPHA;
        if (p === BlendingFactor.DstColor)
            return _gl.DST_COLOR;
        if (p === BlendingFactor.OneMinusDstColor)
            return _gl.ONE_MINUS_DST_COLOR;
        if (p === BlendingFactor.SrcAlphaSaturate)
            return _gl.SRC_ALPHA_SATURATE;
        if (p === TextureFormat.RGB_S3TC_DXT1 || p === TextureFormat.RGBA_S3TC_DXT1 ||
            p === TextureFormat.RGBA_S3TC_DXT3 || p === TextureFormat.RGBA_S3TC_DXT5) {
            extension = this.extensions.get('WEBGL_compressed_texture_s3tc');
            if (extension !== null) {
                if (p === TextureFormat.RGB_S3TC_DXT1)
                    return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === TextureFormat.RGBA_S3TC_DXT1)
                    return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === TextureFormat.RGBA_S3TC_DXT3)
                    return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === TextureFormat.RGBA_S3TC_DXT5)
                    return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
        }
        if (p === TextureFormat.RGB_PVRTC_4BPPV1 || p === TextureFormat.RGB_PVRTC_2BPPV1 ||
            p === TextureFormat.RGBA_PVRTC_4BPPV1 || p === TextureFormat.RGBA_PVRTC_2BPPV1) {
            extension = this.extensions.get('WEBGL_compressed_texture_pvrtc');
            if (extension !== null) {
                if (p === TextureFormat.RGB_PVRTC_4BPPV1)
                    return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === TextureFormat.RGB_PVRTC_2BPPV1)
                    return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === TextureFormat.RGBA_PVRTC_4BPPV1)
                    return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === TextureFormat.RGBA_PVRTC_2BPPV1)
                    return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
        }
        if (p === TextureFormat.RGB_ETC1) {
            extension = this.extensions.get('WEBGL_compressed_texture_etc1');
            if (extension !== null) {
                if (p === TextureFormat.RGB_ETC1)
                    return extension.COMPRESSED_RGB_ETC1_WEBGL;
            }
        }
        if (p === BlendingEquation.Min || p === BlendingEquation.Max) {
            extension = this.extensions.get('EXT_blend_minmax');
            if (extension !== null) {
                if (p === BlendingEquation.Min)
                    return extension.MIN_EXT;
                if (p === BlendingEquation.Max)
                    return extension.MAX_EXT;
            }
        }
        if (p === TextureType.UnsignedInt248) {
            extension = this.extensions.get('WEBGL_depth_texture');
            if (extension !== null)
                return extension.UNSIGNED_INT_24_8_WEBGL;
        }
        return 0;
    };
    WebGLRenderer.prototype.supportsFloatTextures = function () {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get(\"OES_texture_float\").");
        return this.extensions.get("OES_texture_float");
    };
    WebGLRenderer.prototype.supportsHalfFloatTextures = function () {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get(\"OES_texture_half_float\").");
        return this.extensions.get("OES_texture_half_float");
    };
    WebGLRenderer.prototype.supportsStandardDerivatives = function () {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get(\"OES_standard_derivatives\").");
        return this.extensions.get("OES_standard_derivatives");
    };
    WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get(\"WEBGL_compressed_texture_s3tc\").");
        return this.extensions.get("WEBGL_compressed_texture_s3tc");
    };
    WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get(\"WEBGL_compressed_texture_pvrtc\").");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
    };
    WebGLRenderer.prototype.supportsBlendMinMax = function () {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get(\"EXT_blend_minmax\").");
        return this.extensions.get("EXT_blend_minmax");
    };
    WebGLRenderer.prototype.supportsVertexTextures = function () {
        return this.capabilities.vertexTextures;
    };
    WebGLRenderer.prototype.supportsInstancedArrays = function () {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get(\"ANGLE_instanced_arrays\").");
        return this.extensions.get("ANGLE_instanced_arrays");
    };
    WebGLRenderer.prototype.enableScissorTest = function (test) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(test);
    };
    //initMaterial() {
    //  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    //}
    WebGLRenderer.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    };
    WebGLRenderer.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    };
    WebGLRenderer.prototype.updateShadowMap = function () {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    };
    Object.defineProperty(WebGLRenderer.prototype, "shadowMapEnabled", {
        get: function () {
            return this.shadowMap.enabled;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
            this.shadowMap.enabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderer.prototype, "shadowMapType", {
        get: function () {
            return this.shadowMap.type;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
            this.shadowMap.type = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebGLRenderer.prototype, "shadowMapCullFace", {
        get: function () {
            return this.shadowMap.cullFace;
        },
        set: function (value) {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");
            this.shadowMap.cullFace = value;
        },
        enumerable: true,
        configurable: true
    });
    return WebGLRenderer;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var Scene = (function (_super) {
    __extends(Scene, _super);
    function Scene() {
        _super.call(this);
        this.background = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true; // checked by the renderer
        this.type = 'Scene';
    }
    Scene.prototype.copy = function (source, recursive) {
        _super.prototype.copy.call(this, source, recursive);
        if (source.background !== null)
            this.background = source.background.clone();
        if (source.fog !== null)
            this.fog = source.fog.clone();
        if (source.overrideMaterial !== null)
            this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    };
    Scene.prototype.toJSON = function (meta) {
        var data = _super.prototype.toJSON.call(this, meta);
        if (this.background !== null)
            data.object.background = this.background.toJSON(meta);
        if (this.fog !== null)
            data.object.fog = this.fog.toJSON(meta);
        return data;
    };
    return Scene;
}(Object3D));

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */
var LOD = (function (_super) {
    __extends(LOD, _super);
    function LOD() {
        _super.call(this);
        this.type = 'LOD';
        this.levels = [];
        //Object.defineProperties(this, {
        //  levels: {
        //    enumerable: true,
        //    value: []
        //  }
        //});
    }
    LOD.prototype.copy = function (source) {
        _super.prototype.copy.call(this, source, false);
        var levels = source.levels;
        for (var i = 0, l = levels.length; i < l; i++) {
            var level = levels[i];
            this.addLevel(level.object.clone(), level.distance);
        }
        return this;
    };
    LOD.prototype.addLevel = function (object, distance) {
        if (distance === undefined)
            distance = 0;
        distance = Math.abs(distance);
        var levels = this.levels;
        var l;
        for (l = 0; l < levels.length; l++) {
            if (distance < levels[l].distance) {
                break;
            }
        }
        levels.splice(l, 0, { distance: distance, object: object });
        this.add(object);
    };
    LOD.prototype.getObjectForDistance = function (distance) {
        var levels = this.levels;
        var i, l;
        for (i = 1, l = levels.length; i < l; i++) {
            if (distance < levels[i].distance) {
                break;
            }
        }
        return levels[i - 1].object;
    };
    LOD.prototype.raycast = function (raycaster, intersects) {
        var matrixPosition = new Vector3();
        //return function raycast(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(matrixPosition);
        this.getObjectForDistance(distance).raycast(raycaster, intersects);
        return intersects;
        //};
    };
    LOD.prototype.update = function (camera) {
        var v1 = new Vector3();
        var v2 = new Vector3();
        //return function update(camera) {
        var levels = this.levels;
        if (levels.length > 1) {
            v1.setFromMatrixPosition(camera.matrixWorld);
            v2.setFromMatrixPosition(this.matrixWorld);
            var distance = v1.distanceTo(v2);
            levels[0].object.visible = true;
            var i = void 0, l = void 0;
            for (i = 1, l = levels.length; i < l; i++) {
                if (distance >= levels[i].distance) {
                    levels[i - 1].object.visible = false;
                    levels[i].object.visible = true;
                }
                else {
                    break;
                }
            }
            for (; i < l; i++) {
                levels[i].object.visible = false;
            }
        }
        //};
    };
    LOD.prototype.toJSON = function (meta) {
        var data = _super.prototype.toJSON.call(this, meta);
        data.object.levels = [];
        var levels = this.levels;
        for (var i = 0, l = levels.length; i < l; i++) {
            var level = levels[i];
            data.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data;
    };
    Object.defineProperty(LOD.prototype, "objects", {
        get: function () {
            console.warn("THREE.LOD: .objects has been renamed to .levels.");
            return this.levels;
        },
        enumerable: true,
        configurable: true
    });
    return LOD;
}(Object3D));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var Group = (function (_super) {
    __extends(Group, _super);
    function Group() {
        _super.call(this);
        this.type = 'Group';
    }
    return Group;
}(Object3D));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var VideoTexture = (function (_super) {
    __extends(VideoTexture, _super);
    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        _super.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.generateMipmaps = false;
        var scope = this;
        function update() {
            requestAnimationFrame(update);
            if (video.readyState >= video.HAVE_CURRENT_DATA) {
                scope.needsUpdate = true;
            }
        }
        update();
    }
    return VideoTexture;
}(Texture));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var CanvasTexture = (function (_super) {
    __extends(CanvasTexture, _super);
    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        _super.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    }
    return CanvasTexture;
}(Texture));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var WireframeGeometry = (function (_super) {
    __extends(WireframeGeometry, _super);
    function WireframeGeometry(geometry) {
        _super.call(this);
        var edge = [0, 0], hash = {};
        function sortFunction(a, b) {
            return a - b;
        }
        var keys = ['a', 'b', 'c'];
        if (geometry && geometry instanceof Geometry) {
            var vertices = geometry.vertices;
            var faces = geometry.faces;
            var numEdges = 0;
            // allocate maximal size
            var edges = new Uint32Array(6 * faces.length);
            for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (var j = 0; j < 3; j++) {
                    edge[0] = face[keys[j]];
                    edge[1] = face[keys[(j + 1) % 3]];
                    edge.sort(sortFunction);
                    var key = edge.toString();
                    if (hash[key] === undefined) {
                        edges[2 * numEdges] = edge[0];
                        edges[2 * numEdges + 1] = edge[1];
                        hash[key] = true;
                        numEdges++;
                    }
                }
            }
            var coords = new Float32Array(numEdges * 2 * 3);
            for (var i = 0, l = numEdges; i < l; i++) {
                for (var j = 0; j < 2; j++) {
                    var vertex = vertices[edges[2 * i + j]];
                    var index = 6 * i + 3 * j;
                    coords[index + 0] = vertex.x;
                    coords[index + 1] = vertex.y;
                    coords[index + 2] = vertex.z;
                }
            }
            this.addAttribute('position', new BufferAttribute(coords, 3));
        }
        else if (geometry && geometry instanceof BufferGeometry) {
            if (geometry.index !== null) {
                // Indexed BufferGeometry
                var indices = geometry.index.array;
                var vertices = geometry.attributes.position;
                var groups = geometry.groups;
                var numEdges = 0;
                if (groups.length === 0) {
                    geometry.addGroup(0, indices.length);
                }
                // allocate maximal size
                var edges = new Uint32Array(2 * indices.length);
                for (var o = 0, ol = groups.length; o < ol; ++o) {
                    var group = groups[o];
                    var start = group.start;
                    var count = group.count;
                    for (var i = start, il = start + count; i < il; i += 3) {
                        for (var j = 0; j < 3; j++) {
                            edge[0] = indices[i + j];
                            edge[1] = indices[i + (j + 1) % 3];
                            edge.sort(sortFunction);
                            var key = edge.toString();
                            if (hash[key] === undefined) {
                                edges[2 * numEdges] = edge[0];
                                edges[2 * numEdges + 1] = edge[1];
                                hash[key] = true;
                                numEdges++;
                            }
                        }
                    }
                }
                var coords = new Float32Array(numEdges * 2 * 3);
                for (var i = 0, l = numEdges; i < l; i++) {
                    for (var j = 0; j < 2; j++) {
                        var index = 6 * i + 3 * j;
                        var index2 = edges[2 * i + j];
                        coords[index + 0] = vertices.getX(index2);
                        coords[index + 1] = vertices.getY(index2);
                        coords[index + 2] = vertices.getZ(index2);
                    }
                }
                this.addAttribute('position', new BufferAttribute(coords, 3));
            }
            else {
                // non-indexed BufferGeometry
                var vertices = geometry.attributes.position.array;
                var numEdges = vertices.length / 3;
                var numTris = numEdges / 3;
                var coords = new Float32Array(numEdges * 2 * 3);
                for (var i = 0, l = numTris; i < l; i++) {
                    for (var j = 0; j < 3; j++) {
                        var index = 18 * i + 6 * j;
                        var index1 = 9 * i + 3 * j;
                        coords[index + 0] = vertices[index1];
                        coords[index + 1] = vertices[index1 + 1];
                        coords[index + 2] = vertices[index1 + 2];
                        var index2 = 9 * i + 3 * ((j + 1) % 3);
                        coords[index + 3] = vertices[index2];
                        coords[index + 4] = vertices[index2 + 1];
                        coords[index + 5] = vertices[index2 + 2];
                    }
                }
                this.addAttribute('position', new BufferAttribute(coords, 3));
            }
        }
    }
    return WireframeGeometry;
}(BufferGeometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */
var ParametricBufferGeometry = (function (_super) {
    __extends(ParametricBufferGeometry, _super);
    function ParametricBufferGeometry(func, slices, stacks) {
        _super.call(this);
        this.type = 'ParametricBufferGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        // generate vertices and uvs
        var vertices = [];
        var uvs = [];
        var i, j, p;
        var u, v;
        var sliceCount = slices + 1;
        for (i = 0; i <= stacks; i++) {
            v = i / stacks;
            for (j = 0; j <= slices; j++) {
                u = j / slices;
                p = func(u, v);
                vertices.push(p.x, p.y, p.z);
                uvs.push(u, v);
            }
        }
        // generate indices
        var indices = [];
        var a, b, c, d;
        for (i = 0; i < stacks; i++) {
            for (j = 0; j < slices; j++) {
                a = i * sliceCount + j;
                b = i * sliceCount + j + 1;
                c = (i + 1) * sliceCount + j + 1;
                d = (i + 1) * sliceCount + j;
                // faces one and two
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex((indices.length > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
        this.addAttribute('position', Float32Attribute(vertices, 3));
        this.addAttribute('uv', Float32Attribute(uvs, 2));
        // generate normals
        this.computeVertexNormals();
    }
    return ParametricBufferGeometry;
}(BufferGeometry));

/**
 * @author zz85 / https://github.com/zz85
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */
var ParametricGeometry = (function (_super) {
    __extends(ParametricGeometry, _super);
    function ParametricGeometry(func, slices, stacks) {
        _super.call(this);
        this.type = 'ParametricGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
        this.mergeVertices();
    }
    return ParametricGeometry;
}(Geometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 */
var PolyhedronBufferGeometry = (function (_super) {
    __extends(PolyhedronBufferGeometry, _super);
    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
        _super.call(this);
        this.type = 'PolyhedronBufferGeometry';
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
        radius = radius || 1;
        detail = detail || 0;
        // default buffer data
        var vertexBuffer = [];
        var uvBuffer = [];
        // the subdivision creates the vertex buffer data
        subdivide(detail);
        // all vertices should lie on a conceptual sphere with a given radius
        appplyRadius(radius);
        // finally, create the uv data
        generateUVs();
        // build non-indexed geometry
        this.addAttribute('position', Float32Attribute(vertexBuffer, 3));
        this.addAttribute('normal', Float32Attribute(vertexBuffer.slice(), 3));
        this.addAttribute('uv', Float32Attribute(uvBuffer, 2));
        this.normalizeNormals();
        this.boundingSphere = new Sphere(new Vector3(), radius);
        // helper functions
        function subdivide(detail) {
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
            // iterate over all faces and apply a subdivison with the given detail value
            for (var i = 0; i < indices.length; i += 3) {
                // get the vertices of the face
                getVertexByIndex(indices[i + 0], a);
                getVertexByIndex(indices[i + 1], b);
                getVertexByIndex(indices[i + 2], c);
                // perform subdivision
                subdivideFace(a, b, c, detail);
            }
        }
        function subdivideFace(a, b, c, detail) {
            var cols = Math.pow(2, detail);
            // we use this multidimensional array as a data structure for creating the subdivision
            var v = [];
            var i, j;
            // construct all of the vertices for this subdivision
            for (i = 0; i <= cols; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols);
                var bj = b.clone().lerp(c, i / cols);
                var rows = cols - i;
                for (j = 0; j <= rows; j++) {
                    if (j === 0 && i === cols) {
                        v[i][j] = aj;
                    }
                    else {
                        v[i][j] = aj.clone().lerp(bj, j / rows);
                    }
                }
            }
            // construct all of the faces
            for (i = 0; i < cols; i++) {
                for (j = 0; j < 2 * (cols - i) - 1; j++) {
                    var k = Math.floor(j / 2);
                    if (j % 2 === 0) {
                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k]);
                        pushVertex(v[i][k]);
                    }
                    else {
                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k + 1]);
                        pushVertex(v[i + 1][k]);
                    }
                }
            }
        }
        function appplyRadius(radius) {
            var vertex = new Vector3();
            // iterate over the entire buffer and apply the radius to each vertex
            for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                vertex.normalize().multiplyScalar(radius);
                vertexBuffer[i + 0] = vertex.x;
                vertexBuffer[i + 1] = vertex.y;
                vertexBuffer[i + 2] = vertex.z;
            }
        }
        function generateUVs() {
            var vertex = new Vector3();
            for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                var v = inclination(vertex) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }
        function correctSeam() {
            // handle case when face straddles the seam, see #3269
            for (var i = 0; i < uvBuffer.length; i += 6) {
                // uv data of a single face
                var x0 = uvBuffer[i + 0];
                var x1 = uvBuffer[i + 2];
                var x2 = uvBuffer[i + 4];
                var max = Math.max(x0, x1, x2);
                var min = Math.min(x0, x1, x2);
                // 0.9 is somewhat arbitrary
                if (max > 0.9 && min < 0.1) {
                    if (x0 < 0.2)
                        uvBuffer[i + 0] += 1;
                    if (x1 < 0.2)
                        uvBuffer[i + 2] += 1;
                    if (x2 < 0.2)
                        uvBuffer[i + 4] += 1;
                }
            }
        }
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }
        function getVertexByIndex(index, vertex) {
            var stride = index * 3;
            vertex.x = vertices[stride + 0];
            vertex.y = vertices[stride + 1];
            vertex.z = vertices[stride + 2];
        }
        function correctUVs() {
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
            var centroid = new Vector3();
            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();
            for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a).add(b).add(c).divideScalar(3);
                var azi = azimuth(centroid);
                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
            }
        }
        function correctUV(uv, stride, vector, azimuth) {
            if ((azimuth < 0) && (uv.x === 1)) {
                uvBuffer[stride] = uv.x - 1;
            }
            if ((vector.x === 0) && (vector.z === 0)) {
                uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
            }
        }
        // Angle around the Y axis, counter-clockwise when looking from above.
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        // Angle above the XZ plane.
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
        }
    }
    return PolyhedronBufferGeometry;
}(BufferGeometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 */
var TetrahedronBufferGeometry = (function (_super) {
    __extends(TetrahedronBufferGeometry, _super);
    function TetrahedronBufferGeometry(radius, detail) {
        var vertices = [
            1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
        ];
        var indices = [
            2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
        ];
        _super.call(this, vertices, indices, radius, detail);
        this.type = 'TetrahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    return TetrahedronBufferGeometry;
}(PolyhedronBufferGeometry));

/**
 * @author timothypratley / https://github.com/timothypratley
 */
var TetrahedronGeometry = (function (_super) {
    __extends(TetrahedronGeometry, _super);
    function TetrahedronGeometry(radius, detail) {
        _super.call(this);
        this.type = 'TetrahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    return TetrahedronGeometry;
}(Geometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 */
var OctahedronBufferGeometry = (function (_super) {
    __extends(OctahedronBufferGeometry, _super);
    function OctahedronBufferGeometry(radius, detail) {
        var vertices = [
            1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1
        ];
        var indices = [
            0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2
        ];
        _super.call(this, vertices, indices, radius, detail);
        this.type = 'OctahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    return OctahedronBufferGeometry;
}(PolyhedronBufferGeometry));

/**
 * @author timothypratley / https://github.com/timothypratley
 */
var OctahedronGeometry = (function (_super) {
    __extends(OctahedronGeometry, _super);
    function OctahedronGeometry(radius, detail) {
        _super.call(this);
        this.type = 'OctahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    return OctahedronGeometry;
}(Geometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 */
var IcosahedronBufferGeometry = (function (_super) {
    __extends(IcosahedronBufferGeometry, _super);
    function IcosahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2;
        var vertices = [
            -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
            0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
            t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
        ];
        var indices = [
            0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
            1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
            3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
            4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
        ];
        _super.call(this, vertices, indices, radius, detail);
        this.type = 'IcosahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    return IcosahedronBufferGeometry;
}(PolyhedronBufferGeometry));

/**
 * @author timothypratley / https://github.com/timothypratley
 */
var IcosahedronGeometry = (function (_super) {
    __extends(IcosahedronGeometry, _super);
    function IcosahedronGeometry(radius, detail) {
        _super.call(this);
        this.type = 'IcosahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    return IcosahedronGeometry;
}(Geometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 */
var DodecahedronBufferGeometry = (function (_super) {
    __extends(DodecahedronBufferGeometry, _super);
    function DodecahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2;
        var r = 1 / t;
        var vertices = [
            // (1, 1, 1)
            -1, -1, -1, -1, -1, 1,
            -1, 1, -1, -1, 1, 1,
            1, -1, -1, 1, -1, 1,
            1, 1, -1, 1, 1, 1,
            // (0, 1/, )
            0, -r, -t, 0, -r, t,
            0, r, -t, 0, r, t,
            // (1/, , 0)
            -r, -t, 0, -r, t, 0,
            r, -t, 0, r, t, 0,
            // (, 0, 1/)
            -t, 0, -r, t, 0, -r,
            -t, 0, r, t, 0, r
        ];
        var indices = [
            3, 11, 7, 3, 7, 15, 3, 15, 13,
            7, 19, 17, 7, 17, 6, 7, 6, 15,
            17, 4, 8, 17, 8, 10, 17, 10, 6,
            8, 0, 16, 8, 16, 2, 8, 2, 10,
            0, 12, 1, 0, 1, 18, 0, 18, 16,
            6, 10, 2, 6, 2, 13, 6, 13, 15,
            2, 16, 18, 2, 18, 3, 2, 3, 13,
            18, 1, 9, 18, 9, 11, 18, 11, 3,
            4, 14, 12, 4, 12, 0, 4, 0, 8,
            11, 9, 5, 11, 5, 19, 11, 19, 7,
            19, 5, 14, 19, 14, 4, 19, 4, 17,
            1, 12, 14, 1, 14, 5, 1, 5, 9
        ];
        _super.call(this, vertices, indices, radius, detail);
        this.type = 'DodecahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    return DodecahedronBufferGeometry;
}(PolyhedronBufferGeometry));

/**
 * @author Abe Pazos / https://hamoid.com
 */
var DodecahedronGeometry = (function (_super) {
    __extends(DodecahedronGeometry, _super);
    function DodecahedronGeometry(radius, detail) {
        _super.call(this);
        this.type = 'DodecahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    return DodecahedronGeometry;
}(Geometry));

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/
function PolyhedronGeometry(vertices, indices, radius, detail) {
    Geometry.call(this);
    this.type = 'PolyhedronGeometry';
    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
    this.mergeVertices();
}
PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Creates a tube which extrudes along a 3d spline.
 *
 */
var TubeBufferGeometry = (function (_super) {
    __extends(TubeBufferGeometry, _super);
    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
        _super.call(this);
        this.type = 'TubeBufferGeometry';
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        tubularSegments = tubularSegments || 64;
        radius = radius || 1;
        radialSegments = radialSegments || 8;
        closed = closed || false;
        var frames = path.computeFrenetFrames(tubularSegments, closed);
        // expose internals
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        // helper variables
        var vertex = new Vector3();
        var normal = new Vector3();
        var uv = new Vector2();
        // buffer
        var vertices = [];
        var normals = [];
        var uvs = [];
        var indices = [];
        // create buffer data
        generateBufferData();
        // build geometry
        this.setIndex((indices.length > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
        this.addAttribute('position', Float32Attribute(vertices, 3));
        this.addAttribute('normal', Float32Attribute(normals, 3));
        this.addAttribute('uv', Float32Attribute(uvs, 2));
        // functions
        function generateBufferData() {
            for (var i = 0; i < tubularSegments; i++) {
                generateSegment(i);
            }
            // if the geometry is not closed, generate the last row of vertices and normals
            // at the regular position on the given path
            //
            // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
            generateSegment((closed === false) ? tubularSegments : 0);
            // uvs are generated in a separate function.
            // this makes it easy compute correct values for closed geometries
            generateUVs();
            // finally create faces
            generateIndices();
        }
        function generateSegment(i) {
            // we use getPointAt to sample evenly distributed points from the given path
            var P = path.getPointAt(i / tubularSegments);
            // retrieve corresponding normal and binormal
            var N = frames.normals[i];
            var B = frames.binormals[i];
            // generate normals and vertices for the current segment
            for (var j = 0; j <= radialSegments; j++) {
                var v = j / radialSegments * Math.PI * 2;
                var sin = Math.sin(v);
                var cos = -Math.cos(v);
                // normal
                normal.x = (cos * N.x + sin * B.x);
                normal.y = (cos * N.y + sin * B.y);
                normal.z = (cos * N.z + sin * B.z);
                normal.normalize();
                normals.push(normal.x, normal.y, normal.z);
                // vertex
                vertex.x = P.x + radius * normal.x;
                vertex.y = P.y + radius * normal.y;
                vertex.z = P.z + radius * normal.z;
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        function generateIndices() {
            for (var j = 1; j <= tubularSegments; j++) {
                for (var i = 1; i <= radialSegments; i++) {
                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
                    var b = (radialSegments + 1) * j + (i - 1);
                    var c = (radialSegments + 1) * j + i;
                    var d = (radialSegments + 1) * (j - 1) + i;
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
        }
        function generateUVs() {
            for (var i = 0; i <= tubularSegments; i++) {
                for (var j = 0; j <= radialSegments; j++) {
                    uv.x = i / tubularSegments;
                    uv.y = j / radialSegments;
                    uvs.push(uv.x, uv.y);
                }
            }
        }
    }
    return TubeBufferGeometry;
}(BufferGeometry));

/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Creates a tube which extrudes along a 3d spline.
 */
var TubeGeometry = (function (_super) {
    __extends(TubeGeometry, _super);
    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
        _super.call(this);
        this.type = 'TubeGeometry';
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        if (taper !== undefined)
            console.warn('THREE.TubeGeometry: taper has been removed.');
        var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
        // expose internals
        this.tangents = bufferGeometry.tangents;
        this.normals = bufferGeometry.normals;
        this.binormals = bufferGeometry.binormals;
        // create geometry
        this.fromBufferGeometry(bufferGeometry);
        this.mergeVertices();
    }
    return TubeGeometry;
}(Geometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * see: http://www.blackpawn.com/texts/pqtorus/
 */
var TorusKnotBufferGeometry = (function (_super) {
    __extends(TorusKnotBufferGeometry, _super);
    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
        _super.call(this);
        this.type = 'TorusKnotBufferGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
        radius = radius || 100;
        tube = tube || 40;
        tubularSegments = Math.floor(tubularSegments) || 64;
        radialSegments = Math.floor(radialSegments) || 8;
        p = p || 2;
        q = q || 3;
        // used to calculate buffer length
        var vertexCount = ((radialSegments + 1) * (tubularSegments + 1));
        var indexCount = radialSegments * tubularSegments * 2 * 3;
        // buffers
        var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
        var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
        var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
        var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
        // helper variables
        var index = 0, indexOffset = 0;
        var vertex = new Vector3();
        var normal = new Vector3();
        var uv = new Vector2();
        var P1 = new Vector3();
        var P2 = new Vector3();
        var B = new Vector3();
        var T = new Vector3();
        var N = new Vector3();
        // generate vertices, normals and uvs
        for (var i = 0; i <= tubularSegments; ++i) {
            // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
            var u = i / tubularSegments * p * Math.PI * 2;
            // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
            // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
            calculatePositionOnCurve(u, p, q, radius, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
            // calculate orthonormal basis
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            // normalize B, N. T can be ignored, we don't use it
            B.normalize();
            N.normalize();
            for (var j = 0; j <= radialSegments; ++j) {
                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                var v = j / radialSegments * Math.PI * 2;
                var cx = -tube * Math.cos(v);
                var cy = tube * Math.sin(v);
                // now calculate the final vertex position.
                // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
                vertex.x = P1.x + (cx * N.x + cy * B.x);
                vertex.y = P1.y + (cx * N.y + cy * B.y);
                vertex.z = P1.z + (cx * N.z + cy * B.z);
                // vertex
                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                normal.subVectors(vertex, P1).normalize();
                normals.setXYZ(index, normal.x, normal.y, normal.z);
                // uv
                uv.x = i / tubularSegments;
                uv.y = j / radialSegments;
                uvs.setXY(index, uv.x, uv.y);
                // increase index
                index++;
            }
        }
        // generate indices
        for (var j = 1; j <= tubularSegments; j++) {
            for (var i = 1; i <= radialSegments; i++) {
                // indices
                var a = (radialSegments + 1) * (j - 1) + (i - 1);
                var b = (radialSegments + 1) * j + (i - 1);
                var c = (radialSegments + 1) * j + i;
                var d = (radialSegments + 1) * (j - 1) + i;
                // face one
                indices.setX(indexOffset, a);
                indexOffset++;
                indices.setX(indexOffset, b);
                indexOffset++;
                indices.setX(indexOffset, d);
                indexOffset++;
                // face two
                indices.setX(indexOffset, b);
                indexOffset++;
                indices.setX(indexOffset, c);
                indexOffset++;
                indices.setX(indexOffset, d);
                indexOffset++;
            }
        }
        // build geometry
        this.setIndex(indices);
        this.addAttribute('position', vertices);
        this.addAttribute('normal', normals);
        this.addAttribute('uv', uvs);
        // this function calculates the current position on the torus curve
        function calculatePositionOnCurve(u, p, q, radius, position) {
            var cu = Math.cos(u);
            var su = Math.sin(u);
            var quOverP = q / p * u;
            var cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * 0.5 * cu;
            position.y = radius * (2 + cs) * su * 0.5;
            position.z = radius * Math.sin(quOverP) * 0.5;
        }
    }
    return TorusKnotBufferGeometry;
}(BufferGeometry));

/**
 * @author oosmoxiecode
 */
var TorusKnotGeometry = (function (_super) {
    __extends(TorusKnotGeometry, _super);
    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
        _super.call(this);
        this.type = 'TorusKnotGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
        if (heightScale !== undefined)
            console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale(x, y, z) instead.');
        this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
        this.mergeVertices();
    }
    return TorusKnotGeometry;
}(Geometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 */
var TorusBufferGeometry = (function (_super) {
    __extends(TorusBufferGeometry, _super);
    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        _super.call(this);
        this.type = 'TorusBufferGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        radius = radius || 100;
        tube = tube || 40;
        radialSegments = Math.floor(radialSegments) || 8;
        tubularSegments = Math.floor(tubularSegments) || 6;
        arc = arc || Math.PI * 2;
        // used to calculate buffer length
        var vertexCount = ((radialSegments + 1) * (tubularSegments + 1));
        var indexCount = radialSegments * tubularSegments * 2 * 3;
        // buffers
        var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
        var vertices = new Float32Array(vertexCount * 3);
        var normals = new Float32Array(vertexCount * 3);
        var uvs = new Float32Array(vertexCount * 2);
        // offset variables
        var vertexBufferOffset = 0;
        var uvBufferOffset = 0;
        var indexBufferOffset = 0;
        // helper variables
        var center = new Vector3();
        var vertex = new Vector3();
        var normal = new Vector3();
        // generate vertices, normals and uvs
        for (var j = 0; j <= radialSegments; j++) {
            for (var i = 0; i <= tubularSegments; i++) {
                var u = i / tubularSegments * arc;
                var v = j / radialSegments * Math.PI * 2;
                // vertex
                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                vertex.z = tube * Math.sin(v);
                vertices[vertexBufferOffset] = vertex.x;
                vertices[vertexBufferOffset + 1] = vertex.y;
                vertices[vertexBufferOffset + 2] = vertex.z;
                // this vector is used to calculate the normal
                center.x = radius * Math.cos(u);
                center.y = radius * Math.sin(u);
                // normal
                normal.subVectors(vertex, center).normalize();
                normals[vertexBufferOffset] = normal.x;
                normals[vertexBufferOffset + 1] = normal.y;
                normals[vertexBufferOffset + 2] = normal.z;
                // uv
                uvs[uvBufferOffset] = i / tubularSegments;
                uvs[uvBufferOffset + 1] = j / radialSegments;
                // update offsets
                vertexBufferOffset += 3;
                uvBufferOffset += 2;
            }
        }
        // generate indices
        for (var j = 1; j <= radialSegments; j++) {
            for (var i = 1; i <= tubularSegments; i++) {
                // indices
                var a = (tubularSegments + 1) * j + i - 1;
                var b = (tubularSegments + 1) * (j - 1) + i - 1;
                var c = (tubularSegments + 1) * (j - 1) + i;
                var d = (tubularSegments + 1) * j + i;
                // face one
                indices[indexBufferOffset] = a;
                indices[indexBufferOffset + 1] = b;
                indices[indexBufferOffset + 2] = d;
                // face two
                indices[indexBufferOffset + 3] = b;
                indices[indexBufferOffset + 4] = c;
                indices[indexBufferOffset + 5] = d;
                // update offset
                indexBufferOffset += 6;
            }
        }
        // build geometry
        this.setIndex(new BufferAttribute(indices, 1));
        this.addAttribute('position', new BufferAttribute(vertices, 3));
        this.addAttribute('normal', new BufferAttribute(normals, 3));
        this.addAttribute('uv', new BufferAttribute(uvs, 2));
    }
    return TorusBufferGeometry;
}(BufferGeometry));

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */
var TorusGeometry = (function (_super) {
    __extends(TorusGeometry, _super);
    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        _super.call(this);
        this.type = 'TorusGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
    }
    return TorusGeometry;
}(Geometry));

var ShapeUtils = (function () {
    function ShapeUtils() {
    }
    // calculate area of the contour polygon
    ShapeUtils.area = function (contour) {
        var n = contour.length;
        var a = 0.0;
        for (var p = n - 1, q = 0; q < n; p = q++) {
            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
    };
    ShapeUtils.triangulate = function (contour, indices) {
        /**
         * This code is a quick port of code written in C++ which was submitted to
         * flipcode.com by John W. Ratcliff  // July 22, 2000
         * See original code and more information here:
         * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
         *
         * ported to actionscript by Zevan Rosser
         * www.actionsnippet.com
         *
         * ported to javascript by Joshua Koo
         * http://www.lab4games.net/zz85/blog
         *
         */
        function snip(contour, u, v, w, n, verts) {
            var p;
            var ax, ay, bx, by;
            var cx, cy, px, py;
            ax = contour[verts[u]].x;
            ay = contour[verts[u]].y;
            bx = contour[verts[v]].x;
            by = contour[verts[v]].y;
            cx = contour[verts[w]].x;
            cy = contour[verts[w]].y;
            if ((bx - ax) * (cy - ay) - (by - ay) * (cx - ax) <= 0)
                return false;
            var aX, aY, bX, bY, cX, cY;
            var apx, apy, bpx, bpy, cpx, cpy;
            var cCROSSap, bCROSScp, aCROSSbp;
            aX = cx - bx;
            aY = cy - by;
            bX = ax - cx;
            bY = ay - cy;
            cX = bx - ax;
            cY = by - ay;
            for (p = 0; p < n; p++) {
                px = contour[verts[p]].x;
                py = contour[verts[p]].y;
                if (((px === ax) && (py === ay)) ||
                    ((px === bx) && (py === by)) ||
                    ((px === cx) && (py === cy)))
                    continue;
                apx = px - ax;
                apy = py - ay;
                bpx = px - bx;
                bpy = py - by;
                cpx = px - cx;
                cpy = py - cy;
                // see if p is inside triangle abc
                aCROSSbp = aX * bpy - aY * bpx;
                cCROSSap = cX * apy - cY * apx;
                bCROSScp = bX * cpy - bY * cpx;
                if ((aCROSSbp >= -Number.EPSILON) && (bCROSScp >= -Number.EPSILON) && (cCROSSap >= -Number.EPSILON))
                    return false;
            }
            return true;
        }
        // takes in an contour array and returns
        //return function triangulate(contour, indices) {
        var n = contour.length;
        if (n < 3)
            return null;
        var result = [];
        var verts = [];
        var vertIndices = [];
        /* we want a counter-clockwise polygon in verts */
        var u, v, w;
        if (ShapeUtils.area(contour) > 0.0) {
            for (v = 0; v < n; v++)
                verts[v] = v;
        }
        else {
            for (v = 0; v < n; v++)
                verts[v] = (n - 1) - v;
        }
        var nv = n;
        /*  remove nv - 2 vertices, creating 1 triangle every time */
        var count = 2 * nv; /* error detection */
        for (v = nv - 1; nv > 2;) {
            /* if we loop, it is probably a non-simple polygon */
            if ((count--) <= 0) {
                //** Triangulate: ERROR - probable bad polygon!
                //throw ("Warning, unable to triangulate polygon!");
                //return null;
                // Sometimes warning is fine, especially polygons are triangulated in reverse.
                console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');
                if (indices)
                    return vertIndices;
                return result;
            }
            /* three consecutive vertices in current polygon, <u,v,w> */
            u = v;
            if (nv <= u)
                u = 0; /* previous */
            v = u + 1;
            if (nv <= v)
                v = 0; /* new v    */
            w = v + 1;
            if (nv <= w)
                w = 0; /* next     */
            if (snip(contour, u, v, w, nv, verts)) {
                var a = void 0, b = void 0, c = void 0, s = void 0, t = void 0;
                /* true names of the vertices */
                a = verts[u];
                b = verts[v];
                c = verts[w];
                /* output Triangle */
                result.push([contour[a], contour[b], contour[c]]);
                vertIndices.push([verts[u], verts[v], verts[w]]);
                /* remove v from the remaining polygon */
                for (s = v, t = v + 1; t < nv; s++, t++) {
                    verts[s] = verts[t];
                }
                nv--;
                /* reset error detection counter */
                count = 2 * nv;
            }
        }
        if (indices)
            return vertIndices;
        return result;
        //};
    };
    ShapeUtils.triangulateShape = function (contour, holes) {
        function removeDupEndPts(points) {
            var l = points.length;
            if (l > 2 && points[l - 1].equals(points[0])) {
                points.pop();
            }
        }
        removeDupEndPts(contour);
        holes.forEach(removeDupEndPts);
        function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
            // inOtherPt needs to be collinear to the inSegment
            if (inSegPt1.x !== inSegPt2.x) {
                if (inSegPt1.x < inSegPt2.x) {
                    return ((inSegPt1.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt2.x));
                }
                else {
                    return ((inSegPt2.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt1.x));
                }
            }
            else {
                if (inSegPt1.y < inSegPt2.y) {
                    return ((inSegPt1.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt2.y));
                }
                else {
                    return ((inSegPt2.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt1.y));
                }
            }
        }
        function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
            var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
            var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
            var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
            var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
            var limit = seg1dy * seg2dx - seg1dx * seg2dy;
            var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
            if (Math.abs(limit) > Number.EPSILON) {
                // not parallel
                var perpSeg2 = void 0;
                if (limit > 0) {
                    if ((perpSeg1 < 0) || (perpSeg1 > limit))
                        return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ((perpSeg2 < 0) || (perpSeg2 > limit))
                        return [];
                }
                else {
                    if ((perpSeg1 > 0) || (perpSeg1 < limit))
                        return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if ((perpSeg2 > 0) || (perpSeg2 < limit))
                        return [];
                }
                // i.e. to reduce rounding errors
                // intersection at endpoint of segment#1?
                if (perpSeg2 === 0) {
                    if ((inExcludeAdjacentSegs) &&
                        ((perpSeg1 === 0) || (perpSeg1 === limit)))
                        return [];
                    return [inSeg1Pt1];
                }
                if (perpSeg2 === limit) {
                    if ((inExcludeAdjacentSegs) &&
                        ((perpSeg1 === 0) || (perpSeg1 === limit)))
                        return [];
                    return [inSeg1Pt2];
                }
                // intersection at endpoint of segment#2?
                if (perpSeg1 === 0)
                    return [inSeg2Pt1];
                if (perpSeg1 === limit)
                    return [inSeg2Pt2];
                // return real intersection point
                var factorSeg1 = perpSeg2 / limit;
                return [new Vector2(inSeg1Pt1.x + factorSeg1 * seg1dx, inSeg1Pt1.y + factorSeg1 * seg1dy)];
            }
            else {
                // parallel or collinear
                if ((perpSeg1 !== 0) ||
                    (seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy))
                    return [];
                // they are collinear or degenerate
                var seg1Pt = ((seg1dx === 0) && (seg1dy === 0)); // segment1 is just a point?
                var seg2Pt = ((seg2dx === 0) && (seg2dy === 0)); // segment2 is just a point?
                // both segments are points
                if (seg1Pt && seg2Pt) {
                    if ((inSeg1Pt1.x !== inSeg2Pt1.x) || (inSeg1Pt1.y !== inSeg2Pt1.y))
                        return []; // they are distinct  points
                    return [inSeg1Pt1]; // they are the same point
                }
                // segment#1  is a single point
                if (seg1Pt) {
                    if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
                        return []; // but not in segment#2
                    return [inSeg1Pt1];
                }
                // segment#2  is a single point
                if (seg2Pt) {
                    if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
                        return []; // but not in segment#1
                    return [inSeg2Pt1];
                }
                // they are collinear segments, which might overlap
                var seg1min = void 0, seg1max = void 0, seg1minVal = void 0, seg1maxVal = void 0;
                var seg2min = void 0, seg2max = void 0, seg2minVal = void 0, seg2maxVal = void 0;
                if (seg1dx !== 0) {
                    // the segments are NOT on a vertical line
                    if (inSeg1Pt1.x < inSeg1Pt2.x) {
                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.x;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.x;
                    }
                    else {
                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.x;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.x;
                    }
                    if (inSeg2Pt1.x < inSeg2Pt2.x) {
                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.x;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.x;
                    }
                    else {
                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.x;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.x;
                    }
                }
                else {
                    // the segments are on a vertical line
                    if (inSeg1Pt1.y < inSeg1Pt2.y) {
                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.y;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.y;
                    }
                    else {
                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.y;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.y;
                    }
                    if (inSeg2Pt1.y < inSeg2Pt2.y) {
                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.y;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.y;
                    }
                    else {
                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.y;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.y;
                    }
                }
                if (seg1minVal <= seg2minVal) {
                    if (seg1maxVal < seg2minVal)
                        return [];
                    if (seg1maxVal === seg2minVal) {
                        if (inExcludeAdjacentSegs)
                            return [];
                        return [seg2min];
                    }
                    if (seg1maxVal <= seg2maxVal)
                        return [seg2min, seg1max];
                    return [seg2min, seg2max];
                }
                else {
                    if (seg1minVal > seg2maxVal)
                        return [];
                    if (seg1minVal === seg2maxVal) {
                        if (inExcludeAdjacentSegs)
                            return [];
                        return [seg1min];
                    }
                    if (seg1maxVal <= seg2maxVal)
                        return [seg1min, seg1max];
                    return [seg1min, seg2max];
                }
            }
        }
        function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
            // The order of legs is important
            // translation of all points, so that Vertex is at (0,0)
            var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
            var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
            var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;
            // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
            var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
            var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
            if (Math.abs(from2toAngle) > Number.EPSILON) {
                // angle != 180 deg.
                var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                // console.log("from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle);
                if (from2toAngle > 0) {
                    // main angle < 180 deg.
                    return ((from2otherAngle >= 0) && (other2toAngle >= 0));
                }
                else {
                    // main angle > 180 deg.
                    return ((from2otherAngle >= 0) || (other2toAngle >= 0));
                }
            }
            else {
                // angle == 180 deg.
                // console.log("from2to: 180 deg., from2other: " + from2otherAngle);
                return (from2otherAngle > 0);
            }
        }
        function removeHoles(contour, holes) {
            var shape = contour.concat(); // work on this shape
            var hole;
            function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
                // Check if hole point lies within angle around shape point
                var lastShapeIdx = shape.length - 1;
                var prevShapeIdx = inShapeIdx - 1;
                if (prevShapeIdx < 0)
                    prevShapeIdx = lastShapeIdx;
                var nextShapeIdx = inShapeIdx + 1;
                if (nextShapeIdx > lastShapeIdx)
                    nextShapeIdx = 0;
                var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                if (!insideAngle) {
                    // console.log("Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y);
                    return false;
                }
                // Check if shape point lies within angle around hole point
                var lastHoleIdx = hole.length - 1;
                var prevHoleIdx = inHoleIdx - 1;
                if (prevHoleIdx < 0)
                    prevHoleIdx = lastHoleIdx;
                var nextHoleIdx = inHoleIdx + 1;
                if (nextHoleIdx > lastHoleIdx)
                    nextHoleIdx = 0;
                insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
                if (!insideAngle) {
                    // console.log("Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y);
                    return false;
                }
                return true;
            }
            function intersectsShapeEdge(inShapePt, inHolePt) {
                // checks for intersections with shape edges
                var sIdx, nextIdx, intersection;
                for (sIdx = 0; sIdx < shape.length; sIdx++) {
                    nextIdx = sIdx + 1;
                    nextIdx %= shape.length;
                    intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
                    if (intersection.length > 0)
                        return true;
                }
                return false;
            }
            var indepHoles = [];
            function intersectsHoleEdge(inShapePt, inHolePt) {
                // checks for intersections with hole edges
                var ihIdx, chkHole, hIdx, nextIdx, intersection;
                for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
                    chkHole = holes[indepHoles[ihIdx]];
                    for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                        nextIdx = hIdx + 1;
                        nextIdx %= chkHole.length;
                        intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                        if (intersection.length > 0)
                            return true;
                    }
                }
                return false;
            }
            var holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, failedCuts = [], tmpShape1, tmpShape2, tmpHole1, tmpHole2;
            for (var h = 0, hl = holes.length; h < hl; h++) {
                indepHoles.push(h);
            }
            var minShapeIndex = 0;
            var counter = indepHoles.length * 2;
            while (indepHoles.length > 0) {
                counter--;
                if (counter < 0) {
                    console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
                    break;
                }
                // search for shape-vertex and hole-vertex,
                // which can be connected without intersections
                for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
                    shapePt = shape[shapeIndex];
                    holeIndex = -1;
                    // search for hole which can be reached without intersections
                    for (var h = 0; h < indepHoles.length; h++) {
                        holeIdx = indepHoles[h];
                        // prevent multiple checks
                        cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                        if (failedCuts[cutKey] !== undefined)
                            continue;
                        hole = holes[holeIdx];
                        for (var h2 = 0; h2 < hole.length; h2++) {
                            holePt = hole[h2];
                            if (!isCutLineInsideAngles(shapeIndex, h2))
                                continue;
                            if (intersectsShapeEdge(shapePt, holePt))
                                continue;
                            if (intersectsHoleEdge(shapePt, holePt))
                                continue;
                            holeIndex = h2;
                            indepHoles.splice(h, 1);
                            tmpShape1 = shape.slice(0, shapeIndex + 1);
                            tmpShape2 = shape.slice(shapeIndex);
                            tmpHole1 = hole.slice(holeIndex);
                            tmpHole2 = hole.slice(0, holeIndex + 1);
                            shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                            minShapeIndex = shapeIndex;
                            // Debug only, to show the selected cuts
                            // glob_CutLines.push([ shapePt, holePt ]);
                            break;
                        }
                        if (holeIndex >= 0)
                            break; // hole-vertex found
                        failedCuts[cutKey] = true; // remember failure
                    }
                    if (holeIndex >= 0)
                        break; // hole-vertex found
                }
            }
            return shape; /* shape with no holes */
        }
        var allPointsMap = {};
        // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
        var allpoints = contour.concat();
        for (var h = 0, hl = holes.length; h < hl; h++) {
            Array.prototype.push.apply(allpoints, holes[h]);
        }
        //console.log("allpoints",allpoints, allpoints.length);
        // prepare all points map
        for (var i = 0, il = allpoints.length; i < il; i++) {
            var key = allpoints[i].x + ":" + allpoints[i].y;
            if (allPointsMap[key] !== undefined) {
                console.warn("THREE.ShapeUtils: Duplicate point", key, i);
            }
            allPointsMap[key] = i;
        }
        // remove holes by cutting paths to holes and adding them to the shape
        var shapeWithoutHoles = removeHoles(contour, holes);
        var triangle_vertices = ShapeUtils.triangulate(shapeWithoutHoles, false); // True returns indices for points of spooled shape
        var triangle_indices = [];
        //console.log("triangles",triangles, triangles.length);
        // check all face vertices against all points map
        for (var i = 0, il = triangle_vertices.length; i < il; i++) {
            var face_vertices = triangle_vertices[i];
            var face_indices = triangle_indices[i] = [];
            for (var f = 0; f < 3; f++) {
                var key = face_vertices[f].x + ":" + face_vertices[f].y;
                var index = allPointsMap[key];
                if (index !== undefined) {
                    face_indices[f] = index;
                }
            }
        }
        return triangle_indices;
    };
    ShapeUtils.isClockWise = function (pts) {
        return ShapeUtils.area(pts) < 0;
    };
    // Bezier Curves formulas obtained from
    // http://en.wikipedia.org/wiki/B%C3%A9zier_curve
    // Quad Bezier Functions
    ShapeUtils.b2 = function (t, p0, p1, p2) {
        function b2p0(t, p) {
            var k = 1 - t;
            return k * k * p;
        }
        function b2p1(t, p) {
            return 2 * (1 - t) * t * p;
        }
        function b2p2(t, p) {
            return t * t * p;
        }
        //return function b2(t, p0, p1, p2) {
        return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
        //};
    };
    // Cubic Bezier Functions
    ShapeUtils.b3 = function (t, p0, p1, p2, p3) {
        function b3p0(t, p) {
            var k = 1 - t;
            return k * k * k * p;
        }
        function b3p1(t, p) {
            var k = 1 - t;
            return 3 * k * k * t * p;
        }
        function b3p2(t, p) {
            var k = 1 - t;
            return 3 * k * t * t * p;
        }
        function b3p3(t, p) {
            return t * t * t * p;
        }
        //return function b3(t, p0, p1, p2, p3) {
        return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
        //};
    };
    return ShapeUtils;
}());

var ExtrudeGeometry = (function (_super) {
    __extends(ExtrudeGeometry, _super);
    function ExtrudeGeometry(shapes, options) {
        if (typeof (shapes) === "undefined") {
            shapes = [];
            return;
        }
        _super.call(this);
        this.type = 'ExtrudeGeometry';
        shapes = Array.isArray(shapes) ? shapes : [shapes];
        this.addShapeList(shapes, options);
        this.computeFaceNormals();
        // can't really use automatic vertex normals
        // as then front and back sides get smoothed too
        // should do separate smoothing just for sides
        //this.computeVertexNormals();
        //console.log("took", (Date.now() - startTime));
    }
    ExtrudeGeometry.prototype.addShapeList = function (shapes, options) {
        var sl = shapes.length;
        for (var s = 0; s < sl; s++) {
            var shape = shapes[s];
            this.addShape(shape, options);
        }
    };
    ExtrudeGeometry.prototype.addShape = function (shape, options) {
        var amount = options.amount !== undefined ? options.amount : 100;
        var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
        var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
        var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
        var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
        var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
        var steps = options.steps !== undefined ? options.steps : 1;
        var extrudePath = options.extrudePath;
        var extrudePts;
        var extrudeByPath = false;
        // Use default WorldUVGenerator if no UV generators are specified.
        var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
        var splineTube, binormal, normal, position2;
        if (extrudePath) {
            extrudePts = extrudePath.getSpacedPoints(steps);
            extrudeByPath = true;
            bevelEnabled = false; // bevels not supported for path extrusion
            // SETUP TNB variables
            // TODO1 - have a .isClosed in spline?
            splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames(steps, false);
            // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
            binormal = new Vector3();
            normal = new Vector3();
            position2 = new Vector3();
        }
        // Safeguards if bevels are not enabled
        if (!bevelEnabled) {
            bevelSegments = 0;
            bevelThickness = 0;
            bevelSize = 0;
        }
        // Variables initialization
        var scope = this;
        var shapesOffset = this.vertices.length;
        var shapePoints = shape.extractPoints(curveSegments);
        var vertices = shapePoints.shape;
        var holes = shapePoints.holes;
        var reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
            vertices = vertices.reverse();
            // Maybe we should also check if holes are in the opposite direction, just to be safe ...
            for (var h = 0, hl = holes.length; h < hl; h++) {
                var ahole = holes[h];
                if (ShapeUtils.isClockWise(ahole)) {
                    holes[h] = ahole.reverse();
                }
            }
            reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
        }
        var faces = ShapeUtils.triangulateShape(vertices, holes);
        /* Vertices */
        var contour = vertices; // vertices has all points but contour has only points of circumference
        for (var h = 0, hl = holes.length; h < hl; h++) {
            var ahole = holes[h];
            vertices = vertices.concat(ahole);
        }
        function scalePt2(pt, vec, size) {
            if (!vec)
                console.error("THREE.ExtrudeGeometry: vec does not exist");
            return vec.clone().multiplyScalar(size).add(pt);
        }
        var vlen = vertices.length;
        var flen = faces.length;
        // Find directions for point movement
        function getBevelVec(inPt, inPrev, inNext) {
            // computes for inPt the corresponding point inPt' on a new contour
            //   shifted by 1 unit (length of normalized vector) to the left
            // if we walk along contour clockwise, this new contour is outside the old one
            //
            // inPt' is the intersection of the two lines parallel to the two
            //  adjacent edges of inPt at a distance of 1 unit on the left side.
            var v_trans_x, v_trans_y, shrink_by = 1; // resulting translation vector for inPt
            // good reading for geometry algorithms (here: line-line intersection)
            // http://geomalgorithms.com/a05-_intersect-1.html
            var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
            var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
            var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
            // check for collinear edges
            var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
            if (Math.abs(collinear0) > Number.EPSILON) {
                // not collinear
                // length of vectors for normalizing
                var v_prev_len = Math.sqrt(v_prev_lensq);
                var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                // shift adjacent points by unit vectors to the left
                var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
                var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
                // scaling factor for v_prev to intersection point
                var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                    (ptNextShift_y - ptPrevShift_y) * v_next_x) /
                    (v_prev_x * v_next_y - v_prev_y * v_next_x);
                // vector from inPt to intersection point
                v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
                // Don't normalize!, otherwise sharp corners become ugly
                //  but prevent crazy spikes
                var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                if (v_trans_lensq <= 2) {
                    return new Vector2(v_trans_x, v_trans_y);
                }
                else {
                    shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
            }
            else {
                // handle special case of collinear edges
                var direction_eq = false; // assumes: opposite
                if (v_prev_x > Number.EPSILON) {
                    if (v_next_x > Number.EPSILON) {
                        direction_eq = true;
                    }
                }
                else {
                    if (v_prev_x < -Number.EPSILON) {
                        if (v_next_x < -Number.EPSILON) {
                            direction_eq = true;
                        }
                    }
                    else {
                        if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                            direction_eq = true;
                        }
                    }
                }
                if (direction_eq) {
                    // console.log("Warning: lines are a straight sequence");
                    v_trans_x = -v_prev_y;
                    v_trans_y = v_prev_x;
                    shrink_by = Math.sqrt(v_prev_lensq);
                }
                else {
                    // console.log("Warning: lines are a straight spike");
                    v_trans_x = v_prev_x;
                    v_trans_y = v_prev_y;
                    shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        var contourMovements = [];
        for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
            if (j === il)
                j = 0;
            if (k === il)
                k = 0;
            //  (j)---(i)---(k)
            // console.log('i,j,k', i, j , k)
            contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        }
        var holesMovements = [];
        var verticesMovements = contourMovements.concat();
        for (var h = 0, hl = holes.length; h < hl; h++) {
            var ahole = holes[h];
            var oneHoleMovements = [];
            for (var i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                if (j === il)
                    j = 0;
                if (k === il)
                    k = 0;
                //  (j)---(i)---(k)
                oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
            }
            holesMovements.push(oneHoleMovements);
            verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        // Loop bevelSegments, 1 for the front, 1 for the back
        for (var b = 0; b < bevelSegments; b++) {
            //for (b = bevelSegments; b > 0; b --) {
            var t = b / bevelSegments;
            var z = bevelThickness * Math.cos(t * Math.PI / 2);
            var bs_1 = bevelSize * Math.sin(t * Math.PI / 2);
            // contract shape
            for (var i = 0, il = contour.length; i < il; i++) {
                var vert = scalePt2(contour[i], contourMovements[i], bs_1);
                v(vert.x, vert.y, -z);
            }
            // expand holes
            for (var h = 0, hl = holes.length; h < hl; h++) {
                var ahole = holes[h];
                var oneHoleMovements = holesMovements[h];
                for (var i = 0, il = ahole.length; i < il; i++) {
                    var vert = scalePt2(ahole[i], oneHoleMovements[i], bs_1);
                    v(vert.x, vert.y, -z);
                }
            }
        }
        var bs = bevelSize;
        // Back facing vertices
        for (var i = 0; i < vlen; i++) {
            var vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
            if (!extrudeByPath) {
                v(vert.x, vert.y, 0);
            }
            else {
                // v(vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x);
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
            }
        }
        // Add stepped vertices...
        // Including front facing vertices
        for (var s = 1; s <= steps; s++) {
            for (var i = 0; i < vlen; i++) {
                var vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                if (!extrudeByPath) {
                    v(vert.x, vert.y, amount / steps * s);
                }
                else {
                    // v(vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x);
                    normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[s]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
        }
        // Add bevel segments planes
        //for (let b = 1; b <= bevelSegments; b ++) {
        for (var b = bevelSegments - 1; b >= 0; b--) {
            var t = b / bevelSegments;
            var z = bevelThickness * Math.cos(t * Math.PI / 2);
            var bs_2 = bevelSize * Math.sin(t * Math.PI / 2);
            // contract shape
            for (var i = 0, il = contour.length; i < il; i++) {
                var vert = scalePt2(contour[i], contourMovements[i], bs_2);
                v(vert.x, vert.y, amount + z);
            }
            // expand holes
            for (var h = 0, hl = holes.length; h < hl; h++) {
                var ahole = holes[h];
                var oneHoleMovements = holesMovements[h];
                for (var i = 0, il = ahole.length; i < il; i++) {
                    var vert = scalePt2(ahole[i], oneHoleMovements[i], bs_2);
                    if (!extrudeByPath) {
                        v(vert.x, vert.y, amount + z);
                    }
                    else {
                        v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                    }
                }
            }
        }
        /* Faces */
        // Top and bottom faces
        buildLidFaces();
        // Sides faces
        buildSideFaces();
        /////  Internal functions
        function buildLidFaces() {
            if (bevelEnabled) {
                var layer = 0; // steps + 1
                var offset = vlen * layer;
                // Bottom faces
                for (var i = 0; i < flen; i++) {
                    var face = faces[i];
                    f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                // Top faces
                for (var i = 0; i < flen; i++) {
                    var face = faces[i];
                    f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
            }
            else {
                // Bottom faces
                for (var i = 0; i < flen; i++) {
                    var face = faces[i];
                    f3(face[2], face[1], face[0]);
                }
                // Top faces
                for (var i = 0; i < flen; i++) {
                    var face = faces[i];
                    f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
            }
        }
        // Create faces for the z-sides of the shape
        function buildSideFaces() {
            var layeroffset = 0;
            sidewalls(contour, layeroffset);
            layeroffset += contour.length;
            for (var h = 0, hl = holes.length; h < hl; h++) {
                var ahole = holes[h];
                sidewalls(ahole, layeroffset);
                //, true
                layeroffset += ahole.length;
            }
        }
        function sidewalls(contour, layeroffset) {
            var i = contour.length;
            while (--i >= 0) {
                var j = i;
                var k = i - 1;
                if (k < 0)
                    k = contour.length - 1;
                //console.log('b', i,j, i-1, k,vertices.length);
                var sl = steps + bevelSegments * 2;
                for (var s = 0; s < sl; s++) {
                    var slen1 = vlen * s;
                    var slen2 = vlen * (s + 1);
                    var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                    f4(a, b, c, d, contour, s, sl, j, k);
                }
            }
        }
        function v(x, y, z) {
            scope.vertices.push(new Vector3(x, y, z));
        }
        function f3(a, b, c) {
            a += shapesOffset;
            b += shapesOffset;
            c += shapesOffset;
            scope.faces.push(new Face3(a, b, c, null, null, 0));
            var uvs = uvgen.generateTopUV(scope, a, b, c);
            scope.faceVertexUvs[0].push(uvs);
        }
        function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
            a += shapesOffset;
            b += shapesOffset;
            c += shapesOffset;
            d += shapesOffset;
            scope.faces.push(new Face3(a, b, d, null, null, 1));
            scope.faces.push(new Face3(b, c, d, null, null, 1));
            var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
            scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
            scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);
        }
    };
    ExtrudeGeometry._WorldUVGenerator = (function () {
        function class_1() {
        }
        class_1.prototype.generateTopUV = function (geometry, indexA, indexB, indexC) {
            var vertices = geometry.vertices;
            var a = vertices[indexA];
            var b = vertices[indexB];
            var c = vertices[indexC];
            return [
                new Vector2(a.x, a.y),
                new Vector2(b.x, b.y),
                new Vector2(c.x, c.y)
            ];
        };
        class_1.prototype.generateSideWallUV = function (geometry, indexA, indexB, indexC, indexD) {
            var vertices = geometry.vertices;
            var a = vertices[indexA];
            var b = vertices[indexB];
            var c = vertices[indexC];
            var d = vertices[indexD];
            if (Math.abs(a.y - b.y) < 0.01) {
                return [
                    new Vector2(a.x, 1 - a.z),
                    new Vector2(b.x, 1 - b.z),
                    new Vector2(c.x, 1 - c.z),
                    new Vector2(d.x, 1 - d.z)
                ];
            }
            else {
                return [
                    new Vector2(a.y, 1 - a.z),
                    new Vector2(b.y, 1 - b.z),
                    new Vector2(c.y, 1 - c.z),
                    new Vector2(d.y, 1 - d.z)
                ];
            }
        };
        return class_1;
    }());
    ExtrudeGeometry.WorldUVGenerator = new ExtrudeGeometry._WorldUVGenerator();
    return ExtrudeGeometry;
}(Geometry));

var Curve = (function () {
    function Curve() {
    }
    // Virtual base class method to overwrite and implement in subclasses
    //  - t [0 .. 1]
    Curve.prototype.getPoint = function (t) {
        console.warn("THREE.Curve: Warning, getPoint() not implemented!");
        return null;
    };
    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]
    Curve.prototype.getPointAt = function (u) {
        var t = this.getUtoTmapping(u);
        return this.getPoint(t);
    };
    // Get sequence of points using getPoint(t)
    Curve.prototype.getPoints = function (divisions) {
        if (divisions === void 0) { divisions = 5; }
        var points = [];
        for (var d = 0; d <= divisions; d++) {
            points.push(this.getPoint(d / divisions));
        }
        return points;
    };
    // Get sequence of points using getPointAt(u)
    Curve.prototype.getSpacedPoints = function (divisions) {
        if (divisions === void 0) { divisions = 5; }
        var points = [];
        for (var d = 0; d <= divisions; d++) {
            points.push(this.getPointAt(d / divisions));
        }
        return points;
    };
    // Get total curve arc length
    Curve.prototype.getLength = function () {
        var lengths = this.getLengths();
        return lengths[lengths.length - 1];
    };
    // Get list of cumulative segment lengths
    Curve.prototype.getLengths = function (divisions) {
        if (!divisions)
            divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
        if (this.cacheArcLengths
            && (this.cacheArcLengths.length === divisions + 1)
            && !this.needsUpdate) {
            //console.log("cached", this.cacheArcLengths);
            return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        var cache = [];
        var current;
        var last = this.getPoint(0);
        var sum = 0;
        cache.push(0);
        for (var p = 1; p <= divisions; p++) {
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache; // { sums: cache, sum:sum }; Sum is in the last element.
    };
    Curve.prototype.updateArcLengths = function () {
        this.needsUpdate = true;
        this.getLengths();
    };
    // Given u (0 .. 1), get a t to find p. This gives you points which are equidistant
    Curve.prototype.getUtoTmapping = function (u, distance) {
        var arcLengths = this.getLengths();
        var i = 0;
        var il = arcLengths.length;
        var targetArcLength; // The targeted u distance value to get
        if (distance) {
            targetArcLength = distance;
        }
        else {
            targetArcLength = u * arcLengths[il - 1];
        }
        //const time = Date.now();
        // binary search for the index with largest value smaller than target u distance
        var low = 0, high = il - 1, comparison;
        while (low <= high) {
            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
            comparison = arcLengths[i] - targetArcLength;
            if (comparison < 0) {
                low = i + 1;
            }
            else if (comparison > 0) {
                high = i - 1;
            }
            else {
                high = i;
                break;
            }
        }
        i = high;
        //console.log('b' , i, low, high, Date.now()- time);
        if (arcLengths[i] === targetArcLength) {
            var t_1 = i / (il - 1);
            return t_1;
        }
        // we could get finer grain at lengths, or use simple interpolation between two points
        var lengthBefore = arcLengths[i];
        var lengthAfter = arcLengths[i + 1];
        var segmentLength = lengthAfter - lengthBefore;
        // determine where we are between the 'before' and 'after' points
        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        // add that fractional amount to t
        var t = (i + segmentFraction) / (il - 1);
        return t;
    };
    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation
    Curve.prototype.getTangent = function (t) {
        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;
        // Capping in case of danger
        if (t1 < 0)
            t1 = 0;
        if (t2 > 1)
            t2 = 1;
        var pt1 = this.getPoint(t1);
        var pt2 = this.getPoint(t2);
        var vec = pt2.clone().sub(pt1);
        return vec.normalize();
    };
    Curve.prototype.getTangentAt = function (u) {
        var t = this.getUtoTmapping(u);
        return this.getTangent(t);
    };
    Curve.prototype.computeFrenetFrames = function (segments, closed) {
        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
        var normal = new Vector3();
        var tangents = [];
        var normals = [];
        var binormals = [];
        var vec = new Vector3();
        var mat = new Matrix4();
        var i, u, theta;
        // compute the tangent vectors for each segment on the curve
        for (i = 0; i <= segments; i++) {
            u = i / segments;
            tangents[i] = this.getTangentAt(u);
            tangents[i].normalize();
        }
        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the minimum tangent xyz component
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        var min = Number.MAX_VALUE;
        var tx = Math.abs(tangents[0].x);
        var ty = Math.abs(tangents[0].y);
        var tz = Math.abs(tangents[0].z);
        if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
        }
        if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
        }
        if (tz <= min) {
            normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        // compute the slowly-varying normal and binormal vectors for each segment on the curve
        for (i = 1; i <= segments; i++) {
            normals[i] = normals[i - 1].clone();
            binormals[i] = binormals[i - 1].clone();
            vec.crossVectors(tangents[i - 1], tangents[i]);
            if (vec.length() > Number.EPSILON) {
                vec.normalize();
                theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors
                normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i].crossVectors(tangents[i], normals[i]);
        }
        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
        if (closed === true) {
            theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                theta = -theta;
            }
            for (i = 1; i <= segments; i++) {
                // twist a little...
                normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                binormals[i].crossVectors(tangents[i], normals[i]);
            }
        }
        return {
            tangents: tangents,
            normals: normals,
            binormals: binormals
        };
    };
    // TODO: Transformation for Curves?
    /**************************************************************
     *  3D Curves
     **************************************************************/
    // A Factory method for creating new curve subclasses
    Curve.create = function (constructor, getPointFunc) {
        constructor.prototype = Object.create(Curve.prototype);
        constructor.prototype.constructor = constructor;
        constructor.prototype.getPoint = getPointFunc;
        return constructor;
    };
    return Curve;
}());
var Curve2 = (function (_super) {
    __extends(Curve2, _super);
    function Curve2() {
        _super.apply(this, arguments);
    }
    return Curve2;
}(Curve));
var Curve3 = (function (_super) {
    __extends(Curve3, _super);
    function Curve3() {
        _super.apply(this, arguments);
    }
    return Curve3;
}(Curve));

/**************************************************************
 *  Line
 **************************************************************/
var LineCurve = (function (_super) {
    __extends(LineCurve, _super);
    function LineCurve(v1, v2) {
        _super.call(this);
        this.isLineCurve = true;
        this.v1 = v1;
        this.v2 = v2;
    }
    LineCurve.prototype.getPoint = function (t) {
        if (t === 1) {
            return this.v2.clone();
        }
        var point = this.v2.clone().sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
        return point;
    };
    
    // Line curve is linear, so we can overwrite default getPointAt
    LineCurve.prototype.getPointAt = function (u) {
        return this.getPoint(u);
    };
    LineCurve.prototype.getTangent = function (t) {
        var tangent = this.v2.clone().sub(this.v1);
        return tangent.normalize();
    };
    return LineCurve;
}(Curve));

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */
var CurveUtils = (function () {
    function CurveUtils() {
    }
    CurveUtils.tangentQuadraticBezier = function (t, p0, p1, p2) {
        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
    };
    // Puay Bing, thanks for helping with this derivative!
    CurveUtils.tangentCubicBezier = function (t, p0, p1, p2, p3) {
        return -3 * p0 * (1 - t) * (1 - t) +
            3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
            6 * t * p2 * (1 - t) - 3 * t * t * p2 +
            3 * t * t * p3;
    };
    CurveUtils.tangentSpline = function (t, p0, p1, p2, p3) {
        // To check if my formulas are correct
        var h00 = 6 * t * t - 6 * t; // derived from 2t^3  3t^2 + 1
        var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
        var h01 = -6 * t * t + 6 * t; //  2t3 + 3t2
        var h11 = 3 * t * t - 2 * t; // t3  t2
        return h00 + h10 + h01 + h11;
    };
    // Catmull-Rom
    CurveUtils.interpolate = function (p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    };
    return CurveUtils;
}());

/**************************************************************
 *  Spline curve
 **************************************************************/
var SplineCurve = (function (_super) {
    __extends(SplineCurve, _super);
    function SplineCurve(points /* array of Vector2 */) {
        if (points === void 0) { points = []; }
        _super.call(this);
        this.isSplineCurve = true;
        this.points = points;
    }
    SplineCurve.prototype.getPoint = function (t) {
        var points = this.points;
        var point = (points.length - 1) * t;
        var intPoint = Math.floor(point);
        var weight = point - intPoint;
        var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        var point1 = points[intPoint];
        var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        var interpolate = CurveUtils.interpolate;
        return new Vector2(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight));
    };
    
    return SplineCurve;
}(Curve));

/**************************************************************
 *  Ellipse curve
 **************************************************************/
var EllipseCurve = (function (_super) {
    __extends(EllipseCurve, _super);
    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        if (aRotation === void 0) { aRotation = 0; }
        _super.call(this);
        this.isEllipseCurve = true;
        this.aX = aX;
        this.aY = aY;
        this.xRadius = xRadius;
        this.yRadius = yRadius;
        this.aStartAngle = aStartAngle;
        this.aEndAngle = aEndAngle;
        this.aClockwise = aClockwise;
        this.aRotation = aRotation;
    }
    EllipseCurve.prototype.getPoint = function (t) {
        var twoPi = Math.PI * 2;
        var deltaAngle = this.aEndAngle - this.aStartAngle;
        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        // ensures that deltaAngle is 0 .. 2 PI
        while (deltaAngle < 0)
            deltaAngle += twoPi;
        while (deltaAngle > twoPi)
            deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
                deltaAngle = 0;
            }
            else {
                deltaAngle = twoPi;
            }
        }
        if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) {
                deltaAngle = -twoPi;
            }
            else {
                deltaAngle = deltaAngle - twoPi;
            }
        }
        var angle = this.aStartAngle + t * deltaAngle;
        var x = this.aX + this.xRadius * Math.cos(angle);
        var y = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
            var cos = Math.cos(this.aRotation);
            var sin = Math.sin(this.aRotation);
            var tx = x - this.aX;
            var ty = y - this.aY;
            // Rotate the point about the center of the ellipse.
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
        }
        return new Vector2(x, y);
    };
    
    return EllipseCurve;
}(Curve));

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/
/**************************************************************
 *  Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/
var CurvePath = (function () {
    function CurvePath() {
        this.curves = [];
        this.autoClose = false; // Automatically closes the path
    }
    CurvePath.prototype.add = function (curve) {
        this.curves.push(curve);
    };
    CurvePath.prototype.closePath = function () {
        // Add a line curve if start and end of lines are not connected
        var startPoint = this.curves[0].getPoint(0);
        var endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) {
            this.curves.push(new LineCurve(endPoint, startPoint));
        }
    };
    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
    CurvePath.prototype.getPoint = function (t) {
        var d = t * this.getLength();
        var curveLengths = this.getCurveLengths();
        var i = 0;
        // To think about boundaries points.
        while (i < curveLengths.length) {
            if (curveLengths[i] >= d) {
                var diff = curveLengths[i] - d;
                var curve = this.curves[i];
                var segmentLength = curve.getLength();
                var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i++;
        }
        return null;
        // loop where sum != 0, sum > d , sum+1 <d
    };
    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
    CurvePath.prototype.getLength = function () {
        var lens = this.getCurveLengths();
        return lens[lens.length - 1];
    };
    // cacheLengths must be recalculated.
    CurvePath.prototype.updateArcLengths = function () {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths(); // !!!TODO: this.getLengths();
    };
    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
    CurvePath.prototype.getCurveLengths = function () {
        // We use cache values if curves and cache array are same length
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
            return this.cacheLengths;
        }
        // Get length of sub-curve
        // Push sums into cached array
        var lengths = [], sums = 0;
        for (var i = 0, l = this.curves.length; i < l; i++) {
            sums += this.curves[i].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    };
    CurvePath.prototype.getSpacedPoints = function (divisions) {
        if (divisions === void 0) { divisions = 40; }
        var points = [];
        for (var i = 0; i <= divisions; i++) {
            points.push(this.getPoint(i / divisions));
        }
        if (this.autoClose) {
            points.push(points[0]);
        }
        return points;
    };
    CurvePath.prototype.getPoints = function (divisions) {
        if (divisions === void 0) { divisions = 12; }
        var points = [], last;
        for (var i = 0, curves = this.curves; i < curves.length; i++) {
            var curve = curves[i];
            var resolution = (curve && curve instanceof EllipseCurve) ? divisions * 2
                : (curve && curve instanceof LineCurve) ? 1
                    : (curve && curve instanceof SplineCurve) ? divisions * curve.points.length
                        : divisions;
            var pts = curve.getPoints(resolution);
            for (var j = 0; j < pts.length; j++) {
                var point = pts[j];
                if (last && last.equals(point))
                    continue; // ensures no consecutive points are duplicates
                points.push(point);
                last = point;
            }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
            points.push(points[0]);
        }
        return points;
    };
    /**************************************************************
     *  Create Geometries Helpers
     **************************************************************/
    /// Generate geometry from path points (for Line or Points objects)
    CurvePath.prototype.createPointsGeometry = function (divisions) {
        var pts = this.getPoints(divisions);
        return this.createGeometry(pts);
    };
    // Generate geometry from equidistant sampling along the path
    CurvePath.prototype.createSpacedPointsGeometry = function (divisions) {
        var pts = this.getSpacedPoints(divisions);
        return this.createGeometry(pts);
    };
    CurvePath.prototype.createGeometry = function (points) {
        var geometry = new Geometry();
        for (var i = 0, l = points.length; i < l; i++) {
            var point = points[i];
            geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return geometry;
    };
    return CurvePath;
}());

/**************************************************************
 *  Cubic Bezier curve
 **************************************************************/
var CubicBezierCurve = (function (_super) {
    __extends(CubicBezierCurve, _super);
    function CubicBezierCurve(v0, v1, v2, v3) {
        _super.call(this);
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    CubicBezierCurve.prototype.getPoint = function (t) {
        var b3 = ShapeUtils.b3;
        return new Vector2(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
    };
    CubicBezierCurve.prototype.getTangent = function (t) {
        var tangentCubicBezier = CurveUtils.tangentCubicBezier;
        return new Vector2(tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();
    };
    return CubicBezierCurve;
}(Curve));

/**************************************************************
 *  Quadratic Bezier curve
 **************************************************************/
var QuadraticBezierCurve = (function (_super) {
    __extends(QuadraticBezierCurve, _super);
    function QuadraticBezierCurve(v0, v1, v2) {
        _super.call(this);
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }
    QuadraticBezierCurve.prototype.getPoint = function (t) {
        var b2 = ShapeUtils.b2;
        return new Vector2(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y));
    };
    QuadraticBezierCurve.prototype.getTangent = function (t) {
        var tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;
        return new Vector2(tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)).normalize();
    };
    
    return QuadraticBezierCurve;
}(Curve));

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/
var Path = (function (_super) {
    __extends(Path, _super);
    function Path(points) {
        _super.call(this);
        this.currentPoint = new Vector2();
        if (points) {
            this.fromPoints(points);
        }
    }
    Path.prototype.fromPoints = function (vectors) {
        this.moveTo(vectors[0].x, vectors[0].y);
        for (var i = 1, l = vectors.length; i < l; i++) {
            this.lineTo(vectors[i].x, vectors[i].y);
        }
    };
    Path.prototype.moveTo = function (x, y) {
        this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
    };
    Path.prototype.lineTo = function (x, y) {
        var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
    };
    Path.prototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
        var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
    };
    Path.prototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
    };
    Path.prototype.splineThru = function (pts /*Array of Vector*/) {
        var npts = [this.currentPoint.clone()].concat(pts);
        var curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
    };
    Path.prototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    Path.prototype.absarc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    Path.prototype.ellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    };
    Path.prototype.absellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            // if a previous curve is present, attempt to join
            var firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) {
                this.lineTo(firstPoint.x, firstPoint.y);
            }
        }
        this.curves.push(curve);
        var lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
    };
    return Path;
}(CurvePath));

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *  material: <int> // material index for front and back faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/
var ShapeGeometry = (function (_super) {
    __extends(ShapeGeometry, _super);
    function ShapeGeometry(shapes, options) {
        _super.call(this);
        this.type = 'ShapeGeometry';
        if (Array.isArray(shapes)) {
            this.addShapeList(shapes, options);
        }
        else {
            this.addShapeList([shapes], options);
        }
        this.computeFaceNormals();
    }
    /**
     * Add an array of shapes to THREE.ShapeGeometry.
     */
    ShapeGeometry.prototype.addShapeList = function (shapes, options) {
        for (var i = 0, l = shapes.length; i < l; i++) {
            this.addShape(shapes[i], options);
        }
        return this;
    };
    
    /**
     * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
     */
    ShapeGeometry.prototype.addShape = function (shape, options) {
        if (options === undefined)
            options = {};
        var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
        var material = options.material;
        var uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
        //
        var shapesOffset = this.vertices.length;
        var shapePoints = shape.extractPoints(curveSegments);
        var vertices = shapePoints.shape;
        var holes = shapePoints.holes;
        var reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
            vertices = vertices.reverse();
            // Maybe we should also check if holes are in the opposite direction, just to be safe...
            for (var i = 0, l = holes.length; i < l; i++) {
                var hole = holes[i];
                if (ShapeUtils.isClockWise(hole)) {
                    holes[i] = hole.reverse();
                }
            }
            reverse = false;
        }
        var faces = ShapeUtils.triangulateShape(vertices, holes);
        // Vertices
        for (var i = 0, l = holes.length; i < l; i++) {
            var hole = holes[i];
            vertices = vertices.concat(hole);
        }
        //
        for (var i = 0, vlen = vertices.length; i < vlen; i++) {
            var vert = vertices[i];
            this.vertices.push(new Vector3(vert.x, vert.y, 0));
        }
        for (var i = 0, flen = faces.length; i < flen; i++) {
            var face = faces[i];
            var a = face[0] + shapesOffset;
            var b = face[1] + shapesOffset;
            var c = face[2] + shapesOffset;
            this.faces.push(new Face3(a, b, c, null, null, material));
            this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
        }
    };
    return ShapeGeometry;
}(Geometry));

var Shape = (function (_super) {
    __extends(Shape, _super);
    function Shape(points) {
        _super.call(this, points);
        this.holes = [];
    }
    Shape.prototype.getPointsHoles = function (divisions) {
        var holesPts = [];
        for (var i = 0, l = this.holes.length; i < l; i++) {
            holesPts[i] = this.holes[i].getPoints(divisions);
        }
        return holesPts;
    };
    // Get points of shape and holes (keypoints based on segments parameter)
    Shape.prototype.extractAllPoints = function (divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    };
    Shape.prototype.extractPoints = function (divisions) {
        return this.extractAllPoints(divisions);
    };
    Shape.prototype.extrude = function (options) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new ExtrudeGeometry(this, options);
    };
    Shape.prototype.makeGeometry = function (options) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new ShapeGeometry(this, options);
    };
    return Shape;
}(Path));

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/
// minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
var ShapePath = (function () {
    function ShapePath() {
        this.subPaths = [];
        this.currentPath = null;
    }
    ShapePath.prototype.moveTo = function (x, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
    };
    ShapePath.prototype.lineTo = function (x, y) {
        this.currentPath.lineTo(x, y);
    };
    ShapePath.prototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    };
    ShapePath.prototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    };
    ShapePath.prototype.splineThru = function (pts) {
        this.currentPath.splineThru(pts);
    };
    ShapePath.prototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.currentPath.arc(aX, aY, aStartAngle, aEndAngle, aClockwise);
    };
    ShapePath.prototype.absarc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.currentPath.absarc(aX, aY, aStartAngle, aEndAngle, aClockwise);
    };
    ShapePath.prototype.ellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        this.currentPath.ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    };
    ShapePath.prototype.absellipse = function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        this.currentPath.absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    };
    ShapePath.prototype.toShapes = function (isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            var shapes = [];
            for (var i = 0, l = inSubpaths.length; i < l; i++) {
                var tmpPath_1 = inSubpaths[i];
                var tmpShape_1 = new Shape();
                tmpShape_1.curves = tmpPath_1.curves;
                shapes.push(tmpShape_1);
            }
            return shapes;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            var polyLen = inPolygon.length;
            // inPt on polygon contour => immediate success    or
            // toggling of inside/outside at every single! intersection point of an edge
            //  with the horizontal line through inPt, left of inPt
            //  not counting lowerY endpoints of edges and whole edges on that line
            var inside = false;
            for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                var edgeLowPt = inPolygon[p];
                var edgeHighPt = inPolygon[q];
                var edgeDx = edgeHighPt.x - edgeLowPt.x;
                var edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p];
                        edgeDy = -edgeDy;
                    }
                    if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
                        continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x)
                            return true; // inPt is on contour ?
                    }
                    else {
                        var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0)
                            return true; // inPt is on contour ?
                        if (perpEdge < 0)
                            continue;
                        inside = !inside; // true intersection left of inPt
                    }
                }
                else {
                    // parallel or collinear
                    if (inPt.y !== edgeLowPt.y)
                        continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
                        ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
                        return true; // inPt: Point on contour !
                }
            }
            return inside;
        }
        var isClockWise = ShapeUtils.isClockWise;
        var subPaths = this.subPaths;
        if (subPaths.length === 0)
            return [];
        if (noHoles === true)
            return toShapesNoHoles(subPaths);
        var solid, tmpPath, tmpShape, shapes = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
        }
        var holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        // console.log("Holes first", holesFirst);
        var betterShapeHoles = [];
        var newShapes = [];
        var newShapeHoles = [];
        var mainIdx = 0;
        var tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for (var i = 0, l = subPaths.length; i < l; i++) {
            tmpPath = subPaths[i];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if ((!holesFirst) && (newShapes[mainIdx]))
                    mainIdx++;
                newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst)
                    mainIdx++;
                newShapeHoles[mainIdx] = [];
            }
            else {
                newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
            }
        }
        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0])
            return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            var ambiguous = false;
            var toChange = [];
            for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                betterShapeHoles[sIdx] = [];
            }
            for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                var sho = newShapeHoles[sIdx];
                for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                    var ho = sho[hIdx];
                    var hole_unassigned = true;
                    for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                        if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                            if (sIdx !== s2Idx)
                                toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                            if (hole_unassigned) {
                                hole_unassigned = false;
                                betterShapeHoles[s2Idx].push(ho);
                            }
                            else {
                                ambiguous = true;
                            }
                        }
                    }
                    if (hole_unassigned) {
                        betterShapeHoles[sIdx].push(ho);
                    }
                }
            }
            // console.log("ambiguous: ", ambiguous);
            if (toChange.length > 0) {
                // console.log("to change: ", toChange);
                if (!ambiguous)
                    newShapeHoles = betterShapeHoles;
            }
        }
        var tmpHoles;
        for (var i = 0, il = newShapes.length; i < il; i++) {
            tmpShape = newShapes[i].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i];
            for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                tmpShape.holes.push(tmpHoles[j].h);
            }
        }
        //console.log("shape", shapes);
        return shapes;
    };
    return ShapePath;
}());

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */
var Font = (function () {
    function Font(data) {
        this.isFont = true;
        this.data = data;
    }
    Font.prototype.generateShapes = function (text, size, divisions) {
        function createPaths(text) {
            var chars = String(text).split('');
            var scale = size / data.resolution;
            var offset = 0;
            var paths = [];
            for (var i = 0; i < chars.length; i++) {
                var ret = createPath(chars[i], scale, offset);
                offset += ret.offset;
                paths.push(ret.path);
            }
            return paths;
        }
        function createPath(c, scale, offset) {
            var glyph = data.glyphs[c] || data.glyphs['?'];
            if (!glyph)
                return;
            var path = new ShapePath();
            var pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;
            var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
            if (glyph.o) {
                var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
                for (var i = 0, l = outline.length; i < l;) {
                    var action = outline[i++];
                    switch (action) {
                        case 'm':
                            x = outline[i++] * scale + offset;
                            y = outline[i++] * scale;
                            path.moveTo(x, y);
                            break;
                        case 'l':
                            x = outline[i++] * scale + offset;
                            y = outline[i++] * scale;
                            path.lineTo(x, y);
                            break;
                        case 'q':
                            cpx = outline[i++] * scale + offset;
                            cpy = outline[i++] * scale;
                            cpx1 = outline[i++] * scale + offset;
                            cpy1 = outline[i++] * scale;
                            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                            laste = pts[pts.length - 1];
                            if (laste) {
                                cpx0 = laste.x;
                                cpy0 = laste.y;
                                for (var i2 = 1; i2 <= divisions; i2++) {
                                    var t = i2 / divisions;
                                    b2(t, cpx0, cpx1, cpx);
                                    b2(t, cpy0, cpy1, cpy);
                                }
                            }
                            break;
                        case 'b':
                            cpx = outline[i++] * scale + offset;
                            cpy = outline[i++] * scale;
                            cpx1 = outline[i++] * scale + offset;
                            cpy1 = outline[i++] * scale;
                            cpx2 = outline[i++] * scale + offset;
                            cpy2 = outline[i++] * scale;
                            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                            laste = pts[pts.length - 1];
                            if (laste) {
                                cpx0 = laste.x;
                                cpy0 = laste.y;
                                for (var i2 = 1; i2 <= divisions; i2++) {
                                    var t = i2 / divisions;
                                    b3(t, cpx0, cpx1, cpx2, cpx);
                                    b3(t, cpy0, cpy1, cpy2, cpy);
                                }
                            }
                            break;
                    }
                }
            }
            return { offset: glyph.ha * scale, path: path };
        }
        //
        if (size === undefined)
            size = 100;
        if (divisions === undefined)
            divisions = 4;
        var data = this.data;
        var paths = createPaths(text);
        var shapes = [];
        for (var p = 0, pl = paths.length; p < pl; p++) {
            Array.prototype.push.apply(shapes, paths[p].toShapes());
        }
        return shapes;
    };
    return Font;
}());

var TextGeometry = (function (_super) {
    __extends(TextGeometry, _super);
    function TextGeometry(text, parameters) {
        if (parameters === void 0) { parameters = {}; }
        var font = parameters.font;
        if ((font && font instanceof Font) === false) {
            console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
        }
        var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
        // translate parameters to ExtrudeGeometry API
        parameters.amount = parameters.height !== undefined ? parameters.height : 50;
        // defaults
        if (parameters.bevelThickness === undefined)
            parameters.bevelThickness = 10;
        if (parameters.bevelSize === undefined)
            parameters.bevelSize = 8;
        if (parameters.bevelEnabled === undefined)
            parameters.bevelEnabled = false;
        _super.call(this, shapes, parameters);
        this.type = 'TextGeometry';
    }
    return TextGeometry;
}(ExtrudeGeometry));

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */
var SphereBufferGeometry = (function (_super) {
    __extends(SphereBufferGeometry, _super);
    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        _super.call(this);
        this.type = 'SphereBufferGeometry';
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius = radius || 50;
        widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
        heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
        phiStart = phiStart !== undefined ? phiStart : 0;
        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
        var thetaEnd = thetaStart + thetaLength;
        var vertexCount = ((widthSegments + 1) * (heightSegments + 1));
        var positions = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
        var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
        var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
        var index = 0;
        var vertices = [], normal = new Vector3();
        for (var y = 0; y <= heightSegments; y++) {
            var verticesRow = [];
            var v = y / heightSegments;
            for (var x = 0; x <= widthSegments; x++) {
                var u = x / widthSegments;
                var px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                var py = radius * Math.cos(thetaStart + v * thetaLength);
                var pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                normal.set(px, py, pz).normalize();
                positions.setXYZ(index, px, py, pz);
                normals.setXYZ(index, normal.x, normal.y, normal.z);
                uvs.setXY(index, u, 1 - v);
                verticesRow.push(index);
                index++;
            }
            vertices.push(verticesRow);
        }
        var indices = [];
        for (var y = 0; y < heightSegments; y++) {
            for (var x = 0; x < widthSegments; x++) {
                var v1 = vertices[y][x + 1];
                var v2 = vertices[y][x];
                var v3 = vertices[y + 1][x];
                var v4 = vertices[y + 1][x + 1];
                if (y !== 0 || thetaStart > 0)
                    indices.push(v1, v2, v4);
                if (y !== heightSegments - 1 || thetaEnd < Math.PI)
                    indices.push(v2, v3, v4);
            }
        }
        this.setIndex((positions.count > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
        this.addAttribute('position', positions);
        this.addAttribute('normal', normals);
        this.addAttribute('uv', uvs);
        this.boundingSphere = new Sphere(new Vector3(), radius);
    }
    return SphereBufferGeometry;
}(BufferGeometry));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var SphereGeometry = (function (_super) {
    __extends(SphereGeometry, _super);
    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        _super.call(this);
        this.type = 'SphereGeometry';
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
    }
    return SphereGeometry;
}(Geometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 */
var RingBufferGeometry = (function (_super) {
    __extends(RingBufferGeometry, _super);
    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        _super.call(this);
        this.type = 'RingBufferGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        innerRadius = innerRadius || 20;
        outerRadius = outerRadius || 50;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
        phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
        // these are used to calculate buffer length
        var vertexCount = (thetaSegments + 1) * (phiSegments + 1);
        var indexCount = thetaSegments * phiSegments * 2 * 3;
        // buffers
        var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
        var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
        var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
        var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
        // some helper variables
        var index = 0, indexOffset = 0;
        var radius = innerRadius;
        var radiusStep = ((outerRadius - innerRadius) / phiSegments);
        var vertex = new Vector3();
        var uv = new Vector2();
        // generate vertices, normals and uvs
        // values are generate from the inside of the ring to the outside
        for (var j = 0; j <= phiSegments; j++) {
            for (var i = 0; i <= thetaSegments; i++) {
                var segment = thetaStart + i / thetaSegments * thetaLength;
                // vertex
                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                // normal
                normals.setXYZ(index, 0, 0, 1);
                // uv
                uv.x = (vertex.x / outerRadius + 1) / 2;
                uv.y = (vertex.y / outerRadius + 1) / 2;
                uvs.setXY(index, uv.x, uv.y);
                // increase index
                index++;
            }
            // increase the radius for next row of vertices
            radius += radiusStep;
        }
        // generate indices
        for (var j = 0; j < phiSegments; j++) {
            var thetaSegmentLevel = j * (thetaSegments + 1);
            for (var i = 0; i < thetaSegments; i++) {
                var segment = i + thetaSegmentLevel;
                // indices
                var a = segment;
                var b = segment + thetaSegments + 1;
                var c = segment + thetaSegments + 2;
                var d = segment + 1;
                // face one
                indices.setX(indexOffset, a);
                indexOffset++;
                indices.setX(indexOffset, b);
                indexOffset++;
                indices.setX(indexOffset, c);
                indexOffset++;
                // face two
                indices.setX(indexOffset, a);
                indexOffset++;
                indices.setX(indexOffset, c);
                indexOffset++;
                indices.setX(indexOffset, d);
                indexOffset++;
            }
        }
        // build geometry
        this.setIndex(indices);
        this.addAttribute('position', vertices);
        this.addAttribute('normal', normals);
        this.addAttribute('uv', uvs);
    }
    return RingBufferGeometry;
}(BufferGeometry));

/**
 * @author Kaleb Murphy
 */
var RingGeometry = (function (_super) {
    __extends(RingGeometry, _super);
    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        _super.call(this);
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
    }
    return RingGeometry;
}(Geometry));

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */
var PlaneGeometry = (function (_super) {
    __extends(PlaneGeometry, _super);
    function PlaneGeometry(width, height, widthSegments, heightSegments) {
        _super.call(this);
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    }
    return PlaneGeometry;
}(Geometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 */
// points - to create a closed torus, one must use a set of points
//    like so: [a, b, c, d, a], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2PI) range of the lathed section
//    2PI is a closed lathe, less than 2PI is a portion.
var LatheBufferGeometry = (function (_super) {
    __extends(LatheBufferGeometry, _super);
    function LatheBufferGeometry(points, segments, phiStart, phiLength) {
        _super.call(this);
        this.type = 'LatheBufferGeometry';
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        segments = Math.floor(segments) || 12;
        phiStart = phiStart || 0;
        phiLength = phiLength || Math.PI * 2;
        // clamp phiLength so it's in range of [0, 2PI]
        phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
        // these are used to calculate buffer length
        var vertexCount = (segments + 1) * points.length;
        var indexCount = segments * points.length * 2 * 3;
        // buffers
        var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
        var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
        var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
        // helper variables
        var index = 0, indexOffset = 0;
        var inverseSegments = 1.0 / segments;
        var vertex = new Vector3();
        var uv = new Vector2();
        // generate vertices and uvs
        for (var i = 0; i <= segments; i++) {
            var phi = phiStart + i * inverseSegments * phiLength;
            var sin = Math.sin(phi);
            var cos = Math.cos(phi);
            for (var j = 0; j <= (points.length - 1); j++) {
                // vertex
                vertex.x = points[j].x * sin;
                vertex.y = points[j].y;
                vertex.z = points[j].x * cos;
                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                // uv
                uv.x = i / segments;
                uv.y = j / (points.length - 1);
                uvs.setXY(index, uv.x, uv.y);
                // increase index
                index++;
            }
        }
        // generate indices
        for (var i = 0; i < segments; i++) {
            for (var j = 0; j < (points.length - 1); j++) {
                var base = j + i * points.length;
                // indices
                var a = base;
                var b = base + points.length;
                var c = base + points.length + 1;
                var d = base + 1;
                // face one
                indices.setX(indexOffset, a);
                indexOffset++;
                indices.setX(indexOffset, b);
                indexOffset++;
                indices.setX(indexOffset, d);
                indexOffset++;
                // face two
                indices.setX(indexOffset, b);
                indexOffset++;
                indices.setX(indexOffset, c);
                indexOffset++;
                indices.setX(indexOffset, d);
                indexOffset++;
            }
        }
        // build geometry
        this.setIndex(indices);
        this.addAttribute('position', vertices);
        this.addAttribute('uv', uvs);
        // generate normals
        this.computeVertexNormals();
        // if the geometry is closed, we need to average the normals along the seam.
        // because the corresponding vertices are identical (but still have different UVs).
        if (phiLength === Math.PI * 2) {
            var normals = this.attributes.normal.array;
            var n1 = new Vector3();
            var n2 = new Vector3();
            var n = new Vector3();
            // this is the buffer offset for the last line of vertices
            var base = segments * points.length * 3;
            for (var i = 0, j = 0; i < points.length; i++, j += 3) {
                // select the normal of the vertex in the first line
                n1.x = normals[j + 0];
                n1.y = normals[j + 1];
                n1.z = normals[j + 2];
                // select the normal of the vertex in the last line
                n2.x = normals[base + j + 0];
                n2.y = normals[base + j + 1];
                n2.z = normals[base + j + 2];
                // average normals
                n.addVectors(n1, n2).normalize();
                // assign the new values to both normals
                normals[j + 0] = normals[base + j + 0] = n.x;
                normals[j + 1] = normals[base + j + 1] = n.y;
                normals[j + 2] = normals[base + j + 2] = n.z;
            } // next row
        }
    }
    return LatheBufferGeometry;
}(BufferGeometry));

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */
// points - to create a closed torus, one must use a set of points
//    like so: [a, b, c, d, a], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2PI) range of the lathed section
//    2PI is a closed lathe, less than 2PI is a portion.
var LatheGeometry = (function (_super) {
    __extends(LatheGeometry, _super);
    function LatheGeometry(points, segments, phiStart, phiLength) {
        _super.call(this);
        this.type = 'LatheGeometry';
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
        this.mergeVertices();
    }
    return LatheGeometry;
}(Geometry));

/**
 * @author WestLangley / http://github.com/WestLangley
 */
var EdgesGeometry = (function (_super) {
    __extends(EdgesGeometry, _super);
    function EdgesGeometry(geometry, thresholdAngle) {
        if (thresholdAngle === void 0) { thresholdAngle = 1; }
        _super.call(this);
        var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
        var edge = [0, 0], hash = {};
        function sortFunction(a, b) {
            return a - b;
        }
        var keys = ['a', 'b', 'c'];
        var geometry2;
        if ((geometry && geometry instanceof BufferGeometry)) {
            geometry2 = new Geometry();
            geometry2.fromBufferGeometry(geometry);
        }
        else if (geometry && geometry instanceof Geometry) {
            geometry2 = geometry.clone();
        }
        geometry2.mergeVertices();
        geometry2.computeFaceNormals();
        var vertices = geometry2.vertices;
        var faces = geometry2.faces;
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0; j < 3; j++) {
                edge[0] = face[keys[j]];
                edge[1] = face[keys[(j + 1) % 3]];
                edge.sort(sortFunction);
                var key = edge.toString();
                if (hash[key] === undefined) {
                    hash[key] = { vert1: edge[0], vert2: edge[1], face1: i, face2: undefined };
                }
                else {
                    hash[key].face2 = i;
                }
            }
        }
        var coords = [];
        for (var key in hash) {
            var h = hash[key];
            if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
                var vertex1 = vertices[h.vert1];
                coords.push(vertex1.x);
                coords.push(vertex1.y);
                coords.push(vertex1.z);
                var vertex2 = vertices[h.vert2];
                coords.push(vertex2.x);
                coords.push(vertex2.y);
                coords.push(vertex2.z);
            }
        }
        this.addAttribute('position', new BufferAttribute(new Float32Array(coords), 3));
    }
    return EdgesGeometry;
}(BufferGeometry));

/**
 * @author Mugen87 / https://github.com/Mugen87
 */
var CylinderBufferGeometry = (function (_super) {
    __extends(CylinderBufferGeometry, _super);
    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        _super.call(this);
        this.type = 'CylinderBufferGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        var scope = this;
        radiusTop = radiusTop !== undefined ? radiusTop : 20;
        radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
        height = height !== undefined ? height : 100;
        radialSegments = Math.floor(radialSegments) || 8;
        heightSegments = Math.floor(heightSegments) || 1;
        openEnded = openEnded !== undefined ? openEnded : false;
        thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
        thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;
        // used to calculate buffer length
        var nbCap = 0;
        if (openEnded === false) {
            if (radiusTop > 0)
                nbCap++;
            if (radiusBottom > 0)
                nbCap++;
        }
        var vertexCount = calculateVertexCount();
        var indexCount = calculateIndexCount();
        // buffers
        var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
        var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
        var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
        var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
        // helper variables
        var index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;
        // group variables
        var groupStart = 0;
        // generate geometry
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0)
                generateCap(true);
            if (radiusBottom > 0)
                generateCap(false);
        }
        // build geometry
        this.setIndex(indices);
        this.addAttribute('position', vertices);
        this.addAttribute('normal', normals);
        this.addAttribute('uv', uvs);
        // helper functions
        function calculateVertexCount() {
            var count = (radialSegments + 1) * (heightSegments + 1);
            if (openEnded === false) {
                count += ((radialSegments + 1) * nbCap) + (radialSegments * nbCap);
            }
            return count;
        }
        function calculateIndexCount() {
            var count = radialSegments * heightSegments * 2 * 3;
            if (openEnded === false) {
                count += radialSegments * nbCap * 3;
            }
            return count;
        }
        function generateTorso() {
            var normal = new Vector3();
            var vertex = new Vector3();
            var groupCount = 0;
            // this will be used to calculate the normal
            var slope = (radiusBottom - radiusTop) / height;
            // generate vertices, normals and uvs
            for (var y = 0; y <= heightSegments; y++) {
                var indexRow = [];
                var v = y / heightSegments;
                // calculate the radius of the current row
                var radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (var x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);
                    // vertex
                    vertex.x = radius * sinTheta;
                    vertex.y = -v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                    // normal
                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.setXYZ(index, normal.x, normal.y, normal.z);
                    // uv
                    uvs.setXY(index, u, 1 - v);
                    // save index of vertex in respective row
                    indexRow.push(index);
                    // increase index
                    index++;
                }
                // now save vertices of the row in our index array
                indexArray.push(indexRow);
            }
            // generate indices
            for (var x = 0; x < radialSegments; x++) {
                for (var y = 0; y < heightSegments; y++) {
                    // we use the index array to access the correct indices
                    var i1 = indexArray[y][x];
                    var i2 = indexArray[y + 1][x];
                    var i3 = indexArray[y + 1][x + 1];
                    var i4 = indexArray[y][x + 1];
                    // face one
                    indices.setX(indexOffset, i1);
                    indexOffset++;
                    indices.setX(indexOffset, i2);
                    indexOffset++;
                    indices.setX(indexOffset, i4);
                    indexOffset++;
                    // face two
                    indices.setX(indexOffset, i2);
                    indexOffset++;
                    indices.setX(indexOffset, i3);
                    indexOffset++;
                    indices.setX(indexOffset, i4);
                    indexOffset++;
                    // update counters
                    groupCount += 6;
                }
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, 0);
            // calculate new start value for groups
            groupStart += groupCount;
        }
        function generateCap(top) {
            var uv = new Vector2();
            var vertex = new Vector3();
            var groupCount = 0;
            var radius = (top === true) ? radiusTop : radiusBottom;
            var sign = (top === true) ? 1 : -1;
            // save the index of the first center vertex
            var centerIndexStart = index;
            // first we generate the center vertex data of the cap.
            // because the geometry needs one set of uvs per face,
            // we must generate a center vertex per face/segment
            for (var x = 1; x <= radialSegments; x++) {
                // vertex
                vertices.setXYZ(index, 0, halfHeight * sign, 0);
                // normal
                normals.setXYZ(index, 0, sign, 0);
                // uv
                uv.x = 0.5;
                uv.y = 0.5;
                uvs.setXY(index, uv.x, uv.y);
                // increase index
                index++;
            }
            // save the index of the last center vertex
            var centerIndexEnd = index;
            // now we generate the surrounding vertices, normals and uvs
            for (var x = 0; x <= radialSegments; x++) {
                var u = x / radialSegments;
                var theta = u * thetaLength + thetaStart;
                var cosTheta = Math.cos(theta);
                var sinTheta = Math.sin(theta);
                // vertex
                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                // normal
                normals.setXYZ(index, 0, sign, 0);
                // uv
                uv.x = (cosTheta * 0.5) + 0.5;
                uv.y = (sinTheta * 0.5 * sign) + 0.5;
                uvs.setXY(index, uv.x, uv.y);
                // increase index
                index++;
            }
            // generate indices
            for (var x = 0; x < radialSegments; x++) {
                var c = centerIndexStart + x;
                var i = centerIndexEnd + x;
                if (top === true) {
                    // face top
                    indices.setX(indexOffset, i);
                    indexOffset++;
                    indices.setX(indexOffset, i + 1);
                    indexOffset++;
                    indices.setX(indexOffset, c);
                    indexOffset++;
                }
                else {
                    // face bottom
                    indices.setX(indexOffset, i + 1);
                    indexOffset++;
                    indices.setX(indexOffset, i);
                    indexOffset++;
                    indices.setX(indexOffset, c);
                    indexOffset++;
                }
                // update counters
                groupCount += 3;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            // calculate new start value for groups
            groupStart += groupCount;
        }
    }
    return CylinderBufferGeometry;
}(BufferGeometry));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var CylinderGeometry = (function (_super) {
    __extends(CylinderGeometry, _super);
    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        _super.call(this);
        this.type = 'CylinderGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
        this.mergeVertices();
    }
    return CylinderGeometry;
}(Geometry));

/**
 * @author abelnation / http://github.com/abelnation
 */
var ConeGeometry = (function (_super) {
    __extends(ConeGeometry, _super);
    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        _super.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = 'ConeGeometry';
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    return ConeGeometry;
}(CylinderGeometry));

/*
 * @author: abelnation / http://github.com/abelnation
 */
var ConeBufferGeometry = (function (_super) {
    __extends(ConeBufferGeometry, _super);
    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        _super.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = 'ConeBufferGeometry';
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    return ConeBufferGeometry;
}(CylinderBufferGeometry));

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */
var CircleBufferGeometry = (function (_super) {
    __extends(CircleBufferGeometry, _super);
    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
        _super.call(this);
        this.type = 'CircleBufferGeometry';
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius = radius || 50;
        segments = segments !== undefined ? Math.max(3, segments) : 8;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        var vertices = segments + 2;
        var positions = new Float32Array(vertices * 3);
        var normals = new Float32Array(vertices * 3);
        var uvs = new Float32Array(vertices * 2);
        // center data is already zero, but need to set a few extras
        normals[2] = 1.0;
        uvs[0] = 0.5;
        uvs[1] = 0.5;
        for (var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2) {
            var segment = thetaStart + s / segments * thetaLength;
            positions[i] = radius * Math.cos(segment);
            positions[i + 1] = radius * Math.sin(segment);
            normals[i + 2] = 1; // normal z
            uvs[ii] = (positions[i] / radius + 1) / 2;
            uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;
        }
        var indices = [];
        for (var i = 1; i <= segments; i++) {
            indices.push(i, i + 1, 0);
        }
        this.setIndex(new BufferAttribute(new Uint16Array(indices), 1));
        this.addAttribute('position', new BufferAttribute(positions, 3));
        this.addAttribute('normal', new BufferAttribute(normals, 3));
        this.addAttribute('uv', new BufferAttribute(uvs, 2));
        this.boundingSphere = new Sphere(new Vector3(), radius);
    }
    return CircleBufferGeometry;
}(BufferGeometry));

/**
 * @author hughes
 */
var CircleGeometry = (function (_super) {
    __extends(CircleGeometry, _super);
    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
        _super.call(this);
        this.type = 'CircleGeometry';
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
    }
    return CircleGeometry;
}(Geometry));

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */
var BoxGeometry = (function (_super) {
    __extends(BoxGeometry, _super);
    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        _super.call(this);
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
        this.mergeVertices();
    }
    return BoxGeometry;
}(Geometry));



var Geometries = Object.freeze({
	WireframeGeometry: WireframeGeometry,
	ParametricGeometry: ParametricGeometry,
	ParametricBufferGeometry: ParametricBufferGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronBufferGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronBufferGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronBufferGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronBufferGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronBufferGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeBufferGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusBufferGeometry,
	TextGeometry: TextGeometry,
	SphereBufferGeometry: SphereBufferGeometry,
	SphereGeometry: SphereGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingBufferGeometry,
	PlaneBufferGeometry: PlaneBufferGeometry,
	PlaneGeometry: PlaneGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheBufferGeometry,
	ShapeGeometry: ShapeGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	EdgesGeometry: EdgesGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeBufferGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderBufferGeometry,
	CircleBufferGeometry: CircleBufferGeometry,
	CircleGeometry: CircleGeometry,
	BoxBufferGeometry: BoxBufferGeometry,
	BoxGeometry: BoxGeometry
});

var ShadowMaterial = (function (_super) {
    __extends(ShadowMaterial, _super);
    function ShadowMaterial() {
        _super.call(this, {
            uniforms: UniformsUtils.merge([
                UniformsLib["lights"],
                {
                    opacity: { value: 1.0 }
                }
            ]),
            vertexShader: ShaderChunk['shadow_vert'],
            fragmentShader: ShaderChunk['shadow_frag']
        });
        this.isShadowMaterial = true;
        this.lights = true;
        this.transparent = true;
    }
    Object.defineProperty(ShadowMaterial.prototype, "opacity", {
        get: function () { return this.uniforms.opacity.value; },
        set: function (value) { this.uniforms.opacity.value = value; },
        enumerable: true,
        configurable: true
    });
    return ShadowMaterial;
}(ShaderMaterial));



var Materials = Object.freeze({
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MultiMaterial: MultiMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});

/**
 * @author mrdoob / http://mrdoob.com/
 */
var Cache = (function () {
    function Cache() {
    }
    Cache.add = function (key, file) {
        if (Cache.enabled === false)
            return;
        // console.log('THREE.Cache', 'Adding key:', key);
        Cache.files[key] = file;
    };
    Cache.get = function (key) {
        if (Cache.enabled === false)
            return;
        // console.log('THREE.Cache', 'Checking key:', key);
        return Cache.files[key];
    };
    Cache.remove = function (key) {
        delete Cache.files[key];
    };
    Cache.clear = function () {
        Cache.files = {};
    };
    Cache.enabled = false;
    Cache.files = {};
    return Cache;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var LoadingManager = (function () {
    function LoadingManager(onLoad, onProgress, onError) {
        this.isLoading = false;
        this.itemsLoaded = 0;
        this.itemsTotal = 0;
        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
    }
    LoadingManager.prototype.itemStart = function (url) {
        this.itemsTotal++;
        if (this.isLoading === false) {
            if (this.onStart !== undefined) {
                this.onStart(url, this.itemsLoaded, this.itemsTotal);
            }
        }
        this.isLoading = true;
    };
    LoadingManager.prototype.itemEnd = function (url) {
        this.itemsLoaded++;
        if (this.onProgress !== undefined) {
            this.onProgress(url, this.itemsLoaded, this.itemsTotal);
        }
        if (this.itemsLoaded === this.itemsTotal) {
            this.isLoading = false;
            if (this.onLoad !== undefined) {
                this.onLoad();
            }
        }
    };
    
    LoadingManager.prototype.itemError = function (url) {
        if (this.onError !== undefined) {
            this.onError(url);
        }
    };
    
    return LoadingManager;
}());
var DefaultLoadingManager = new LoadingManager();

/**
 * @author mrdoob / http://mrdoob.com/
 */
var XHRLoader = (function () {
    function XHRLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.manager = manager;
    }
    XHRLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        if (url === undefined)
            url = '';
        if (this.path !== undefined)
            url = this.path + url;
        var scope = this;
        var cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function () {
                if (onLoad)
                    onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        var request;
        // Check for data: URI
        var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        var dataUriRegexResult = url.match(dataUriRegex);
        // Safari can not handle Data URIs through XMLHttpRequest so process manually
        if (dataUriRegexResult) {
            var mimeType = dataUriRegexResult[1];
            var isBase64 = !!dataUriRegexResult[2];
            var data = dataUriRegexResult[3];
            data = decodeURIComponent(data);
            if (isBase64) {
                data = window.atob(data);
            }
            try {
                var response_1;
                var responseType = (this.responseType || '').toLowerCase();
                switch (responseType) {
                    case 'arraybuffer':
                    case 'blob':
                        response_1 = new ArrayBuffer(data.length);
                        var view = new Uint8Array(response_1);
                        for (var i = 0; i < data.length; i++) {
                            view[i] = data.charCodeAt(i);
                        }
                        if (responseType === 'blob') {
                            response_1 = new Blob([response_1], { "type": mimeType });
                        }
                        break;
                    case 'document':
                        var parser = new DOMParser();
                        response_1 = parser.parseFromString(data, mimeType);
                        break;
                    case 'json':
                        response_1 = JSON.parse(data);
                        break;
                    default:
                        response_1 = data;
                        break;
                }
                // Wait for next browser tick
                window.setTimeout(function () {
                    if (onLoad)
                        onLoad(response_1);
                    scope.manager.itemEnd(url);
                }, 0);
            }
            catch (error) {
                // Wait for next browser tick
                window.setTimeout(function () {
                    if (onError)
                        onError(error);
                    scope.manager.itemError(url);
                }, 0);
            }
        }
        else {
            request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.addEventListener('load', function (event) {
                var response = request.response;
                Cache.add(url, response);
                if (request.status === 200) {
                    if (onLoad)
                        onLoad(response);
                    scope.manager.itemEnd(url);
                }
                else if (request.status === 0) {
                    // Some browsers return HTTP Status 0 when using non-http protocol
                    // e.g. 'file://' or 'data://'. Handle as success.
                    console.warn('THREE.XHRLoader: HTTP Status 0 received.');
                    if (onLoad)
                        onLoad(response);
                    scope.manager.itemEnd(url);
                }
                else {
                    if (onError)
                        onError(event);
                    scope.manager.itemError(url);
                }
            }, false);
            if (onProgress !== undefined) {
                request.addEventListener('progress', function (event) {
                    onProgress(event);
                }, false);
            }
            request.addEventListener('error', function (event) {
                if (onError)
                    onError(event);
                scope.manager.itemError(url);
            }, false);
            if (this.responseType !== undefined)
                request.responseType = this.responseType;
            if (this.withCredentials !== undefined)
                request.withCredentials = this.withCredentials;
            if (request.overrideMimeType)
                request.overrideMimeType('text/plain');
            request.send(null);
        }
        scope.manager.itemStart(url);
        return request;
    };
    XHRLoader.prototype.setPath = function (value) {
        this.path = value;
        return this;
    };
    XHRLoader.prototype.setResponseType = function (value) {
        this.responseType = value;
        return this;
    };
    XHRLoader.prototype.setWithCredentials = function (value) {
        this.withCredentials = value;
        return this;
    };
    return XHRLoader;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */
var CompressedTextureLoader = (function () {
    function CompressedTextureLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.manager = manager;
        // override in sub classes
        this._parser = null;
    }
    CompressedTextureLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        var scope = this;
        var images = [];
        var texture = new CompressedTexture();
        texture.image = images;
        var loader = new XHRLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');
        var loaded = 0;
        function loadTexture(i) {
            loader.load(url[i], function (buffer) {
                var texDatas = scope._parser(buffer, true);
                images[i] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                };
                loaded += 1;
                if (loaded === 6) {
                    if (texDatas.mipmapCount === 1)
                        texture.minFilter = TextureFilter.Linear;
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad)
                        onLoad(texture);
                }
            }, onProgress, onError);
        }
        if (Array.isArray(url)) {
            loaded = 0;
            for (var i = 0, il = url.length; i < il; ++i) {
                loadTexture(i);
            }
        }
        else {
            // compressed cubemap texture stored in a single DDS file
            loader.load(url, function (buffer) {
                var texDatas = scope._parser(buffer, true);
                if (texDatas.isCubemap) {
                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                    for (var f = 0; f < faces; f++) {
                        images[f] = { mipmaps: [] };
                        for (var i = 0; i < texDatas.mipmapCount; i++) {
                            images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                            images[f].format = texDatas.format;
                            images[f].width = texDatas.width;
                            images[f].height = texDatas.height;
                        }
                    }
                }
                else {
                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;
                }
                if (texDatas.mipmapCount === 1) {
                    texture.minFilter = TextureFilter.Linear;
                }
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                    onLoad(texture);
            }, onProgress, onError);
        }
        return texture;
    };
    CompressedTextureLoader.prototype.setPath = function (value) {
        this.path = value;
        return this;
    };
    return CompressedTextureLoader;
}());

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */
var BinaryTextureLoader = (function () {
    function BinaryTextureLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.manager = manager;
        // override in sub classes
        this._parser = null;
    }
    BinaryTextureLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new DataTexture();
        var loader = new XHRLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.load(url, function (buffer) {
            var texData = scope._parser(buffer);
            if (!texData)
                return;
            if (undefined !== texData.image) {
                texture.image = texData.image;
            }
            else if (undefined !== texData.data) {
                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;
            }
            texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : TextureWrapping.ClampToEdge;
            texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : TextureWrapping.ClampToEdge;
            texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : TextureFilter.Linear;
            texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : TextureFilter.LinearMipMapLinear;
            texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
            if (undefined !== texData.format) {
                texture.format = texData.format;
            }
            if (undefined !== texData.type) {
                texture.type = texData.type;
            }
            if (undefined !== texData.mipmaps) {
                texture.mipmaps = texData.mipmaps;
            }
            if (1 === texData.mipmapCount) {
                texture.minFilter = TextureFilter.Linear;
            }
            texture.needsUpdate = true;
            if (onLoad)
                onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
    };
    return BinaryTextureLoader;
}());
var DataTextureLoader = BinaryTextureLoader;

/**
 * @author mrdoob / http://mrdoob.com/
 */
var ImageLoader = (function () {
    function ImageLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.manager = manager;
    }
    ImageLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        var scope = this;
        var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        image.onload = function (event) {
            image.onload = null;
            URL.revokeObjectURL(image.src);
            if (onLoad)
                onLoad(image);
            scope.manager.itemEnd(url);
        };
        image.onerror = onError;
        if (url.indexOf('data:') === 0) {
            image.src = url;
        }
        else {
            var loader = new XHRLoader();
            loader.setPath(this.path);
            loader.setResponseType('blob');
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function (blob) {
                image.src = URL.createObjectURL(blob);
            }, onProgress, onError);
        }
        scope.manager.itemStart(url);
        return image;
    };
    ImageLoader.prototype.setCrossOrigin = function (value) {
        this.crossOrigin = value;
        return this;
    };
    ImageLoader.prototype.setWithCredentials = function (value) {
        this.withCredentials = value;
        return this;
    };
    ImageLoader.prototype.setPath = function (value) {
        this.path = value;
        return this;
    };
    return ImageLoader;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var CubeTextureLoader = (function () {
    function CubeTextureLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.manager = manager;
    }
    CubeTextureLoader.prototype.load = function (urls, onLoad, onProgress, onError) {
        var texture = new CubeTexture();
        var loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        var loaded = 0;
        function loadTexture(i) {
            loader.load(urls[i], function (image) {
                texture.images[i] = image;
                loaded++;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad)
                        onLoad(texture);
                }
            }, undefined, onError);
        }
        for (var i = 0; i < urls.length; ++i) {
            loadTexture(i);
        }
        return texture;
    };
    CubeTextureLoader.prototype.setCrossOrigin = function (value) {
        this.crossOrigin = value;
        return this;
    };
    CubeTextureLoader.prototype.setPath = function (value) {
        this.path = value;
        return this;
    };
    return CubeTextureLoader;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var TextureLoader = (function () {
    function TextureLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.manager = manager;
    }
    TextureLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        var texture = new Texture();
        var loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setWithCredentials(this.withCredentials);
        loader.setPath(this.path);
        loader.load(url, function (image) {
            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
            var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture.format = isJPEG ? TextureFormat.RGB : TextureFormat.RGBA;
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad !== undefined) {
                onLoad(texture);
            }
        }, onProgress, onError);
        return texture;
    };
    TextureLoader.prototype.setCrossOrigin = function (value) {
        this.crossOrigin = value;
        return this;
    };
    TextureLoader.prototype.setWithCredentials = function (value) {
        this.withCredentials = value;
        return this;
    };
    TextureLoader.prototype.setPath = function (value) {
        this.path = value;
        return this;
    };
    return TextureLoader;
}());

/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */
var AnimationUtils = (function () {
    function AnimationUtils() {
    }
    // same as Array.prototype.slice, but also works on typed arrays
    AnimationUtils.arraySlice = function (array, from, to) {
        if (AnimationUtils.isTypedArray(array)) {
            return new array.constructor(array.subarray(from, to));
        }
        return array.slice(from, to);
    };
    // converts an array to a specific type
    AnimationUtils.convertArray = function (array, type, forceClone) {
        if (forceClone === void 0) { forceClone = false; }
        if (!array ||
            !forceClone && array.constructor === type)
            return array;
        if (typeof type.BYTES_PER_ELEMENT === 'number') {
            return new type(array); // create typed array
        }
        return Array.prototype.slice.call(array); // create Array
    };
    AnimationUtils.isTypedArray = function (object) {
        return ArrayBuffer.isView(object) &&
            !(object instanceof DataView);
    };
    // returns an array by which times and values can be sorted
    AnimationUtils.getKeyframeOrder = function (times) {
        function compareTime(i, j) {
            return times[i] - times[j];
        }
        var n = times.length;
        var result = new Array(n);
        for (var i = 0; i !== n; ++i)
            result[i] = i;
        result.sort(compareTime);
        return result;
    };
    // uses the array previously returned by 'getKeyframeOrder' to sort data
    AnimationUtils.sortedArray = function (values, stride, order) {
        var nValues = values.length;
        var result = new values.constructor(nValues);
        for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
            var srcOffset = order[i] * stride;
            for (var j = 0; j !== stride; ++j) {
                result[dstOffset++] = values[srcOffset + j];
            }
        }
        return result;
    };
    // function for parsing AOS keyframe formats
    AnimationUtils.flattenJSON = function (jsonKeys, times, values, valuePropertyName) {
        var i = 1, key = jsonKeys[0];
        while (key !== undefined && key[valuePropertyName] === undefined) {
            key = jsonKeys[i++];
        }
        if (key === undefined)
            return; // no data
        var value = key[valuePropertyName];
        if (value === undefined)
            return; // no data
        if (Array.isArray(value)) {
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    values.push.apply(values, value); // push all elements
                }
                key = jsonKeys[i++];
            } while (key !== undefined);
        }
        else if (value.toArray !== undefined) {
            // ...assume THREE.Math-ish
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    value.toArray(values, values.length);
                }
                key = jsonKeys[i++];
            } while (key !== undefined);
        }
        else {
            // otherwise push as-is
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    values.push(value);
                }
                key = jsonKeys[i++];
            } while (key !== undefined);
        }
    };
    return AnimationUtils;
}());

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 *     http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */
var Interpolant = (function () {
    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.settings = null; // optional, subclass-specific settings structure
        // Note: The indirection allows central control of many interpolants.
        // --- Protected interface
        this.DefaultSettings_ = {};
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== undefined ?
            resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
    }
    Interpolant.prototype.evaluate = function (t) {
        var pp = this.parameterPositions;
        var i1 = this._cachedIndex;
        var t1 = pp[i1];
        var t0 = pp[i1 - 1];
        validate_interval: {
            seek: {
                var right = void 0;
                linear_scan: {
                    //- See http://jsperf.com/comparison-to-undefined/3
                    //- slower code:
                    //-
                    //-         if (t >= t1 || t1 === undefined) {
                    forward_scan: if (!(t < t1)) {
                        for (var giveUpAt = i1 + 2;;) {
                            if (t1 === undefined) {
                                if (t < t0)
                                    break forward_scan;
                                // after end
                                i1 = pp.length;
                                this._cachedIndex = i1;
                                return this.afterEnd_(i1 - 1, t, t0);
                            }
                            if (i1 === giveUpAt)
                                break; // this loop
                            t0 = t1;
                            t1 = pp[++i1];
                            if (t < t1) {
                                // we have arrived at the sought interval
                                break seek;
                            }
                        }
                        // prepare binary search on the right side of the index
                        right = pp.length;
                        break linear_scan;
                    }
                    //- slower code:
                    //-          if (t < t0 || t0 === undefined) {
                    if (!(t >= t0)) {
                        // looping?
                        var t1global = pp[1];
                        if (t < t1global) {
                            i1 = 2; // + 1, using the scan for the details
                            t0 = t1global;
                        }
                        // linear reverse scan
                        for (var giveUpAt = i1 - 2;;) {
                            if (t0 === undefined) {
                                // before start
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t, t1);
                            }
                            if (i1 === giveUpAt)
                                break; // this loop
                            t1 = t0;
                            t0 = pp[--i1 - 1];
                            if (t >= t0) {
                                // we have arrived at the sought interval
                                break seek;
                            }
                        }
                        // prepare binary search on the left side of the index
                        right = i1;
                        i1 = 0;
                        break linear_scan;
                    }
                    // the interval is valid
                    break validate_interval;
                } // linear scan
                // binary search
                while (i1 < right) {
                    var mid = (i1 + right) >>> 1;
                    if (t < pp[mid]) {
                        right = mid;
                    }
                    else {
                        i1 = mid + 1;
                    }
                }
                t1 = pp[i1];
                t0 = pp[i1 - 1];
                // check boundary cases, again
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t1);
                }
                if (t1 === undefined) {
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t0, t);
                }
            } // seek
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
        } // validate_interval
        return this.interpolate_(i1, t0, t, t1);
    };
    Interpolant.prototype.getSettings_ = function () {
        return this.settings || this.DefaultSettings_;
    };
    Interpolant.prototype.copySampleValue_ = function (index, t0, t1) {
        // copies a sample value to the result buffer
        var result = this.resultBuffer;
        var values = this.sampleValues;
        var stride = this.valueSize;
        var offset = index * stride;
        for (var i = 0; i !== stride; ++i) {
            result[i] = values[offset + i];
        }
        return result;
    };
    // Template methods for derived classes:
    Interpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
        throw new Error("call to abstract method");
        // implementations shall return this.resultBuffer
    };
    Interpolant.prototype.intervalChanged_ = function (i1, t0, t1) {
        // empty
    };
    Interpolant.prototype.beforeStart_ = function (i, t0, t1) {
        return this.copySampleValue_(i, t0, t1); //(0, t, t0), returns this.resultBuffer
    };
    Interpolant.prototype.afterEnd_ = function (i, t0, t1) {
        return this.copySampleValue_(i, t0, t1); //(N-1, tN-1, t), returns this.resultBuffer
    };
    return Interpolant;
}());

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */
var CubicInterpolant = (function (_super) {
    __extends(CubicInterpolant, _super);
    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
        this.DefaultSettings_ = {
            endingStart: EndingMode.ZeroCurvature,
            endingEnd: EndingMode.ZeroCurvature
        };
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
    }
    CubicInterpolant.prototype.intervalChanged_ = function (i1, t0, t1) {
        var pp = this.parameterPositions;
        var iPrev = i1 - 2;
        var iNext = i1 + 1;
        var tPrev = pp[iPrev];
        var tNext = pp[iNext];
        if (tPrev === undefined) {
            switch (this.getSettings_().endingStart) {
                case EndingMode.ZeroSlope:
                    // f'(t0) = 0
                    iPrev = i1;
                    tPrev = 2 * t0 - t1;
                    break;
                case EndingMode.WrapAround:
                    // use the other end of the curve
                    iPrev = pp.length - 2;
                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                    break;
                default:
                    // f''(t0) = 0 a.k.a. Natural Spline
                    iPrev = i1;
                    tPrev = t1;
            }
        }
        if (tNext === undefined) {
            switch (this.getSettings_().endingEnd) {
                case EndingMode.ZeroSlope:
                    // f'(tN) = 0
                    iNext = i1;
                    tNext = 2 * t1 - t0;
                    break;
                case EndingMode.WrapAround:
                    // use the other end of the curve
                    iNext = 1;
                    tNext = t1 + pp[1] - pp[0];
                    break;
                default:
                    // f''(tN) = 0, a.k.a. Natural Spline
                    iNext = i1 - 1;
                    tNext = t0;
            }
        }
        var halfDt = (t1 - t0) * 0.5;
        var stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    };
    CubicInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
        var result = this.resultBuffer;
        var values = this.sampleValues;
        var stride = this.valueSize;
        var o1 = i1 * stride;
        var o0 = o1 - stride;
        var oP = this._offsetPrev;
        var oN = this._offsetNext;
        var wP = this._weightPrev;
        var wN = this._weightNext;
        var p = (t - t0) / (t1 - t0);
        var pp = p * p;
        var ppp = pp * p;
        // evaluate polynomials
        var sP = -wP * ppp + 2 * wP * pp - wP * p;
        var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        var sN = wN * ppp - wN * pp;
        // combine data linearly
        for (var i = 0; i !== stride; ++i) {
            result[i] =
                sP * values[oP + i] +
                    s0 * values[o0 + i] +
                    s1 * values[o1 + i] +
                    sN * values[oN + i];
        }
        return result;
    };
    return CubicInterpolant;
}(Interpolant));

/**
 * @author tschw
 */
var LinearInterpolant = (function (_super) {
    __extends(LinearInterpolant, _super);
    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    LinearInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
        var result = this.resultBuffer;
        var values = this.sampleValues;
        var stride = this.valueSize;
        var offset1 = i1 * stride;
        var offset0 = offset1 - stride;
        var weight1 = (t - t0) / (t1 - t0);
        var weight0 = 1 - weight1;
        for (var i = 0; i !== stride; ++i) {
            result[i] =
                values[offset0 + i] * weight0 +
                    values[offset1 + i] * weight1;
        }
        return result;
    };
    return LinearInterpolant;
}(Interpolant));

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */
var DiscreteInterpolant = (function (_super) {
    __extends(DiscreteInterpolant, _super);
    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    DiscreteInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
        return this.copySampleValue_(i1 - 1);
    };
    return DiscreteInterpolant;
}(Interpolant));

/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
var KeyframeTrack = (function () {
    function KeyframeTrack(name, times, values, interpolation) {
        this.TimeBufferType = Float32Array;
        this.ValueBufferType = Float32Array;
        this.DefaultInterpolation = InterpolateMode.Linear;
        if (name === undefined)
            throw new Error("track name is undefined");
        if (times === undefined || times.length === 0) {
            throw new Error("no keyframes in track named " + name);
        }
        this.name = name;
        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
        this.validate();
        this.optimize();
    }
    KeyframeTrack.prototype.InterpolantFactoryMethodDiscrete = function (result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    };
    KeyframeTrack.prototype.InterpolantFactoryMethodLinear = function (result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    };
    KeyframeTrack.prototype.InterpolantFactoryMethodSmooth = function (result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    };
    KeyframeTrack.prototype.setInterpolation = function (interpolation) {
        var factoryMethod;
        switch (interpolation) {
            case InterpolateMode.Discrete:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;
            case InterpolateMode.Linear:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;
            case InterpolateMode.Smooth:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (factoryMethod === undefined) {
            var message = "unsupported interpolation for " +
                this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === undefined) {
                // fall back to default, unless the default itself is messed up
                if (interpolation !== this.DefaultInterpolation) {
                    this.setInterpolation(this.DefaultInterpolation);
                }
                else {
                    throw new Error(message); // fatal, in this case
                }
            }
            console.warn(message);
            return;
        }
        this.createInterpolant = factoryMethod;
    };
    KeyframeTrack.prototype.getInterpolation = function () {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return InterpolateMode.Discrete;
            case this.InterpolantFactoryMethodLinear:
                return InterpolateMode.Linear;
            case this.InterpolantFactoryMethodSmooth:
                return InterpolateMode.Smooth;
        }
        throw new Error();
    };
    KeyframeTrack.prototype.getValueSize = function () {
        return this.values.length / this.times.length;
    };
    // move all keyframes either forwards or backwards in time
    KeyframeTrack.prototype.shift = function (timeOffset) {
        if (timeOffset !== 0.0) {
            var times = this.times;
            for (var i = 0, n = times.length; i !== n; ++i) {
                times[i] += timeOffset;
            }
        }
        return this;
    };
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    KeyframeTrack.prototype.scale = function (timeScale) {
        if (timeScale !== 1.0) {
            var times = this.times;
            for (var i = 0, n = times.length; i !== n; ++i) {
                times[i] *= timeScale;
            }
        }
        return this;
    };
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    KeyframeTrack.prototype.trim = function (startTime, endTime) {
        var times = this.times;
        var nKeys = times.length;
        var from = 0;
        var to = nKeys - 1;
        while (from !== nKeys && times[from] < startTime)
            ++from;
        while (to !== -1 && times[to] > endTime)
            --to;
        ++to; // inclusive -> exclusive bound
        if (from !== 0 || to !== nKeys) {
            // empty tracks are forbidden, so keep at least one keyframe
            if (from >= to)
                to = Math.max(to, 1), from = to - 1;
            var stride = this.getValueSize();
            this.times = AnimationUtils.arraySlice(times, from, to);
            this.values = AnimationUtils.
                arraySlice(this.values, from * stride, to * stride);
        }
        return this;
    };
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    KeyframeTrack.prototype.validate = function () {
        var valid = true;
        var valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("invalid value size in track", this);
            valid = false;
        }
        var times = this.times;
        var values = this.values;
        var nKeys = times.length;
        if (nKeys === 0) {
            console.error("track is empty", this);
            valid = false;
        }
        var prevTime = null;
        for (var i = 0; i !== nKeys; i++) {
            var currTime = times[i];
            if (typeof currTime === 'number' && isNaN(currTime)) {
                console.error("time is not a valid number", this, i, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error("out of order keys", this, i, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values !== undefined) {
            if (AnimationUtils.isTypedArray(values)) {
                for (var i = 0, n = values.length; i !== n; ++i) {
                    var value = values[i];
                    if (isNaN(value)) {
                        console.error("value is not a valid number", this, i, value);
                        valid = false;
                        break;
                    }
                }
            }
        }
        return valid;
    };
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    KeyframeTrack.prototype.optimize = function () {
        var times = this.times;
        var values = this.values;
        var stride = this.getValueSize();
        var smoothInterpolation = this.getInterpolation() === InterpolateMode.Smooth;
        var writeIndex = 1;
        var lastIndex = times.length - 1;
        for (var i = 1; i < lastIndex; ++i) {
            var keep = false;
            var time = times[i];
            var timeNext = times[i + 1];
            // remove adjacent keyframes scheduled at the same time
            if (time !== timeNext && (i !== 1 || time !== time[0])) {
                if (!smoothInterpolation) {
                    // remove unnecessary keyframes same as their neighbors
                    var offset = i * stride;
                    var offsetP = offset - stride;
                    var offsetN = offset + stride;
                    for (var j = 0; j !== stride; ++j) {
                        var value = values[offset + j];
                        if (value !== values[offsetP + j] ||
                            value !== values[offsetN + j]) {
                            keep = true;
                            break;
                        }
                    }
                }
                else
                    keep = true;
            }
            // in-place compaction
            if (keep) {
                if (i !== writeIndex) {
                    times[writeIndex] = times[i];
                    var readOffset = i * stride;
                    var writeOffset = writeIndex * stride;
                    for (var j = 0; j !== stride; ++j)
                        values[writeOffset + j] = values[readOffset + j];
                }
                ++writeIndex;
            }
        }
        // flush last keyframe (compaction looks ahead)
        if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j)
                values[writeOffset + j] = values[readOffset + j];
            ++writeIndex;
        }
        if (writeIndex !== times.length) {
            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        }
        return this;
    };
    return KeyframeTrack;
}());

/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
var NewStringKeyframeTrack = (function (_super) {
    __extends(NewStringKeyframeTrack, _super);
    function NewStringKeyframeTrack(name, times, values, interpolation) {
        _super.call(this, name, times, values, interpolation);
        this.ValueTypeName = 'string';
        this.ValueBufferType = Array;
        this.DefaultInterpolation = InterpolateMode.Discrete;
    }
    return NewStringKeyframeTrack;
}(KeyframeTrack));

/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
var NewBooleanKeyframeTrack = (function (_super) {
    __extends(NewBooleanKeyframeTrack, _super);
    function NewBooleanKeyframeTrack(name, times, values, interpolation) {
        _super.call(this, name, times, values, interpolation);
        this.ValueTypeName = 'color';
        this.ValueBufferType = Array;
        this.DefaultInterpolation = InterpolateMode.Discrete;
    }
    return NewBooleanKeyframeTrack;
}(KeyframeTrack));

/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */
var QuaternionLinearInterpolant = (function (_super) {
    __extends(QuaternionLinearInterpolant, _super);
    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    QuaternionLinearInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
        var result = this.resultBuffer;
        var values = this.sampleValues;
        var stride = this.valueSize;
        var offset = i1 * stride;
        var alpha = (t - t0) / (t1 - t0);
        for (var end = offset + stride; offset !== end; offset += 4) {
            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        }
        return result;
    };
    return QuaternionLinearInterpolant;
}(Interpolant));

/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
var NewQuaternionKeyframeTrack = (function (_super) {
    __extends(NewQuaternionKeyframeTrack, _super);
    function NewQuaternionKeyframeTrack(name, times, values, interpolation) {
        _super.call(this, name, times, values, interpolation);
        this.ValueTypeName = 'quaternion';
        // ValueBufferType is inherited
        this.DefaultInterpolation = InterpolateMode.Linear;
    }
    NewQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodLinear = function (result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    };
    return NewQuaternionKeyframeTrack;
}(KeyframeTrack));

/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
var NewColorKeyframeTrack = (function (_super) {
    __extends(NewColorKeyframeTrack, _super);
    function NewColorKeyframeTrack(name, times, values, interpolation) {
        _super.call(this, name, times, values, interpolation);
        this.ValueTypeName = 'color';
    }
    return NewColorKeyframeTrack;
}(KeyframeTrack));

/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
var NewVectorKeyframeTrack = (function (_super) {
    __extends(NewVectorKeyframeTrack, _super);
    function NewVectorKeyframeTrack(name, times, values, interpolation) {
        _super.call(this, name, times, values, interpolation);
        this.ValueTypeName = 'vector';
    }
    return NewVectorKeyframeTrack;
}(KeyframeTrack));

/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
var NewNumberKeyframeTrack = (function (_super) {
    __extends(NewNumberKeyframeTrack, _super);
    function NewNumberKeyframeTrack(name, times, values, interpolation) {
        _super.call(this, name, times, values, interpolation);
        this.ValueTypeName = 'number';
    }
    return NewNumberKeyframeTrack;
}(KeyframeTrack));

var KeyframeTrackUtils = (function () {
    function KeyframeTrackUtils() {
    }
    // Static methods:
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    KeyframeTrackUtils.parse = function (json) {
        if (json.type === undefined) {
            throw new Error("track type undefined, can not parse");
        }
        var trackType = KeyframeTrackUtils._getTrackTypeForValueTypeName(json.type);
        if (json.times === undefined) {
            var times = [], values = [];
            AnimationUtils.flattenJSON(json.keys, times, values, 'value');
            json.times = times;
            json.values = values;
        }
        // derived classes can define a static parse method
        if (trackType.parse !== undefined) {
            return trackType.parse(json);
        }
        else {
            // by default, we asssume a constructor compatible with the base
            return new trackType(json.name, json.times, json.values, json.interpolation);
        }
    };
    KeyframeTrackUtils.toJSON = function (track) {
        var trackType = track.constructor;
        var json;
        // derived classes can define a static toJSON method
        if (trackType.toJSON !== undefined) {
            json = trackType.toJSON(track);
        }
        else {
            // by default, we assume the data can be serialized as-is
            json = {
                'name': track.name,
                'times': AnimationUtils.convertArray(track.times, Array),
                'values': AnimationUtils.convertArray(track.values, Array)
            };
            var interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) {
                json.interpolation = interpolation;
            }
        }
        json.type = track.ValueTypeName; // mandatory
        return json;
    };
    KeyframeTrackUtils._getTrackTypeForValueTypeName = function (typeName) {
        switch (typeName.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return NewNumberKeyframeTrack;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return NewVectorKeyframeTrack;
            case "color":
                return NewColorKeyframeTrack;
            case "quaternion":
                return NewQuaternionKeyframeTrack;
            case "bool":
            case "boolean":
                return NewBooleanKeyframeTrack;
            case "string":
                return NewStringKeyframeTrack;
        }
        throw new Error("Unsupported typeName: " + typeName);
    };
    return KeyframeTrackUtils;
}());

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */
var AnimationClip = (function () {
    function AnimationClip(name, duration, tracks) {
        this.name = name;
        this.tracks = tracks;
        this.duration = (duration !== undefined) ? duration : -1;
        this.uuid = _Math.generateUUID();
        // this means it should figure out its duration by scanning the tracks
        if (this.duration < 0) {
            this.resetDuration();
        }
        this.optimize();
    }
    AnimationClip.prototype.resetDuration = function () {
        var tracks = this.tracks;
        var duration = 0;
        for (var i = 0, n = tracks.length; i !== n; ++i) {
            var track = this.tracks[i];
            duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
    };
    AnimationClip.prototype.trim = function () {
        for (var i = 0; i < this.tracks.length; i++) {
            this.tracks[i].trim(0, this.duration);
        }
        return this;
    };
    AnimationClip.prototype.optimize = function () {
        for (var i = 0; i < this.tracks.length; i++) {
            this.tracks[i].optimize();
        }
        return this;
    };
    // Static methods:
    AnimationClip.parse = function (json) {
        var tracks = [], jsonTracks = json.tracks, frameTime = 1.0 / (json.fps || 1.0);
        for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
            tracks.push(KeyframeTrackUtils.parse(jsonTracks[i]).scale(frameTime));
        }
        return new AnimationClip(json.name, json.duration, tracks);
    };
    AnimationClip.toJSON = function (clip) {
        var tracks = [];
        var clipTracks = clip.tracks;
        var json = {
            'name': clip.name,
            'duration': clip.duration,
            'tracks': tracks
        };
        for (var i = 0, n = clipTracks.length; i !== n; ++i) {
            tracks.push(KeyframeTrackUtils.toJSON(clipTracks[i]));
        }
        return json;
    };
    AnimationClip.CreateFromMorphTargetSequence = function (name, morphTargetSequence, fps, noLoop) {
        var numMorphTargets = morphTargetSequence.length;
        var tracks = [];
        for (var i = 0; i < numMorphTargets; i++) {
            var times = [];
            var values = [];
            times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
            values.push(0, 1, 0);
            var order = AnimationUtils.getKeyframeOrder(times);
            times = AnimationUtils.sortedArray(times, 1, order);
            values = AnimationUtils.sortedArray(values, 1, order);
            // if there is a key at the first frame, duplicate it as the
            // last frame as well for perfect loop.
            if (!noLoop && times[0] === 0) {
                times.push(numMorphTargets);
                values.push(values[0]);
            }
            tracks.push(new NewNumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
        }
        return new AnimationClip(name, -1, tracks);
    };
    AnimationClip.findByName = function (objectOrClipArray, name) {
        var clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            var o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for (var i = 0; i < clipArray.length; i++) {
            if (clipArray[i].name === name) {
                return clipArray[i];
            }
        }
        return null;
    };
    AnimationClip.CreateClipsFromMorphTargetSequences = function (morphTargets, fps, noLoop) {
        var animationToMorphTargets = {};
        // tested with https://regex101.com/ on trick sequences
        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
        var pattern = /^([\w-]*?)([\d]+)$/;
        // sort morph target names into animation groups based
        // patterns like Walk_001, Walk_002, Run_001, Run_002
        for (var i = 0, il = morphTargets.length; i < il; i++) {
            var morphTarget = morphTargets[i];
            var parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                var name = parts[1];
                var animationMorphTargets = animationToMorphTargets[name];
                if (!animationMorphTargets) {
                    animationToMorphTargets[name] = animationMorphTargets = [];
                }
                animationMorphTargets.push(morphTarget);
            }
        }
        var clips = [];
        for (var name in animationToMorphTargets) {
            clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        }
        return clips;
    };
    // parse the animation.hierarchy format
    AnimationClip.parseAnimation = function (animation, bones) {
        if (!animation) {
            console.error("  no animation in JSONLoader data");
            return null;
        }
        function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {
            // only return track if there are actually keys.
            if (animationKeys.length !== 0) {
                var times = [];
                var values = [];
                AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                // empty keys are filtered out, so check again
                if (times.length !== 0) {
                    destTracks.push(new trackType(trackName, times, values));
                }
            }
        }
        var tracks = [];
        var clipName = animation.name || 'default';
        // automatic length determination in AnimationClip.
        var duration = animation.length || -1;
        var fps = animation.fps || 30;
        var hierarchyTracks = animation.hierarchy || [];
        for (var h = 0; h < hierarchyTracks.length; h++) {
            var animationKeys = hierarchyTracks[h].keys;
            // skip empty tracks
            if (!animationKeys || animationKeys.length === 0)
                continue;
            // process morph targets in a way exactly compatible
            // with AnimationHandler.init(animation)
            if (animationKeys[0].morphTargets) {
                // figure out all morph targets used in this track
                var morphTargetNames = {};
                var k = void 0;
                for (k = 0; k < animationKeys.length; k++) {
                    if (animationKeys[k].morphTargets) {
                        for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                            morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                        }
                    }
                }
                // create a track for each morph target with all zero
                // morphTargetInfluences except for the keys in which
                // the morphTarget is named.
                for (var morphTargetName in morphTargetNames) {
                    var times = [];
                    var values = [];
                    for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                        var animationKey = animationKeys[k];
                        times.push(animationKey.time);
                        values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
                    }
                    tracks.push(new NewNumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                }
                duration = morphTargetNames.length * (fps || 1.0);
            }
            else {
                // ...assume skeletal animation
                var boneName = '.bones[' + bones[h].name + ']';
                addNonemptyTrack(NewVectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                addNonemptyTrack(NewQuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                addNonemptyTrack(NewVectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
            }
        }
        if (tracks.length === 0) {
            return null;
        }
        var clip = new AnimationClip(clipName, duration, tracks);
        return clip;
    };
    return AnimationClip;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var MaterialLoader = (function () {
    function MaterialLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.textures = new Map();
        this.manager = manager;
    }
    MaterialLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new XHRLoader(scope.manager);
        loader.load(url, function (text) {
            onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
    };
    MaterialLoader.prototype.setTextures = function (value) {
        this.textures = value;
    };
    MaterialLoader.prototype.parse = function (json) {
        var textures = this.textures;
        function getTexture(name) {
            if (textures[name] === undefined) {
                console.warn('THREE.MaterialLoader: Undefined texture', name);
            }
            return textures[name];
        }
        var material = new Materials[json.type]();
        if (json.uuid !== undefined)
            material.uuid = json.uuid;
        if (json.name !== undefined)
            material.name = json.name;
        if (json.color !== undefined)
            material.color.setHex(json.color);
        if (json.roughness !== undefined)
            material.roughness = json.roughness;
        if (json.metalness !== undefined)
            material.metalness = json.metalness;
        if (json.emissive !== undefined)
            material.emissive.setHex(json.emissive);
        if (json.specular !== undefined)
            material.specular.setHex(json.specular);
        if (json.shininess !== undefined)
            material.shininess = json.shininess;
        if (json.uniforms !== undefined)
            material.uniforms = json.uniforms;
        if (json.vertexShader !== undefined)
            material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined)
            material.fragmentShader = json.fragmentShader;
        if (json.vertexColors !== undefined)
            material.vertexColors = json.vertexColors;
        if (json.fog !== undefined)
            material.fog = json.fog;
        if (json.shading !== undefined)
            material.shading = json.shading;
        if (json.blending !== undefined)
            material.blending = json.blending;
        if (json.side !== undefined)
            material.side = json.side;
        if (json.opacity !== undefined)
            material.opacity = json.opacity;
        if (json.transparent !== undefined)
            material.transparent = json.transparent;
        if (json.alphaTest !== undefined)
            material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined)
            material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined)
            material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined)
            material.colorWrite = json.colorWrite;
        if (json.wireframe !== undefined)
            material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined)
            material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined)
            material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined)
            material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.skinning !== undefined)
            material.skinning = json.skinning;
        if (json.morphTargets !== undefined)
            material.morphTargets = json.morphTargets;
        // for PointsMaterial
        if (json.size !== undefined)
            material.size = json.size;
        if (json.sizeAttenuation !== undefined)
            material.sizeAttenuation = json.sizeAttenuation;
        // maps
        if (json.map !== undefined)
            material.map = getTexture(json.map);
        if (json.alphaMap !== undefined) {
            material.alphaMap = getTexture(json.alphaMap);
            material.transparent = true;
        }
        if (json.bumpMap !== undefined)
            material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined)
            material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined)
            material.normalMap = getTexture(json.normalMap);
        if (json.normalScale !== undefined) {
            var normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) {
                // Blender exporter used to export a scalar. See #7459
                normalScale = [normalScale, normalScale];
            }
            material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined)
            material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined)
            material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined)
            material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined)
            material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined)
            material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined)
            material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined)
            material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined)
            material.specularMap = getTexture(json.specularMap);
        if (json.envMap !== undefined)
            material.envMap = getTexture(json.envMap);
        if (json.reflectivity !== undefined)
            material.reflectivity = json.reflectivity;
        if (json.lightMap !== undefined)
            material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined)
            material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined)
            material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined)
            material.aoMapIntensity = json.aoMapIntensity;
        // MultiMaterial
        if (json.materials !== undefined) {
            for (var i = 0, l = json.materials.length; i < l; i++) {
                material.materials.push(this.parse(json.materials[i]));
            }
        }
        return material;
    };
    return MaterialLoader;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var BufferGeometryLoader = (function () {
    function BufferGeometryLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.manager = manager;
    }
    BufferGeometryLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new XHRLoader(scope.manager);
        loader.load(url, function (text) {
            onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
    };
    BufferGeometryLoader.prototype.parse = function (json) {
        var geometry = new BufferGeometry();
        var index = json.data.index;
        var TYPED_ARRAYS = {
            'Int8Array': Int8Array,
            'Uint8Array': Uint8Array,
            'Uint8ClampedArray': Uint8ClampedArray,
            'Int16Array': Int16Array,
            'Uint16Array': Uint16Array,
            'Int32Array': Int32Array,
            'Uint32Array': Uint32Array,
            'Float32Array': Float32Array,
            'Float64Array': Float64Array
        };
        if (index !== undefined) {
            var typedArray = new TYPED_ARRAYS[index.type](index.array);
            geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        var attributes = json.data.attributes;
        for (var key in attributes) {
            var attribute = attributes[key];
            var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
            geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
        }
        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) {
            for (var i = 0, n = groups.length; i !== n; ++i) {
                var group = groups[i];
                geometry.addGroup(group.start, group.count, group.materialIndex);
            }
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
            var center = new Vector3();
            if (boundingSphere.center !== undefined) {
                center.fromArray(boundingSphere.center);
            }
            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        return geometry;
    };
    return BufferGeometryLoader;
}());

/**
 * @author alteredq / http://alteredqualia.com/
 */
var Loader = (function () {
    function Loader() {
        this.onLoadStart = function () { };
        this.onLoadProgress = function () { };
        this.onLoadComplete = function () { };
    }
    Loader.prototype.extractUrlBase = function (url) {
        var parts = url.split('/');
        if (parts.length === 1)
            return './';
        parts.pop();
        return parts.join('/') + '/';
    };
    Loader.prototype.initMaterials = function (materials, texturePath, crossOrigin) {
        var array = [];
        for (var i = 0; i < materials.length; ++i) {
            array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
        }
        return array;
    };
    Loader.prototype.createMaterial = function (m, texturePath, crossOrigin) {
        var color = new Color(), textureLoader = new TextureLoader(), materialLoader = new MaterialLoader();
        //return function createMaterial(m, texturePath, crossOrigin) {
        // convert from old material format
        var textures = new Map();
        function loadTexture(path, repeat, offset, wrap, anisotropy) {
            var fullPath = texturePath + path;
            var loader = Loader.Handlers.get(fullPath);
            var texture;
            if (loader !== null) {
                texture = loader.load(fullPath);
            }
            else {
                textureLoader.setCrossOrigin(crossOrigin);
                texture = textureLoader.load(fullPath);
            }
            if (repeat !== undefined) {
                texture.repeat.fromArray(repeat);
                if (repeat[0] !== 1)
                    texture.wrapS = TextureWrapping.Repeat;
                if (repeat[1] !== 1)
                    texture.wrapT = TextureWrapping.Repeat;
            }
            if (offset !== undefined) {
                texture.offset.fromArray(offset);
            }
            if (wrap !== undefined) {
                if (wrap[0] === 'repeat')
                    texture.wrapS = TextureWrapping.Repeat;
                if (wrap[0] === 'mirror')
                    texture.wrapS = TextureWrapping.MirroredRepeat;
                if (wrap[1] === 'repeat')
                    texture.wrapT = TextureWrapping.Repeat;
                if (wrap[1] === 'mirror')
                    texture.wrapT = TextureWrapping.MirroredRepeat;
            }
            if (anisotropy !== undefined) {
                texture.anisotropy = anisotropy;
            }
            var uuid = _Math.generateUUID();
            textures[uuid] = texture;
            return uuid;
        }
        //
        var json = {
            uuid: _Math.generateUUID(),
            type: 'MeshLambertMaterial'
        };
        for (var name in m) {
            var value = m[name];
            switch (name) {
                case 'DbgColor':
                case 'DbgIndex':
                case 'opticalDensity':
                case 'illumination':
                    break;
                case 'DbgName':
                    json.name = value;
                    break;
                case 'blending':
                    json.blending = BlendingMode[value];
                    break;
                case 'colorAmbient':
                case 'mapAmbient':
                    console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
                    break;
                case 'colorDiffuse':
                    json.color = color.fromArray(value).getHex();
                    break;
                case 'colorSpecular':
                    json.specular = color.fromArray(value).getHex();
                    break;
                case 'colorEmissive':
                    json.emissive = color.fromArray(value).getHex();
                    break;
                case 'specularCoef':
                    json.shininess = value;
                    break;
                case 'shading':
                    if (value.toLowerCase() === 'basic')
                        json.type = 'MeshBasicMaterial';
                    if (value.toLowerCase() === 'phong')
                        json.type = 'MeshPhongMaterial';
                    if (value.toLowerCase() === 'standard')
                        json.type = 'MeshStandardMaterial';
                    break;
                case 'mapDiffuse':
                    json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                    break;
                case 'mapDiffuseRepeat':
                case 'mapDiffuseOffset':
                case 'mapDiffuseWrap':
                case 'mapDiffuseAnisotropy':
                    break;
                case 'mapEmissive':
                    json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                    break;
                case 'mapEmissiveRepeat':
                case 'mapEmissiveOffset':
                case 'mapEmissiveWrap':
                case 'mapEmissiveAnisotropy':
                    break;
                case 'mapLight':
                    json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                    break;
                case 'mapLightRepeat':
                case 'mapLightOffset':
                case 'mapLightWrap':
                case 'mapLightAnisotropy':
                    break;
                case 'mapAO':
                    json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                    break;
                case 'mapAORepeat':
                case 'mapAOOffset':
                case 'mapAOWrap':
                case 'mapAOAnisotropy':
                    break;
                case 'mapBump':
                    json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                    break;
                case 'mapBumpScale':
                    json.bumpScale = value;
                    break;
                case 'mapBumpRepeat':
                case 'mapBumpOffset':
                case 'mapBumpWrap':
                case 'mapBumpAnisotropy':
                    break;
                case 'mapNormal':
                    json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                    break;
                case 'mapNormalFactor':
                    json.normalScale = [value, value];
                    break;
                case 'mapNormalRepeat':
                case 'mapNormalOffset':
                case 'mapNormalWrap':
                case 'mapNormalAnisotropy':
                    break;
                case 'mapSpecular':
                    json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                    break;
                case 'mapSpecularRepeat':
                case 'mapSpecularOffset':
                case 'mapSpecularWrap':
                case 'mapSpecularAnisotropy':
                    break;
                case 'mapMetalness':
                    json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                    break;
                case 'mapMetalnessRepeat':
                case 'mapMetalnessOffset':
                case 'mapMetalnessWrap':
                case 'mapMetalnessAnisotropy':
                    break;
                case 'mapRoughness':
                    json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                    break;
                case 'mapRoughnessRepeat':
                case 'mapRoughnessOffset':
                case 'mapRoughnessWrap':
                case 'mapRoughnessAnisotropy':
                    break;
                case 'mapAlpha':
                    json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                    break;
                case 'mapAlphaRepeat':
                case 'mapAlphaOffset':
                case 'mapAlphaWrap':
                case 'mapAlphaAnisotropy':
                    break;
                case 'flipSided':
                    json.side = SideMode.Back;
                    break;
                case 'doubleSided':
                    json.side = SideMode.Double;
                    break;
                case 'transparency':
                    console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
                    json.opacity = value;
                    break;
                case 'depthTest':
                case 'depthWrite':
                case 'colorWrite':
                case 'opacity':
                case 'reflectivity':
                case 'transparent':
                case 'visible':
                case 'wireframe':
                    json[name] = value;
                    break;
                case 'vertexColors':
                    if (value === true)
                        json.vertexColors = ColorsMode.Vertex;
                    if (value === 'face')
                        json.vertexColors = ColorsMode.Face;
                    break;
                default:
                    console.error('THREE.Loader.createMaterial: Unsupported', name, value);
                    break;
            }
        }
        if (json.type === 'MeshBasicMaterial')
            delete json.emissive;
        if (json.type !== 'MeshPhongMaterial')
            delete json.specular;
        if (json.opacity < 1)
            json.transparent = true;
        materialLoader.setTextures(textures);
        return materialLoader.parse(json);
        //};
    };
    Loader.Handlers = (function () {
        function class_1() {
        }
        class_1.add = function (regex, loader) {
            this.handlers.push(regex, loader);
        };
        class_1.get = function (file) {
            var handlers = this.handlers;
            for (var i = 0, l = handlers.length; i < l; i += 2) {
                var regex = handlers[i];
                var loader = handlers[i + 1];
                if (regex.test(file)) {
                    return loader;
                }
            }
            return null;
        };
        class_1.handlers = [];
        return class_1;
    }());
    return Loader;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
var JSONLoader = (function () {
    function JSONLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.withCredentials = false;
        //if (typeof manager === 'boolean') {
        //  console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
        //  manager = undefined;
        //}
        this.manager = manager;
    }
    JSONLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        var scope = this;
        var texturePath = this.texturePath && (typeof this.texturePath === "string") ? this.texturePath : Loader.prototype.extractUrlBase(url);
        var loader = new XHRLoader(this.manager);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function (text) {
            var json = JSON.parse(text);
            var metadata = json.metadata;
            if (metadata !== undefined) {
                var type = metadata.type;
                if (type !== undefined) {
                    if (type.toLowerCase() === 'object') {
                        console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                        return;
                    }
                    if (type.toLowerCase() === 'scene') {
                        console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
                        return;
                    }
                }
            }
            var object = scope.parse(json, texturePath);
            onLoad(object.geometry, object.materials);
        }, onProgress, onError);
    };
    JSONLoader.prototype.setTexturePath = function (value) {
        this.texturePath = value;
    };
    JSONLoader.prototype.parse = function (json, texturePath) {
        var geometry = new Geometry();
        var scale = (json.scale !== undefined) ? 1.0 / json.scale : 1.0;
        parseModel(scale);
        parseSkin();
        parseMorphing(scale);
        parseAnimations();
        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();
        function parseModel(scale) {
            function isBitSet(value, position) {
                return value & (1 << position);
            }
            var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
            if (json.uvs !== undefined) {
                // disregard empty arrays
                for (i = 0; i < json.uvs.length; i++) {
                    if (json.uvs[i].length)
                        nUvLayers++;
                }
                for (i = 0; i < nUvLayers; i++) {
                    geometry.faceVertexUvs[i] = [];
                }
            }
            offset = 0;
            zLength = vertices.length;
            while (offset < zLength) {
                vertex = new Vector3();
                vertex.x = vertices[offset++] * scale;
                vertex.y = vertices[offset++] * scale;
                vertex.z = vertices[offset++] * scale;
                geometry.vertices.push(vertex);
            }
            offset = 0;
            zLength = faces.length;
            while (offset < zLength) {
                type = faces[offset++];
                isQuad = isBitSet(type, 0);
                hasMaterial = isBitSet(type, 1);
                hasFaceVertexUv = isBitSet(type, 3);
                hasFaceNormal = isBitSet(type, 4);
                hasFaceVertexNormal = isBitSet(type, 5);
                hasFaceColor = isBitSet(type, 6);
                hasFaceVertexColor = isBitSet(type, 7);
                // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
                if (isQuad) {
                    faceA = new Face3();
                    faceA.a = faces[offset];
                    faceA.b = faces[offset + 1];
                    faceA.c = faces[offset + 3];
                    faceB = new Face3();
                    faceB.a = faces[offset + 1];
                    faceB.b = faces[offset + 2];
                    faceB.c = faces[offset + 3];
                    offset += 4;
                    if (hasMaterial) {
                        materialIndex = faces[offset++];
                        faceA.materialIndex = materialIndex;
                        faceB.materialIndex = materialIndex;
                    }
                    // to get face <=> uv index correspondence
                    fi = geometry.faces.length;
                    if (hasFaceVertexUv) {
                        for (i = 0; i < nUvLayers; i++) {
                            uvLayer = json.uvs[i];
                            geometry.faceVertexUvs[i][fi] = [];
                            geometry.faceVertexUvs[i][fi + 1] = [];
                            for (j = 0; j < 4; j++) {
                                uvIndex = faces[offset++];
                                u = uvLayer[uvIndex * 2];
                                v = uvLayer[uvIndex * 2 + 1];
                                uv = new Vector2(u, v);
                                if (j !== 2)
                                    geometry.faceVertexUvs[i][fi].push(uv);
                                if (j !== 0)
                                    geometry.faceVertexUvs[i][fi + 1].push(uv);
                            }
                        }
                    }
                    if (hasFaceNormal) {
                        normalIndex = faces[offset++] * 3;
                        faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                        faceB.normal.copy(faceA.normal);
                    }
                    if (hasFaceVertexNormal) {
                        for (i = 0; i < 4; i++) {
                            normalIndex = faces[offset++] * 3;
                            normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                            if (i !== 2)
                                faceA.vertexNormals.push(normal);
                            if (i !== 0)
                                faceB.vertexNormals.push(normal);
                        }
                    }
                    if (hasFaceColor) {
                        colorIndex = faces[offset++];
                        hex = colors[colorIndex];
                        faceA.color.setHex(hex);
                        faceB.color.setHex(hex);
                    }
                    if (hasFaceVertexColor) {
                        for (i = 0; i < 4; i++) {
                            colorIndex = faces[offset++];
                            hex = colors[colorIndex];
                            if (i !== 2)
                                faceA.vertexColors.push(new Color(hex));
                            if (i !== 0)
                                faceB.vertexColors.push(new Color(hex));
                        }
                    }
                    geometry.faces.push(faceA);
                    geometry.faces.push(faceB);
                }
                else {
                    face = new Face3();
                    face.a = faces[offset++];
                    face.b = faces[offset++];
                    face.c = faces[offset++];
                    if (hasMaterial) {
                        materialIndex = faces[offset++];
                        face.materialIndex = materialIndex;
                    }
                    // to get face <=> uv index correspondence
                    fi = geometry.faces.length;
                    if (hasFaceVertexUv) {
                        for (i = 0; i < nUvLayers; i++) {
                            uvLayer = json.uvs[i];
                            geometry.faceVertexUvs[i][fi] = [];
                            for (j = 0; j < 3; j++) {
                                uvIndex = faces[offset++];
                                u = uvLayer[uvIndex * 2];
                                v = uvLayer[uvIndex * 2 + 1];
                                uv = new Vector2(u, v);
                                geometry.faceVertexUvs[i][fi].push(uv);
                            }
                        }
                    }
                    if (hasFaceNormal) {
                        normalIndex = faces[offset++] * 3;
                        face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                    }
                    if (hasFaceVertexNormal) {
                        for (i = 0; i < 3; i++) {
                            normalIndex = faces[offset++] * 3;
                            normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                            face.vertexNormals.push(normal);
                        }
                    }
                    if (hasFaceColor) {
                        colorIndex = faces[offset++];
                        face.color.setHex(colors[colorIndex]);
                    }
                    if (hasFaceVertexColor) {
                        for (i = 0; i < 3; i++) {
                            colorIndex = faces[offset++];
                            face.vertexColors.push(new Color(colors[colorIndex]));
                        }
                    }
                    geometry.faces.push(face);
                }
            }
        }
        function parseSkin() {
            var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
            if (json.skinWeights) {
                for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                    var x = json.skinWeights[i];
                    var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
                    var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
                    var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
                    geometry.skinWeights.push(new Vector4(x, y, z, w));
                }
            }
            if (json.skinIndices) {
                for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                    var a = json.skinIndices[i];
                    var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
                    var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
                    var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
                    geometry.skinIndices.push(new Vector4(a, b, c, d));
                }
            }
            geometry.bones = json.bones;
            if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
                console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                    geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
            }
        }
        function parseMorphing(scale) {
            if (json.morphTargets !== undefined) {
                for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                    geometry.morphTargets[i] = {};
                    geometry.morphTargets[i].name = json.morphTargets[i].name;
                    geometry.morphTargets[i].vertices = [];
                    var dstVertices = geometry.morphTargets[i].vertices;
                    var srcVertices = json.morphTargets[i].vertices;
                    for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                        var vertex = new Vector3();
                        vertex.x = srcVertices[v] * scale;
                        vertex.y = srcVertices[v + 1] * scale;
                        vertex.z = srcVertices[v + 2] * scale;
                        dstVertices.push(vertex);
                    }
                }
            }
            if (json.morphColors !== undefined && json.morphColors.length > 0) {
                console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                var faces = geometry.faces;
                var morphColors = json.morphColors[0].colors;
                for (var i = 0, l = faces.length; i < l; i++) {
                    faces[i].color.fromArray(morphColors, i * 3);
                }
            }
        }
        function parseAnimations() {
            var outputAnimations = [];
            // parse old style Bone/Hierarchy animations
            var animations = [];
            if (json.animation !== undefined) {
                animations.push(json.animation);
            }
            if (json.animations !== undefined) {
                if (json.animations.length) {
                    animations = animations.concat(json.animations);
                }
                else {
                    animations.push(json.animations);
                }
            }
            for (var i = 0; i < animations.length; i++) {
                var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                if (clip)
                    outputAnimations.push(clip);
            }
            // parse implicit morph animations
            if (geometry.morphTargets) {
                // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
                var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                outputAnimations = outputAnimations.concat(morphAnimationClips);
            }
            if (outputAnimations.length > 0)
                geometry.animations = outputAnimations;
        }
        if (json.materials === undefined || json.materials.length === 0) {
            return { geometry: geometry };
        }
        else {
            var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
            return { geometry: geometry, materials: materials };
        }
    };
    return JSONLoader;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var ObjectLoader = (function () {
    function ObjectLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.texturePath = '';
        this.manager = manager;
    }
    ObjectLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        if (this.texturePath === '') {
            this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
        }
        var scope = this;
        var loader = new XHRLoader(scope.manager);
        loader.load(url, function (text) {
            scope.parse(JSON.parse(text), onLoad);
        }, onProgress, onError);
    };
    ObjectLoader.prototype.setTexturePath = function (value) {
        this.texturePath = value;
    };
    ObjectLoader.prototype.setCrossOrigin = function (value) {
        this.crossOrigin = value;
    };
    ObjectLoader.prototype.parse = function (json, onLoad) {
        var geometries = this.parseGeometries(json.geometries);
        var images = this.parseImages(json.images, function () {
            if (onLoad !== undefined)
                onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials);
        if (json.animations) {
            object.animations = this.parseAnimations(json.animations);
        }
        if (json.images === undefined || json.images.length === 0) {
            if (onLoad !== undefined)
                onLoad(object);
        }
        return object;
    };
    ObjectLoader.prototype.parseGeometries = function (json) {
        var geometries = new Map();
        if (json !== undefined) {
            var geometryLoader = new JSONLoader();
            var bufferGeometryLoader = new BufferGeometryLoader();
            for (var i = 0, l = json.length; i < l; i++) {
                var geometry = void 0;
                var data = json[i];
                switch (data.type) {
                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':
                        geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                        break;
                    case 'BoxGeometry':
                    case 'BoxBufferGeometry':
                    case 'CubeGeometry':
                        geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                        break;
                    case 'CircleGeometry':
                    case 'CircleBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                        break;
                    case 'CylinderGeometry':
                    case 'CylinderBufferGeometry':
                        geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;
                    case 'ConeGeometry':
                    case 'ConeBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;
                    case 'SphereGeometry':
                    case 'SphereBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                        break;
                    case 'DodecahedronGeometry':
                    case 'IcosahedronGeometry':
                    case 'OctahedronGeometry':
                    case 'TetrahedronGeometry':
                        geometry = new Geometries[data.type](data.radius, data.detail);
                        break;
                    case 'RingGeometry':
                    case 'RingBufferGeometry':
                        geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                        break;
                    case 'TorusGeometry':
                    case 'TorusBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                        break;
                    case 'TorusKnotGeometry':
                    case 'TorusKnotBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                        break;
                    case 'LatheGeometry':
                    case 'LatheBufferGeometry':
                        geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                        break;
                    case 'BufferGeometry':
                        geometry = bufferGeometryLoader.parse(data);
                        break;
                    case 'Geometry':
                        geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                        continue;
                }
                geometry.uuid = data.uuid;
                if (data.name !== undefined)
                    geometry.name = data.name;
                geometries[data.uuid] = geometry;
            }
        }
        return geometries;
    };
    ObjectLoader.prototype.parseMaterials = function (json, textures) {
        var materials = new Map();
        if (json !== undefined) {
            var loader = new MaterialLoader();
            loader.setTextures(textures);
            for (var i = 0, l = json.length; i < l; i++) {
                var material = loader.parse(json[i]);
                materials[material.uuid] = material;
            }
        }
        return materials;
    };
    ObjectLoader.prototype.parseAnimations = function (json) {
        var animations = [];
        for (var i = 0; i < json.length; i++) {
            var clip = AnimationClip.parse(json[i]);
            animations.push(clip);
        }
        return animations;
    };
    ObjectLoader.prototype.parseImages = function (json, onLoad) {
        var scope = this;
        var images = new Map();
        var loader;
        function loadImage(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function () {
                scope.manager.itemEnd(url);
            }, undefined, function () {
                scope.manager.itemError(url);
            });
        }
        if (json !== undefined && json.length > 0) {
            var manager = new LoadingManager(onLoad);
            loader = new ImageLoader(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (var i = 0, l = json.length; i < l; i++) {
                var image = json[i];
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                images[image.uuid] = loadImage(path);
            }
        }
        return images;
    };
    ObjectLoader.prototype.parseTextures = function (json, images) {
        function parseConstant(value, type) {
            if (typeof (value) === 'number')
                return value;
            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
            return type[value];
        }
        var textures = new Map();
        if (json !== undefined) {
            for (var i = 0, l = json.length; i < l; i++) {
                var data = json[i];
                if (data.image === undefined) {
                    console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                }
                if (images[data.image] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined image', data.image);
                }
                var texture = new Texture(images[data.image]);
                texture.needsUpdate = true;
                texture.uuid = data.uuid;
                if (data.name !== undefined)
                    texture.name = data.name;
                if (data.mapping !== undefined)
                    texture.mapping = parseConstant(data.mapping, TextureMapping);
                if (data.offset !== undefined)
                    texture.offset.fromArray(data.offset);
                if (data.repeat !== undefined)
                    texture.repeat.fromArray(data.repeat);
                if (data.wrap !== undefined) {
                    texture.wrapS = parseConstant(data.wrap[0], TextureWrapping);
                    texture.wrapT = parseConstant(data.wrap[1], TextureWrapping);
                }
                if (data.minFilter !== undefined)
                    texture.minFilter = parseConstant(data.minFilter, TextureFilter);
                if (data.magFilter !== undefined)
                    texture.magFilter = parseConstant(data.magFilter, TextureFilter);
                if (data.anisotropy !== undefined)
                    texture.anisotropy = data.anisotropy;
                if (data.flipY !== undefined)
                    texture.flipY = data.flipY;
                textures[data.uuid] = texture;
            }
        }
        return textures;
    };
    ObjectLoader.prototype.parseObject = function (data, geometries, materials) {
        var matrix = new Matrix4();
        //return function parseObject(data, geometries, materials) {
        var object;
        function getGeometry(name) {
            if (geometries[name] === undefined) {
                console.warn('THREE.ObjectLoader: Undefined geometry', name);
            }
            return geometries[name];
        }
        function getMaterial(name) {
            if (name === undefined)
                return undefined;
            if (materials[name] === undefined) {
                console.warn('THREE.ObjectLoader: Undefined material', name);
            }
            return materials[name];
        }
        switch (data.type) {
            case 'Scene':
                object = new Scene();
                if (data.background !== undefined) {
                    if (Number.isInteger(data.background)) {
                        object.background = new Color(data.background);
                    }
                }
                if (data.fog !== undefined) {
                    if (data.fog.type === 'Fog') {
                        object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                    }
                    else if (data.fog.type === 'FogExp2') {
                        object.fog = new FogExp2(data.fog.color, data.fog.density);
                    }
                }
                break;
            case 'PerspectiveCamera':
                object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                if (data.focus !== undefined)
                    object.focus = data.focus;
                if (data.zoom !== undefined)
                    object.zoom = data.zoom;
                if (data.filmGauge !== undefined)
                    object.filmGauge = data.filmGauge;
                if (data.filmOffset !== undefined)
                    object.filmOffset = data.filmOffset;
                if (data.view !== undefined)
                    object.view = Object.assign({}, data.view);
                break;
            case 'OrthographicCamera':
                object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                break;
            case 'AmbientLight':
                object = new AmbientLight(data.color, data.intensity);
                break;
            case 'DirectionalLight':
                object = new DirectionalLight(data.color, data.intensity);
                break;
            case 'PointLight':
                object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                break;
            case 'SpotLight':
                object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                break;
            case 'HemisphereLight':
                object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                break;
            case 'Mesh':
                var geometry = getGeometry(data.geometry);
                var material = getMaterial(data.material);
                if (geometry.bones && geometry.bones.length > 0) {
                    object = new SkinnedMesh(geometry, material);
                }
                else {
                    object = new Mesh(geometry, material);
                }
                break;
            case 'LOD':
                object = new LOD();
                break;
            case 'Line':
                object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                break;
            case 'LineSegments':
                object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'PointCloud':
            case 'Points':
                object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'Sprite':
                object = new Sprite(getMaterial(data.material));
                break;
            case 'Group':
                object = new Group();
                break;
            default:
                object = new Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== undefined)
            object.name = data.name;
        if (data.matrix !== undefined) {
            matrix.fromArray(data.matrix);
            matrix.decompose(object.position, object.quaternion, object.scale);
        }
        else {
            if (data.position !== undefined)
                object.position.fromArray(data.position);
            if (data.rotation !== undefined)
                object.rotation.fromArray(data.rotation);
            if (data.quaternion !== undefined)
                object.quaternion.fromArray(data.quaternion);
            if (data.scale !== undefined)
                object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== undefined)
            object.castShadow = data.castShadow;
        if (data.receiveShadow !== undefined)
            object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
            if (data.shadow.bias !== undefined)
                object.shadow.bias = data.shadow.bias;
            if (data.shadow.radius !== undefined)
                object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== undefined)
                object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== undefined)
                object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== undefined)
            object.visible = data.visible;
        if (data.userData !== undefined)
            object.userData = data.userData;
        if (data.children !== undefined) {
            for (var child in data.children) {
                object.add(this.parseObject(data.children[child], geometries, materials));
            }
        }
        if (data.type === 'LOD') {
            var levels = data.levels;
            for (var l = 0; l < levels.length; l++) {
                var level = levels[l];
                var child = object.getObjectByProperty('uuid', level.object);
                if (child !== undefined) {
                    object.addLevel(child, level.distance);
                }
            }
        }
        return object;
        //};
    };
    return ObjectLoader;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var FontLoader = (function () {
    function FontLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.manager = manager;
    }
    FontLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new XHRLoader(this.manager);
        loader.load(url, function (text) {
            var json;
            try {
                json = JSON.parse(text);
            }
            catch (e) {
                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                json = JSON.parse(text.substring(65, text.length - 2));
            }
            var font = scope.parse(json);
            if (onLoad)
                onLoad(font);
        }, onProgress, onError);
    };
    FontLoader.prototype.parse = function (json) {
        return new Font(json);
    };
    return FontLoader;
}());

var context;
function getAudioContext() {
    if (context === undefined) {
        // !!!TODO: context = new (window.AudioContext || window.webkitAudioContext)();
        context = new AudioContext();
    }
    return context;
}

/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */
var AudioLoader = (function () {
    function AudioLoader(manager) {
        if (manager === void 0) { manager = DefaultLoadingManager; }
        this.manager = manager;
    }
    AudioLoader.prototype.load = function (url, onLoad, onProgress, onError) {
        var loader = new XHRLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.load(url, function (buffer) {
            var context = getAudioContext();
            context.decodeAudioData(buffer, function (audioBuffer) {
                onLoad(audioBuffer);
            });
        }, onProgress, onError);
    };
    return AudioLoader;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 */
var StereoCamera = (function () {
    function StereoCamera() {
        this.type = 'StereoCamera';
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
    }
    StereoCamera.prototype.update = function (camera) {
        var instance, focus, fov, aspect, near, far, zoom;
        var eyeRight = new Matrix4();
        var eyeLeft = new Matrix4();
        //return function update(camera) {
        var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
            aspect !== camera.aspect * this.aspect || near !== camera.near ||
            far !== camera.far || zoom !== camera.zoom;
        if (needsUpdate) {
            instance = this;
            focus = camera.focus;
            fov = camera.fov;
            aspect = camera.aspect * this.aspect;
            near = camera.near;
            far = camera.far;
            zoom = camera.zoom;
            // Off-axis stereoscopic effect based on
            // http://paulbourke.net/stereographics/stereorender/
            var projectionMatrix = camera.projectionMatrix.clone();
            var eyeSep = this.eyeSep / 2;
            var eyeSepOnProjection = eyeSep * near / focus;
            var ymax = (near * Math.tan(_Math.DEG2RAD * fov * 0.5)) / zoom;
            var xmin = void 0, xmax = void 0;
            // translate xOffset
            eyeLeft.elements[12] = -eyeSep;
            eyeRight.elements[12] = eyeSep;
            // for left eye
            xmin = -ymax * aspect + eyeSepOnProjection;
            xmax = ymax * aspect + eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(projectionMatrix);
            // for right eye
            xmin = -ymax * aspect - eyeSepOnProjection;
            xmax = ymax * aspect - eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
        //};
    };
    return StereoCamera;
}());

/**
 * Camera for rendering cube maps
 *  - renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */
var CubeCamera = (function (_super) {
    __extends(CubeCamera, _super);
    function CubeCamera(near, far, cubeResolution) {
        _super.call(this);
        this.type = 'CubeCamera';
        var fov = 90, aspect = 1;
        this.cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        this.cameraPX.up.set(0, -1, 0);
        this.cameraPX.lookAt(new Vector3(1, 0, 0));
        this.add(this.cameraPX);
        this.cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        this.cameraNX.up.set(0, -1, 0);
        this.cameraNX.lookAt(new Vector3(-1, 0, 0));
        this.add(this.cameraNX);
        this.cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        this.cameraPY.up.set(0, 0, 1);
        this.cameraPY.lookAt(new Vector3(0, 1, 0));
        this.add(this.cameraPY);
        this.cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        this.cameraNY.up.set(0, 0, -1);
        this.cameraNY.lookAt(new Vector3(0, -1, 0));
        this.add(this.cameraNY);
        this.cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        this.cameraPZ.up.set(0, -1, 0);
        this.cameraPZ.lookAt(new Vector3(0, 0, 1));
        this.add(this.cameraPZ);
        this.cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        this.cameraNZ.up.set(0, -1, 0);
        this.cameraNZ.lookAt(new Vector3(0, 0, -1));
        this.add(this.cameraNZ);
        var options = { format: TextureFormat.RGB, magFilter: TextureFilter.Linear, minFilter: TextureFilter.Linear };
        this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
    }
    CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
        if (this.parent === null)
            this.updateMatrixWorld();
        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderTarget.activeCubeFace = 0;
        renderer.render(scene, this.cameraPX, renderTarget);
        renderTarget.activeCubeFace = 1;
        renderer.render(scene, this.cameraNX, renderTarget);
        renderTarget.activeCubeFace = 2;
        renderer.render(scene, this.cameraPY, renderTarget);
        renderTarget.activeCubeFace = 3;
        renderer.render(scene, this.cameraNY, renderTarget);
        renderTarget.activeCubeFace = 4;
        renderer.render(scene, this.cameraPZ, renderTarget);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderTarget.activeCubeFace = 5;
        renderer.render(scene, this.cameraNZ, renderTarget);
        renderer.setRenderTarget(null);
    };
    return CubeCamera;
}(Object3D));

var AudioListener = (function (_super) {
    __extends(AudioListener, _super);
    function AudioListener() {
        _super.call(this);
        this.type = 'AudioListener';
        this.context = getAudioContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
    }
    AudioListener.prototype.getInput = function () {
        return this.gain;
    };
    AudioListener.prototype.removeFilter = function () {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
    };
    AudioListener.prototype.getFilter = function () {
        return this.filter;
    };
    AudioListener.prototype.setFilter = function (value) {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
        }
        else {
            this.gain.disconnect(this.context.destination);
        }
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
    };
    AudioListener.prototype.getMasterVolume = function () {
        return this.gain.gain.value;
    };
    AudioListener.prototype.setMasterVolume = function (value) {
        this.gain.gain.value = value;
    };
    AudioListener.prototype.updateMatrixWorld = function (force) {
        var position = new Vector3();
        var quaternion = new Quaternion();
        var scale = new Vector3();
        var orientation = new Vector3();
        //return function updateMatrixWorld(force) {
        _super.prototype.updateMatrixWorld.call(this, force);
        var listener = this.context.listener;
        var up = this.up;
        this.matrixWorld.decompose(position, quaternion, scale);
        orientation.set(0, 0, -1).applyQuaternion(quaternion);
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
        //};
    };
    return AudioListener;
}(Object3D));

var Audio = (function (_super) {
    __extends(Audio, _super);
    function Audio(listener) {
        _super.call(this);
        this.autoplay = false;
        this.startTime = 0;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.sourceType = 'empty';
        this.filters = [];
        this.type = 'Audio';
        this.context = listener.context;
        this.source = this.context.createBufferSource();
        this.source.onended = this.onEnded.bind(this);
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
    }
    Audio.prototype.getOutput = function () {
        return this.gain;
    };
    Audio.prototype.setNodeSource = function (audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = 'audioNode';
        this.source = audioNode;
        this.connect();
        return this;
    };
    Audio.prototype.setBuffer = function (audioBuffer) {
        this.source.buffer = audioBuffer;
        this.sourceType = 'buffer';
        if (this.autoplay)
            this.play();
        return this;
    };
    Audio.prototype.play = function () {
        if (this.isPlaying === true) {
            console.warn('THREE.Audio: Audio is already playing.');
            return this;
        }
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return this;
        }
        var source = this.context.createBufferSource();
        source.buffer = this.source.buffer;
        source.loop = this.source.loop;
        source.onended = this.source.onended;
        source.start(0, this.startTime);
        source.playbackRate.value = this.playbackRate;
        this.isPlaying = true;
        this.source = source;
        return this.connect();
    };
    Audio.prototype.pause = function () {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return this;
        }
        this.source.stop();
        this.startTime = this.context.currentTime;
        this.isPlaying = false;
        return this;
    };
    Audio.prototype.stop = function () {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return this;
        }
        this.source.stop();
        this.startTime = 0;
        this.isPlaying = false;
        return this;
    };
    Audio.prototype.connect = function () {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (var i = 1, l = this.filters.length; i < l; i++) {
                this.filters[i - 1].connect(this.filters[i]);
            }
            this.filters[this.filters.length - 1].connect(this.getOutput());
        }
        else {
            this.source.connect(this.getOutput());
        }
        return this;
    };
    Audio.prototype.disconnect = function () {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (var i = 1, l = this.filters.length; i < l; i++) {
                this.filters[i - 1].disconnect(this.filters[i]);
            }
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        }
        else {
            this.source.disconnect(this.getOutput());
        }
        return this;
    };
    Audio.prototype.getFilters = function () {
        return this.filters;
    };
    Audio.prototype.setFilters = function (value) {
        if (value === void 0) { value = []; }
        if (this.isPlaying === true) {
            this.disconnect();
            this.filters = value;
            this.connect();
        }
        else {
            this.filters = value;
        }
        return this;
    };
    Audio.prototype.getFilter = function () {
        return this.getFilters()[0];
    };
    Audio.prototype.setFilter = function (filter) {
        return this.setFilters(filter ? [filter] : []);
    };
    Audio.prototype.setPlaybackRate = function (value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return this;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) {
            this.source.playbackRate.value = this.playbackRate;
        }
        return this;
    };
    Audio.prototype.getPlaybackRate = function () {
        return this.playbackRate;
    };
    Audio.prototype.onEnded = function () {
        this.isPlaying = false;
    };
    Audio.prototype.getLoop = function () {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return false;
        }
        return this.source.loop;
    };
    Audio.prototype.setLoop = function (value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.source.loop = value;
    };
    Audio.prototype.getVolume = function () {
        return this.gain.gain.value;
    };
    Audio.prototype.setVolume = function (value) {
        this.gain.gain.value = value;
        return this;
    };
    Audio.prototype.load = function (file) {
        console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");
        var scope = this;
        var audioLoader = new AudioLoader();
        audioLoader.load(file, function (buffer) {
            scope.setBuffer(buffer);
        });
        return this;
    };
    return Audio;
}(Object3D));

var PositionalAudio = (function (_super) {
    __extends(PositionalAudio, _super);
    function PositionalAudio(listener) {
        _super.call(this, listener);
        this.panner = this.context.createPanner();
        this.panner.connect(this.gain);
    }
    PositionalAudio.prototype.getOutput = function () {
        return this.panner;
    };
    PositionalAudio.prototype.getRefDistance = function () {
        return this.panner.refDistance;
    };
    PositionalAudio.prototype.setRefDistance = function (value) {
        this.panner.refDistance = value;
    };
    PositionalAudio.prototype.getRolloffFactor = function () {
        return this.panner.rolloffFactor;
    };
    PositionalAudio.prototype.setRolloffFactor = function (value) {
        this.panner.rolloffFactor = value;
    };
    PositionalAudio.prototype.getDistanceModel = function () {
        return this.panner.distanceModel;
    };
    PositionalAudio.prototype.setDistanceModel = function (value) {
        this.panner.distanceModel = value;
    };
    PositionalAudio.prototype.getMaxDistance = function () {
        return this.panner.maxDistance;
    };
    PositionalAudio.prototype.setMaxDistance = function (value) {
        this.panner.maxDistance = value;
    };
    PositionalAudio.prototype.updateMatrixWorld = function (force) {
        var position = new Vector3();
        //return function updateMatrixWorld(force) {
        _super.prototype.updateMatrixWorld.call(this, force);
        position.setFromMatrixPosition(this.matrixWorld);
        this.panner.setPosition(position.x, position.y, position.z);
        //};
    };
    return PositionalAudio;
}(Audio));

var AudioAnalyser = (function () {
    function AudioAnalyser(audio, fftSize) {
        if (fftSize === void 0) { fftSize = 2048; }
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
    AudioAnalyser.prototype.getFrequencyData = function () {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    };
    AudioAnalyser.prototype.getAverageFrequency = function () {
        var value = 0;
        var data = this.getFrequencyData();
        for (var i = 0; i < data.length; i++) {
            value += data[i];
        }
        return value / data.length;
    };
    AudioAnalyser.prototype.getData = function (file) {
        console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
        return this.getFrequencyData();
    };
    return AudioAnalyser;
}());

/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
var PropertyMixer = (function () {
    function PropertyMixer(binding, typeName, valueSize) {
        this.binding = binding;
        this.valueSize = valueSize;
        var bufferType = Float64Array, mixFunction;
        switch (typeName) {
            case 'quaternion':
                mixFunction = this._slerp;
                break;
            case 'string':
            case 'bool':
                bufferType = Array, mixFunction = this._select;
                break;
            default: mixFunction = this._lerp;
        }
        this.buffer = new bufferType(valueSize * 4);
        // layout: [ incoming | accu0 | accu1 | orig ]
        //
        // interpolators can use .buffer as their .result
        // the data then goes to 'incoming'
        //
        // 'accu0' and 'accu1' are used frame-interleaved for
        // the cumulative result and are compared to detect
        // changes
        //
        // 'orig' stores the original state of the property
        this._mixBufferRegion = mixFunction;
        this.cumulativeWeight = 0;
        this.useCount = 0;
        this.referenceCount = 0;
    }
    // accumulate data in the 'incoming' region into 'accu<i>'
    PropertyMixer.prototype.accumulate = function (accuIndex, weight) {
        // note: happily accumulating nothing when weight = 0, the caller knows
        // the weight and shouldn't have made the call in the first place
        var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        var currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            // accuN := incoming * weight
            for (var i = 0; i !== stride; ++i) {
                buffer[offset + i] = buffer[i];
            }
            currentWeight = weight;
        }
        else {
            // accuN := accuN + incoming * weight
            currentWeight += weight;
            var mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
    };
    // apply the state of 'accu<i>' to the binding when accus differ
    PropertyMixer.prototype.apply = function (accuIndex) {
        var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
        this.cumulativeWeight = 0;
        if (weight < 1) {
            // accuN := accuN + original * (1 - cumulativeWeight)
            var originalValueOffset = stride * 3;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        for (var i = stride, e = stride + stride; i !== e; ++i) {
            if (buffer[i] !== buffer[i + stride]) {
                // value has changed -> update scene graph
                binding.setValue(buffer, offset);
                break;
            }
        }
    };
    // remember the state of the bound property and copy it to both accus
    PropertyMixer.prototype.saveOriginalState = function () {
        var binding = this.binding;
        var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
        binding.getValue(buffer, originalValueOffset);
        // accu[0..1] := orig -- initially detect changes against the original
        for (var i = stride, e = originalValueOffset; i !== e; ++i) {
            buffer[i] = buffer[originalValueOffset + (i % stride)];
        }
        this.cumulativeWeight = 0;
    };
    // apply the state previously taken via 'saveOriginalState' to the binding
    PropertyMixer.prototype.restoreOriginalState = function () {
        var originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    };
    // mix functions
    PropertyMixer.prototype._select = function (buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) {
            for (var i = 0; i !== stride; ++i) {
                buffer[dstOffset + i] = buffer[srcOffset + i];
            }
        }
    };
    PropertyMixer.prototype._slerp = function (buffer, dstOffset, srcOffset, t, stride) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    };
    PropertyMixer.prototype._lerp = function (buffer, dstOffset, srcOffset, t, stride) {
        var s = 1 - t;
        for (var i = 0; i !== stride; ++i) {
            var j = dstOffset + i;
            buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
        }
    };
    return PropertyMixer;
}());

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *   -  Add objects you would otherwise pass as 'root' to the
 *     constructor or the .clipAction method of AnimationMixer.
 *
 *   -  Instead pass this object as 'root'.
 *
 *   -  You can also add and remove objects later when the mixer
 *     is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *   -   The animated properties must be compatible among the
 *     all objects in the group.
 *
 *  -  A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */
var AnimationObjectGroup = (function () {
    function AnimationObjectGroup(var_args) {
        this.uuid = _Math.generateUUID();
        // cached objects followed by the active ones
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0; // threshold
        // note: read by PropertyBinding.Composite
        var indices = {};
        this._indicesByUUID = indices; // for bookkeeping
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            indices[arguments[i].uuid] = i;
        }
        this._paths = []; // inside: string
        this._parsedPaths = []; // inside: { we don't care, here }
        this._bindings = []; // inside: Array< PropertyBinding >
        this._bindingsIndicesByPath = {}; // inside: indices in these arrays
        var scope = this;
        this.stats = {
            objects: {
                get total() { return scope._objects.length; },
                get inUse() { return scope._objects.length - scope.nCachedObjects_; }
            },
            get bindingsPerObject() { return scope._bindings.length; }
        };
    }
    AnimationObjectGroup.prototype.add = function (var_args) {
        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index === undefined) {
                // unknown object -> add it to the ACTIVE region
                index = nObjects++;
                indicesByUUID[uuid] = index;
                objects.push(object);
                // accounting is done, now do the same for all bindings
                for (var j = 0, m = nBindings; j !== m; ++j) {
                    bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                }
            }
            else if (index < nCachedObjects) {
                knownObject = objects[index];
                // move existing object to the ACTIVE region
                var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[uuid] = firstActiveIndex;
                objects[firstActiveIndex] = object;
                // accounting is done, now do the same for all bindings
                for (var j = 0, m = nBindings; j !== m; ++j) {
                    var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = lastCached;
                    if (binding === undefined) {
                        // since we do not bother to create new bindings
                        // for objects that are cached, the binding may
                        // or may not exist
                        binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                    }
                    bindingsForPath[firstActiveIndex] = binding;
                }
            }
            else if (objects[index] !== knownObject) {
                console.error("Different objects with the same UUID " +
                    "detected. Clean the caches or recreate your " +
                    "infrastructure when reloading scenes...");
            } // else the object is already where we want it to be
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    };
    AnimationObjectGroup.prototype.remove = function (var_args) {
        var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined && index >= nCachedObjects) {
                // move existing object into the CACHED region
                var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                indicesByUUID[firstActiveObject.uuid] = index;
                objects[index] = firstActiveObject;
                indicesByUUID[uuid] = lastCachedIndex;
                objects[lastCachedIndex] = object;
                // accounting is done, now do the same for all bindings
                for (var j = 0, m = nBindings; j !== m; ++j) {
                    var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                }
            }
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    };
    // remove & forget
    AnimationObjectGroup.prototype.uncache = function (var_args) {
        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined) {
                delete indicesByUUID[uuid];
                if (index < nCachedObjects) {
                    // object is cached, shrink the CACHED region
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    // last cached object takes this object's place
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    // last object goes to the activated slot and pop
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index] = lastCached;
                        bindingsForPath[firstActiveIndex] = last;
                        bindingsForPath.pop();
                    }
                }
                else {
                    // object is active, just swap with the last and pop
                    var lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastObject.uuid] = index;
                    objects[index] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j];
                        bindingsForPath[index] = bindingsForPath[lastIndex];
                        bindingsForPath.pop();
                    }
                } // cached or active
            } // if object is known
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    };
    // Internal interface used by befriended PropertyBinding.Composite:
    AnimationObjectGroup.prototype.subscribe_ = function (path, parsedPath) {
        // returns an array of bindings for the given path that is changed
        // according to the contained objects in the group
        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
        if (index !== undefined)
            return bindings[index];
        var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
            var object = objects[i];
            bindingsForPath[i] =
                new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
    };
    AnimationObjectGroup.prototype.unsubscribe_ = function (path) {
        // tells the group to forget about a property path and no longer
        // update the array previously obtained with 'subscribe_'
        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== undefined) {
            var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
        }
    };
    AnimationObjectGroup.isAnimationObjectGroup = true;
    return AnimationObjectGroup;
}());

var PropertyBinding = (function () {
    function PropertyBinding(rootNode, path, parsedPath) {
        // initial state of these methods that calls 'bind'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
        this.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        };
        this.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        };
        this.GetterByBindingType = [
            this.getValue_direct,
            this.getValue_array,
            this.getValue_arrayElement,
            this.getValue_toArray
        ];
        this.SetterByBindingTypeAndVersioning = [
            [
                // Direct
                this.setValue_direct,
                this.setValue_direct_setNeedsUpdate,
                this.setValue_direct_setMatrixWorldNeedsUpdate
            ], [
                // EntireArray
                this.setValue_array,
                this.setValue_array_setNeedsUpdate,
                this.setValue_array_setMatrixWorldNeedsUpdate
            ], [
                // ArrayElement
                this.setValue_arrayElement,
                this.setValue_arrayElement_setNeedsUpdate,
                this.setValue_arrayElement_setMatrixWorldNeedsUpdate
            ], [
                // HasToFromArray
                this.setValue_fromArray,
                this.setValue_fromArray_setNeedsUpdate,
                this.setValue_fromArray_setMatrixWorldNeedsUpdate
            ]
        ];
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
    }
    PropertyBinding.prototype._getValue_unbound = function (targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
        // Note: This class uses a State pattern on a per-method basis:
        // 'bind' sets 'this.getValue' / 'setValue' and shadows the
        // prototype version of these methods with one that represents
        // the bound state. When the property is not found, the methods
        // become no-ops.
    };
    PropertyBinding.prototype._setValue_unbound = function (sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    };
    // create getter / setter pair for a property in the scene graph
    PropertyBinding.prototype.bind = function () {
        var targetObject = this.node;
        var parsedPath = this.parsedPath;
        var objectName = parsedPath.objectName;
        var propertyName = parsedPath.propertyName;
        var propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        // set fail state so we can just 'return' on error
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        // ensure there is a value node
        if (!targetObject) {
            console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
            return;
        }
        if (objectName) {
            var objectIndex = parsedPath.objectIndex;
            // special cases were we need to reach deeper into the hierarchy to get the face materials....
            switch (objectName) {
                case 'materials':
                    if (!targetObject.material) {
                        console.error('  can not bind to material as node does not have a material', this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error('  can not bind to material.materials as node.material does not have a materials array', this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                case 'bones':
                    if (!targetObject.skeleton) {
                        console.error('  can not bind to bones as node does not have a skeleton', this);
                        return;
                    }
                    // potential future optimization: skip this if propertyIndex is already an integer
                    // and convert the integer string to a true integer.
                    targetObject = targetObject.skeleton.bones;
                    // support resolving morphTarget names into indices.
                    for (var i = 0; i < targetObject.length; i++) {
                        if (targetObject[i].name === objectIndex) {
                            objectIndex = i;
                            break;
                        }
                    }
                    break;
                default:
                    if (targetObject[objectName] === undefined) {
                        console.error('  can not bind to objectName of node, undefined', this);
                        return;
                    }
                    targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        // resolve property
        var nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            var nodeName = parsedPath.nodeName;
            console.error("  trying to update property for track: " + nodeName +
                '.' + propertyName + " but it wasn't found.", targetObject);
            return;
        }
        // determine versioning scheme
        var versioning = this.Versioning.None;
        if (targetObject.needsUpdate !== undefined) {
            versioning = this.Versioning.NeedsUpdate;
            this.targetObject = targetObject;
        }
        else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
            this.targetObject = targetObject;
        }
        // determine how the property gets bound
        var bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            // access a sub element of the property array (only primitives are supported right now)
            if (propertyName === "morphTargetInfluences") {
                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                // support resolving morphTarget names into indices.
                if (!targetObject.geometry) {
                    console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry', this);
                    return;
                }
                if (!targetObject.geometry.morphTargets) {
                    console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this);
                    return;
                }
                for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
                    if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                        propertyIndex = i;
                        break;
                    }
                }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        }
        else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            // must use copy for Object3D.Euler/Quaternion
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        }
        else if (nodeProperty.length !== undefined) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        }
        else {
            this.propertyName = propertyName;
        }
        // select getter / setter
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    };
    PropertyBinding.prototype.unbind = function () {
        this.node = null;
        // back to the prototype version of getValue / setValue
        // note: avoiding to mutate the shape of 'this' via 'delete'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    };
    // these are used to "bind" a nonexistent property
    PropertyBinding.prototype._getValue_unavailable = function (targetArray, offset) { };
    PropertyBinding.prototype._setValue_unavailable = function (targetArray, offset) { };
    PropertyBinding.prototype.getValue_direct = function (buffer, offset) {
        buffer[offset] = this.node[this.propertyName];
    };
    PropertyBinding.prototype.getValue_array = function (buffer, offset) {
        var source = this.resolvedProperty;
        for (var i = 0, n = source.length; i !== n; ++i) {
            buffer[offset++] = source[i];
        }
    };
    PropertyBinding.prototype.getValue_arrayElement = function (buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
    };
    PropertyBinding.prototype.getValue_toArray = function (buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
    };
    // Direct
    PropertyBinding.prototype.setValue_direct = function (buffer, offset) {
        this.node[this.propertyName] = buffer[offset];
    };
    PropertyBinding.prototype.setValue_direct_setNeedsUpdate = function (buffer, offset) {
        this.node[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
    };
    PropertyBinding.prototype.setValue_direct_setMatrixWorldNeedsUpdate = function (buffer, offset) {
        this.node[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
    };
    // EntireArray
    PropertyBinding.prototype.setValue_array = function (buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
        }
    };
    PropertyBinding.prototype.setValue_array_setNeedsUpdate = function (buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
    };
    PropertyBinding.prototype.setValue_array_setMatrixWorldNeedsUpdate = function (buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
    };
    // ArrayElement
    PropertyBinding.prototype.setValue_arrayElement = function (buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
    };
    PropertyBinding.prototype.setValue_arrayElement_setNeedsUpdate = function (buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
    };
    PropertyBinding.prototype.setValue_arrayElement_setMatrixWorldNeedsUpdate = function (buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
    };
    // HasToFromArray
    PropertyBinding.prototype.setValue_fromArray = function (buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
    };
    PropertyBinding.prototype.setValue_fromArray_setNeedsUpdate = function (buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
    };
    PropertyBinding.prototype.setValue_fromArray_setMatrixWorldNeedsUpdate = function (buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
    };
    PropertyBinding.create = function (root, path, parsedPath) {
        if (!((root && root instanceof AnimationObjectGroup))) {
            return new PropertyBinding(root, path, parsedPath);
        }
        else {
            return new PropertyBinding.Composite(root, path, parsedPath);
        }
    };
    PropertyBinding.parseTrackName = function (trackName) {
        // matches strings in the form of:
        //    nodeName.property
        //    nodeName.property[accessor]
        //    nodeName.material.property[accessor]
        //    uuid.property[accessor]
        //    uuid.objectName[objectIndex].propertyName[propertyIndex]
        //    parentName/nodeName.property
        //    parentName/parentName/nodeName.property[index]
        //    .bone[Armature.DEF_cog].position
        //    scene:helium_balloon_model:helium_balloon_model.position
        // created and tested via https://regex101.com/#javascript
        var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
        var matches = re.exec(trackName);
        if (!matches) {
            throw new Error("cannot parse trackName at all: " + trackName);
        }
        var results = {
            // directoryName: matches[ 1 ], // (tschw) currently unused
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6] // allowed to be null, specifies that the whole property is set.
        };
        if (results.propertyName === null || results.propertyName.length === 0) {
            throw new Error("can not parse propertyName from trackName: " + trackName);
        }
        return results;
    };
    PropertyBinding.findNode = function (root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
            return root;
        }
        // search into skeleton bones.
        if (root.skeleton) {
            var searchSkeleton = function (skeleton) {
                for (var i = 0; i < skeleton.bones.length; i++) {
                    var bone_1 = skeleton.bones[i];
                    if (bone_1.name === nodeName) {
                        return bone_1;
                    }
                }
                return null;
            };
            var bone = searchSkeleton(root.skeleton);
            if (bone) {
                return bone;
            }
        }
        // search into node subtree.
        if (root.children) {
            var searchNodeSubtree_1 = function (children) {
                for (var i = 0; i < children.length; i++) {
                    var childNode = children[i];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) {
                        return childNode;
                    }
                    var result = searchNodeSubtree_1(childNode.children);
                    if (result)
                        return result;
                }
                return null;
            };
            var subTreeNode = searchNodeSubtree_1(root.children);
            if (subTreeNode) {
                return subTreeNode;
            }
        }
        return null;
    };
    PropertyBinding.Composite = (function () {
        function class_1(targetGroup, path, optionalParsedPath) {
            var parsedPath = optionalParsedPath ||
                PropertyBinding.parseTrackName(path);
            this._targetGroup = targetGroup;
            this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        class_1.prototype.getValue = function (array, offset) {
            this.bind(); // bind all binding
            var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
            // and only call .getValue on the first
            if (binding !== undefined)
                binding.getValue(array, offset);
        };
        class_1.prototype.setValue = function (array, offset) {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].setValue(array, offset);
            }
        };
        class_1.prototype.bind = function () {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].bind();
            }
        };
        class_1.prototype.unbind = function () {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].unbind();
            }
        };
        return class_1;
    }());
    return PropertyBinding;
}());

/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */
var AnimationAction = (function () {
    function AnimationAction(mixer, clip, localRoot) {
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot || null;
        var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        var interpolantSettings = {
            endingStart: EndingMode.ZeroCurvature,
            endingEnd: EndingMode.ZeroCurvature
        };
        for (var i = 0; i !== nTracks; ++i) {
            var interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants; // bound by the mixer
        // inside: PropertyMixer (managed by the mixer)
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null; // for the memory manager
        this._byClipCacheIndex = null; // for the memory manager
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopMode.Repeat;
        this._loopCount = -1;
        // global mixer time when the action is to be started
        // it's set back to 'null' upon start of the action
        this._startTime = null;
        // scaled local time of the action
        // gets clamped or wrapped to 0..clip.duration according to loop
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity; // no. of repetitions when looping
        this.paused = false; // false -> zero effective time scale
        this.enabled = true; // true -> zero effective weight
        this.clampWhenFinished = false; // keep feeding the last frame?
        this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
        this.zeroSlopeAtEnd = true; // clips for start, loop and end
    }
    // State & Scheduling
    AnimationAction.prototype.play = function () {
        this._mixer._activateAction(this);
        return this;
    };
    AnimationAction.prototype.stop = function () {
        this._mixer._deactivateAction(this);
        return this.reset();
    };
    AnimationAction.prototype.reset = function () {
        this.paused = false;
        this.enabled = true;
        this.time = 0; // restart clip
        this._loopCount = -1; // forget previous loops
        this._startTime = null; // forget scheduling
        return this.stopFading().stopWarping();
    };
    AnimationAction.prototype.isRunning = function () {
        return this.enabled && !this.paused && this.timeScale !== 0 &&
            this._startTime === null && this._mixer._isActiveAction(this);
    };
    // return true when play has been called
    AnimationAction.prototype.isScheduled = function () {
        return this._mixer._isActiveAction(this);
    };
    AnimationAction.prototype.startAt = function (time) {
        this._startTime = time;
        return this;
    };
    AnimationAction.prototype.setLoop = function (mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
    };
    // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    AnimationAction.prototype.setEffectiveWeight = function (weight) {
        this.weight = weight;
        // note: same logic as when updated at runtime
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
    };
    // return the weight considering fading and .enabled
    AnimationAction.prototype.getEffectiveWeight = function () {
        return this._effectiveWeight;
    };
    AnimationAction.prototype.fadeIn = function (duration) {
        return this._scheduleFading(duration, 0, 1);
    };
    AnimationAction.prototype.fadeOut = function (duration) {
        return this._scheduleFading(duration, 1, 0);
    };
    AnimationAction.prototype.crossFadeFrom = function (fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
            var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1.0, startEndRatio, duration);
            this.warp(endStartRatio, 1.0, duration);
        }
        return this;
    };
    AnimationAction.prototype.crossFadeTo = function (fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
    };
    AnimationAction.prototype.stopFading = function () {
        var weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
    };
    // Time Scale Control
    // set the weight stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    AnimationAction.prototype.setEffectiveTimeScale = function (timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
    };
    // return the time scale considering warping and .paused
    AnimationAction.prototype.getEffectiveTimeScale = function () {
        return this._effectiveTimeScale;
    };
    AnimationAction.prototype.setDuration = function (duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
    };
    AnimationAction.prototype.syncWith = function (action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
    };
    AnimationAction.prototype.halt = function (duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
    };
    AnimationAction.prototype.warp = function (startTimeScale, endTimeScale, duration) {
        var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant(),
                this._timeScaleInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        times[1] = now + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
    };
    AnimationAction.prototype.stopWarping = function () {
        var timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
    };
    // Object Accessors
    AnimationAction.prototype.getMixer = function () {
        return this._mixer;
    };
    AnimationAction.prototype.getClip = function () {
        return this._clip;
    };
    AnimationAction.prototype.getRoot = function () {
        return this._localRoot || this._mixer._root;
    };
    // Interna
    AnimationAction.prototype._update = function (time, deltaTime, timeDirection, accuIndex) {
        // called by the mixer
        var startTime = this._startTime;
        if (startTime !== null) {
            // check for scheduled start of action
            var timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {
                return; // yet to come / don't decide when delta = 0
            }
            // start
            this._startTime = null; // unschedule
            deltaTime = timeDirection * timeRunning;
        }
        // apply time scale and advance time
        deltaTime *= this._updateTimeScale(time);
        var clipTime = this._updateTime(deltaTime);
        // note: _updateTime may disable the action resulting in
        // an effective weight of 0
        var weight = this._updateWeight(time);
        if (weight > 0) {
            var interpolants = this._interpolants;
            var propertyMixers = this._propertyBindings;
            for (var j = 0, m = interpolants.length; j !== m; ++j) {
                interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulate(accuIndex, weight);
            }
        }
    };
    AnimationAction.prototype._updateWeight = function (time) {
        var weight = 0;
        if (this.enabled) {
            weight = this.weight;
            var interpolant = this._weightInterpolant;
            if (interpolant !== null) {
                var interpolantValue = interpolant.evaluate(time)[0];
                weight *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) {
                        // faded out, disable
                        this.enabled = false;
                    }
                }
            }
        }
        this._effectiveWeight = weight;
        return weight;
    };
    AnimationAction.prototype._updateTimeScale = function (time) {
        var timeScale = 0;
        if (!this.paused) {
            timeScale = this.timeScale;
            var interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
                var interpolantValue = interpolant.evaluate(time)[0];
                timeScale *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) {
                        // motion has halted, pause
                        this.paused = true;
                    }
                    else {
                        // warp done - apply final time scale
                        this.timeScale = timeScale;
                    }
                }
            }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
    };
    AnimationAction.prototype._updateTime = function (deltaTime) {
        var time = this.time + deltaTime;
        if (deltaTime === 0)
            return time;
        var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
        if (loop === LoopMode.Once) {
            if (loopCount === -1) {
                // just started
                this.loopCount = 0;
                this._setEndings(true, true, false);
            }
            handle_stop: {
                if (time >= duration) {
                    time = duration;
                }
                else if (time < 0) {
                    time = 0;
                }
                else
                    break handle_stop;
                if (this.clampWhenFinished)
                    this.paused = true;
                else
                    this.enabled = false;
                this._mixer.dispatchEvent({
                    type: 'finished', action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });
            }
        }
        else {
            var pingPong = (loop === LoopMode.PingPong);
            if (loopCount === -1) {
                // just started
                if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                }
                else {
                    // when looping in reverse direction, the initial
                    // transition through zero counts as a repetition,
                    // so leave loopCount at -1
                    this._setEndings(this.repetitions === 0, true, pingPong);
                }
            }
            if (time >= duration || time < 0) {
                // wrap around
                var loopDelta = Math.floor(time / duration); // signed
                time -= duration * loopDelta;
                loopCount += Math.abs(loopDelta);
                var pending = this.repetitions - loopCount;
                if (pending < 0) {
                    // have to stop (switch state, clamp time, fire event)
                    if (this.clampWhenFinished)
                        this.paused = true;
                    else
                        this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this._mixer.dispatchEvent({
                        type: 'finished', action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                }
                else {
                    // keep running
                    if (pending === 0) {
                        // entering the last round
                        var atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);
                    }
                    else {
                        this._setEndings(false, false, pingPong);
                    }
                    this._loopCount = loopCount;
                    this._mixer.dispatchEvent({
                        type: 'loop', action: this, loopDelta: loopDelta
                    });
                }
            }
            if (pingPong && (loopCount & 1) === 1) {
                // invert time for the "pong round"
                this.time = time;
                return duration - time;
            }
        }
        this.time = time;
        return time;
    };
    AnimationAction.prototype._setEndings = function (atStart, atEnd, pingPong) {
        var settings = this._interpolantSettings;
        if (pingPong) {
            settings.endingStart = EndingMode.ZeroSlope;
            settings.endingEnd = EndingMode.ZeroSlope;
        }
        else {
            // assuming for LoopMode.Once atStart == atEnd == true
            if (atStart) {
                settings.endingStart = this.zeroSlopeAtStart ?
                    EndingMode.ZeroSlope : EndingMode.ZeroCurvature;
            }
            else {
                settings.endingStart = EndingMode.WrapAround;
            }
            if (atEnd) {
                settings.endingEnd = this.zeroSlopeAtEnd ?
                    EndingMode.ZeroSlope : EndingMode.ZeroCurvature;
            }
            else {
                settings.endingEnd = EndingMode.WrapAround;
            }
        }
    };
    AnimationAction.prototype._scheduleFading = function (duration, weightNow, weightThen) {
        var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant(),
                this._weightInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        values[0] = weightNow;
        times[1] = now + duration;
        values[1] = weightThen;
        return this;
    };
    return AnimationAction;
}());

/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
var AnimationMixer = (function (_super) {
    __extends(AnimationMixer, _super);
    function AnimationMixer(root) {
        _super.call(this);
        this._controlInterpolantsResultBuffer = new Float32Array(1);
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1.0;
    }
    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    AnimationMixer.prototype.clipAction = function (clip, optionalRoot) {
        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?
            AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
        if (actionsForClip !== undefined) {
            var existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== undefined) {
                return existingAction;
            }
            // we know the clip, so we don't have to parse all
            // the bindings again but can just copy
            prototypeAction = actionsForClip.knownActions[0];
            // also, take the clip from the prototype action
            if (clipObject === null)
                clipObject = prototypeAction._clip;
        }
        // clip must be known when specified via string
        if (clipObject === null)
            return null;
        // allocate all resources required to run it
        var newAction = new AnimationAction(this, clipObject, optionalRoot);
        this._bindAction(newAction, prototypeAction);
        // and make the action known to the memory manager
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
    };
    // get an existing action
    AnimationMixer.prototype.existingAction = function (clip, optionalRoot) {
        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?
            AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            return actionsForClip.actionByRoot[rootUuid] || null;
        }
        return null;
    };
    // deactivates all previously scheduled actions
    AnimationMixer.prototype.stopAllAction = function () {
        var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
        this._nActiveActions = 0;
        this._nActiveBindings = 0;
        for (var i = 0; i !== nActions; ++i) {
            actions[i].reset();
        }
        for (var i = 0; i !== nBindings; ++i) {
            bindings[i].useCount = 0;
        }
        return this;
    };
    // advance the time and update apply the animation
    AnimationMixer.prototype.update = function (deltaTime) {
        deltaTime *= this.timeScale;
        var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        // run active actions
        for (var i = 0; i !== nActions; ++i) {
            var action = actions[i];
            if (action.enabled) {
                action._update(time, deltaTime, timeDirection, accuIndex);
            }
        }
        // update scene graph
        var bindings = this._bindings, nBindings = this._nActiveBindings;
        for (var i = 0; i !== nBindings; ++i) {
            bindings[i].apply(accuIndex);
        }
        return this;
    };
    // return this mixer's root target object
    AnimationMixer.prototype.getRoot = function () {
        return this._root;
    };
    // free all resources specific to a particular clip
    AnimationMixer.prototype.uncacheClip = function (clip) {
        var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            // note: just calling _removeInactiveAction would mess up the
            // iteration state and also require updating the state we can
            // just throw away
            var actionsToRemove = actionsForClip.knownActions;
            for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                var action = actionsToRemove[i];
                this._deactivateAction(action);
                var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                action._cacheIndex = null;
                action._byClipCacheIndex = null;
                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();
                this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
        }
    };
    // free all resources specific to a particular root target object
    AnimationMixer.prototype.uncacheRoot = function (root) {
        var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for (var clipUuid in actionsByClip) {
            var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== undefined) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) {
            for (var trackName in bindingByName) {
                var binding = bindingByName[trackName];
                binding.restoreOriginalState();
                this._removeInactiveBinding(binding);
            }
        }
    };
    // remove a targeted clip from the cache
    AnimationMixer.prototype.uncacheAction = function (clip, optionalRoot) {
        var action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
        }
    };
    // Implementation details:
    AnimationMixer.prototype._bindAction = function (action, prototypeAction) {
        var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
        }
        for (var i = 0; i !== nTracks; ++i) {
            var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
            if (binding !== undefined) {
                bindings[i] = binding;
            }
            else {
                binding = bindings[i];
                if (binding !== undefined) {
                    // existing binding, make sure the cache knows
                    if (binding._cacheIndex === null) {
                        ++binding.referenceCount;
                        this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                }
                var path = prototypeAction && prototypeAction.
                    _propertyBindings[i].binding.parsedPath;
                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
                bindings[i] = binding;
            }
            interpolants[i].resultBuffer = binding.buffer;
        }
    };
    AnimationMixer.prototype._activateAction = function (action) {
        if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
                // this action has been forgotten by the cache, but the user
                // appears to be still using it -> rebind
                var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                this._addInactiveAction(action, clipUuid, rootUuid);
            }
            var bindings = action._propertyBindings;
            // increment reference counts / sort out state
            for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (binding.useCount++ === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                }
            }
            this._lendAction(action);
        }
    };
    AnimationMixer.prototype._deactivateAction = function (action) {
        if (this._isActiveAction(action)) {
            var bindings = action._propertyBindings;
            // decrement reference counts / sort out state
            for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (--binding.useCount === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                }
            }
            this._takeBackAction(action);
        }
    };
    // Memory manager
    AnimationMixer.prototype._initMemoryManager = function () {
        this._actions = []; // 'nActiveActions' followed by inactive ones
        this._nActiveActions = 0;
        this._actionsByClip = {};
        // inside:
        // {
        //     knownActions: Array< AnimationAction >  - used as prototypes
        //     actionByRoot: AnimationAction      - lookup
        // }
        this._bindings = []; // 'nActiveBindings' followed by inactive ones
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
        this._controlInterpolants = []; // same game as above
        this._nActiveControlInterpolants = 0;
        var scope = this;
        this.stats = {
            actions: {
                get total() { return scope._actions.length; },
                get inUse() { return scope._nActiveActions; }
            },
            bindings: {
                get total() { return scope._bindings.length; },
                get inUse() { return scope._nActiveBindings; }
            },
            controlInterpolants: {
                get total() { return scope._controlInterpolants.length; },
                get inUse() { return scope._nActiveControlInterpolants; }
            }
        };
    };
    // Memory management for AnimationAction objects
    AnimationMixer.prototype._isActiveAction = function (action) {
        var index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
    };
    AnimationMixer.prototype._addInactiveAction = function (action, clipUuid, rootUuid) {
        var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
            actionsForClip = {
                knownActions: [action],
                actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
        }
        else {
            var knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
    };
    AnimationMixer.prototype._removeInactiveAction = function (action) {
        var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        var actionByRoot = actionsForClip.actionByRoot, rootUuid = (actions._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) {
            delete actionsByClip[clipUuid];
        }
        this._removeInactiveBindingsForAction(action);
    };
    AnimationMixer.prototype._removeInactiveBindingsForAction = function (action) {
        var bindings = action._propertyBindings;
        for (var i = 0, n = bindings.length; i !== n; ++i) {
            var binding = bindings[i];
            if (--binding.referenceCount === 0) {
                this._removeInactiveBinding(binding);
            }
        }
    };
    AnimationMixer.prototype._lendAction = function (action) {
        // [ active actions |  inactive actions  ]
        // [  active actions >| inactive actions ]
        //                 s        a
        //                  <-swap->
        //                 a        s
        var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
    };
    AnimationMixer.prototype._takeBackAction = function (action) {
        // [  active actions  | inactive actions ]
        // [ active actions |< inactive actions  ]
        //        a        s
        //         <-swap->
        //        s        a
        var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
    };
    // Memory management for PropertyMixer objects
    AnimationMixer.prototype._addInactiveBinding = function (binding, rootUuid, trackName) {
        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
        if (bindingByName === undefined) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
    };
    AnimationMixer.prototype._removeInactiveBinding = function (binding) {
        var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        remove_empty_map: {
            for (var _ in bindingByName)
                break remove_empty_map;
            delete bindingsByRoot[rootUuid];
        }
    };
    AnimationMixer.prototype._lendBinding = function (binding) {
        var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
    };
    AnimationMixer.prototype._takeBackBinding = function (binding) {
        var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
    };
    // Memory management of Interpolants for weight and time scale
    AnimationMixer.prototype._lendControlInterpolant = function () {
        var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
        if (interpolant === undefined) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
    };
    AnimationMixer.prototype._takeBackControlInterpolant = function (interpolant) {
        var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
    };
    return AnimationMixer;
}(EventDispatcher));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var Uniform = (function () {
    function Uniform(value) {
        if (typeof value === 'string') {
            console.warn('THREE.Uniform: Type parameter is no longer needed.');
            value = arguments[1];
        }
        this.value = value;
    }
    Object.defineProperty(Uniform.prototype, "dynamic", {
        set: function (value) {
            console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
        },
        enumerable: true,
        configurable: true
    });
    Uniform.prototype.onUpdate = function (callback) {
        console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
        return this;
    };
    return Uniform;
}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */
var Intersect = (function () {
    function Intersect() {
    }
    return Intersect;
}());
var Raycaster = (function () {
    function Raycaster(origin, direction, near, far) {
        this.linePrecision = 1;
        this.ray = new Ray(origin, direction);
        // direction is assumed to be normalized (for accurate distance calculations)
        this.near = near || 0;
        this.far = far || Infinity;
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {}
        };
        //Object.defineProperties(this.params, {
        //  PointCloud: {
        //    get: function () {
        //      console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
        //      return this.Points;
        //    }
        //  }
        //});
    }
    Raycaster.prototype.set = function (origin, direction) {
        // direction is assumed to be normalized (for accurate distance calculations)
        this.ray.set(origin, direction);
    };
    Raycaster.prototype.setFromCamera = function (coords, camera) {
        if ((camera && camera instanceof PerspectiveCamera)) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
        }
        else if ((camera && camera instanceof OrthographicCamera)) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        }
        else {
            console.error('THREE.Raycaster: Unsupported camera type.');
        }
    };
    Raycaster.prototype.intersectObject = function (object, recursive) {
        var intersects = [];
        intersectObject(object, this, intersects, recursive);
        intersects.sort(ascSort);
        return intersects;
    };
    Raycaster.prototype.intersectObjects = function (objects, recursive) {
        var intersects = [];
        if (Array.isArray(objects) === false) {
            console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
            return intersects;
        }
        for (var i = 0, l = objects.length; i < l; i++) {
            intersectObject(objects[i], this, intersects, recursive);
        }
        intersects.sort(ascSort);
        return intersects;
    };
    return Raycaster;
}());
function ascSort(a, b) {
    return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects, recursive) {
    if (object.visible === false)
        return;
    object.raycast(raycaster, intersects);
    if (recursive === true) {
        var children = object.children;
        for (var i = 0, l = children.length; i < l; i++) {
            intersectObject(children[i], raycaster, intersects, true);
        }
    }
}

/**
 * @author alteredq / http://alteredqualia.com/
 */
var Clock = (function () {
    function Clock(autoStart) {
        if (autoStart === void 0) { autoStart = true; }
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
        this.autoStart = autoStart;
    }
    Clock.prototype.start = function () {
        this.startTime = (performance || Date).now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
    };
    Clock.prototype.stop = function () {
        this.getElapsedTime();
        this.running = false;
    };
    Clock.prototype.getElapsedTime = function () {
        this.getDelta();
        return this.elapsedTime;
    };
    Clock.prototype.getDelta = function () {
        var diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
        }
        if (this.running) {
            var newTime = (performance || Date).now();
            diff = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    };
    return Clock;
}());

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
var Spline = (function () {
    function Spline(points) {
        this.points = points;
    }
    Spline.prototype.initFromArray = function (a) {
        this.points = [];
        for (var i = 0; i < a.length; i++) {
            this.points[i] = { x: a[i][0], y: a[i][1], z: a[i][2] };
        }
    };
    Spline.prototype.getPoint = function (k) {
        var c = [], v3 = { x: 0, y: 0, z: 0 };
        var point, intPoint, weight, w2, w3, pa, pb, pc, pd;
        point = (this.points.length - 1) * k;
        intPoint = Math.floor(point);
        weight = point - intPoint;
        c[0] = intPoint === 0 ? intPoint : intPoint - 1;
        c[1] = intPoint;
        c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
        pa = this.points[c[0]];
        pb = this.points[c[1]];
        pc = this.points[c[2]];
        pd = this.points[c[3]];
        w2 = weight * weight;
        w3 = weight * w2;
        v3.x = Spline.interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
        v3.y = Spline.interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
        v3.z = Spline.interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
        return v3;
    };
    Spline.prototype.getControlPointsArray = function () {
        var l = this.points.length, coords = [];
        for (var i = 0; i < l; i++) {
            var p = this.points[i];
            coords[i] = [p.x, p.y, p.z];
        }
        return coords;
    };
    // approximate length by summing linear segments
    Spline.prototype.getLength = function (nSubDivisions) {
        if (nSubDivisions === void 0) { nSubDivisions = 100; }
        var oldIntPoint = 0;
        var oldPosition = new Vector3();
        var tmpVec = new Vector3();
        var chunkLengths = [];
        var totalLength = 0;
        // first point has 0 length
        chunkLengths[0] = 0;
        var nSamples = this.points.length * nSubDivisions;
        oldPosition.copy(this.points[0]);
        for (var i = 1; i < nSamples; i++) {
            var index = i / nSamples;
            var position = this.getPoint(index);
            tmpVec.copy(position);
            totalLength += tmpVec.distanceTo(oldPosition);
            oldPosition.copy(position);
            var point = (this.points.length - 1) * index;
            var intPoint = Math.floor(point);
            if (intPoint !== oldIntPoint) {
                chunkLengths[intPoint] = totalLength;
                oldIntPoint = intPoint;
            }
        }
        // last point ends with total length
        chunkLengths[chunkLengths.length] = totalLength;
        return { chunks: chunkLengths, total: totalLength };
    };
    Spline.prototype.reparametrizeByArcLength = function (samplingCoef) {
        var newpoints = [];
        var tmpVec = new Vector3();
        var sl = this.getLength();
        newpoints.push(tmpVec.copy(this.points[0]).clone());
        for (var i = 1; i < this.points.length; i++) {
            //tmpVec.copy(this.points[i - 1]);
            //linearDistance = tmpVec.distanceTo(this.points[i]);
            var realDistance = sl.chunks[i] - sl.chunks[i - 1];
            var sampling = Math.ceil(samplingCoef * realDistance / sl.total);
            var indexCurrent = (i - 1) / (this.points.length - 1);
            var indexNext = i / (this.points.length - 1);
            for (var j = 1; j < sampling - 1; j++) {
                var index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
                var position = this.getPoint(index);
                newpoints.push(tmpVec.copy(position).clone());
            }
            newpoints.push(tmpVec.copy(this.points[i]).clone());
        }
        this.points = newpoints;
    };
    // Catmull-Rom
    Spline.interpolate = function (p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    };
    return Spline;
}());

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The poles (phi) are at the positive and negative y axis.
 * The equator starts at positive z.
 */
var Spherical = (function () {
    function Spherical(radius, phi, theta) {
        if (radius === void 0) { radius = 1.0; }
        if (phi === void 0) { phi = 0; }
        if (theta === void 0) { theta = 0; }
        this.radius = radius;
        this.phi = phi; // up / down towards top and bottom pole
        this.theta = theta; // around the equator of the sphere
    }
    Spherical.prototype.set = function (radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    };
    Spherical.prototype.clone = function () {
        return new this.constructor().copy(this);
    };
    Spherical.prototype.copy = function (other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
    };
    // restrict phi to be betwee EPS and PI-EPS
    Spherical.prototype.makeSafe = function () {
        var EPS = 0.000001;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
    };
    Spherical.prototype.setFromVector3 = function (vec3) {
        this.radius = vec3.length();
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        }
        else {
            this.theta = Math.atan2(vec3.x, vec3.z); // equator angle around y-up axis
            this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1)); // polar angle
        }
        return this;
    };
    return Spherical;
}());

/**
 * @author alteredq / http://alteredqualia.com/
 */
var MorphBlendMesh = (function (_super) {
    __extends(MorphBlendMesh, _super);
    function MorphBlendMesh(geometry, material) {
        _super.call(this, geometry, material);
        this.animationsMap = {};
        this.animationsList = [];
        // prepare default animation
        // (all frames played together in 1 second)
        var numFrames = this.geometry.morphTargets.length;
        var name = "__default";
        var startFrame = 0;
        var endFrame = numFrames - 1;
        var fps = numFrames / 1;
        this.createAnimation(name, startFrame, endFrame, fps);
        this.setAnimationWeight(name, 1);
    }
    MorphBlendMesh.prototype.createAnimation = function (name, start, end, fps) {
        var animation = {
            start: start,
            end: end,
            length: end - start + 1,
            fps: fps,
            duration: (end - start) / fps,
            lastFrame: 0,
            currentFrame: 0,
            active: false,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: false,
            mirroredLoop: false
        };
        this.animationsMap[name] = animation;
        this.animationsList.push(animation);
    };
    
    MorphBlendMesh.prototype.autoCreateAnimations = function (fps) {
        var pattern = /([a-z]+)_?(\d+)/i;
        var firstAnimation, frameRanges = {};
        var geometry = this.geometry;
        for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
            var morph = geometry.morphTargets[i];
            var chunks = morph.name.match(pattern);
            if (chunks && chunks.length > 1) {
                var name = chunks[1];
                if (!frameRanges[name])
                    frameRanges[name] = { start: Infinity, end: -Infinity };
                var range = frameRanges[name];
                if (i < range.start)
                    range.start = i;
                if (i > range.end)
                    range.end = i;
                if (!firstAnimation)
                    firstAnimation = name;
            }
        }
        for (var name in frameRanges) {
            var range = frameRanges[name];
            this.createAnimation(name, range.start, range.end, fps);
        }
        this.firstAnimation = firstAnimation;
    };
    MorphBlendMesh.prototype.setAnimationDirectionForward = function (name) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.direction = 1;
            animation.directionBackwards = false;
        }
    };
    MorphBlendMesh.prototype.setAnimationDirectionBackward = function (name) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.direction = -1;
            animation.directionBackwards = true;
        }
    };
    MorphBlendMesh.prototype.setAnimationFPS = function (name, fps) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.fps = fps;
            animation.duration = (animation.end - animation.start) / animation.fps;
        }
    };
    MorphBlendMesh.prototype.setAnimationDuration = function (name, duration) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.duration = duration;
            animation.fps = (animation.end - animation.start) / animation.duration;
        }
    };
    MorphBlendMesh.prototype.setAnimationWeight = function (name, weight) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.weight = weight;
        }
    };
    MorphBlendMesh.prototype.setAnimationTime = function (name, time) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.time = time;
        }
    };
    
    MorphBlendMesh.prototype.getAnimationTime = function (name) {
        var time = 0;
        var animation = this.animationsMap[name];
        if (animation) {
            time = animation.time;
        }
        return time;
    };
    MorphBlendMesh.prototype.getAnimationDuration = function (name) {
        var duration = -1;
        var animation = this.animationsMap[name];
        if (animation) {
            duration = animation.duration;
        }
        return duration;
    };
    MorphBlendMesh.prototype.playAnimation = function (name) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.time = 0;
            animation.active = true;
        }
        else {
            console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
        }
    };
    MorphBlendMesh.prototype.stopAnimation = function (name) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.active = false;
        }
    };
    MorphBlendMesh.prototype.update = function (delta) {
        for (var i = 0, il = this.animationsList.length; i < il; i++) {
            var animation = this.animationsList[i];
            if (!animation.active)
                continue;
            var frameTime = animation.duration / animation.length;
            animation.time += animation.direction * delta;
            if (animation.mirroredLoop) {
                if (animation.time > animation.duration || animation.time < 0) {
                    animation.direction *= -1;
                    if (animation.time > animation.duration) {
                        animation.time = animation.duration;
                        animation.directionBackwards = true;
                    }
                    if (animation.time < 0) {
                        animation.time = 0;
                        animation.directionBackwards = false;
                    }
                }
            }
            else {
                animation.time = animation.time % animation.duration;
                if (animation.time < 0)
                    animation.time += animation.duration;
            }
            var keyframe = animation.start + _Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
            var weight = animation.weight;
            if (keyframe !== animation.currentFrame) {
                this.morphTargetInfluences[animation.lastFrame] = 0;
                this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
                this.morphTargetInfluences[keyframe] = 0;
                animation.lastFrame = animation.currentFrame;
                animation.currentFrame = keyframe;
            }
            var mix = (animation.time % frameTime) / frameTime;
            if (animation.directionBackwards)
                mix = 1 - mix;
            if (animation.currentFrame !== animation.lastFrame) {
                this.morphTargetInfluences[animation.currentFrame] = mix * weight;
                this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
            }
            else {
                this.morphTargetInfluences[animation.currentFrame] = weight;
            }
        }
    };
    
    return MorphBlendMesh;
}(Mesh));

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/
var VertexNormalsHelper = (function (_super) {
    __extends(VertexNormalsHelper, _super);
    function VertexNormalsHelper(object, size, color, linewidth) {
        if (size === void 0) { size = 1; }
        if (color === void 0) { color = 0xff0000; }
        if (linewidth === void 0) { linewidth = 1; }
        ///this.object = object;
        ///this.size = size;
        //
        var nNormals = 0;
        var objGeometry = object.geometry;
        if ((objGeometry && objGeometry instanceof Geometry)) {
            nNormals = objGeometry.faces.length * 3;
        }
        else if ((objGeometry && objGeometry instanceof BufferGeometry)) {
            nNormals = objGeometry.attributes.normal.count;
        }
        //
        var geometry = new BufferGeometry();
        var positions = Float32Attribute(nNormals * 2 * 3, 3);
        geometry.addAttribute('position', positions);
        _super.call(this, geometry, new LineBasicMaterial({ color: color, linewidth: linewidth }));
        //
        this.object = object;
        this.size = size;
        this.matrixAutoUpdate = false;
        this.update();
    }
    VertexNormalsHelper.prototype.update = function () {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var normalMatrix = new Matrix3();
        //return function update() {
        var keys = ['a', 'b', 'c'];
        this.object.updateMatrixWorld(true);
        normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var matrixWorld = this.object.matrixWorld;
        var position = this.geometry.attributes.position;
        //
        var objGeometry = this.object.geometry;
        if ((objGeometry && objGeometry instanceof Geometry)) {
            var vertices = objGeometry.vertices;
            var faces = objGeometry.faces;
            var idx = 0;
            for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                    var vertex = vertices[face[keys[j]]];
                    var normal = face.vertexNormals[j];
                    v1.copy(vertex).applyMatrix4(matrixWorld);
                    v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                    position.setXYZ(idx, v1.x, v1.y, v1.z);
                    idx = idx + 1;
                    position.setXYZ(idx, v2.x, v2.y, v2.z);
                    idx = idx + 1;
                }
            }
        }
        else if ((objGeometry && objGeometry instanceof BufferGeometry)) {
            var objPos = objGeometry.attributes.position;
            var objNorm = objGeometry.attributes.normal;
            var idx = 0;
            // for simplicity, ignore index and drawcalls, and render every normal
            for (var j = 0, jl = objPos.count; j < jl; j++) {
                v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
                v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
                v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                position.setXYZ(idx, v1.x, v1.y, v1.z);
                idx = idx + 1;
                position.setXYZ(idx, v2.x, v2.y, v2.z);
                idx = idx + 1;
            }
        }
        position.needsUpdate = true;
        return this;
        //};
    };
    return VertexNormalsHelper;
}(LineSegments));

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/
var SpotLightHelper = (function (_super) {
    __extends(SpotLightHelper, _super);
    function SpotLightHelper(light) {
        _super.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        var geometry = new BufferGeometry();
        var positions = [
            0, 0, 0, 0, 0, 1,
            0, 0, 0, 1, 0, 1,
            0, 0, 0, -1, 0, 1,
            0, 0, 0, 0, 1, 1,
            0, 0, 0, 0, -1, 1
        ];
        for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
            var p1 = (i / l) * Math.PI * 2;
            var p2 = (j / l) * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.addAttribute('position', Float32Attribute(positions, 3));
        var material = new LineBasicMaterial({ fog: false });
        this.cone = new LineSegments(geometry, material);
        this.add(this.cone);
        this.update();
    }
    SpotLightHelper.prototype.dispose = function () {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
    };
    SpotLightHelper.prototype.update = function () {
        var vector = new Vector3();
        var vector2 = new Vector3();
        //return function update() {
        var coneLength = this.light.distance ? this.light.distance : 1000;
        var coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        vector.setFromMatrixPosition(this.light.matrixWorld);
        vector2.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(vector2.sub(vector));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        //};
    };
    return SpotLightHelper;
}(Object3D));

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */
var SkeletonHelper = (function (_super) {
    __extends(SkeletonHelper, _super);
    function SkeletonHelper(object) {
        var bones = SkeletonHelper.getBoneList(object);
        var geometry = new Geometry();
        for (var i = 0; i < bones.length; i++) {
            var bone = bones[i];
            if ((bone.parent && bone.parent instanceof Bone)) {
                geometry.vertices.push(new Vector3());
                geometry.vertices.push(new Vector3());
                geometry.colors.push(new Color(0, 0, 1));
                geometry.colors.push(new Color(0, 1, 0));
            }
        }
        geometry.dynamic = true;
        var material = new LineBasicMaterial({ vertexColors: ColorsMode.Vertex, depthTest: false, depthWrite: false, transparent: true });
        _super.call(this, geometry, material);
        this.bones = bones;
        this.root = object;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
    }
    SkeletonHelper.getBoneList = function (object) {
        var boneList = [];
        if ((object && object instanceof Bone)) {
            boneList.push(object);
        }
        for (var i = 0; i < object.children.length; i++) {
            boneList.push.apply(boneList, SkeletonHelper.getBoneList(object.children[i]));
        }
        return boneList;
    };
    SkeletonHelper.prototype.getBonesList = function (object) {
        return SkeletonHelper.getBoneList(object);
    };
    SkeletonHelper.prototype.update = function () {
        var geometry = this.geometry;
        if (geometry instanceof Geometry) {
            var matrixWorldInv = new Matrix4().getInverse(this.root.matrixWorld);
            var boneMatrix = new Matrix4();
            var j = 0;
            for (var i = 0; i < this.bones.length; i++) {
                var bone = this.bones[i];
                if ((bone.parent && bone.parent instanceof Bone)) {
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                    geometry.vertices[j].setFromMatrixPosition(boneMatrix);
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                    geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
                    j += 2;
                }
            }
            geometry.verticesNeedUpdate = true;
            geometry.computeBoundingSphere();
        }
    };
    return SkeletonHelper;
}(LineSegments));

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */
var PointLightHelper = (function (_super) {
    __extends(PointLightHelper, _super);
    function PointLightHelper(light, sphereSize) {
        light.updateMatrixWorld();
        var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
        var material = new MeshBasicMaterial({ wireframe: true, fog: false });
        material.color.copy(light.color).multiplyScalar(light.intensity);
        _super.call(this, geometry, material);
        this.light = light;
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        /*
        let distanceGeometry = new THREE.IcosahedronGeometry(1, 2);
        let distanceMaterial = new THREE.MeshBasicMaterial({ color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true });
        this.lightSphere = new THREE.Mesh(bulbGeometry, bulbMaterial);
        this.lightDistance = new THREE.Mesh(distanceGeometry, distanceMaterial);
        let d = light.distance;
        if (d === 0.0) {
          this.lightDistance.visible = false;
        } else {
          this.lightDistance.scale.set(d, d, d);
        }
        this.add(this.lightDistance);
        */
    }
    PointLightHelper.prototype.dispose = function () {
        this.geometry.dispose();
        this.material.dispose();
    };
    PointLightHelper.prototype.update = function () {
        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        /*
        let d = this.light.distance;
        if (d === 0.0) {
          this.lightDistance.visible = false;
        } else {
          this.lightDistance.visible = true;
          this.lightDistance.scale.set(d, d, d);
        }
        */
    };
    return PointLightHelper;
}(Mesh));

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */
var HemisphereLightHelper = (function (_super) {
    __extends(HemisphereLightHelper, _super);
    function HemisphereLightHelper(light, sphereSize) {
        _super.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.colors = [new Color(), new Color()];
        var geometry = new SphereGeometry(sphereSize, 4, 2);
        geometry.rotateX(-Math.PI / 2);
        for (var i = 0, il = 8; i < il; i++) {
            geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
        }
        var material = new MeshBasicMaterial({ vertexColors: ColorsMode.Face, wireframe: true });
        this.lightSphere = new Mesh(geometry, material);
        this.add(this.lightSphere);
        this.update();
    }
    HemisphereLightHelper.prototype.dispose = function () {
        this.lightSphere.geometry.dispose();
        this.lightSphere.material.dispose();
    };
    HemisphereLightHelper.prototype.update = function () {
        var vector = new Vector3();
        //return function update() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = true;
        //};
    };
    return HemisphereLightHelper;
}(Object3D));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var GridHelper = (function (_super) {
    __extends(GridHelper, _super);
    function GridHelper(size, divisions, color1, color2) {
        if (divisions === void 0) { divisions = 1; }
        if (color1 === void 0) { color1 = 0x444444; }
        if (color2 === void 0) { color2 = 0x888888; }
        var _color1 = new Color(color1);
        var _color2 = new Color(color2);
        var center = divisions / 2;
        var step = (size * 2) / divisions;
        var vertices = [], colors = [];
        for (var i = 0, j = 0, k = -size; i <= divisions; i++, k += step) {
            vertices.push(-size, 0, k, size, 0, k);
            vertices.push(k, 0, -size, k, 0, size);
            var color = i === center ? _color1 : _color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
        }
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', Float32Attribute(vertices, 3));
        geometry.addAttribute('color', Float32Attribute(colors, 3));
        var material = new LineBasicMaterial({ vertexColors: ColorsMode.Vertex });
        _super.call(this, geometry, material);
    }
    GridHelper.prototype.setColors = function () {
        console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
    };
    return GridHelper;
}(LineSegments));

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/
var FaceNormalsHelper = (function (_super) {
    __extends(FaceNormalsHelper, _super);
    function FaceNormalsHelper(object, size, color, linewidth) {
        if (size === void 0) { size = 1; }
        if (color === void 0) { color = 0xffff00; }
        if (linewidth === void 0) { linewidth = 1; }
        // FaceNormalsHelper only supports THREE.Geometry
        ///this.object = object;
        ///this.size = (size !== undefined) ? size : 1;
        //
        var nNormals = 0;
        var objGeometry = object.geometry;
        if ((objGeometry && objGeometry instanceof Geometry)) {
            nNormals = objGeometry.faces.length;
        }
        else {
            console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
        }
        //
        var geometry = new BufferGeometry();
        var positions = Float32Attribute(nNormals * 2 * 3, 3);
        geometry.addAttribute('position', positions);
        _super.call(this, geometry, new LineBasicMaterial({ color: color, linewidth: linewidth }));
        //
        this.object = object;
        this.size = size;
        this.matrixAutoUpdate = false;
        this.update();
    }
    FaceNormalsHelper.prototype.update = function () {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var normalMatrix = new Matrix3();
        //return function update() {
        this.object.updateMatrixWorld(true);
        normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var matrixWorld = this.object.matrixWorld;
        var position = this.geometry.attributes.position;
        //
        var objGeometry = this.object.geometry;
        var vertices = objGeometry.vertices;
        var faces = objGeometry.faces;
        var idx = 0;
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            var normal = face.normal;
            v1.copy(vertices[face.a])
                .add(vertices[face.b])
                .add(vertices[face.c])
                .divideScalar(3)
                .applyMatrix4(matrixWorld);
            v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
            position.setXYZ(idx, v1.x, v1.y, v1.z);
            idx = idx + 1;
            position.setXYZ(idx, v2.x, v2.y, v2.z);
            idx = idx + 1;
        }
        position.needsUpdate = true;
        return this;
        //};
    };
    return FaceNormalsHelper;
}(LineSegments));

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */
var DirectionalLightHelper = (function (_super) {
    __extends(DirectionalLightHelper, _super);
    function DirectionalLightHelper(light, size) {
        if (size === void 0) { size = 1; }
        _super.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', Float32Attribute([
            -size, size, 0,
            size, size, 0,
            size, -size, 0,
            -size, -size, 0,
            -size, size, 0
        ], 3));
        var material = new LineBasicMaterial({ fog: false });
        this.add(new Line(geometry, material));
        geometry = new BufferGeometry();
        geometry.addAttribute('position', Float32Attribute([0, 0, 0, 0, 0, 1], 3));
        this.add(new Line(geometry, material));
        this.update();
    }
    DirectionalLightHelper.prototype.dispose = function () {
        var lightPlane = this.children[0];
        var targetLine = this.children[1];
        lightPlane.geometry.dispose();
        lightPlane.material.dispose();
        targetLine.geometry.dispose();
        targetLine.material.dispose();
    };
    DirectionalLightHelper.prototype.update = function () {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var v3 = new Vector3();
        //return function update() {
        v1.setFromMatrixPosition(this.light.matrixWorld);
        v2.setFromMatrixPosition(this.light.target.matrixWorld);
        v3.subVectors(v2, v1);
        var lightPlane = this.children[0];
        var targetLine = this.children[1];
        lightPlane.lookAt(v3);
        lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        targetLine.lookAt(v3);
        targetLine.scale.z = v3.length();
        //};
    };
    
    return DirectionalLightHelper;
}(Object3D));

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *  - shows frustum, line of sight and up of the camera
 *  - suitable for fast updates
 *   - based on frustum visualization in lightgl.js shadowmap example
 *    http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */
var CameraHelper = (function (_super) {
    __extends(CameraHelper, _super);
    function CameraHelper(camera) {
        var geometry = new Geometry();
        var material = new LineBasicMaterial({ color: 0xffffff, vertexColors: ColorsMode.Face });
        var pointMap = {};
        // colors
        var hexFrustum = 0xffaa00;
        var hexCone = 0xff0000;
        var hexUp = 0x00aaff;
        var hexTarget = 0xffffff;
        var hexCross = 0x333333;
        // near
        addLine("n1", "n2", hexFrustum);
        addLine("n2", "n4", hexFrustum);
        addLine("n4", "n3", hexFrustum);
        addLine("n3", "n1", hexFrustum);
        // far
        addLine("f1", "f2", hexFrustum);
        addLine("f2", "f4", hexFrustum);
        addLine("f4", "f3", hexFrustum);
        addLine("f3", "f1", hexFrustum);
        // sides
        addLine("n1", "f1", hexFrustum);
        addLine("n2", "f2", hexFrustum);
        addLine("n3", "f3", hexFrustum);
        addLine("n4", "f4", hexFrustum);
        // cone
        addLine("p", "n1", hexCone);
        addLine("p", "n2", hexCone);
        addLine("p", "n3", hexCone);
        addLine("p", "n4", hexCone);
        // up
        addLine("u1", "u2", hexUp);
        addLine("u2", "u3", hexUp);
        addLine("u3", "u1", hexUp);
        // target
        addLine("c", "t", hexTarget);
        addLine("p", "c", hexCross);
        // cross
        addLine("cn1", "cn2", hexCross);
        addLine("cn3", "cn4", hexCross);
        addLine("cf1", "cf2", hexCross);
        addLine("cf3", "cf4", hexCross);
        function addLine(a, b, hex) {
            addPoint(a, hex);
            addPoint(b, hex);
        }
        function addPoint(id, hex) {
            geometry.vertices.push(new Vector3());
            geometry.colors.push(new Color(hex));
            if (pointMap[id] === undefined) {
                pointMap[id] = [];
            }
            pointMap[id].push(geometry.vertices.length - 1);
        }
        _super.call(this, geometry, material);
        this.camera = camera;
        this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
    }
    CameraHelper.prototype.update = function () {
        var geometry, pointMap;
        var vector = new Vector3();
        var camera = new Camera();
        function setPoint(point, x, y, z) {
            vector.set(x, y, z).unproject(camera);
            var points = pointMap[point];
            if (points !== undefined) {
                for (var i = 0, il = points.length; i < il; i++) {
                    geometry.vertices[points[i]].copy(vector);
                }
            }
        }
        //return function update() {
        geometry = this.geometry;
        pointMap = this.pointMap;
        var w = 1, h = 1;
        // we need just camera projection matrix
        // world matrix must be identity
        camera.projectionMatrix.copy(this.camera.projectionMatrix);
        // center / target
        setPoint("c", 0, 0, -1);
        setPoint("t", 0, 0, 1);
        // near
        setPoint("n1", -w, -h, -1);
        setPoint("n2", w, -h, -1);
        setPoint("n3", -w, h, -1);
        setPoint("n4", w, h, -1);
        // far
        setPoint("f1", -w, -h, 1);
        setPoint("f2", w, -h, 1);
        setPoint("f3", -w, h, 1);
        setPoint("f4", w, h, 1);
        // up
        setPoint("u1", w * 0.7, h * 1.1, -1);
        setPoint("u2", -w * 0.7, h * 1.1, -1);
        setPoint("u3", 0, h * 2, -1);
        // cross
        setPoint("cf1", -w, 0, 1);
        setPoint("cf2", w, 0, 1);
        setPoint("cf3", 0, -h, 1);
        setPoint("cf4", 0, h, 1);
        setPoint("cn1", -w, 0, -1);
        setPoint("cn2", w, 0, -1);
        setPoint("cn3", 0, -h, -1);
        setPoint("cn4", 0, h, -1);
        geometry.verticesNeedUpdate = true;
        //};
    };
    return CameraHelper;
}(LineSegments));

/**
 * @author WestLangley / http://github.com/WestLangley
 */
// a helper to show the world-axis-aligned bounding box for an object
var BoundingBoxHelper = (function (_super) {
    __extends(BoundingBoxHelper, _super);
    function BoundingBoxHelper(object, color) {
        if (color === void 0) { color = 0x888888; }
        _super.call(this, new BoxGeometry(1, 1, 1), new MeshBasicMaterial({ color: color, wireframe: true }));
        this.object = object;
        this.box = new Box3();
    }
    BoundingBoxHelper.prototype.update = function () {
        this.box.setFromObject(this.object);
        this.box.getSize(this.scale);
        this.box.getCenter(this.position);
    };
    return BoundingBoxHelper;
}(Mesh));

/**
 * @author mrdoob / http://mrdoob.com/
 */
var BoxHelper = (function (_super) {
    __extends(BoxHelper, _super);
    function BoxHelper(object, color) {
        if (color === void 0) { color = 0xffff00; }
        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var positions = new Float32Array(8 * 3);
        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.addAttribute('position', new BufferAttribute(positions, 3));
        _super.call(this, geometry, new LineBasicMaterial({ color: color }));
        if (object !== undefined) {
            this.update(object);
        }
    }
    BoxHelper.prototype.update = function (object) {
        var box = new Box3();
        //return function update(object) {
        if ((object && object instanceof Box3)) {
            box.copy(object);
        }
        else {
            box.setFromObject(object);
        }
        if (box.isEmpty())
            return;
        var min = box.min;
        var max = box.max;
        /*
          5____4
        1/___0/|
        | 6__|_7
        2/___3/
        0: max.x, max.y, max.z
        1: min.x, max.y, max.z
        2: min.x, min.y, max.z
        3: max.x, min.y, max.z
        4: max.x, max.y, min.z
        5: min.x, max.y, min.z
        6: min.x, min.y, min.z
        7: max.x, min.y, min.z
        */
        var position = this.geometry.attributes.position;
        var array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
        //};
    };
    return BoxHelper;
}(LineSegments));

var lineGeometry = new BufferGeometry();
lineGeometry.addAttribute('position', Float32Attribute([0, 0, 0, 0, 1, 0], 3));
var coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
coneGeometry.translate(0, -0.5, 0);
var ArrowHelper = (function (_super) {
    __extends(ArrowHelper, _super);
    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
        // dir is assumed to be normalized
        _super.call(this);
        if (color === undefined)
            color = 0xffff00;
        if (length === undefined)
            length = 1;
        if (headLength === undefined)
            headLength = 0.2 * length;
        if (headWidth === undefined)
            headWidth = 0.2 * headLength;
        this.position.copy(origin);
        this.line = new Line(lineGeometry, new LineBasicMaterial({ color: color }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({ color: color }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
    }
    ArrowHelper.prototype.setDirection = function (dir) {
        var axis = new Vector3();
        //return function setDirection(dir) {
        // dir is assumed to be normalized
        if (dir.y > 0.99999) {
            this.quaternion.set(0, 0, 0, 1);
        }
        else if (dir.y < -0.99999) {
            this.quaternion.set(1, 0, 0, 0);
        }
        else {
            axis.set(dir.z, 0, -dir.x).normalize();
            var radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(axis, radians);
        }
        //};
    };
    ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
        if (headLength === undefined)
            headLength = 0.2 * length;
        if (headWidth === undefined)
            headWidth = 0.2 * headLength;
        this.line.scale.set(1, Math.max(0, length - headLength), 1);
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
    };
    ArrowHelper.prototype.setColor = function (color) {
        this.line.material.color.copy(color);
        this.cone.material.color.copy(color);
    };
    return ArrowHelper;
}(Object3D));

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */
var AxisHelper = (function (_super) {
    __extends(AxisHelper, _super);
    function AxisHelper(size) {
        if (size === void 0) { size = 1; }
        var vertices = new Float32Array([
            0, 0, 0, size, 0, 0,
            0, 0, 0, 0, size, 0,
            0, 0, 0, 0, 0, size
        ]);
        var colors = new Float32Array([
            1, 0, 0, 1, 0.6, 0,
            0, 1, 0, 0.6, 1, 0,
            0, 0, 1, 0, 0.6, 1
        ]);
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({ vertexColors: ColorsMode.Vertex });
        _super.call(this, geometry, material);
    }
    return AxisHelper;
}(LineSegments));

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */
var CatmullRomCurve3 = (function (_super) {
    __extends(CatmullRomCurve3, _super);
    function CatmullRomCurve3(p) {
        if (p === void 0) { p = []; }
        _super.call(this);
        this.closed = false;
        this.tension = 0.5;
        this.points = p;
        this.closed = false;
    }
    CatmullRomCurve3.prototype.getPoint = function (t) {
        var tmp = new Vector3();
        var px = new CubicPoly();
        var py = new CubicPoly();
        var pz = new CubicPoly();
        var points = this.points;
        var l = points.length;
        if (l < 2)
            console.log('duh, you need at least 2 points');
        var point = (l - (this.closed ? 0 : 1)) * t;
        var intPoint = Math.floor(point);
        var weight = point - intPoint;
        if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
        }
        else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
        }
        var p0, p1, p2, p3; // 4 points
        if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l];
        }
        else {
            // extrapolate first point
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
        }
        p1 = points[intPoint % l];
        p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) {
            p3 = points[(intPoint + 2) % l];
        }
        else {
            // extrapolate last point
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
        }
        if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {
            // init Centripetal / Chordal Catmull-Rom
            var pow = this.type === 'chordal' ? 0.5 : 0.25;
            var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            // safety check for repeated points
            if (dt1 < 1e-4)
                dt1 = 1.0;
            if (dt0 < 1e-4)
                dt0 = dt1;
            if (dt2 < 1e-4)
                dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        }
        else if (this.type === 'catmullrom') {
            var tension = this.tension;
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
        }
        var v = new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
        return v;
    };
    return CatmullRomCurve3;
}(Curve));
/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM
This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/
var CubicPoly = (function () {
    function CubicPoly() {
    }
    /*
     * Compute coefficients for a cubic polynomial
     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
     * such that
     *   p(0) = x0, p(1) = x1
     *  and
     *   p'(0) = t0, p'(1) = t1.
     */
    CubicPoly.prototype.init = function (x0, x1, t0, t1) {
        this.c0 = x0;
        this.c1 = t0;
        this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
    };
    CubicPoly.prototype.initNonuniformCatmullRom = function (x0, x1, x2, x3, dt0, dt1, dt2) {
        // compute tangents when parameterized in [t1,t2]
        var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        // rescale tangents for parametrization in [0,1]
        t1 *= dt1;
        t2 *= dt1;
        // initCubicPoly
        this.init(x1, x2, t1, t2);
    };
    // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
    CubicPoly.prototype.initCatmullRom = function (x0, x1, x2, x3, tension) {
        this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    };
    CubicPoly.prototype.calc = function (t) {
        var t2 = t * t;
        var t3 = t2 * t;
        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
    };
    return CubicPoly;
}());

/**************************************************************
 *  Closed Spline 3D curve
 **************************************************************/
var ClosedSplineCurve3 = (function (_super) {
    __extends(ClosedSplineCurve3, _super);
    function ClosedSplineCurve3(points) {
        console.warn('THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.');
        _super.call(this, points);
        this.type = 'catmullrom';
        this.closed = true;
    }
    return ClosedSplineCurve3;
}(CatmullRomCurve3));

/**************************************************************
 *  Spline 3D curve
 **************************************************************/
var SplineCurve3 = (function (_super) {
    __extends(SplineCurve3, _super);
    function SplineCurve3(points /* array of Vector3 */) {
        if (points === void 0) { points = []; }
        _super.call(this);
        console.warn('THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3');
        this.points = points;
    }
    SplineCurve3.prototype.getPoint = function (t) {
        var points = this.points;
        var point = (points.length - 1) * t;
        var intPoint = Math.floor(point);
        var weight = point - intPoint;
        var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        var point1 = points[intPoint];
        var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        var interpolate = CurveUtils.interpolate;
        return new Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));
    };
    return SplineCurve3;
}(Curve));

/**************************************************************
 *  Cubic Bezier 3D curve
 **************************************************************/
var CubicBezierCurve3 = (function (_super) {
    __extends(CubicBezierCurve3, _super);
    function CubicBezierCurve3(v0, v1, v2, v3) {
        _super.call(this);
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    CubicBezierCurve3.prototype.getPoint = function (t) {
        var b3 = ShapeUtils.b3;
        return new Vector3(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
    };
    return CubicBezierCurve3;
}(Curve));

/**************************************************************
 *  Quadratic Bezier 3D curve
 **************************************************************/
var QuadraticBezierCurve3 = (function (_super) {
    __extends(QuadraticBezierCurve3, _super);
    function QuadraticBezierCurve3(v0, v1, v2) {
        _super.call(this);
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }
    QuadraticBezierCurve3.prototype.getPoint = function (t) {
        var b2 = ShapeUtils.b2;
        return new Vector3(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y), b2(t, this.v0.z, this.v1.z, this.v2.z));
    };
    return QuadraticBezierCurve3;
}(Curve));

/**************************************************************
 *  Line3D
 **************************************************************/
var LineCurve3 = (function (_super) {
    __extends(LineCurve3, _super);
    function LineCurve3(v1, v2) {
        _super.call(this);
        this.v1 = v1;
        this.v2 = v2;
    }
    LineCurve3.prototype.getPoint = function (t) {
        if (t === 1) {
            return this.v2.clone();
        }
        var vector = new Vector3();
        vector.subVectors(this.v2, this.v1); // diff
        vector.multiplyScalar(t);
        vector.add(this.v1);
        return vector;
    };
    return LineCurve3;
}(Curve));

/**************************************************************
 *  Arc curve
 **************************************************************/
var ArcCurve = (function (_super) {
    __extends(ArcCurve, _super);
    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        _super.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    }
    return ArcCurve;
}(EllipseCurve));

/**
 * @author alteredq / http://alteredqualia.com/
 */
var SceneUtils = (function () {
    function SceneUtils() {
    }
    SceneUtils.createMultiMaterialObject = function (geometry, materials) {
        var group = new Group();
        for (var i = 0, l = materials.length; i < l; i++) {
            group.add(new Mesh(geometry, materials[i]));
        }
        return group;
    };
    SceneUtils.detach = function (child, parent, scene) {
        child.applyMatrix(parent.matrixWorld);
        parent.remove(child);
        scene.add(child);
    };
    SceneUtils.attach = function (child, scene, parent) {
        var matrixWorldInverse = new Matrix4();
        matrixWorldInverse.getInverse(parent.matrixWorld);
        child.applyMatrix(matrixWorldInverse);
        scene.remove(child);
        parent.add(child);
    };
    return SceneUtils;
}());

var Face4 = (function (_super) {
    __extends(Face4, _super);
    function Face4(a, b, c, d, normal, color, materialIndex) {
        console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
        _super.call(this, a, b, c, normal, color, materialIndex);
    }
    return Face4;
}(Face3));
var LineStrip = 0;
var LinePieces = 1;
var PointCloud = (function (_super) {
    __extends(PointCloud, _super);
    function PointCloud(geometry, material) {
        console.warn("THREE.PointCloud has been renamed to THREE.Points.");
        _super.call(this, geometry, material);
    }
    return PointCloud;
}(Points));
var ParticleSystem = (function (_super) {
    __extends(ParticleSystem, _super);
    function ParticleSystem(geometry, material) {
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
        _super.call(this, geometry, material);
    }
    return ParticleSystem;
}(Points));
var PointCloudMaterial = (function (_super) {
    __extends(PointCloudMaterial, _super);
    function PointCloudMaterial(parameters) {
        console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
        _super.call(this, parameters);
    }
    return PointCloudMaterial;
}(PointsMaterial));
var ParticleBasicMaterial = (function (_super) {
    __extends(ParticleBasicMaterial, _super);
    function ParticleBasicMaterial(parameters) {
        console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
        _super.call(this, parameters);
    }
    return ParticleBasicMaterial;
}(PointsMaterial));
var ParticleSystemMaterial = (function (_super) {
    __extends(ParticleSystemMaterial, _super);
    function ParticleSystemMaterial(parameters) {
        console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
        _super.call(this, parameters);
    }
    return ParticleSystemMaterial;
}(PointsMaterial));
var Vertex = (function (_super) {
    __extends(Vertex, _super);
    function Vertex(x, y, z) {
        console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
        _super.call(this, x, y, z);
    }
    return Vertex;
}(Vector3));
//
var EdgesHelper = (function (_super) {
    __extends(EdgesHelper, _super);
    function EdgesHelper(object, hex) {
        if (hex === void 0) { hex = 0xffffff; }
        console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
        _super.call(this, new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex }));
    }
    return EdgesHelper;
}(LineSegments));
var WireframeHelper = (function (_super) {
    __extends(WireframeHelper, _super);
    function WireframeHelper(object, hex) {
        if (hex === void 0) { hex = 0xffffff; }
        console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
        _super.call(this, new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex }));
    }
    return WireframeHelper;
}(LineSegments));
//
var GeometryUtils = (function () {
    function GeometryUtils() {
    }
    GeometryUtils.merge = function (geometry1, geometry2, materialIndexOffset) {
        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge(geometry2, matrix, materialIndexOffset) instead.");
        var matrix;
        if (geometry2 instanceof Mesh) {
            geometry2.matrixAutoUpdate && geometry2.updateMatrix();
            matrix = geometry2.matrix;
            geometry2 = geometry2.geometry;
        }
        geometry1.merge(geometry2, matrix, materialIndexOffset);
    };
    GeometryUtils.center = function (geometry) {
        console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
        return geometry.center();
    };
    return GeometryUtils;
}());
var ImageUtils = (function () {
    function ImageUtils() {
    }
    ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var loader = new TextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var texture = loader.load(url, onLoad, undefined, onError);
        if (mapping)
            texture.mapping = mapping;
        return texture;
    };
    ImageUtils.prototype.loadTextureCube = function (urls, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var loader = new CubeTextureLoader();
        loader.setCrossOrigin(ImageUtils.crossOrigin);
        var texture = loader.load(urls, onLoad, undefined, onError);
        if (mapping)
            texture.mapping = mapping;
        return texture;
    };
    ImageUtils.prototype.loadCompressedTexture = function () {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    };
    ImageUtils.prototype.loadCompressedTextureCube = function () {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    };
    return ImageUtils;
}());
//
var Projector = (function () {
    function Projector() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.ts.");
    }
    Projector.prototype.projectVector = function (vector, camera) {
        console.warn("THREE.Projector: .projectVector() is now vector.project().");
        vector.project(camera);
    };
    Projector.prototype.unprojectVector = function (vector, camera) {
        console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
        vector.unproject(camera);
    };
    Projector.prototype.pickingRay = function (vector, camera) {
        console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
    };
    
    return Projector;
}());
//
var CanvasRenderer = (function () {
    function CanvasRenderer() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.ts");
        this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    CanvasRenderer.prototype.clear = function () { };
    CanvasRenderer.prototype.render = function () { };
    CanvasRenderer.prototype.setClearColor = function () { };
    CanvasRenderer.prototype.setSize = function () { };
    return CanvasRenderer;
}());

export { WebGLRenderTargetCube, WebGLRenderTarget, WebGLRenderer, ShaderLib, UniformsLib, UniformsUtils, ShaderChunk, FogExp2, Fog, Scene, LensFlare, Sprite, LOD, SkinnedMesh, Skeleton, Bone, Mesh, LineSegments, Line, Points, Group, VideoTexture, DataTexture, CompressedTexture, CubeTexture, CanvasTexture, DepthTexture, TextureIdCount, Texture, MaterialIdCount, CompressedTextureLoader, BinaryTextureLoader, DataTextureLoader, CubeTextureLoader, TextureLoader, ObjectLoader, MaterialLoader, BufferGeometryLoader, DefaultLoadingManager, LoadingManager, JSONLoader, ImageLoader, FontLoader, XHRLoader, Loader, Cache, AudioLoader, SpotLightShadow, SpotLight, PointLight, HemisphereLight, DirectionalLightShadow, DirectionalLight, AmbientLight, LightShadow, Light, StereoCamera, PerspectiveCamera, OrthographicCamera, CubeCamera, Camera, AudioListener, PositionalAudio, getAudioContext, AudioAnalyser, Audio, NewVectorKeyframeTrack as VectorKeyframeTrack, NewStringKeyframeTrack as StringKeyframeTrack, NewQuaternionKeyframeTrack as QuaternionKeyframeTrack, NewNumberKeyframeTrack as NumberKeyframeTrack, NewColorKeyframeTrack as ColorKeyframeTrack, NewBooleanKeyframeTrack as BooleanKeyframeTrack, PropertyMixer, PropertyBinding, KeyframeTrack, AnimationUtils, AnimationObjectGroup, AnimationMixer, AnimationClip, Uniform, InstancedBufferGeometry, BufferGeometry, GeometryIdCount, Geometry, InterleavedBufferAttribute, InstancedInterleavedBuffer, InterleavedBuffer, InstancedBufferAttribute, DynamicBufferAttribute, Float64Attribute, Float32Attribute, Uint32Attribute, Int32Attribute, Uint16Attribute, Int16Attribute, Uint8ClampedAttribute, Uint8Attribute, Int8Attribute, BufferAttribute, Face3, Object3DIdCount, Object3D, Raycaster, Intersect, Layers, EventDispatcher, Clock, QuaternionLinearInterpolant, LinearInterpolant, DiscreteInterpolant, CubicInterpolant, Interpolant, Triangle, Spline, _Math as Math, Spherical, Plane, Frustum, Sphere, Ray, Matrix4, Matrix3, Box3, Box2, Line3, Euler, Vector4, Vector3, Vector2, Quaternion, ColorKeywords, Color, MorphBlendMesh, ImmediateRenderObject, VertexNormalsHelper, SpotLightHelper, SkeletonHelper, PointLightHelper, HemisphereLightHelper, GridHelper, FaceNormalsHelper, DirectionalLightHelper, CameraHelper, BoundingBoxHelper, BoxHelper, ArrowHelper, AxisHelper, ClosedSplineCurve3, CatmullRomCurve3, SplineCurve3, CubicBezierCurve3, QuadraticBezierCurve3, LineCurve3, ArcCurve, EllipseCurve, SplineCurve, CubicBezierCurve, QuadraticBezierCurve, LineCurve, Shape, Path, ShapePath, Font, CurvePath, Curve, ShapeUtils, SceneUtils, CurveUtils, WireframeGeometry, ParametricGeometry, ParametricBufferGeometry, TetrahedronGeometry, TetrahedronBufferGeometry, OctahedronGeometry, OctahedronBufferGeometry, IcosahedronGeometry, IcosahedronBufferGeometry, DodecahedronGeometry, DodecahedronBufferGeometry, PolyhedronGeometry, PolyhedronBufferGeometry, TubeGeometry, TubeBufferGeometry, TorusKnotGeometry, TorusKnotBufferGeometry, TorusGeometry, TorusBufferGeometry, TextGeometry, SphereBufferGeometry, SphereGeometry, RingGeometry, RingBufferGeometry, PlaneBufferGeometry, PlaneGeometry, LatheGeometry, LatheBufferGeometry, ShapeGeometry, ExtrudeGeometry, EdgesGeometry, ConeGeometry, ConeBufferGeometry, CylinderGeometry, CylinderBufferGeometry, CircleBufferGeometry, CircleGeometry, BoxBufferGeometry, BoxGeometry, ShadowMaterial, SpriteMaterial, RawShaderMaterial, ShaderMaterial, PointsMaterial, MultiMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshPhongMaterial, MeshNormalMaterial, MeshLambertMaterial, MeshDepthMaterial, MeshBasicMaterial, LineDashedMaterial, LineBasicMaterial, Material, REVISION, MOUSE, CullFace, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, FrontFaceDirection, FrontFaceDirectionCW, FrontFaceDirectionCCW, ShadowMap, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, SideMode, FrontSide, BackSide, DoubleSide, ShadingMode, FlatShading, SmoothShading, ColorsMode, NoColors, FaceColors, VertexColors, BlendingMode, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, BlendingEquation, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, BlendingFactor, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, DepthFunction, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, BlendingOperation, MultiplyOperation, MixOperation, AddOperation, ToneMapping, NoToneMapping, LinearToneMapping, ReinhardToneMapping, Uncharted2ToneMapping, CineonToneMapping, TextureMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, SphericalReflectionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, TextureWrapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, TextureFilter, NearestFilter, NearestMipMapNearestFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipMapNearestFilter, LinearMipMapLinearFilter, TextureType, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, TextureFormat, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, RGBEFormat, DepthFormat, DepthStencilFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, LoopMode, LoopOnce, LoopRepeat, LoopPingPong, InterpolateMode, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, EndingMode, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, DrawMode, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, TextureEncoding, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, DepthPacking, BasicDepthPacking, RGBADepthPacking, BoxGeometry as CubeGeometry, LineStrip, LinePieces, MultiMaterial as MeshFaceMaterial, Sprite as Particle, Face4, PointCloud, ParticleSystem, PointCloudMaterial, ParticleBasicMaterial, ParticleSystemMaterial, Vertex, EdgesHelper, WireframeHelper, GeometryUtils, ImageUtils, Projector, CanvasRenderer };

Object.defineProperty( exports, 'AudioContext', {
	get: function () {
		return exports.getAudioContext();
	}
});
//# sourceMappingURL=three.modules.js.map
